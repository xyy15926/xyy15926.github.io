<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Category: Algorithm - UBeaRLy</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="UBeaRLy&#039;s Proxy"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="UBeaRLy&#039;s Proxy"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="UBeaRLy"><meta property="og:url" content="https://xyy15926.github.io/"><meta property="og:site_name" content="UBeaRLy"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://xyy15926.github.io/img/og_image.png"><meta property="article:author" content="UBeaRLy"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xyy15926.github.io"},"headline":"UBeaRLy","image":["https://xyy15926.github.io/img/og_image.png"],"author":{"@type":"Person","name":"UBeaRLy"},"publisher":{"@type":"Organization","name":"UBeaRLy","logo":{"@type":"ImageObject","url":"https://xyy15926.github.io/img/logo.svg"}},"description":""}</script><link rel="alternate" href="/atom.xml" title="UBeaRLy" type="application/atom+xml"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/darcula.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><script data-ad-client="ca-pub-5385776267343559" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><meta name="follow_it-verification-code" content="SVBypAPPHxjjr7Y4hHfn"><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="UBeaRLy" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Visit on GitHub" href="https://github.com/xyy15926/proxy"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">Categories</a></li><li class="is-active"><a href="#" aria-current="page">Algorithm</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:37.000Z" title="3/21/2019, 5:27:37 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-03-13T06:56:03.000Z" title="3/13/2019, 2:56:03 PM">2019-03-13</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Data-Structure/">Data Structure</a></span><span class="level-item">6 minutes read (About 910 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Data-Structure/linear_queue_stack.html">Stack&amp;Queue</a></h1><div class="content"><ul>
<li>从数据结构来看，栈和队列也是线性表，但其基本操作是线性表
操作的子集</li>
<li>从数据类型来看，栈和队列是和线性表不同的抽象数据类型</li>
</ul>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a><em>Stack</em></h2><p>栈：限定在<strong>表尾/栈顶</strong>进行插入和删除、操作受限的线性表</p>
<blockquote>
<ul>
<li><em>top</em>：栈顶，表尾端</li>
<li><em>bottom</em>：栈底，表头端</li>
</ul>
</blockquote>
<ul>
<li><p>栈的修改是按照<code>LIFO</code>的方式运转，又称后进先出的线性表</p>
<ul>
<li>入栈：插入元素</li>
<li>出栈：删除栈顶元素</li>
</ul>
</li>
<li><p><em>last in first out</em>/栈应用广泛，对实现递归操作必不可少</p>
</li>
</ul>
<h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><p>顺序栈：顺序映像存储栈底到栈顶的数据元素，同时附设指针指示
栈顶元素在顺序栈帧中的位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	SElemType * base;</span><br><span class="line">	SElemType *top;</span><br><span class="line">	<span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>base</code>永远指向栈底，<code>top</code>指向栈顶元素<strong>下个位置</strong><blockquote>
<ul>
<li><code>base==NULL</code>：栈不存在</li>
<li><code>top==base</code>：表示空栈</li>
</ul>
</blockquote>
</li>
<li>栈在使用过程中所需最大空间难以估计，因此一般初始化设空栈
  时不应限定栈的最大容量，应分配基本容量，逐渐增加</li>
</ul>
</blockquote>
<h3 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a><em>Queue</em></h2><p>队列：限定在<strong>表尾/队尾</strong>进行插入、在<strong>表头/队头</strong>进行删除的
受限线性表</p>
<blockquote>
<ul>
<li><em>rear</em>：队尾，允许插入的一端</li>
<li><em>front</em>：队头，允许删除的一端</li>
</ul>
</blockquote>
<ul>
<li>队列是一种<em>FIFO</em>的线性表</li>
<li>队列在程序设计中经常出现<ul>
<li>操作系统作业排队</li>
<li>图的广度优先遍历</li>
</ul>
</li>
</ul>
<h3 id="链式存储结构-1"><a href="#链式存储结构-1" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><h4 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h4><p>链队列：使用链表表示的队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">	QElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>  * <span class="title">next</span>;</span></span><br><span class="line">&#125;QNode, *QueuePtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	QueuePtr front;</span><br><span class="line">	QueuePtr rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>front</code>：头指针</li>
<li><code>rear</code>：尾指针</li>
</ul>
</blockquote>
<ul>
<li>为方便同样给链队列添加头结点，令头指针指向头结点，此时
空队列判断条件为头、尾指针均指向头结点</li>
<li>链队列的操作即为单链表插入、删除操作的特殊情况的，需要
同时修改头、尾指针</li>
</ul>
<h3 id="顺序存储结构-1"><a href="#顺序存储结构-1" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><p>循环队列：使用顺序结构存储队列元素，附设两个指针分别指示对头
、队尾的位置</p>
<ul>
<li>为充分利用数组空间，将数组视为<strong>环状空间</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	QElemType * base;</span><br><span class="line">	<span class="keyword">int</span> front;</span><br><span class="line">	<span class="keyword">int</span> rear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>front</code>：头指针</li>
<li><code>rear</code>：尾指针</li>
<li>循环队列时，无法通过<code>rear==front</code>判断队列空、满，可以在
  环上、环外设置标志位判断</li>
</ul>
</blockquote>
<ul>
<li>C语言中无法用动态分配的一维数组实现循环队列，必须设置
最大队列长度，如果无法确定，应该使用链队列</li>
</ul>
<h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a><em>Deque</em></h2><p>双端队列：限定删除、插入操作在表两端进行的线性表</p>
<ul>
<li>输出受限双端队列：一个端点允许删除、插入，另一个端点只
允许插入</li>
<li>输入受限双端队列：一个端点允许删除、插入，另一个端点只
允许删除</li>
<li>栈底邻接的两个栈：限定某个端点插入元素只能从该端点删除</li>
</ul>
<blockquote>
<ul>
<li>看起了灵活，但是实际应用不多</li>
</ul>
</blockquote>
<h3 id="Priority-Queue优先队列"><a href="#Priority-Queue优先队列" class="headerlink" title="Priority Queue优先队列"></a>Priority Queue优先队列</h3><ul>
<li>用于从一个动态改变的候选集合中选择一个优先级高的元素</li>
<li>主要操作<ul>
<li>查找、删除最大元素</li>
<li>插入元素</li>
</ul>
</li>
<li>实现<ul>
<li>可以基于数组、有序数组实现</li>
<li>基于heap的优先队列实现更好</li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:37.000Z" title="3/21/2019, 5:27:37 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-03-13T08:53:40.000Z" title="3/13/2019, 4:53:40 PM">2019-03-13</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Data-Structure/">Data Structure</a></span><span class="level-item">6 minutes read (About 856 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Data-Structure/linear_string.html">String</a></h1><div class="content"><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>串/字符串：零个或多个字符组成的有限序列</p>
<ul>
<li>文本串：字母、数字、特殊符号构成</li>
<li>位串：0、1构成</li>
<li>基因序列：可以使用字符串模型表示，其字母表只包括4个
字母<code>&#123;A, C, G, T&#125;</code></li>
</ul>
<script type="math/tex; mode=display">
s = 'a_1a_2\cdots\a_n'</script><blockquote>
<ul>
<li>$s$：串名，其后单引号括起是串的值</li>
<li>$a_i$：字母、数字等字符</li>
<li>$n$：串中字符的数目，串长度，零个字符的串称为空串</li>
</ul>
</blockquote>
<ul>
<li>串的逻辑结构和线性表相似，只是串的数据对象约束为字符集</li>
<li>串的基本操作和线性表有很大差别<ul>
<li>线性表基本操作大多以“单个元素”作为操作对象</li>
<li>串的基本操作通常以“串的整体”作为操作对象</li>
</ul>
</li>
</ul>
<h2 id="串的存储表示"><a href="#串的存储表示" class="headerlink" title="串的存储表示"></a>串的存储表示</h2><ul>
<li>串只作为输入、输出常量出现，则只需要存储串的串值字符序列</li>
<li>在非数值处理中，串也以变量形式出现</li>
</ul>
<h3 id="定长顺序存储"><a href="#定长顺序存储" class="headerlink" title="定长顺序存储"></a>定长顺序存储</h3><ul>
<li>类似线性表的顺序存储结构</li>
<li>按照预定义大小，为每个定义的串变量分配固定长度的存储区，
存储字符序列</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> SString[MAXSTRLEN+<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>串实际长度在预定义范围内随意，超过预定义长度的串值则被
舍去（截断）</li>
<li>串实际长度存储方式<ul>
<li>以下标为0的数组分量存放：Pascal</li>
<li>在串值后面加入不计串长的结束标记字符：C以<code>\0</code>标记，
此时串长为隐含值，不利于某些操作</li>
</ul>
</li>
<li>串操作的原操作为“字符序列的复制”，操作的时间复杂度基于
复制的字符序列长度</li>
</ul>
<h3 id="堆分配存储"><a href="#堆分配存储" class="headerlink" title="堆分配存储"></a>堆分配存储</h3><ul>
<li>仍然以地址连续的存储单元存储串字符序列，但存储空间是在
程序执行过程中动态分配得到</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typdef <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> *ch;</span><br><span class="line">	<span class="keyword">int</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>length</code>：串长</li>
</ul>
</blockquote>
<ul>
<li>既有顺序存储结构的特点，处理方便，对串长又没有任何限制</li>
<li>此存储结构的串操作仍是基于“字符序列的复制”进行</li>
</ul>
<h3 id="块链存储"><a href="#块链存储" class="headerlink" title="块链存储"></a>块链存储</h3><ul>
<li>使用链表的方式存储串值</li>
<li>但是串结构特殊的，需要设置节点大小</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> ch[CHUNKSIZE];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">CHUNK</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;Chunk;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	Chunk *head, *tail;</span><br><span class="line">	<span class="keyword">int</span> curlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>CHUNKSIZE</code>：节点大小，每个节点中最大存储字符数量</li>
<li><code>curlen</code>：当前串长度</li>
</ul>
</blockquote>
<ul>
<li>节点大小不为1时，链表最后一个节点不一定全被串值占满，
此时通常补上非串值字符</li>
<li>一般情况下，对串进行操作时，只需要从头到尾扫描即可<ul>
<li>对串值不必简历双向链表</li>
<li>设尾指针是为了方便进行联结操作（联结操作需要注意
串尾无效字符）</li>
</ul>
</li>
<li>节点大小选择影响串处理效率<ul>
<li>存储效率 = 串值所占存储位/实际分配存储位</li>
<li>存储密度小，运算处理方便，存储量占用大</li>
</ul>
</li>
<li>块链结构对某些串操作有一定方便，但是总的来说不如另外两种
存储结构灵活，存储量大、操作复杂</li>
</ul>
<h2 id="串的模式匹配"><a href="#串的模式匹配" class="headerlink" title="串的模式匹配"></a>串的模式匹配</h2><p>模式匹配：子串定位操作</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:37.000Z" title="3/21/2019, 5:27:37 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-02-22T03:21:40.000Z" title="2/22/2019, 11:21:40 AM">2019-02-22</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Problem/">Problem</a></span><span class="level-item">7 minutes read (About 1029 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Problem/geometry.html">几何问题</a></h1><div class="content"><h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><p>处理类似于点、线、多面体这样的几何对象</p>
<h2 id="最近对问题"><a href="#最近对问题" class="headerlink" title="最近对问题"></a>最近对问题</h2><p>给定平面上的n个点中，距离最近的两个点</p>
<ul>
<li>点数量n不大3时，可以通过蛮力算法求解的</li>
<li>假设集合中每个点均不相同、点按其x坐标升序排列</li>
<li>另外使用算法得到点按照y坐标升序排列的列表Q</li>
</ul>
<h3 id="蛮力算法"><a href="#蛮力算法" class="headerlink" title="蛮力算法"></a>蛮力算法</h3><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BruteForceClosestPoints(p)</span><br><span class="line">	<span class="comment">// 蛮力算法求平面中距离最近的点</span></span><br><span class="line">	<span class="comment">// 输入：n个点的列表p；p_i = (x_i, y_i)</span></span><br><span class="line">	<span class="comment">// 输出：两个最近点的距离</span></span><br><span class="line">	d = \infty</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span> to n <span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">for</span> j = i+<span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">			d = min(d, <span class="built_in">sqrt</span>((x_i - x_j)^<span class="number">2</span> + (y_i - y_j)^<span class="number">2</span>))</span><br><span class="line">	<span class="keyword">return</span> d</span><br></pre></td></tr></table></figure>
<h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><ul>
<li>忽略平方根函数，只比较平方</li>
</ul>
<h4 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h4><ul>
<li><p>在点集在x轴方向中位数m作垂线，将点集分成大小为
$\lceiling n/2 \rceiling, \lfloor n/2 \rfloor$两个子集
$P_l, P_r$，然后递归求解子问题$P_l, P_r$得到最近点问题解</p>
</li>
<li><p>定义$d=min{d_l, d_r}$</p>
<ul>
<li>d不一定是所有点对最小距离</li>
<li>最小距离点对可能分别位于分界线两侧，在合并子问题的
解时需要考虑</li>
</ul>
</li>
<li><p>只需要考虑关于m对称的2d垂直带中的点，记S为来自Q、位于
分隔带中的点列表</p>
<ul>
<li>S同样升序排列</li>
<li>扫描S，遇到距离更近的点对时更新最小距离$d_{min}=d$</li>
<li>对于S中点P，只需考虑<strong>在其后、y坐标差小于$d_min$</strong>
的矩形范围内点（因为S有序，P前的点已经考虑过）</li>
<li>该矩形范围内点数目不超过6个（包括P），所以考虑下个点
前，至多考虑5个点</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">EfficientClosestPair(P, Q)</span><br><span class="line">	<span class="comment">// 分治法解决最近点问题</span></span><br><span class="line">	<span class="comment">// 输入：P存储平面上n个点，按x轴坐标升序排列</span></span><br><span class="line">			Q存储和P相同的n个点，按y坐标升序排列</span><br><span class="line">	<span class="comment">/// 输出：最近点直接欧几里得距离</span></span><br><span class="line">	<span class="keyword">if</span> n &lt;= <span class="number">3</span></span><br><span class="line">		<span class="keyword">return</span> 蛮力法最小距离</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		将P前ceiling(n/<span class="number">2</span>)个点复制到P_l</span><br><span class="line">		将Q相应的ceiling(n/<span class="number">2</span>)点复制到Q_l</span><br><span class="line">		将P余下<span class="built_in">floor</span>(n/<span class="number">2</span>)个点复制到P_r</span><br><span class="line">		将Q余下<span class="built_in">floor</span>(n/<span class="number">2</span>)个点复制到Q_r</span><br><span class="line"></span><br><span class="line">		d_l = EfficientClosestPair(P_l, Q_l)</span><br><span class="line">		d_r = EfficientClosestPair(P_r, Q_r)</span><br><span class="line">		d = min&#123;d_l, d_r&#125;</span><br><span class="line"></span><br><span class="line">		m = P[ceiling(n/<span class="number">2</span>) - <span class="number">1</span>].x</span><br><span class="line">		将Q中所有|x-m|&lt;d的点复制到数组S[<span class="number">0.</span>.num<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">		dminsq = d^<span class="number">2</span></span><br><span class="line">		<span class="keyword">for</span> i=<span class="number">0</span> to num<span class="number">-2</span> <span class="keyword">do</span></span><br><span class="line">			k = i+<span class="number">1</span></span><br><span class="line">			<span class="keyword">while</span> k &lt;= num<span class="number">-1</span> <span class="keyword">and</span> (S[k].y - S[i].y)^<span class="number">2</span> &lt; dminsq</span><br><span class="line">				dminsq = min((S[k].x - S[i].x)^<span class="number">2</span> + (S[k].y - S[i].y)^<span class="number">2</span>, dminsq)</span><br><span class="line">				k = k+<span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>(dminsq)</span><br></pre></td></tr></table></figure>
<h4 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>算法时间效率</p>
<ul>
<li>将问题划分为规模相同子问题、合并子问题解，算法都只
需要线性时间</li>
<li>运行时间递推式$T(n) = 2T(n/2) + f(n)$，其中
$f(n) \in \Theta(n)$，则$T(n) \in \Theta(nlogn)$</li>
<li>已经证明在对算法可以执行的操作没有特殊假设情况下，
这是可能得到的最好效率</li>
</ul>
</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li>聚类分析</li>
</ul>
<h2 id="凸包问题"><a href="#凸包问题" class="headerlink" title="凸包问题"></a>凸包问题</h2><p>寻找能把给定集合中所有点都包含在里面的最小凸多边形</p>
<ul>
<li>设集合S中点按照x坐标升序排列，存储在列表P中
（x坐标相同，按y坐标升序）</li>
</ul>
<h3 id="蛮力算法-1"><a href="#蛮力算法-1" class="headerlink" title="蛮力算法"></a>蛮力算法</h3><h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><ul>
<li>对于n个点集中两个点$p_i$、$p_j$，当且仅当集合中其他点
都位于穿过这两点的直线<strong>同侧</strong>时，其连线是该集合凸包边界
一部分</li>
<li>检验每对点，满足条件的点即构成凸包边界</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>算法时间效率为$O(n^3)$</li>
</ul>
<h3 id="快包算法（分治法）"><a href="#快包算法（分治法）" class="headerlink" title="快包算法（分治法）"></a>快包算法（分治法）</h3><h4 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>$p_1、$p_n$显然是凸包顶点，且$\overrightarrow{p_1p_n}$
将点集分为左右两部分$S_1$、$S_2$</p>
<ul>
<li>其上的点不是凸包顶点，之后不必考虑</li>
<li>S的凸包也被划分为upper hull、lower hull，可以使用
相同的方法构造</li>
</ul>
</li>
<li><p>若$S<em>1$为空，则上包就是线段$p_1p_n$；否则寻找距离
$p_1p_n$最大点$p</em>{max}$，若有多个，则选择使得夹角
$\angle p_{max}p_1p_n$最大点</p>
<ul>
<li>$p_max$是上包顶点</li>
<li>包含在$\triangle p<em>1p</em>{max}p_2$中的点不是上包顶点，
之后不必考虑</li>
<li>不存在同时位于$\overrightarrow{p<em>1p</em>{max}}$、
$\overrightarrow{p_{max}p_n}$左侧的点</li>
</ul>
</li>
<li><p>对$\overrightarrow{p<em>1p</em>{max}}$及其左侧点构成的集合
$S<em>{1,1}$、$\overrightarrow{p</em>{max}p<em>n}$及其左侧的点构成
集合$S</em>{1,2}$，重复以上即可继续得到上包顶点</p>
</li>
<li><p>类似的可以对$S_2$寻找下包顶点</p>
</li>
</ul>
<blockquote>
<p>   向量左侧、距离计算参考线代</p>
</blockquote>
<h4 id="算法特点-1"><a href="#算法特点-1" class="headerlink" title="算法特点"></a>算法特点</h4><p>快包和快排很类似</p>
<ul>
<li>最差效率$\Theta(n)$，平均效率好得多</li>
<li>也一般会把问题平均的分成两个较小子问题，提高效率</li>
<li>对于均匀分布在某些凸区域（园、矩形）的点，快包平均效率
可以达到线性</li>
</ul>
<h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><ul>
<li>计算机动画中使用凸包替换物体本身，加快碰撞检测速度</li>
<li>车辆路径规划</li>
<li>地理信息系统中根据卫星图像计算accessibility map</li>
<li>数理统计中用于进行异常值检测</li>
<li>计算点集直径的高效算法中需要用到</li>
</ul>
<h2 id="欧几里得最小生成树问题"><a href="#欧几里得最小生成树问题" class="headerlink" title="欧几里得最小生成树问题"></a>欧几里得最小生成树问题</h2><p>给定平面上n个点，构造顶点为这n个点的总长度最小的树</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h2 id="二维散点"><a href="#二维散点" class="headerlink" title="二维散点"></a>二维散点</h2><h3 id="Convex-Hull"><a href="#Convex-Hull" class="headerlink" title="Convex Hull"></a>Convex Hull</h3><p>凸包：包含点集S的<strong>最小</strong>凸集合</p>
<ul>
<li>离散点集：包含所有点的<strong>最小凸多边形</strong></li>
<li>最小：凸包一定是所有包含S的凸集合的子集</li>
<li>凸包能方便地提供目标形状或给定数据集地一个近似</li>
</ul>
<h3 id="Extreme-Point"><a href="#Extreme-Point" class="headerlink" title="Extreme Point"></a>Extreme Point</h3><p>极点：对于任何以集合中点为端点的线段，不是线段中点的点</p>
<ul>
<li><p>极点有一些特性是凸集中其他点不具备的性质</p>
<ul>
<li>单纯形法：如果存在极值，则一定可以在极点处取到</li>
<li>找到极点、极点排序方向即可解决凸包问题</li>
</ul>
</li>
<li><p>举例</p>
<ul>
<li>三角形中3个顶点</li>
<li>圆周上所有点</li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:37.000Z" title="3/21/2019, 5:27:37 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-02T10:16:43.000Z" title="8/2/2021, 6:16:43 PM">2021-08-02</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Problem/">Problem</a></span><span class="level-item">19 minutes read (About 2882 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Problem/numeric_analysis.html">数值问题</a></h1><div class="content"><h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><p>涉及连续性数学问题</p>
<ul>
<li>解方程、方程组，计算定积分，函数求值</li>
<li>和离散数学中：图、树、排序、组合相对</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><p>大部分此类问题只能近似求解</p>
<ul>
<li>泰勒展开求解$e^x$</li>
<li><em>Composite Trapezoidal rule</em>：组合梯形法则，计算
定积分</li>
</ul>
</li>
<li><p>此类问题大部分要操作实数，而实数在计算机内部只能近似表示
，大量对近近似数的算术操作可能会叠加误差，输出错误结果</p>
</li>
</ul>
<h2 id="整数乘法"><a href="#整数乘法" class="headerlink" title="整数乘法"></a>整数乘法</h2><h3 id="俄式乘法"><a href="#俄式乘法" class="headerlink" title="俄式乘法"></a>俄式乘法</h3><p>两个正整数n、m相乘的非主流算法</p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ul>
<li>反复应用以下公式，简化每步的计算<script type="math/tex; mode=display">
n为奇数：n * m = \frac n 2 * 2m + m \\
n为偶数：n * m = \frac n 2 * 2m</script></li>
<li>以$1 * m$作为算法终止条件</li>
</ul>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>n为奇数步骤中的m，可以最后累加即可</p>
</li>
<li><p>算法中只有折半、加倍、相加操作</p>
<ul>
<li>手动计算非常简便</li>
<li>计算机硬件对折半、加倍只需要移位就可</li>
</ul>
</li>
<li><p>减常因子法</p>
</li>
</ul>
<h3 id="大整数乘法"><a href="#大整数乘法" class="headerlink" title="大整数乘法"></a>大整数乘法</h3><h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><p>考虑a、b两个n位整数，n为偶数</p>
<ul>
<li><p>从中间把数字分段，得到$a_1, a_0, b_1, b_0$</p>
</li>
<li><p>则有</p>
<script type="math/tex; mode=display">\begin{align}
c & = a * b = (a_1 10^{n/2} + a_0) * (b_1 10^{n/2} + b_0) \\
& = (a_1 * b_1)10^n + (a_1 * b_0 + a_0 * b_1) 10^{n/2} + (a_0 + b_0) \\
& = c_2 10^n + c_1 10^{n/2} + c_0
\end{align}</script><ul>
<li>$c_2 = a_1 * b_1$</li>
<li>$c_0 = a_0 * b_0$</li>
<li>$c_1 = (a_1 + a_0) * (b_1 + b_0) - (c_2 + c_0)</li>
</ul>
</li>
<li><p>若n/2也是偶数，可以使用相同的方法计算得到三个乘法表达式</p>
<ul>
<li>若n为2的幂次，就可以得到计算n位数积的递归乘法</li>
<li>n迭代到足够小时，递归就可以停止</li>
</ul>
</li>
</ul>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>算法效率</p>
<ul>
<li>乘法次数递推式：$M(n)=3M(n/2), M(1)=1$，则
$M(n) = n^(log_2 3) \approx n^{1.585}$</li>
<li>加法次数递推式：$A(n)=3A(n/2) + cn, A(1)=1$，则
$A(n) \in \Theta(n^{log_2 3})$</li>
</ul>
</li>
<li><p>算法有渐进效率优势，实际性能依赖于计算机系统、算法实现
质量，在某些情况下</p>
<ul>
<li>计算8位乘法时，分治算法速度快于传统方法</li>
<li>计算超过100位时，速度是传统算法2倍</li>
</ul>
</li>
<li><p>分治法</p>
</li>
</ul>
<h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><p>计算最大公约数、最大公倍数</p>
<h4 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h4><script type="math/tex; mode=display">gcd(m, n) = gcd(n, m mod n)</script><ul>
<li>n为0，返回m作为结果结束</li>
<li>将m处以n的余数赋给r</li>
<li>将n付给m，r赋给n，返回第一步</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Euclid(m, n)</span><br><span class="line">	while n != 0 do</span><br><span class="line">		r = m mod n</span><br><span class="line">		m = n</span><br><span class="line">		n = r</span><br><span class="line">	return m</span><br></pre></td></tr></table></figure>
<h4 id="最大公倍数"><a href="#最大公倍数" class="headerlink" title="最大公倍数"></a>最大公倍数</h4><script type="math/tex; mode=display">lcm(m, n) = \frac {m * n} {gcd(m, n)}</script><ul>
<li>利用最大公约数计算最小公倍数</li>
</ul>
<h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><ul>
<li>变治法（+减可变规模）</li>
</ul>
<h2 id="特定点求值"><a href="#特定点求值" class="headerlink" title="特定点求值"></a>特定点求值</h2><h3 id="霍纳法则（计算多项式）"><a href="#霍纳法则（计算多项式）" class="headerlink" title="霍纳法则（计算多项式）"></a>霍纳法则（计算多项式）</h3><p>霍纳法则：不断将x作为公因子提取出来，合并降次后的项，然后
计算多项式在特定点的值</p>
<h4 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Horner(P[<span class="number">0.</span>.n], x)</span><br><span class="line">	<span class="comment">// 用霍纳法则求多项式在给定点的值</span></span><br><span class="line">	<span class="comment">// 输入：多项式系数数组P[0..n]、数字x</span></span><br><span class="line">	<span class="comment">// 输出：多项式在x点的值</span></span><br><span class="line">	p = P[n]</span><br><span class="line">	<span class="keyword">for</span> i = n<span class="number">-1</span> downto <span class="number">0</span> <span class="keyword">do</span></span><br><span class="line">		p = x*p + P[i]</span><br><span class="line">	<span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>
<h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>算法效率</p>
<ul>
<li>效率始终为n，只相当于直接计算中$a_n x^n$的乘法数量</li>
</ul>
</li>
<li><p>变治法</p>
</li>
</ul>
<h3 id="二进制（计算）幂"><a href="#二进制（计算）幂" class="headerlink" title="二进制（计算）幂"></a>二进制（计算）幂</h3><p>将幂次转换为二进制位串，利用二进制位串简化计算</p>
<h4 id="从左至右二进制幂"><a href="#从左至右二进制幂" class="headerlink" title="从左至右二进制幂"></a>从左至右二进制幂</h4><ul>
<li>对位串应用霍纳法则</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LeftRightBinaryExponentiation(a, B[<span class="number">0.</span>.n<span class="number">-1</span>])</span><br><span class="line">	<span class="comment">// 从左至右二进制幂算法计算a^n</span></span><br><span class="line">	<span class="comment">// 输入：数字a、表示幂次的二级制位串B[0..n-1]</span></span><br><span class="line">	<span class="comment">// 输出：a^n的值</span></span><br><span class="line">	product = a</span><br><span class="line">	<span class="keyword">for</span> i = n<span class="number">-1</span> downto <span class="number">0</span> <span class="keyword">do</span></span><br><span class="line">		product = product * product</span><br><span class="line">		<span class="keyword">if</span> B[i] == <span class="number">1</span>:</span><br><span class="line">			prduct = product * a</span><br><span class="line">	<span class="keyword">return</span> product</span><br></pre></td></tr></table></figure>
<h4 id="从右至左二进制幂"><a href="#从右至左二进制幂" class="headerlink" title="从右至左二进制幂"></a>从右至左二进制幂</h4><ul>
<li>累次计算二进制位串中为1部分值，将其累乘</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RightLeftBinaryExponentiation(a, B[<span class="number">0.</span>.n<span class="number">-1</span>])</span><br><span class="line">	<span class="comment">// 从右至左二进制幂算法</span></span><br><span class="line">	<span class="comment">// 输入：数字a、表示幂次的二级制位串B[0..n-1]</span></span><br><span class="line">	<span class="comment">// 输出：a^n的值</span></span><br><span class="line">	term = a</span><br><span class="line">	<span class="keyword">if</span> B[<span class="number">0</span>] == <span class="number">1</span></span><br><span class="line">		product = a</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		product = <span class="number">1</span></span><br><span class="line">		<span class="comment">// 保存累乘值</span></span><br><span class="line">	<span class="keyword">for</span> i = i to n <span class="keyword">do</span></span><br><span class="line">		term *= <span class="number">2</span></span><br><span class="line">		<span class="comment">// 保存二进制位为1部分值</span></span><br><span class="line">		<span class="keyword">if</span> B[i] = <span class="number">1</span></span><br><span class="line">			product = product * term</span><br><span class="line">	<span class="keyword">return</span> product</span><br></pre></td></tr></table></figure>
<h4 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>算法效率</p>
<ul>
<li>两个算法效率取决于位串长度，是对数级的</li>
</ul>
</li>
<li><p>变治法</p>
</li>
</ul>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul>
<li>在密码技术中，需要对超过100位十进制整数进行乘法运算，而
计算机往往不能直接运算</li>
</ul>
<h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><h3 id="Strassen矩阵乘法"><a href="#Strassen矩阵乘法" class="headerlink" title="Strassen矩阵乘法"></a>Strassen矩阵乘法</h3><script type="math/tex; mode=display">\begin{align}
\begin{bmatrix}
C_{00} & C_{01} \\
C_{10} & C_{11}
\end{bmatrix}
    & =
\begin{bmatrix}
A_{00} & A_{01} \\
A_{10} & A_{11}
\end{bmatrix}
\begin{bmatrix}
B_{00} & B_{01} \\
B_{10} & B_{11}
\end{bmatrix} \\
    & =
\begin{bmatrix}
M_1+M_2-M_5+M_7 & M_3+M_5 \\
M_2+M_4 & M_1+M_3-M_2+M_6
\end{bmatrix} \\

M_1 & = (A_{00} + A_{11}) · (B_{00} + B_{11}) \\
M_2 & = (A_{10} + A_{11}) · B_{00} \\
M_3 & = A_{00} · (B_{01} - B_{11}) \\
M_4 & = A_{11} · (B_{10} - B_{00}) \\
M_5 & = (A_{00} + A_{01}) · B_{11} \\
M_6 & = (A_{10} - A_{00}) · (B_{00} + B_{01}) \\
M_7 & = (A_{01} + A_{11}) · (B_{10} + B_{11}) \\
\end{align}</script><h4 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h4><p>若A、B是两个n阶方阵（若n不是2幂次，考虑填充0）</p>
<ul>
<li>将A、B、C均分块为4个n/2子矩阵</li>
<li>递归使用Strassen方程中定义的矩阵M进行计算计算C各个子阵</li>
</ul>
<h4 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>对2 * 2分块计算，Strassen算法执行了7次乘法、18次加减法，
蛮力算法需要执行8次乘法、4次加法</p>
</li>
<li><p>算法效率</p>
<ul>
<li>乘法次数递推式：$M(n) = 7M(n/2), M(1) = 1$，则
$M(n) = 7^{log<em>2 n} = n^{log_2 7} \approx n</em>{2.807}$</li>
<li>加法次数递推式：$A(n) = 7A(n/2) + 18(n/2)^2, A(1)=0$
，则$A(n) \in \Theta(n^{log_2 7})$</li>
<li>矩阵趋于无穷大时，算法表现出的渐进效率卓越</li>
</ul>
</li>
<li><p>还有一些算法能运行时间$\in \Theta(n^\alpha)$，最小能达到
2.376，但是这些算法乘法常量很大、算法复杂，没有实用价值</p>
</li>
<li><p>矩阵乘法效率下界为$n^2$，目前得到的最优效率和其还有很大
距离</p>
</li>
<li><p>分治法</p>
</li>
</ul>
<h2 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h2><ul>
<li>假设方程组系数矩阵为n阶方阵，且解唯一</li>
<li>主要思想都是高斯消元法（变治法），只是出于效率、误差有
不同实现方式</li>
</ul>
<h3 id="前向消去法"><a href="#前向消去法" class="headerlink" title="前向消去法"></a>前向消去法</h3><h4 id="算法-4"><a href="#算法-4" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ForwardElimination(A[<span class="number">1.</span>.n, <span class="number">1.</span>.n], b[<span class="number">1.</span>.n])</span><br><span class="line">	<span class="comment">// 对方程组扩展矩阵[A|b]使用高斯消元法</span></span><br><span class="line">	<span class="comment">// 输入：矩阵A[1..n, 1..n]，向量b[1..n]</span></span><br><span class="line">	<span class="comment">// 输出：扩展的上三角矩阵</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">		A[i, n+<span class="number">1</span>] = b[i]</span><br><span class="line">		<span class="comment">// 得到扩展矩阵</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span> to n<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">for</span> j = i+<span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">			<span class="keyword">for</span> k = n+<span class="number">1</span> downto i <span class="keyword">do</span></span><br><span class="line">				A[j, k] = A[j, k] - A[i, k]*A[j, i] / A[i, i]</span><br></pre></td></tr></table></figure>
<h4 id="算法特点-1"><a href="#算法特点-1" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>前向消去法不一定正确</p>
<ul>
<li>如果A[i, i]==0，不能以其作为除数，此时需要交换行
（解唯一时总是存在非0行）</li>
<li>A[i, i]非常小，导致比例因子A[j, i] / A[i, i]非常大，
产生大的舍入误差</li>
</ul>
</li>
<li><p>最内层循环效率低</p>
</li>
</ul>
<h3 id="部分选主元法"><a href="#部分选主元法" class="headerlink" title="部分选主元法"></a>部分选主元法</h3><h4 id="算法-5"><a href="#算法-5" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BetterForwardElimination(A[<span class="number">1.</span>.n, <span class="number">1.</span>.n], b[<span class="number">1.</span>.n])</span><br><span class="line">	<span class="comment">// 用部分选主元法实现高斯消去</span></span><br><span class="line">	<span class="comment">// 输入：矩阵A[1..n, 1..n]，向量b[1..n]</span></span><br><span class="line">	<span class="comment">// 输出：扩展的上三角矩阵</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">		A[i, n+<span class="number">1</span>] = b[i]</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span> to n<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">		pivotrow = i</span><br><span class="line">		<span class="keyword">for</span> j = i+<span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">			<span class="keyword">if</span> |A[j, i]| &gt; A[pivot, i]</span><br><span class="line">				pivotrow = j</span><br><span class="line">				<span class="comment">// 选择第i列系数最大的行作为第i次迭代基点</span></span><br><span class="line">				<span class="comment">// 保证比例因子绝对值不会大于1</span></span><br><span class="line">			<span class="keyword">for</span> k = i to n+<span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">				swap(A[i, k], A[pivot, k])</span><br><span class="line">			<span class="keyword">for</span> j = j+<span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">				temp = A[j, i] / A[i, i]</span><br><span class="line">				<span class="comment">// 这样只需要计算依次比例因子</span></span><br><span class="line">				<span class="keyword">for</span> k = i to n+<span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">					A[j, k] = A[j, k] - A[i, k] * temp</span><br></pre></td></tr></table></figure>
<h4 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h4><ul>
<li>部分选主元法克服了前向消去法弊端<ul>
<li>最内层乘法（加法）执行次数为
$\frac {n(n-1)(2n+5) 6 \approx \frac n^3 3 \in \Theta(n^3)$</li>
<li>始终能保证比例因子绝对值不大于1</li>
</ul>
</li>
</ul>
<h3 id="反向替换法"><a href="#反向替换法" class="headerlink" title="反向替换法"></a>反向替换法</h3><p>在得到上三角系数矩阵中</p>
<ul>
<li>从最后一个方程中可以立刻求出$x_n$</li>
<li>将$x<em>n$带入倒数第二个方程求出$x</em>{n-1}$</li>
<li>逐次递推得到所以解</li>
</ul>
<h4 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a>特点</h4><ul>
<li>算法时间效率$\in \Theta(n^2)$</li>
</ul>
<h3 id="高斯消去法应用"><a href="#高斯消去法应用" class="headerlink" title="高斯消去法应用"></a>高斯消去法应用</h3><ul>
<li>矩阵（可逆矩阵）中应用<ul>
<li>LU分解（Doolittle分解）</li>
<li>Cholesky分解（要求矩阵正定）</li>
<li>求逆</li>
<li>求行列式</li>
</ul>
</li>
<li>高斯消元法整个算法效率取决于消去部分，是立方级<ul>
<li>事实上此方法在计算机上求解大规模方程组很难，因为舍入
误差在计算过程中会不断累积</li>
</ul>
</li>
</ul>
<h2 id="非线性方程求解"><a href="#非线性方程求解" class="headerlink" title="非线性方程求解"></a>非线性方程求解</h2><ul>
<li><p>5次及以上多项式没有只包含多项式系数、算术操作、开根号
的通用求根公式</p>
</li>
<li><p>方程的代数解并不具有很大的意义，充其量只是为方程的根设置
一个符号，然后再说方程有一个根等于这个符号（高斯）</p>
</li>
</ul>
<h3 id="平分法"><a href="#平分法" class="headerlink" title="平分法"></a>平分法</h3><p>基于连续函数界值定理，类似于连续版折半查找</p>
<h4 id="算法-6"><a href="#算法-6" class="headerlink" title="算法"></a>算法</h4><p>在区间[a, b]的端点上，$f(x)$符号取反</p>
<ul>
<li>计算$f(x<em>{mid}), x</em>{mid}= \frac {a+b} 2$的值</li>
<li>若$f(x_{mid})=0$，则求得一个</li>
<li>否则选择使得$f(x)$能在端点上取得相反值区间$[a, x<em>{mid}$
、$[x</em>{mid}, b]$</li>
<li>当包含根得区间小于预定义得$\epsilon &gt; 0$时，就可以停止
算法</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Bisection(f(x), a, b, eps, N)</span><br><span class="line">	<span class="comment">// 评分法求f(x) = 0的一个根</span></span><br><span class="line">	<span class="comment">// 输入：f(a)f(b) &lt; 0，eps绝对误差上界，N迭代次数上界</span></span><br><span class="line">	<span class="comment">// 输出：(a, b)上的一个根近似（精确）值，或包含根的区间</span></span><br><span class="line">	n = <span class="number">1</span></span><br><span class="line">		<span class="comment">// 迭代计数</span></span><br><span class="line">	<span class="keyword">while</span> n &lt;= N <span class="keyword">do</span></span><br><span class="line">		x = (a + b)/<span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> x - a &lt; eps</span><br><span class="line">			 <span class="keyword">return</span> x</span><br><span class="line">		fval = f(x)</span><br><span class="line">		<span class="keyword">if</span> fval = <span class="number">0</span></span><br><span class="line">			<span class="keyword">return</span> x</span><br><span class="line">		<span class="keyword">if</span> fval*f(a) &lt; <span class="number">0</span>:</span><br><span class="line">			b = x</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			a = x</span><br><span class="line">		n += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> a, b</span><br><span class="line">		<span class="comment">// 达到迭代限制，返回包含根的区间</span></span><br></pre></td></tr></table></figure>
<h4 id="特点-8"><a href="#特点-8" class="headerlink" title="特点"></a>特点</h4><ul>
<li>求解精度<ul>
<li>理论上迭代次数足够$x_n$可以任意接近真实根$x^{*}$</li>
<li>实际上，机器使用0表示非常小的值，$\epsilon$小于特定
机器阈值时，算法不会停止，也无法得到满足条件的解</li>
<li>d对目标函数求值时可能会发生舍入误差</li>
</ul>
</li>
<li>缺点<ul>
<li>相较于其他已经算法，收敛速度较慢</li>
<li>并且无法扩展到更加一般的方程、方程组领域</li>
</ul>
</li>
<li>优点<ul>
<li>区间特性容易检验</li>
</ul>
</li>
</ul>
<h3 id="Method-of-False-Position"><a href="#Method-of-False-Position" class="headerlink" title="Method of False Position"></a>Method of False Position</h3><p>试位法：类似于连续版差值查找</p>
<h4 id="算法-7"><a href="#算法-7" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>类似平分法每次也使用某个区间$[a_n, b_n]$括住连续函数的
根，函数在端点取值符号相反</p>
</li>
<li><p>使用穿过$(a_n, f(a_n)), (b_n, f(b_n))$的直线在x轴截距
$x=\frac {a_nf(b_n) - b_nf(a_n)} {f(b_n) - f(a_n)}$作为
分割点</p>
</li>
</ul>
<h4 id="特点-9"><a href="#特点-9" class="headerlink" title="特点"></a>特点</h4><ul>
<li>对许多实例，试位法收敛速度较平分法更快</li>
</ul>
<h3 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h3><p>Newton-Raphon Method</p>
<h4 id="算法-8"><a href="#算法-8" class="headerlink" title="算法"></a>算法</h4><ul>
<li>方法产生近似解序列：函数切线在x轴截距
$x_{n+1} = x_n - \frac {f(x_n)} {f^{‘}(x_n)},n=0,1,\cdots$</li>
</ul>
<h4 id="特点-10"><a href="#特点-10" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>大多数情况下，若初值$x_0$足够接近根，牛顿法能够保证序列
收敛与根；对远离根的初值，无法保证一定会收敛</p>
</li>
<li><p>优点</p>
<ul>
<li>牛顿法相较于平分法、试位法收敛速度更快，选定合适的
初值能够快速收敛</li>
<li>能够应用于更一般类型的方程、方程组</li>
</ul>
</li>
<li><p>方法每次都迭代需要重新求函数、导数值</p>
<ul>
<li>导数值等于0，则牛顿法失效</li>
<li>导数绝对值越大，牛顿法越有效</li>
</ul>
</li>
<li><p>牛顿法不会把根括起来</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:15.000Z" title="3/21/2019, 5:27:15 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-03-14T09:29:47.000Z" title="3/14/2019, 5:29:47 PM">2019-03-14</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">8 minutes read (About 1263 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/data_structure_abstract.html">Abstract Data Type</a></h1><div class="content"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<ul>
<li><em>data</em>：数据，对客观事物的符号表示，在计算机科学中，指
  所以能输入计算机中、并被计算机处理的符号总称</li>
<li><em>data element</em>：数据元素，数据基本单位，在计算机中通常
  作为整体考虑</li>
<li><em>data item</em>：数据项，数据元素的组成部分</li>
<li><em>data object</em>：数据对象，性质相同的数据元素的集合，数据
  的子集</li>
</ul>
</blockquote>
<h3 id="Data-Structure"><a href="#Data-Structure" class="headerlink" title="Data Structure"></a><em>Data Structure</em></h3><p>数据结构：相互直接存在<strong>一种或多种特定</strong>关系的数据元素的集合</p>
<ul>
<li>使用基本类型不断组合形成的<strong>层次结构</strong></li>
<li>某种意义上，数据结构可以看作是<strong>一组具有相同结构的值</strong></li>
</ul>
<script type="math/tex; mode=display">
Data_Structure = (D, S)</script><blockquote>
<ul>
<li>$D$：数据元素有限集</li>
<li>$S$：结构/关系有限集，数据元素之间相互之间的<strong>逻辑关系</strong></li>
</ul>
</blockquote>
<ul>
<li><p>集合：结构中数据元素<strong>只有同属一个集合</strong>的关系</p>
</li>
<li><p>线性结构：结构中数据元素之间存在<strong>一对一</strong>关系</p>
<ul>
<li>存在唯一一个被称为“第一个”的数据元素</li>
<li>存在唯一一个被称为“最后一个”的数据元素</li>
<li>除第一个外，每个数据元素均只有一个前驱</li>
<li>除最后一个外，每个数据元素均只有一个后继</li>
</ul>
</li>
<li><p>树型结构：结构中数据元素存在<strong>一对多</strong>关系</p>
</li>
<li><p>图状/网状结构：结构中数据元素存在<strong>多对多</strong>的关系</p>
</li>
</ul>
<h3 id="关系表示"><a href="#关系表示" class="headerlink" title="关系表示"></a>关系表示</h3><blockquote>
<ul>
<li>逻辑结构：数据结构中描述的逻辑关系</li>
<li>物理/存储结构：数据结构在计算机中的表示（映像）</li>
</ul>
</blockquote>
<p>数据元素之间关系在计算机中映像/表示方法/存储结构</p>
<ul>
<li><p>顺序映像：借助元素在存储器中的<strong>相对位置</strong>表示数据元素
之间的逻辑关系</p>
<ul>
<li>需要使用<strong>地址连续的存储单元依次存储</strong>数据元素</li>
<li>所以需要静态分配空间，即给可能数据对象<strong>预分配</strong>空间
，空间不够时只能重新分配</li>
<li>由此得到<strong>顺序存储结构</strong></li>
</ul>
</li>
<li><p>非顺序/链式映像：借助<strong>指示元素</strong>存储地址的指针表示数据
元素之间的逻辑关系</p>
<ul>
<li>可以使用任意存储单元存储数据元素，另外存储一个指示
其直接后继的信息</li>
<li>常用动态分配空间，即在需要创建数据对象时给其分配空间</li>
<li>也可以静态分配空间，使用地址连续的存储单元存储数据
对象，此时指示元素可以是序号</li>
<li>由此得到<strong>链式存储结构</strong></li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><em>node</em>：节点，数据元素信息、直接后继元素信息的存储映像</li>
<li>数据域：存储元素信息的域</li>
<li>指针域：存储直接后继位置的域</li>
</ul>
</blockquote>
<h3 id="Data-Type"><a href="#Data-Type" class="headerlink" title="Data Type"></a><em>Data Type</em></h3><p>数据类型：<strong>值的集合</strong>和定义在值集上的<strong>一组操作</strong>的总称</p>
<blockquote>
<ul>
<li><em>atomic data type</em>：原子类型，值不可分解</li>
<li><em>fixed-aggregate data type</em>：固定聚合类型，值由确定数目
  的成分按某种结构组成</li>
<li><em>variable-aggregate data type</em>：可变聚合类型，值的成分
  数目不确定</li>
<li>结构类型：固定、可变聚合类型的统称，值由若干成分按某种
  结构组成，可分解，其成分可以是结构或非结构<blockquote>
<ul>
<li>结构类型可以看作是由一种数据结构和定义在其上的一组
 操作组成</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<ul>
<li>在计算机中，每个处理核心（硬件、软件）都提供了一组原子
类型或结构类型</li>
<li>从硬件角度，引入数据类型是作为<strong>解释计算机内存中信息</strong>
含义的手段</li>
<li>对使用者而言，实现了信息的隐蔽</li>
</ul>
<h4 id="Abtract-Data-Type"><a href="#Abtract-Data-Type" class="headerlink" title="Abtract Data Type"></a><em>Abtract Data Type</em></h4><p><em>ADT</em>：抽象数据类型，一个<strong>数学模型</strong>已经定义在该模型上的
一组操作</p>
<script type="math/tex; mode=display">
Data_Type = (D, S, P)</script><blockquote>
<ul>
<li>$D$：数据对象</li>
<li>$S$：D上的关系集</li>
<li>$P$：对D的基本操作集</li>
</ul>
</blockquote>
<ul>
<li><strong>根据其行为而不是其内部表示</strong>定义类型</li>
<li>实质上与数据类型是同一个概念，“抽象”的意义在于数据类型的
数学抽象特性<ul>
<li>或者说抽象数据类型范畴更广，包括自定义数据类型</li>
</ul>
</li>
<li>抽象层次越高，含有该抽象数据类型的程序复用程度越高</li>
</ul>
<h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><ul>
<li><p><em>ADT</em>是面向对象编程的核心</p>
</li>
<li><p>将对象行为和其实现相分离，这也是面向对象编程的基本
技术</p>
<ul>
<li><em>simplicity</em>：简单性，隐藏细节方便理解</li>
<li><em>flexibility</em>：灵活性，类通过对外行为被定义，可以
自由改变内部实现</li>
<li><em>security</em>：安全性，扮演防火墙，确保实现、用户彼此
分离</li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:15.000Z" title="3/21/2019, 5:27:15 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-02-22T03:22:21.000Z" title="2/22/2019, 11:22:21 AM">2019-02-22</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">44 minutes read (About 6539 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/alg_analysis.html">算法分析</a></h1><div class="content"><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>算法：一系列解决问题的<strong>明确</strong>指令，即对于符合一定规范的
输入，能够在有限时间内获得要求的输出</p>
<ul>
<li>算法每步都必须<strong>没有歧义</strong></li>
<li>必须确定算法所处理的<strong>输入的值域</strong></li>
<li>同一算法可以用几种不同的形式描述</li>
<li>同一问题，可能存在几种不同的算法</li>
<li>同问题的不同算法，可能基于不同的解题思路，速度也会不同</li>
</ul>
<h3 id="算法正确性证明"><a href="#算法正确性证明" class="headerlink" title="算法正确性证明"></a>算法正确性证明</h3><ul>
<li>对某些算法，正确性证明十分简单，对于另一些算法，可能十分
复杂</li>
<li>证明正确性的一般方法是使用数学归纳法，因为算法的迭代过程
本身就符合其所需的一系列步骤</li>
<li>根据特定输入追踪算法操作有意义，但是并不能证明算法的
正确性，只需要一个算法不能正确处理的输入实例就足够了</li>
<li>对于近似算法，常常试图证明算法所产生的误差，不超出预定义
的误差</li>
</ul>
<h3 id="算法分析方向"><a href="#算法分析方向" class="headerlink" title="算法分析方向"></a>算法分析方向</h3><ul>
<li>时间效率（time efficiency）：算法运行速度</li>
<li>空间效率（space efficiency）：算法需要多少额外的存储空间</li>
<li>简单性（simplicity）：取决于审视者的眼光<ul>
<li>简单的算法更容易理解、实现</li>
<li>相应程序包含更少的bug</li>
</ul>
</li>
<li>一般性（generality）<ul>
<li>所解决问题的一般性</li>
<li>所接受输入的一般性</li>
</ul>
</li>
<li>最优性（optimality）：与所解决问题的复杂度有关，与某算法
效率无关</li>
<li>是否每个问题都能够用算法的方法来解决</li>
</ul>
<h3 id="非确定性"><a href="#非确定性" class="headerlink" title="非确定性"></a>非确定性</h3><h4 id="Deterministic-Alogrithm"><a href="#Deterministic-Alogrithm" class="headerlink" title="Deterministic Alogrithm"></a><em>Deterministic Alogrithm</em></h4><p>确定算法：利用问题解析性质，产生确定的有限、无限序列使其收敛
于全局最优解</p>
<ul>
<li><p>依某确定性策略搜索局部极小，试图跳跃已获得的局部极小而
达到某个全局最优点</p>
</li>
<li><p>能充分利用问题解析性质，从计算效率高</p>
</li>
</ul>
<h4 id="Nondeterministic-Algorithm"><a href="#Nondeterministic-Algorithm" class="headerlink" title="Nondeterministic Algorithm"></a><em>Nondeterministic Algorithm</em></h4><p>不确定算法，包括两个阶段，将判定问题的实例l作为其输入</p>
<blockquote>
<ul>
<li>猜测（非确定）阶段：生成任意串S作为l候选解</li>
<li>验证（确定）阶段：把l、S作为输入，，若S是l解输出<em>是</em>，
  否则返回<em>否</em>或无法停止</li>
</ul>
</blockquote>
<ul>
<li><p>当选仅当对问题每个真实例，不确定算法会在<strong>某次</strong>执行中
返回<em>是</em>时，称算法能求解此问题</p>
</li>
<li><p>即要求不确定算法对某个解至少能够猜中一次、验证正确性，
同时不应该将错误答案判定为<em>是</em></p>
</li>
<li><p><em>Nondeterministic Polynominal Algorithm</em>：验证阶段时间
效率是多项式级的不确定算法</p>
</li>
</ul>
<h2 id="分析框架"><a href="#分析框架" class="headerlink" title="分析框架"></a>分析框架</h2><ul>
<li>time complexity：算法运行速度</li>
<li>space complexity：算法需要的额外空间<ul>
<li>算法需要的额外空间已经不是需要重点关注的问题</li>
</ul>
</li>
</ul>
<h3 id="影响因素"><a href="#影响因素" class="headerlink" title="影响因素"></a>影响因素</h3><h4 id="输入规模-n"><a href="#输入规模-n" class="headerlink" title="输入规模$n$"></a>输入规模$n$</h4><ul>
<li><p>几乎所有算法，对规模更大的输入需要运行更长时间，因此使用
输入规模作为参数很有价值</p>
</li>
<li><p>在有些情况下，选择不同的参数表示输入规模有差别</p>
</li>
<li><p>选择输入规模的度量单位还受到算法的操作细节影响</p>
</li>
<li><p>和数字特性相关的算法，倾向于使用$n$的二进制位数
$b=\lfloor {log_{2}^{n}} \rfloor + 1$</p>
</li>
</ul>
<h4 id="其他因素"><a href="#其他因素" class="headerlink" title="其他因素"></a>其他因素</h4><p>有些算法的运行时间不仅取决于输入规模，还取决于特定输入的细节</p>
<ul>
<li><em>worst-case efficiency</em>：最坏情况下的效率</li>
<li><em>best-case efficiency</em>：最优情况下的效率</li>
<li><em>average-case efficiency</em><ul>
<li>平均效率的研究比最差、优效率研究困难很多</li>
<li>可以将输入划分为几种类型，使得对同类实例，算法基本
执行次数相同，推导各类输入的概率分布，得到平均次数</li>
</ul>
</li>
<li><em>amortized efficiency</em>：应用于算法对同样的数据结构所执行
的一系列操作<ul>
<li>有些情况下，算法单次执行时间代价高，但是n次运行的
总运行时间明显优于单次执行最差效率 * n</li>
</ul>
</li>
</ul>
<h3 id="衡量角度"><a href="#衡量角度" class="headerlink" title="衡量角度"></a>衡量角度</h3><h4 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h4><ul>
<li><p>使用<strong>时间</strong>标准的度量算法程序运行时间缺陷</p>
<ul>
<li>计算机速度</li>
<li>程序实现质量</li>
<li>编译器</li>
<li>计时困难</li>
</ul>
</li>
<li><p>找到<em>basic operation</em>并计算其运行次数</p>
<ul>
<li>不依赖于其他无关因素</li>
<li>对总运行时间贡献最大，不需要统计算法每步操作执行次数</li>
<li>如：对排序基本操作为键比较，数学问题则是四则运算，
需要注意除法、乘法、加减法耗时依次减小</li>
</ul>
</li>
<li><p>时间估计</p>
<ul>
<li>$c_{op}$：特定计算一个基本操作的执行时间</li>
<li>$C(n)$：算法执行基本操作的次数</li>
<li>$T(n)=c_{op}C(n)$：可以用于估算算法的执行时间<ul>
<li>需要小心使用</li>
<li>$C(n)$不包含非基本操作的信息，也只是估计的结果</li>
<li>$c_{op}$也是不可靠的估计值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Order-of-Growth"><a href="#Order-of-Growth" class="headerlink" title="Order of Growth"></a>Order of Growth</h4><p>小规模输入运行时间差别不足以将高效算法与低效算法相区别，
对大规模输入忽略乘法常量，仅关注执行次数的<em>order of growth</em>
及其常数倍，即算法的渐进效率</p>
<ul>
<li><p>按照算法渐进效率进行分类的方法缺乏使用价值，因为没有指定
乘法常量的值</p>
</li>
<li><p>但是对于实际类型输入，除了少数算法，乘法常量之间不会相差
悬殊，作为规律，即使是中等规模的输入，属于较优渐进
效率类型的算法也会比来自较差类型的算法效果好</p>
</li>
<li><p>对数函数：增长慢，以至于可以认为，对数级操作次数的算法能
瞬间完成任何实际规模输入</p>
</li>
<li>指数级：指数函数、阶乘函数<ul>
<li>需要指数级操作次数的算法只能用于解决规模非常小的问题</li>
</ul>
</li>
</ul>
<h3 id="渐进效率"><a href="#渐进效率" class="headerlink" title="渐进效率"></a>渐进效率</h3><h4 id="渐进符号"><a href="#渐进符号" class="headerlink" title="渐进符号"></a>渐进符号</h4><h5 id="O-g-n"><a href="#O-g-n" class="headerlink" title="$O(g(n))$"></a>$O(g(n))$</h5><ul>
<li><p>对于足够大的n，$t(n)$的上界由$g(n)$的常数倍确定，则
$t(n) \in O(g(n))$</p>
</li>
<li><p>即存在大于0的常数$c$、非负整数$n_{0}$，使得</p>
<script type="math/tex; mode=display">n > n_{0} 时，t(n) \leqslant cg(n)</script></li>
<li><p>增长次数小于等于$g(n) n \rightarrow \infty$
（及常数倍）的函数集合</p>
</li>
</ul>
<h5 id="Omega-g-n"><a href="#Omega-g-n" class="headerlink" title="$\Omega (g(n))$"></a>$\Omega (g(n))$</h5><ul>
<li><p>对于足够大的n，$t(n)$的下界由$g(n)$的常数倍确定，则
$t(n) \in \Omega(g(n))$</p>
</li>
<li><p>即存在大于0的常数$c$、非负整数$n_{0}$，使得</p>
<script type="math/tex; mode=display">n > n_{0} 时，t(n) \geqslant cg(n)</script></li>
<li><p>增长次数大于等于$g(n) n \rightarrow \infty$
（及常数倍）的函数集合</p>
</li>
</ul>
<h5 id="Theta-g-n"><a href="#Theta-g-n" class="headerlink" title="$\Theta (g(n))$"></a>$\Theta (g(n))$</h5><ul>
<li><p>对于足够大的n，$t(n)$的上、下界由$g(n)$的常数倍确定，则
$t(n) \in \Theta(g(n))$</p>
</li>
<li><p>即存在大于0的常数$c<em>{1}, c</em>{2}$、非负整数$n_{0}$，使得</p>
<script type="math/tex; mode=display">
n > n_{0} 时，c_{2}g(n) \leqslant t(n) \leqslant c_{1}g(n)</script></li>
<li><p>增长次数等于$g(n) n \rightarrow \infty$（及常数倍）
的函数集合</p>
</li>
</ul>
<h4 id="极限比较增长次数"><a href="#极限比较增长次数" class="headerlink" title="极限比较增长次数"></a>极限比较增长次数</h4><p>利用极限比较增长次数：比直接利用定义判断算法的增长次数方便，
可以使用微积分技术计算极限</p>
<script type="math/tex; mode=display">
\lim_{n \rightarrow \infty} \frac {t(n)} {g_n}
\left\{
    \begin{array}\\
    0        & t(n)的增长次数比g(n)小，t(n) \in O(g(n))\\
    c>0        & t(n)的增长次数同g(n)，t(n) \in \Theta(g(n)) \\
    \infty    & t(n)的增长次数比g(n)大，t(n) \in \Omega(g(n))\\
    不存在 \\
    \end{array}
\right.</script><h4 id="基本渐进效率类型"><a href="#基本渐进效率类型" class="headerlink" title="基本渐进效率类型"></a>基本渐进效率类型</h4><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>$1$</td>
<td>常量</td>
<td>很少，效率最高</td>
</tr>
<tr>
<td>$log_{n}$</td>
<td>对数</td>
<td>算法的每次循环都会消去问题规模的常数因子，对数算法不可能关注输入的每个部分</td>
</tr>
<tr>
<td>$n$</td>
<td>线性</td>
<td>能关注输入每个部分的算法至少是线性运行时间</td>
</tr>
<tr>
<td>$nlog_{n}$</td>
<td>线性对数</td>
<td>许多分治算法都属于此类型</td>
</tr>
<tr>
<td>$n^{2}$</td>
<td>平方</td>
<td>包含两重嵌套循环的典型效率</td>
</tr>
<tr>
<td>$n^{3}$</td>
<td>立方</td>
<td>包含三重嵌套循环的典型效率</td>
</tr>
<tr>
<td>$2^{n}$</td>
<td>指数</td>
<td>求n个元素的所有子集</td>
</tr>
<tr>
<td>$n!$</td>
<td>阶乘</td>
<td>n个元素集合的全排列</td>
</tr>
</tbody>
</table>
</div>
<h2 id="算法的数学分析"><a href="#算法的数学分析" class="headerlink" title="算法的数学分析"></a>算法的数学分析</h2><h3 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h3><h4 id="分析通用方案"><a href="#分析通用方案" class="headerlink" title="分析通用方案"></a>分析通用方案</h4><ol>
<li>决定表示输入规模的参数</li>
<li>找出算法的基本操作：一般位于算法最内层循环</li>
<li>检查算法基本操作执行次数是否只依赖于输入规模，如果和其他
特性有关，需要分别研究最差、最优、平均效率</li>
<li>建立算法基本操作执行次数的求和表达式（或者是递推关系）</li>
<li>利用求和运算的标准公式、法则建立操作次数的闭合公式，或
至少确定其增长次数</li>
</ol>
<h3 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h3><p>用一个方程把squence的generic term和一个或多个其他项相关联，
并提供第一个项或前几项的精确值</p>
<script type="math/tex; mode=display">
\begin{array}\\
    x(n) = x(n-1) + n (n>0) \\
    x(0) = 0
\end{array}</script><ul>
<li><em>recurrence</em>：递推式</li>
<li><em>initial condition</em>：序列起始值、递归调用结束条件</li>
<li>求解：找到序列通项的精确公式满足递推式、初始条件，或者
证明序列不存在</li>
<li><em>general solution</em>：满足<strong>递推方程</strong>所有解序列公式，通常
会包含参数</li>
<li><em>particular solution</em>：满足给定递推方程的特定序列，通常
感兴趣的是满足初始条件的特解</li>
</ul>
<h4 id="递归求解方法"><a href="#递归求解方法" class="headerlink" title="递归求解方法"></a>递归求解方法</h4><ul>
<li><p><em>method of forward substituion</em>：从序列初始项开始，使用
递推方程生成给面若干项，从中找出能用闭合公式表示的模式</p>
<ul>
<li>带入递推方程、初始条件验证</li>
<li>数学归纳法证明</li>
</ul>
</li>
<li><p><em>method of backward subsitution</em>：从序列末尾开始，把序列
通项$x(n)$表示为$x(n-i)$的函数，使得i是初始条件之一，
再求和公式得到递推式的解</p>
</li>
<li><p><em>second-order linear recurrence with constant coefficients</em>
：求解<em>characteristic equation</em>得到特征根得到通解</p>
</li>
</ul>
<h4 id="常见递推类型"><a href="#常见递推类型" class="headerlink" title="常见递推类型"></a>常见递推类型</h4><h5 id="decrease-by-one"><a href="#decrease-by-one" class="headerlink" title="decrease-by-one"></a><em>decrease-by-one</em></h5><p>减一法：利用规模为n、n-1的给定实例之间的关系求解问题</p>
<ul>
<li>减常数法特例</li>
</ul>
<script type="math/tex; mode=display">
\begin{align*}
T(n)& = T(n-1) + f(n) \\
    & = T(n-2) + f(n-2) + f(n) \\
    & = \cdots \\
    & = T(0) + \sum_{j=1}^{n} f(j) \\
\end{align*}</script><h5 id="decrease-by-a-constant-factor"><a href="#decrease-by-a-constant-factor" class="headerlink" title="decrease-by-a-constant-factor"></a><em>decrease-by-a-constant-factor</em></h5><p>减常因子法：把规模为n的实例化简为规模为n/b的实例求解问题</p>
<script type="math/tex; mode=display">
\begin{align*}
T(b^{k}) &= T(b^{k-1}) + f(b^{k}) \\
        &= T(b^{k-2}) + f(b^{k-1}) + f(b^{k}) \\
        &= \cdots \\
        &= T(1) + \sum_{j=1}^{k} f(b^{j})
\end{align*}</script><h5 id="divide-and-conquer"><a href="#divide-and-conquer" class="headerlink" title="divide-and-conquer"></a><em>divide-and-conquer</em></h5><p>分治法：将给定实例划分为若干较小实例，对每个实例递归求解，如有必要，
再将较小实例的接合并为给定实例的一个解</p>
<script type="math/tex; mode=display">
\begin{align*}
T(b^{k}) &= aT(n/b) + f(n) \\
        &= a[aT(b^{k-2} + f(b^{k-1})] + f(b^{k}) \\
        &= a^{2}T(b^{k-2}) + af(b^{k-1}) + f(b^{k}) \\
        &= a^{2}[aT(b^{k-3} + f(b^{k-2})] + af(b^{k-1}) + f(b^{k}) \\
        &= a^{3}aT(b^{k-3} + a^{2}f(b^{k-2}) + af(b^{k-1}) + f(b^{k}) \\
        &= \cdots \\
        &=a^{k}T(1) + a^{k-1}f(b^{1}) + a^{k-2}f(b^{2}) + \cdots + a^{0}f(b^{k}) \\
        &=a^{k} \left[ T(1) + \sum_{j=1}^{k} \frac {f(b^{j})} {a^{j}} \right] \\

n = b^{k} \\
T(n) &= n^{log_{b}^{a}} \left[ T(1) + \sum_{j=1}^{log_{b}^{n}} \frac {f(b^{j})} {a^{j}} \right]
\end{align*}</script><h4 id="平滑法则、主定理"><a href="#平滑法则、主定理" class="headerlink" title="平滑法则、主定理"></a>平滑法则、主定理</h4><ul>
<li><p><em>eventually nondecreaing</em>：$f(n)$在自然数上非负，若
$\exists n<em>{0}, \forall n</em>{2} &gt; n<em>{1} \geqslant n</em>{0}, f(n<em>{2}) &gt; f(n</em>{1})$，
则为最终非递减</p>
</li>
<li><p><em>smooth</em>：$f(n)$在自然数上非负、最终非递减，若
$f(2n) \in \Theta(f(n))$，则平滑</p>
<ul>
<li>若$f(n)$平滑，则对任何整数b有$f(bn) \in \Theta(f(n))$</li>
</ul>
</li>
</ul>
<h5 id="平滑法则"><a href="#平滑法则" class="headerlink" title="平滑法则"></a>平滑法则</h5><p>$T(n)$最终非递减，$f(n)$平滑，若$n=b^{k}(b&gt;2)$时有
$T(n) \in \Theta(f(n))$，则$T(n) \in \Theta(f(n))$</p>
<h5 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h5><ul>
<li>方便对分治法、减常因子法效率进行分析</li>
</ul>
<p>$T(n)$最终非递减，满足递推式</p>
<script type="math/tex; mode=display">
T(n) = aT(n/b) + f(n), \quad n=b^{k}, k=1,2,3,\cdots \\
T(1) = c \\
a \geqslant 1, b \geqslant 2, c > 0</script><p>若$f(n) \in \Theta(n^{d}), d \geqslant 0$，则</p>
<script type="math/tex; mode=display">T(n) \in
\left\{
    \begin{array}\\
    \Theta(n^{d})    & a<b^{d} \\
    \Theta(n^{d}log_{n})    & a=b^{d} \\
    \Theta(n^{log_{b}^{a}})    & a>b^{d} \\
    \end{array}
\right.</script><h4 id="分析通用方案-1"><a href="#分析通用方案-1" class="headerlink" title="分析通用方案"></a>分析通用方案</h4><ol>
<li>决定衡量输入规模的参数</li>
<li>找出算法基本操作</li>
<li>检查算法基本操作执行次数是否只依赖于输入规模，如果和其他
特性有关，需要分别研究最差、最优、平均效率</li>
<li>建立算法基本操作执行次数的递推关系、相应初始条件</li>
<li>求解递推式，或至少确定其增长次数</li>
</ol>
<h2 id="算法时间效率极限"><a href="#算法时间效率极限" class="headerlink" title="算法时间效率极限"></a>算法时间效率极限</h2><p>确定已知、未知算法效率极限</p>
<h3 id="算法下界"><a href="#算法下界" class="headerlink" title="算法下界"></a>算法下界</h3><p>算法下界是问题可能具有的最佳效率</p>
<ul>
<li><p>可以用于评价某问题具体算法效率</p>
<ul>
<li>不同问题算法直接比较无意义</li>
</ul>
</li>
<li><p>寻找问题的更优算法时，可以根据算法下界确定期望获得的改进</p>
<ul>
<li>若算法下界是紧密的，则改进至多不过是常数因子</li>
<li>若算法下界和算法仍有差距，则可能存在更快算法，或者是
证明更好的下界</li>
</ul>
</li>
</ul>
<h4 id="Trivial-Lower-Bound"><a href="#Trivial-Lower-Bound" class="headerlink" title="Trivial Lower Bound"></a>Trivial Lower Bound</h4><p>平凡下界：任何算法只要要“读取”所有要处理的项、“写”全部
输出，对其计数即可得到平凡下界</p>
<ul>
<li><p>往往过小，用处不大</p>
</li>
<li><p>确定问题中所有算法都必须要处理的输入也是个障碍</p>
</li>
<li><p>例</p>
<ul>
<li><p>生成n个不同项所有排列的算法$\in \Omega(n!)$，且下界
是紧密的，因为好的排列算法在每个排列上时间为常数</p>
</li>
<li><p>计算n次多项式值算法至少必须要处理所有系数，否则改变
任意系数多项式值改变，任何算法$\in \Omega(n)$</p>
</li>
<li><p>计算两个n阶方阵乘积算法$\in Omega(n^2)$，因为任何
算法必须处理矩阵中$2n^2$个元素</p>
</li>
</ul>
</li>
</ul>
<h4 id="Information-Theoretic-Lower-Bound"><a href="#Information-Theoretic-Lower-Bound" class="headerlink" title="Information-Theoretic Lower Bound"></a>Information-Theoretic Lower Bound</h4><p>信息论下界：试图通过算法必须处理的信息量（比特数）建立
效率下界</p>
<ul>
<li><p>例</p>
<ul>
<li>猜整数中，整数的不确定信息量就是
$\lceil \log_2 n \rceil$（数字二进制位数），
n为整数上界</li>
</ul>
</li>
</ul>
<h4 id="Adversary-Lower-Bound"><a href="#Adversary-Lower-Bound" class="headerlink" title="Adversary Lower Bound"></a>Adversary Lower Bound</h4><p>敌手下界：敌手基于恶意、一致的逻辑，迫使算法尽可能多执行，
从而确定的为了保证算法正确性的下界</p>
<blockquote>
<ul>
<li>恶意使得它不断把算法推向最消耗时间的路径</li>
<li>一致要求它必须和已经做出的选择保持一致（按照一定规则）</li>
</ul>
</blockquote>
<ul>
<li><p>例</p>
<ul>
<li><p>猜整数中，敌手把1~n个数字作为可选对象，每次做出判断
后，敌手保留数字较多集合，使得最消耗时间、不违背之前
选择</p>
</li>
<li><p>两个有序列表${a_i}, {b_j}$归并排序中，敌手使用规则：
当前仅当i &lt; j时，对$a_i &lt; b_j$返回真（设置列表值大小
可以达到），则任何算法必须比较2n-1次，否则交换未比较
元素归并错误</p>
</li>
</ul>
</li>
</ul>
<h4 id="问题化简"><a href="#问题化简" class="headerlink" title="问题化简"></a>问题化简</h4><p>问题Q下界已知，考虑<strong>将问题Q转换</strong>为下界未知问题P，得到P下界</p>
<blockquote>
<ul>
<li>应该表明任意Q问题实例可以转换为P问题</li>
<li>即问题Q应该是问题P的子集，正确的算法至少应该能解决Q问题</li>
</ul>
</blockquote>
<ul>
<li><p>许多问题复杂性不清楚，而对问题复杂度的直观判断和问题表现
形式相关，并不可靠</p>
</li>
<li><p>常在问题化简中使用的已知下界问题</p>
<p>|问题|下界|紧密性|
|——-|——-|——-|
|排序|$\Omega(nlogn)$|是|
|有序数组查找|$\Omega(logn)$|是|
|元素惟一性|$\Omega(nlogn)$|是|
|n位整数乘法|$\Omega(n)$|未知|
|n阶方程点乘|$\Omega(n^2)$|未知|</p>
</li>
<li><p>例</p>
<ul>
<li><p>欧几里得最小生成树：使用元素唯一性问题作为下界已知
问题</p>
<ul>
<li>将n个实数映射为x轴上的n个点</li>
<li>设T为此点集最小生成树，T必然包含一条最短边??#todo</li>
<li>检查T是否包含长度为0的边即为元素惟一性</li>
</ul>
</li>
<li><p>任意矩阵A、B乘法：使用方阵乘法作为下界已知问题</p>
<ul>
<li><p>将A、B化成对称方阵进行计算</p>
<script type="math/tex; mode=display">
X =  \begin{bmatrix}
0 & A \\
A^T & 0 \\
\end{bmatrix},
Y = \begin{bmatrix}
0 & B^T \\
B & 0 \\
\end{bmatrix} \\
XY = \begin{bmatrix}
AB & 0 \\
0 & A^TB^T \\
\end{bmatrix}</script></li>
<li><p>乘积AB可以方便提取，而翻倍的矩阵乘法不会影响复杂性</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="决策树（二叉）"><a href="#决策树（二叉）" class="headerlink" title="决策树（二叉）"></a>决策树（二叉）</h3><p>可以使用（二叉）决策树研究基于比较的算法性能</p>
<ul>
<li><p>每个非叶子节点代表一次键值比较</p>
</li>
<li><p>叶子节点个数大于等于输出，不同叶子节点可以产生相同输出</p>
</li>
<li><p>对于特定规模为n的输入，算法操作沿着决策树一条从根到叶子
节点完成，所以最坏情况下比较次数等于算法<strong>决策树高度</strong></p>
</li>
<li><p>如果树具有由输出数量确定叶子，则树必须由足够高度容纳叶子
，即对于任何具有$l$个叶子，树高度
$h \leqslant \lceil log_2 l \rceil$，这也就是
信息论下界</p>
</li>
</ul>
<h4 id="线性表排序"><a href="#线性表排序" class="headerlink" title="线性表排序"></a>线性表排序</h4><p>任意n个元素列表排序输出数量等于$n!$，所以任何基于比较的排序
算法的二叉树高度，即最坏情况下比较次数</p>
<script type="math/tex; mode=display">
\begin{align*}
C_{worst} & \geqslant \lceil log_2 n! \rceil \\
    & \approx log_2 \sqrt {2\pi n} (n/e)^n  \\
    & = nlog_2n - nlog_2e + \frac {log_2n + log_22\pi} 2 \\
    & \approx nlog_2n
\end{align*}</script><ul>
<li><p>归并排序、堆排序在最坏情况下大约必须要做$nlog_2n$次比较
，所以其渐进效率最优</p>
</li>
<li><p>也说明<strong>渐进下界</strong>$\lceil log_2n! \rceil$是紧密的
，不能继续改进</p>
<ul>
<li><p>但这个只是基于二叉决策树的渐进下界，对于具体值估计
可能不准</p>
</li>
<li><p>如$\lceil log_2 12! \rceil = 29$，而事实证明
12个元素排序30次比较是必要、充分的</p>
</li>
</ul>
</li>
<li><p>也可以使用决策树分析基于比较的排序算法的平均性能，即
决策树叶子节点平均深度</p>
<ul>
<li><p>基于排序的所有输出都不特殊的标准假设，可以证明平均
比较次数<strong>下界</strong>$C_{avg}(n) \geqslant log_2n!$</p>
</li>
<li><p>这个平均是建立在所有输出都不特殊假设上，所以这个其实
应该是<strong>不同算法平均比较次数下界的上界</strong></p>
</li>
<li><p>对于单独排序算法，平均效率会明显好于最差效率</p>
</li>
</ul>
</li>
</ul>
<h4 id="有序线性表查找"><a href="#有序线性表查找" class="headerlink" title="有序线性表查找"></a>有序线性表查找</h4><p>有序线性表查找最主要算法是折半查找，其在最坏情况下下效率
$C<em>{worst}^{bs} = \lfloor log_2n \rfloor + 1 = \lceil log</em>(n+1) \rceil$</p>
<ul>
<li><p>折半查找使用的<strong>三路比较</strong>（小于、等于、大于），可以使用
三叉查找树表示</p>
<ul>
<li><p>三叉查找树会有2n+1个节点：n个查找成功节点、n+1个查找
失败节点</p>
</li>
<li><p>所以在最坏情况下，比较次数下界
$C_{worst}(n) \geqslant \lceil log_3{2n+1} \rceil$
小于折半查找最坏情况下比较次数（渐进）</p>
</li>
</ul>
</li>
<li><p>然而，事实上可以删除三叉查找树中间子树（等于分支），得到
一棵二叉树</p>
<ul>
<li><p>非叶子节点同样表示三路比较，只是同时作为查找成功终点</p>
</li>
<li><p>可以得到一个新的下界
$C_{worst}(n) \geqslant \lceil log_2{n+1} \rceil$</p>
</li>
</ul>
</li>
<li><p>更复杂的分析表明，标准查找假设下，折半查找平均情况比较
次数是最少的</p>
<ul>
<li>查找成功时$log_2n - 1$</li>
<li>查找失败时$log_2(n+1)$</li>
</ul>
</li>
</ul>
<h2 id="P、NP、完全NP问题"><a href="#P、NP、完全NP问题" class="headerlink" title="P、NP、完全NP问题"></a>P、NP、完全NP问题</h2><h3 id="复杂性理论"><a href="#复杂性理论" class="headerlink" title="复杂性理论"></a>复杂性理论</h3><blockquote>
<ul>
<li><p>如果算法的最差时间效率$\in O(p(n))$，$p(n)$为问题输入
  规模n的多项式函数，则称算法能在多项式时间内对问题求解</p>
</li>
<li><p><em>Tractable</em>：易解的，可以在多项式时间内求解的问题</p>
</li>
<li><p><em>Intractable</em>：难解的，不能在多项式内求解的问题</p>
</li>
</ul>
</blockquote>
<p>使用多项式函数理由</p>
<ul>
<li><p>无法保证在合理时间内对难解问题所有实例求解，除非问题实例
非常小</p>
</li>
<li><p>对实用类型的算法而言，其多项式次数很少大于3，虽然多项式
次数相差很大时运行时间也会有巨大差别</p>
</li>
<li><p>多项式函数具有方便的特性</p>
<ul>
<li>多项式加和、组合也为多项式</li>
</ul>
</li>
<li><p>多项式类型可以发展出<em>Computational Complexity</em>利用</p>
<ul>
<li>该理论试图对问题内在复杂性进行分类</li>
<li>只要使用一种主要计算模型描述问题，并用合理编码方案
描述输入，问题难解性都是相同的</li>
</ul>
</li>
</ul>
<h3 id="Decision-Problem"><a href="#Decision-Problem" class="headerlink" title="Decision Problem"></a>Decision Problem</h3><p>判定问题：寻求一种可行的、机械的算法，能够对某类问题在有穷
步骤内确定是否具有某性质</p>
<ul>
<li><p><em>Undecidable</em>问题：不可判定问题，不能使用任何算法求解的
判定问题</p>
<ul>
<li>停机问题：给定程序、输入，判断程序对于输入停止还是
无限运行下去</li>
</ul>
</li>
<li><p><em>Decidable</em>问题：可判定问题，能用算法求解的问题</p>
<ul>
<li><p>可判定、难解问题存在，但非常少</p>
</li>
<li><p>很多判定问题（或者可以转化为等价判定问题），既没有
找到多项式类型算法，也没有证明这样算法不存在，即无法
判断是否难解</p>
</li>
</ul>
</li>
</ul>
<h3 id="P、NP问题"><a href="#P、NP问题" class="headerlink" title="P、NP问题"></a>P、NP问题</h3><h4 id="P问题"><a href="#P问题" class="headerlink" title="P问题"></a>P问题</h4><p>Polynomial类型问题</p>
<blockquote>
<ul>
<li><p>非正式定义：易解的问题，即能够在多项式时间内求解的
  问题（计算机范畴）</p>
</li>
<li><p>正式定义：能够用<strong>确定性</strong>算法在多项式时间内求解的
  <strong>判定问题</strong></p>
</li>
</ul>
<blockquote>
<ul>
<li><p>多项式时间内求解：排除难解问题</p>
</li>
<li><p>判定问题：很多重要问题可以化简为更容易研究的判断问题
   ，虽然原始表达形式不是判定问题</p>
</li>
</ul>
</blockquote>
</blockquote>
<h4 id="NP问题"><a href="#NP问题" class="headerlink" title="NP问题"></a>NP问题</h4><p>Nondeterministic Polynomial类型问题：可以用<strong>不确定多项式</strong>
算法求解的判定问题</p>
<ul>
<li><p>NP问题虽然计算上对问题求解困难，但是在计算上判定待定结
是否解决问题是简单的：可以在多项式时间内完成</p>
</li>
<li><p>大多数判断问题都是属于NP类型的</p>
<ul>
<li><p>$P \subseteq NP$：如果问题属于P，在不确定算法验证
阶段忽略猜测</p>
</li>
<li><p>还包括以下没有找到多项式算法、也没有证明算法不存在
的组合优化问题的判定版本</p>
<ul>
<li>哈密顿回路问题</li>
<li>旅行商问题</li>
<li>背包问题</li>
<li>划分问题</li>
<li>装箱问题</li>
<li>图着色问题</li>
<li>整数线性规划问题</li>
</ul>
</li>
</ul>
</li>
<li><p>$P \overset ? = NP$：P和NP问题是否一致，计算机科学理论
中最重要的未解之谜</p>
<ul>
<li>P = NP意味着虽然没有找到，但能够在多项式时间内求解
许多组合优化问题确实存在</li>
</ul>
</li>
</ul>
<h4 id="NPC问题"><a href="#NPC问题" class="headerlink" title="NPC问题"></a>NPC问题</h4><p><em>NP Complete</em>问题</p>
<blockquote>
<ul>
<li>属于NP问题种，和该类型其他问题难度一致</li>
</ul>
<blockquote>
<ul>
<li>证明问题属于NP问题比较简单</li>
</ul>
</blockquote>
<ul>
<li>NP中其他任何问题（已知或未知）可以在多项式时间内化简为
  NPC问题</li>
</ul>
<blockquote>
<ul>
<li><p>直接证明任何NP问题都可以在多项式时间内化简为当前问题
   比较困难</p>
</li>
<li><p>常常利用多项式规约特性，证明某个确定NPC问题可以
   多项式规约为当前问题</p>
</li>
</ul>
</blockquote>
</blockquote>
<ul>
<li><p>判定问题相互转换例</p>
<ul>
<li>哈密顿回路问题中图G映射加权图$G^{‘}$，G中存在边在
权重为1，不存在边权重为2，则哈密顿回路问题转换为$G^{‘}$
是否存在长度不超过$|V|$的哈密顿回路，即旅行商问题的等价</li>
</ul>
</li>
<li><p>NPC问题案例</p>
<ul>
<li><p><em>CNF-Satisfied Problem</em>：合取范式可满足性问题，首个
被发现NPC问题</p>
</li>
<li><p>前面提到的著名NP问题都是NPC问题</p>
<ul>
<li>包括哈密顿回路问题？？？</li>
</ul>
</li>
</ul>
</li>
<li><p>仅仅得到一个NPC问题的<strong>多项式确定</strong>算法，所有NP问题可以
在多项式时间内求解</p>
<ul>
<li><p>则$P = NP$</p>
</li>
<li><p>即对于所有类型判定问题而言，检验待定解、在多项式时间
内求解在复杂性商没有本质区别</p>
</li>
</ul>
</li>
<li><p>而NPC问题可以被其他NP问题转换而来意味着，NPC问题目前不
存在对所有实例通用的多项式时间算法</p>
</li>
</ul>
<h4 id="NP-Hard问题"><a href="#NP-Hard问题" class="headerlink" title="NP-Hard问题"></a>NP-Hard问题</h4><p>NP-Hard问题：所有NP问题都可以通过多项式规约到其</p>
<ul>
<li><p>不满足NPC问题第一个条件，可以不是NP问题</p>
</li>
<li><p>其范围包含NPC问题，前述组合优化问题最优版本也是NP-Hard</p>
</li>
<li><p>可以理解为：至少和NPC问题一样困难的问题</p>
</li>
</ul>
<p><img src="/imgs/p_np_npc_nphard.png" alt="p_np_npc_nphard"></p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><h4 id="Polynomially-Reducible"><a href="#Polynomially-Reducible" class="headerlink" title="Polynomially Reducible"></a>Polynomially Reducible</h4><p>判定问题$D_1$可以<strong>多项式规约</strong>为判定问题$D_2$，条件是存在
函数t可以把$D_1$的实例转换为$D_2$的实例，满足</p>
<blockquote>
<ul>
<li><p>t把$D_1$所有真实例映射为$D_2$真实例，把$D_1$所有假实例
  映射为$D_2$假实例</p>
</li>
<li><p>t可以用多项式算法计算</p>
</li>
</ul>
</blockquote>
<h4 id="CNF-Satisfied-Problem"><a href="#CNF-Satisfied-Problem" class="headerlink" title="CNF-Satisfied Problem"></a>CNF-Satisfied Problem</h4><p>合取范式满足性问题：能否设置合取范式类型的布尔表达式中布尔
变量值，使得整个表达式值为<em>真</em></p>
<ul>
<li>每个布尔表达式都可以表达为合取范式</li>
</ul>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/categories/Algorithm/page/3/">Previous</a></div><div class="pagination-next is-invisible is-hidden-mobile"><a href="/categories/Algorithm/page/5/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/categories/Algorithm/">1</a></li><li><a class="pagination-link" href="/categories/Algorithm/page/2/">2</a></li><li><a class="pagination-link" href="/categories/Algorithm/page/3/">3</a></li><li><a class="pagination-link is-current" href="/categories/Algorithm/page/4/">4</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">36</span></span></a><ul><li><a class="level is-mobile" href="/categories/Algorithm/Data-Structure/"><span class="level-start"><span class="level-item">Data Structure</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Heuristic/"><span class="level-start"><span class="level-item">Heuristic</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Issue/"><span class="level-start"><span class="level-item">Issue</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Problem/"><span class="level-start"><span class="level-item">Problem</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Specification/"><span class="level-start"><span class="level-item">Specification</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/C-C/"><span class="level-start"><span class="level-item">C/C++</span></span><span class="level-end"><span class="level-item tag">34</span></span></a><ul><li><a class="level is-mobile" href="/categories/C-C/Cppref/"><span class="level-start"><span class="level-item">Cppref</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/Cstd/"><span class="level-start"><span class="level-item">Cstd</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/MPI/"><span class="level-start"><span class="level-item">MPI</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/STL/"><span class="level-start"><span class="level-item">STL</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/CS/"><span class="level-start"><span class="level-item">CS</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/CS/Character/"><span class="level-start"><span class="level-item">Character</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Parallel/"><span class="level-start"><span class="level-item">Parallel</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Program-Design/"><span class="level-start"><span class="level-item">Program Design</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Storage/"><span class="level-start"><span class="level-item">Storage</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Daily-Life/"><span class="level-start"><span class="level-item">Daily Life</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/Daily-Life/Maxism/"><span class="level-start"><span class="level-item">Maxism</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Database/"><span class="level-start"><span class="level-item">Database</span></span><span class="level-end"><span class="level-item tag">27</span></span></a><ul><li><a class="level is-mobile" href="/categories/Database/Hadoop/"><span class="level-start"><span class="level-item">Hadoop</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Database/SQL-DB/"><span class="level-start"><span class="level-item">SQL DB</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Database/Spark/"><span class="level-start"><span class="level-item">Spark</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/Scala/"><span class="level-start"><span class="level-item">Scala</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">42</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Bash-Programming/"><span class="level-start"><span class="level-item">Bash Programming</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Configuration/"><span class="level-start"><span class="level-item">Configuration</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/File-System/"><span class="level-start"><span class="level-item">File System</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/IPC/"><span class="level-start"><span class="level-item">IPC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Process-Schedual/"><span class="level-start"><span class="level-item">Process Schedual</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Shell/"><span class="level-start"><span class="level-item">Shell</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Tool/"><span class="level-start"><span class="level-item">Tool</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Tool/Vi/"><span class="level-start"><span class="level-item">Vi</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Model/"><span class="level-start"><span class="level-item">ML Model</span></span><span class="level-end"><span class="level-item tag">21</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Model/Linear-Model/"><span class="level-start"><span class="level-item">Linear Model</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Model-Component/"><span class="level-start"><span class="level-item">Model Component</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Nolinear-Model/"><span class="level-start"><span class="level-item">Nolinear Model</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Unsupervised-Model/"><span class="level-start"><span class="level-item">Unsupervised Model</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/"><span class="level-start"><span class="level-item">ML Specification</span></span><span class="level-end"><span class="level-item tag">17</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/Click-Through-Rate/"><span class="level-start"><span class="level-item">Click Through Rate</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/Click-Through-Rate/Recommandation-System/"><span class="level-start"><span class="level-item">Recommandation System</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/Computer-Vision/"><span class="level-start"><span class="level-item">Computer Vision</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Specification/FinTech/"><span class="level-start"><span class="level-item">FinTech</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/FinTech/Risk-Control/"><span class="level-start"><span class="level-item">Risk Control</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/Graph-Analysis/"><span class="level-start"><span class="level-item">Graph Analysis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Specification/NLP/"><span class="level-start"><span class="level-item">NLP</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Technique/"><span class="level-start"><span class="level-item">ML Technique</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Technique/Feature-Engineering/"><span class="level-start"><span class="level-item">Feature Engineering</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Technique/Neural-Network/"><span class="level-start"><span class="level-item">Neural Network</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Theory/"><span class="level-start"><span class="level-item">ML Theory</span></span><span class="level-end"><span class="level-item tag">11</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Theory/Loss/"><span class="level-start"><span class="level-item">Loss</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Theory/Model-Enhencement/"><span class="level-start"><span class="level-item">Model Enhencement</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Theory/Optimization/"><span class="level-start"><span class="level-item">Optimization</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Algebra/"><span class="level-start"><span class="level-item">Math Algebra</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Algebra/Linear-Algebra/"><span class="level-start"><span class="level-item">Linear Algebra</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Algebra/Universal-Algebra/"><span class="level-start"><span class="level-item">Universal Algebra</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Analysis/"><span class="level-start"><span class="level-item">Math Analysis</span></span><span class="level-end"><span class="level-item tag">23</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Analysis/Fourier-Analysis/"><span class="level-start"><span class="level-item">Fourier Analysis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Functional-Analysis/"><span class="level-start"><span class="level-item">Functional Analysis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Optimization/"><span class="level-start"><span class="level-item">Optimization</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Real-Analysis/"><span class="level-start"><span class="level-item">Real Analysis</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Mixin/"><span class="level-start"><span class="level-item">Math Mixin</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Mixin/Statistics/"><span class="level-start"><span class="level-item">Statistics</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Mixin/Time-Series/"><span class="level-start"><span class="level-item">Time Series</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Probability/"><span class="level-start"><span class="level-item">Probability</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">89</span></span></a><ul><li><a class="level is-mobile" href="/categories/Python/Cookbook/"><span class="level-start"><span class="level-item">Cookbook</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Jupyter/"><span class="level-start"><span class="level-item">Jupyter</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Keras/"><span class="level-start"><span class="level-item">Keras</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Matplotlib/"><span class="level-start"><span class="level-item">Matplotlib</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Numpy/"><span class="level-start"><span class="level-item">Numpy</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Pandas/"><span class="level-start"><span class="level-item">Pandas</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Py3Ref/"><span class="level-start"><span class="level-item">Py3Ref</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Py3std/"><span class="level-start"><span class="level-item">Py3std</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Pywin32/"><span class="level-start"><span class="level-item">Pywin32</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Readme/"><span class="level-start"><span class="level-item">Readme</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/TensorFlow/"><span class="level-start"><span class="level-item">TensorFlow</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Twists/"><span class="level-start"><span class="level-item">Twists</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/RLang/"><span class="level-start"><span class="level-item">RLang</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Rust/"><span class="level-start"><span class="level-item">Rust</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Set/"><span class="level-start"><span class="level-item">Set</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/"><span class="level-start"><span class="level-item">Tool</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/Tool/Editor/"><span class="level-start"><span class="level-item">Editor</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Markup-Language/"><span class="level-start"><span class="level-item">Markup Language</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Web-Browser/"><span class="level-start"><span class="level-item">Web Browser</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Windows/"><span class="level-start"><span class="level-item">Windows</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/Web/CSS/"><span class="level-start"><span class="level-item">CSS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/NPM/"><span class="level-start"><span class="level-item">NPM</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/Proxy/"><span class="level-start"><span class="level-item">Proxy</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/Thrift/"><span class="level-start"><span class="level-item">Thrift</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://octodex.github.com/images/hula_loop_octodex03.gif" alt="UBeaRLy"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">UBeaRLy</p><p class="is-size-6 is-block">Protector of Proxy</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">392</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">93</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">522</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/xyy15926" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/xyy15926"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-04T15:07:54.896Z">2021-08-04</time></p><p class="title"><a href="/uncategorized/README.html"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-03T07:46:51.000Z">2021-08-03</time></p><p class="title"><a href="/Web/NPM/hexo_config.html">Hexo 建站</a></p><p class="categories"><a href="/categories/Web/">Web</a> / <a href="/categories/Web/NPM/">NPM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-03T02:32:45.000Z">2021-08-03</time></p><p class="title"><a href="/Web/NPM/config.html">NPM 总述</a></p><p class="categories"><a href="/categories/Web/">Web</a> / <a href="/categories/Web/NPM/">NPM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-02T08:11:11.000Z">2021-08-02</time></p><p class="title"><a href="/Python/Py3std/internet_data.html">互联网数据</a></p><p class="categories"><a href="/categories/Python/">Python</a> / <a href="/categories/Python/Py3std/">Py3std</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-29T13:55:00.000Z">2021-07-29</time></p><p class="title"><a href="/Linux/Shell/sh_apps.html">Shell 应用程序</a></p><p class="categories"><a href="/categories/Linux/">Linux</a> / <a href="/categories/Linux/Shell/">Shell</a></p></div></article></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">Advertisement</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5385776267343559" data-ad-slot="6995841235" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="https://api.follow.it/subscription-form/WWxwMVBsOUtoNTdMSlJ4Z1lWVnRISERsd2t6ek9MeVpEUWs0YldlZGxUdXlKdDNmMEZVV1hWaFZFYWFSNmFKL25penZodWx3UzRiaVkxcnREWCtOYUJhZWhNbWpzaUdyc1hPangycUh5RTVjRXFnZnFGdVdSTzZvVzJBcTJHKzl8aXpDK1ROWWl4N080YkFEK3QvbEVWNEJuQjFqdWdxODZQcGNoM1NqbERXST0=/8" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="UBeaRLy" height="28"></a><p class="is-size-7"><span>&copy; 2021 UBeaRLy</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/xyy15926/proxy"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>