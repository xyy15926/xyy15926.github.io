<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>UBeaRLy</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="UBeaRLy&#039;s Proxy"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="UBeaRLy&#039;s Proxy"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="UBeaRLy"><meta property="og:url" content="https://xyy15926.github.io/"><meta property="og:site_name" content="UBeaRLy"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://xyy15926.github.io/img/og_image.png"><meta property="article:author" content="UBeaRLy"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xyy15926.github.io"},"headline":"UBeaRLy","image":["https://xyy15926.github.io/img/og_image.png"],"author":{"@type":"Person","name":"UBeaRLy"},"publisher":{"@type":"Organization","name":"UBeaRLy","logo":{"@type":"ImageObject","url":"https://xyy15926.github.io/img/logo.svg"}},"description":""}</script><link rel="alternate" href="/atom.xml" title="UBeaRLy" type="application/atom+xml"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/darcula.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><script data-ad-client="ca-pub-5385776267343559" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="UBeaRLy" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Visit on GitHub" href="https://github.com/xyy15926/proxy"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-06-09T15:24:42.000Z" title="6/9/2019, 11:24:42 PM">2019-06-09</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-06-09T15:24:35.000Z" title="6/9/2019, 11:24:35 PM">2019-06-09</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Py3std/">Py3std</a></span><span class="level-item">a few seconds read (About 12 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Py3std/data_types.html">Python数据类型</a></h1><div class="content"><h2 id="collections"><a href="#collections" class="headerlink" title="collections"></a><code>collections</code></h2><h2 id="array"><a href="#array" class="headerlink" title="array"></a><code>array</code></h2><h2 id="headq"><a href="#headq" class="headerlink" title="headq"></a><code>headq</code></h2><h2 id="bisect"><a href="#bisect" class="headerlink" title="bisect"></a><code>bisect</code></h2><h2 id="weakref"><a href="#weakref" class="headerlink" title="weakref"></a><code>weakref</code></h2><h2 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a><code>datetime</code></h2><h2 id="calender"><a href="#calender" class="headerlink" title="calender"></a><code>calender</code></h2><h2 id="types"><a href="#types" class="headerlink" title="types"></a><code>types</code></h2><h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a><code>copy</code></h2><h2 id="pprint"><a href="#pprint" class="headerlink" title="pprint"></a><code>pprint</code></h2><h2 id="reprlib"><a href="#reprlib" class="headerlink" title="reprlib"></a><code>reprlib</code></h2><h2 id="enum"><a href="#enum" class="headerlink" title="enum"></a><code>enum</code></h2></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-06-09T09:23:02.000Z" title="6/9/2019, 5:23:02 PM">2019-06-09</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-06-09T09:23:02.000Z" title="6/9/2019, 5:23:02 PM">2019-06-09</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Py3Ref/">Py3Ref</a></span><span class="level-item">10 minutes read (About 1499 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Py3Ref/py3ref_abstract.html">Python概述</a></h1><div class="content"><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><ul>
<li>语言的具体实现可能发生改变、其他实现可能使用不同方式</li>
<li>在语言的参考文档中加入过多细节实现很危险</li>
</ul>
<h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><p>python只是一种语言，其具体解释器实现有很多种</p>
<ul>
<li><p><em>CPython</em>：C语言实现，最原始版本</p>
<ul>
<li>通常就被称为Python，其他实现区分时才强调为CPython</li>
<li>新语言特性通常较早出现</li>
</ul>
</li>
<li><p><em>Jython</em>：Java实现</p>
<ul>
<li>将Python代码编译为Java字节码</li>
<li>可以左线Java应用的脚本语言、创建需要Java类库支持的
应用</li>
<li>在JVM上运行</li>
</ul>
</li>
<li><p><em>Python for .NET</em>：实际上使用CPython实现，但是属于.NET
托管应用，可以引入.NET类库</p>
</li>
<li><p><em>IronPython</em>：.NET实现</p>
<ul>
<li>生成IL的完全Python实现，将Python代码直接编译为.NET
程序集</li>
</ul>
</li>
<li><p>PyPy：RPython（Python语言子集）实现</p>
<ul>
<li>JIT编译器，执行效率高于CPython</li>
<li>非栈式支持</li>
<li>允许方便修改解释器，鼓励对语言本身进行实验</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>CPython是解释器实现版本，<code>cython</code>是将Python代码翻译为
  C插件的项目/包</li>
</ul>
</blockquote>
<h2 id="Notation说明"><a href="#Notation说明" class="headerlink" title="Notation说明"></a><em>Notation</em>说明</h2><p>标注：词法、句法解析的描述使用修改过的BNF语法标注</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name ::= lc_letter(lc_letter | &quot;_&quot;)*</span><br><span class="line">lc_letter ::= &quot;a&quot;...&quot;z&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>::=</code>：声明规则，左侧为规则名称</li>
<li><code>|</code>：分隔可选项</li>
<li><code>*</code>：前一项的零次、多次重复</li>
<li><code>+</code>：前一项的一次、多次重复</li>
<li><code>[]</code>：括起内容可选，即出现零次、一次</li>
<li><code>()</code>：分组</li>
<li><code>&quot;&quot;</code>：固定字符串包含在引号内</li>
<li><code> </code>：空格仅用于分隔<em>token</em></li>
<li><code>...</code>：三个点分割的本义字符表示在指定区间范围内的任意
  单个字符</li>
<li><code>&lt;&gt;</code>：对所定义符号的非常描述，在必要时用于说明“控制字符”
  意图</li>
</ul>
</blockquote>
<ul>
<li>每条规则通常为一行，多个可选项规则可用<code>|</code>为界分为多行</li>
<li>词法定义：作用域输入源中的单独字符</li>
<li>句法定义：作用于词法分析生成的<em>token stream</em></li>
</ul>
<h2 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h2><ul>
<li>实例方法：定义在类命名空间中、未因访问而绑定函数</li>
<li>绑定方法：已绑定实例方法</li>
<li>静态方法</li>
<li>类方法</li>
<li>[类]实例：类实例化所得对象</li>
<li>对象：泛指所有python对象，包括类、实例</li>
</ul>
<h2 id="Global-Intepretor-Lock"><a href="#Global-Intepretor-Lock" class="headerlink" title="Global Intepretor Lock"></a><em>Global Intepretor Lock</em></h2><p>全局内存锁：<em>GIL</em>，任何python字节码执行前必须获得的解释器锁</p>
<ul>
<li>在任何时刻，只能有一个线程处于工作状态</li>
<li>避免多个线程同时操作变量导致内存泄漏、错误释放</li>
</ul>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li><p>GIL实现简单，只需要管理一把解释器锁就能保证线程内存安全</p>
<ul>
<li>当然GIL只能保证引用计数正确，避免由此导致内存问题</li>
<li>还需要原子操作、对象锁避免并发更新问题</li>
</ul>
</li>
<li><p>GIL单线程情况下性能更好、稳定，若通过给所有对象引用计数
加锁来实现线程安全</p>
<ul>
<li>容易出现死锁</li>
<li>性能下降很多</li>
</ul>
</li>
<li><p>方便兼容C遗留库，这也是python得以发展的原因</p>
<ul>
<li>很多python需要的C库扩展要求线程安全的内存管理</li>
</ul>
</li>
</ul>
<h3 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h3><ul>
<li><p>Python线程是真正的操作系统线程</p>
<ul>
<li>在准备好之后必须获得一把共享锁才能运行</li>
<li>每个线程都会在执行一定机器指令和后切换到无锁状态，
暂停运行</li>
<li>事实上程序在开始时已经在运行“主线程”</li>
</ul>
<blockquote>
<ul>
<li>解释器检查线程切换频率<code>sys.getcheckinterval()</code></li>
</ul>
</blockquote>
</li>
<li><p>Python线程无法在多核CPU间分配，对CPU-Bound程序基本没有
提升效果，对于IO-Bound的程序性能仍然有巨大帮助</p>
</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li><p>多进程</p>
<ul>
<li>进程分支：<code>os.fork</code></li>
<li>派生进程：<code>multiprocessing.Process</code>、
<code>concurrent.futures</code></li>
</ul>
</li>
<li><p>C语言库封装线程：<code>ctypes</code>、<code>cython</code></p>
<ul>
<li>C扩展形式实现任务线程可在python虚拟机作用域外运行
可以并行运行任意数量线程</li>
<li>在运行时释放GIL、结束后继续运行python代码时重新获取
GIL，真正实现独立运行</li>
</ul>
</li>
<li><p>使用其他版本Python解释器：只有原始Python版本CPython使用
GIL实现</p>
<ul>
<li>Jython</li>
<li>IronPython</li>
<li>PyPy</li>
</ul>
</li>
</ul>
<h2 id="Python最高层级组件"><a href="#Python最高层级组件" class="headerlink" title="Python最高层级组件"></a>Python最高层级组件</h2><h3 id="完整的Python程序"><a href="#完整的Python程序" class="headerlink" title="完整的Python程序"></a>完整的Python程序</h3><ul>
<li><p>完整的python程序会在最小初始化环境中被执行</p>
<ul>
<li>所有内置、标准模块均可用，但均处于未初始化状态</li>
<li>只有<code>sys</code>、<code>builtins</code>、<code>__main__</code>已经初始化</li>
<li><code>__main__</code>模块为完整程序的执行提供局部、全局命名空间</li>
</ul>
</li>
<li><p>完整程序可通过三种形式传递给解释器</p>
<ul>
<li><code>-c</code>命令行选项传递字符串</li>
<li>文件作为第一个命令行参数</li>
<li>标准输入</li>
</ul>
<blockquote>
<ul>
<li>若文件、标准输入是tty设备，解释器进入交互模式，否则
 将文件当作完整程序执行</li>
</ul>
</blockquote>
</li>
<li><p>解释器也可以通过交互模式被发起调用</p>
<ul>
<li>每次读取执行一条语句，语句会在<code>__main__</code>命名空间中
被执行</li>
<li>初始环境同完整程序</li>
</ul>
</li>
</ul>
<h3 id="输入类型"><a href="#输入类型" class="headerlink" title="输入类型"></a>输入类型</h3><h4 id="文件输入"><a href="#文件输入" class="headerlink" title="文件输入"></a>文件输入</h4><p>文件输入：从非交互式文件读取的输入，具有相同形式</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_input ::= (NEWLINE|statement)*</span><br></pre></td></tr></table></figure>
<ul>
<li><p>适合以下几种情况</p>
<ul>
<li>解析完整的python程序（从文件、字符串）</li>
<li>解析模块</li>
<li>解析传递给<code>exec()</code>函数的字符串</li>
</ul>
</li>
</ul>
<h4 id="交互式输入"><a href="#交互式输入" class="headerlink" title="交互式输入"></a>交互式输入</h4><p>交互式输入：从tty设备读取输入</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interactive_input ::= [stmt_list] NEWLINE | compound_stmt NEWLINE</span><br></pre></td></tr></table></figure>
<ul>
<li>注意<ul>
<li>交互模式中（最高层级）复合语句后必须带有空行，帮助
解释器确定输入的结束</li>
</ul>
</li>
</ul>
<h4 id="表达式输入"><a href="#表达式输入" class="headerlink" title="表达式输入"></a>表达式输入</h4><p>表达式输入</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval_input ::= expression_list NEWLINE*</span><br></pre></td></tr></table></figure>
<ul>
<li><code>eval</code>被用于表达式输入</li>
<li>忽略开头空白</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-06-09T08:54:21.000Z" title="6/9/2019, 4:54:21 PM">2019-06-09</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-06-09T08:54:21.000Z" title="6/9/2019, 4:54:21 PM">2019-06-09</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Py3Ref/">Py3Ref</a></span><span class="level-item">36 minutes read (About 5403 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Py3Ref/import_system.html">Python包、模块</a></h1><div class="content"><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><h3 id="导入方式"><a href="#导入方式" class="headerlink" title="导入方式"></a>导入方式</h3><p><em>importing</em>操作可以使得模块能够访问其他模块中代码</p>
<ul>
<li><p><code>import</code>：结合了以下两个操作，发起导入调机制最常用方式</p>
<ul>
<li>搜索指定名称模块：对<code>__import__()</code>带有适当参数调用</li>
<li>将搜索结果绑定到当前作用域中名称：<code>__import__</code>返回值
被用于执行名称绑定操作</li>
</ul>
</li>
<li><p><code>__import__()</code>：只执行模块搜索、找到模块后创建<code>module</code></p>
<ul>
<li>可能产生某些副作用<ul>
<li>导入父包</li>
<li>更新各种缓存：<code>sys.modules</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>importlib.import_module()</code></p>
<ul>
<li>可能会选择绕过<code>__import__</code>，使用其自己的解决方案实现
导入机制</li>
<li>用于为动态模块导入提供支持</li>
</ul>
<blockquote>
<ul>
<li><code>importlib</code>模块参见标准库</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h4><ul>
<li>任意机制加载子模块时，父模块命名空间中会添加对子模块对象
的绑定</li>
</ul>
<h3 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a><em>Packages</em></h3><ul>
<li><p>python只有一种模块对象类型：所有模块都属于该类型，C、
Python语言实现均是</p>
</li>
<li><p>包：为帮助组织模块、并提供名称层次结构引入</p>
<ul>
<li>可将包<strong>视为</strong>文件系统中目录、模块视为目录中文件，
但<strong>包、模块不是必须来自文件系统</strong></li>
<li>类似文件系统，包通过层次结构进行组织：包内包括模块、
子包</li>
</ul>
</li>
<li><p><strong>所有包都是模块，但并非所有模块都是包</strong></p>
<ul>
<li>包是一种特殊的模块</li>
<li>特别的，任何具有<code>__path__</code>属性的模块都被当作包</li>
</ul>
</li>
<li><p>所有模块都有自己的名字</p>
<ul>
<li>子包名与其父包名以<code>.</code>分隔，同python标准属性访问语法</li>
</ul>
</li>
</ul>
<h4 id="Regular-Packages"><a href="#Regular-Packages" class="headerlink" title="Regular Packages"></a><em>Regular Packages</em></h4><p>正规包：通常以包含<code>__init__.py</code>文件的目录形式出现</p>
<ul>
<li><p><code>__init__.py</code>文件可以包含和其他模块中包含python模块相似
的代码</p>
</li>
<li><p>正规包被导入时</p>
<ul>
<li><code>__init__.py</code>文件会隐式被执行，其中定义对象被绑定到
该包命名空间中名称</li>
<li>python会为模块添加额外属性</li>
</ul>
</li>
</ul>
<h4 id="Namespace-Packages"><a href="#Namespace-Packages" class="headerlink" title="Namespace Packages"></a><em>Namespace Packages</em></h4><p>命名空间包：由多个部分构成，每个部分为父包增加一个子包</p>
<ul>
<li><p>包各部分可以物理不相邻，不一定直接对应到文件系统对象，
可能是无实体表示的虚拟模块</p>
<ul>
<li>可能处于文件系统不同位置</li>
<li>可能处于zip文件、网络上，或在导入期间其他可搜索位置</li>
</ul>
</li>
<li><p><code>__path__</code>属性不是普通列表，而是定制的可迭代类型</p>
<ul>
<li>若父包、或最高层级包<code>sys.path</code>路径发生改变，对象会
在包内的下次导入尝试时，自动执行新的对包部分的搜索</li>
</ul>
</li>
<li><p>命名空间包中没有<code>__init__.py</code>文件</p>
<ul>
<li>毕竟可能有多个父目录提供包不同部分，彼此物理不相邻</li>
<li>python会在包、子包导入时为其创建命名空间包</li>
</ul>
</li>
</ul>
<h3 id="导入相关模块属性"><a href="#导入相关模块属性" class="headerlink" title="导入相关模块属性"></a>导入相关模块属性</h3><blockquote>
<ul>
<li>以下属性在加载时被设置，参见
  <em>cs_python/py3ref/import_system</em></li>
</ul>
</blockquote>
<ul>
<li><p><code>__name__</code>：模块完整限定名称，唯一标识模块</p>
</li>
<li><p><code>__loader__</code>：导入系统加载模块时使用的加载器对象</p>
<ul>
<li>主要用于内省</li>
<li>也可用于额外加载器专用功能</li>
</ul>
</li>
<li><p><code>__package__</code>：取代<code>__name__</code>用于主模块计算显式相对
导入</p>
<ul>
<li>模块为包：应设置为<code>__name__</code></li>
<li>模块非包：最高层级模块应设为空字符串，否则为父包名</li>
</ul>
<blockquote>
<ul>
<li>预期同<code>__spec__.parent</code>值相同，未定义时，以
 <code>__spec__.parent</code>作为回退项</li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li><code>python &lt;PYSCIRPT&gt;</code>直接执行脚本时<code>__name__</code>被设置为
  <code>__main__</code>、<code>__package__</code>设置为<code>None</code>，此时导入器无法
  解释相对导入中<code>.</code>，相对导入报错</li>
<li><code>python -m &lt;PYSCIRPT&gt;</code>则会按模块逻辑设置<code>__name__</code>、
  <code>__package__</code>，相对导入可以正常执行</li>
</ul>
</blockquote>
<h4 id="spec"><a href="#spec" class="headerlink" title="__spec__"></a><code>__spec__</code></h4><p><code>__spec__</code>：导入模块时要使用的<strong>模块规格说明</strong></p>
<ul>
<li>对<code>__spec__</code>正确设置将同时作用于解释器启动期间
初始化的模块</li>
<li>仅<code>__main__</code>某些情况下被设置为<code>None</code></li>
</ul>
<h4 id="path"><a href="#path" class="headerlink" title="__path__"></a><code>__path__</code></h4><ul>
<li><p><strong>具有该属性模块即为包</strong>：包模块必须设置<code>__path__</code>属性，
非包模块不应设置</p>
</li>
<li><p>在导入子包期间被使用，在导入机制内部功能同<code>sys.path</code>，
即用于提供模块搜索位置列表</p>
<ul>
<li>但受到更多限制，其必须为字符串组成可迭代对象，但若其
没有进一步用处可以设置为空</li>
<li>适用作用于<code>sys.path</code>的规则</li>
<li><code>sys.path_hooks</code>会在遍历包的<code>__path__</code>时被查询</li>
</ul>
</li>
<li><p>可在包的<code>__init__.py</code>中设置、更改</p>
<ul>
<li>在<em>PEP420</em>引入之后，命名空间包不再需要提供仅包含操作
<code>__path__</code>代码的<code>__init__.py</code>文件，导入机制会自动为
命名空间包正确设置<code>__path__</code></li>
<li>在之前其为实现命名空间包的典型方式</li>
</ul>
</li>
</ul>
<h4 id="repr"><a href="#repr" class="headerlink" title="__repr__"></a><code>__repr__</code></h4><ul>
<li><p>若模块具有<code>__spec__</code>，导入机制将尝试使用其中规格信息生成
repr</p>
<ul>
<li><code>name</code></li>
<li><code>loader</code></li>
<li><code>origin</code></li>
<li><code>has_location</code></li>
</ul>
</li>
<li><p>若模块具有<code>__file__</code>属性，将被用作repr的一部分</p>
</li>
<li><p>否则若模块具有<code>__loader__</code>属性且非<code>None</code>，则加载器repr
将被用作模块repr的一部分</p>
</li>
<li><p>其他情况下，仅在repr中适用模块的<code>__name__</code></p>
</li>
</ul>
<blockquote>
<ul>
<li>可以在模块规则说明中显式控制模块对象repr</li>
</ul>
</blockquote>
<h4 id="file-cached"><a href="#file-cached" class="headerlink" title="__file__/__cached__"></a><code>__file__</code>/<code>__cached__</code></h4><blockquote>
<ul>
<li><code>__file__</code>：模块对应的被加载文件的路径名</li>
<li><code>__cached__</code>：编译版本代码（字节码文件）路径</li>
</ul>
</blockquote>
<ul>
<li><p><code>__file__</code>为可选项，须为字符串</p>
<ul>
<li>可以在其无语法意义时不设置</li>
<li>对从共享库动态加载的扩展模块，应为共享库文件路径名</li>
</ul>
</li>
<li><p><code>__cached__</code></p>
<ul>
<li>不要求编译文件已经存在，可以表示<strong>应该存放</strong>编译文件
的位置</li>
<li>不要求<code>__file__</code>已经设置<ul>
<li>有时加载器可以从缓存加载模块但是无法从文件加载</li>
<li>加载静态链接至解释器内部的C模块</li>
</ul>
</li>
</ul>
</li>
<li><p>从<code>.pyc</code>文件加载缓存字节码前会检查其是否最新</p>
<ul>
<li>默认通过比较缓存文件中保存的源文件修改时间戳实现</li>
<li>也支持基于哈希的缓冲文件，此时<code>.pyc</code>文件中保存源文件
哈希值<ul>
<li>检查型：求源文件哈希值再和缓存文件中哈希值比较</li>
<li>非检查型：只要缓存文件存在就直接认为缓存文件有效</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><code>--check-hash-based-pycs</code>命名行选项设置基于哈希的
 <code>.pyc</code>文件有效性</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="执行相关模块属性"><a href="#执行相关模块属性" class="headerlink" title="执行相关模块属性"></a>执行相关模块属性</h3><ul>
<li><code>__doc__</code>：模块文档字符串</li>
<li><code>__annotaion__</code>：包含变量标注的字典<ul>
<li>在模块体执行时获取</li>
</ul>
</li>
<li><code>__dict__</code>：以字典对象表示的模块命名空间</li>
</ul>
<blockquote>
<ul>
<li>CPython：由于CPython清理模块字典的设定，模块离开作用域时
  模块字典将被清理，即使字典还有活动引用，可以复制该字典、
  保持模块状态以直接使用其字典</li>
</ul>
</blockquote>
<h3 id="sys-modules模块缓存"><a href="#sys-modules模块缓存" class="headerlink" title="sys.modules模块缓存"></a><code>sys.modules</code>模块缓存</h3><p><code>sys.modules</code>映射：缓存之前导入的所有模块（包括中间路径）
（即导入子模块会注册父模块条目）</p>
<ul>
<li><p>其中每个键值对就是限定名称、模块对象</p>
</li>
<li><p>在其中查找模块名称</p>
<ul>
<li>若存在需要导入模块，则导入完成</li>
<li>若名称对应值为<code>None</code>则<code>raise ModuleNotFoundError</code></li>
<li>若找不到指定模块名称，python将继续搜索</li>
</ul>
</li>
<li><p>映射可写，可删除其中键值对</p>
<ul>
<li>不一定破坏关联模块，因为其他模块可能保留对其引用</li>
<li>但是会使<strong>命名模块</strong>缓存条目无效，导致下次导入时重新
搜索命名模块，得到两个不同的两个模块对象</li>
</ul>
<blockquote>
<ul>
<li><code>importlib.reload</code>将重用相同模块对象，通过重新运行
 模块代码重新初始化模块内容</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="Finders-And-Loaders"><a href="#Finders-And-Loaders" class="headerlink" title="Finders And Loaders"></a><em>Finders And Loaders</em></h2><blockquote>
<ul>
<li><em>Finders</em>：查找器，确定能否使用所知策略找到指定名称模块</li>
<li><em>Loaders</em>：加载器，加载找到的指定模块</li>
<li><em>Importer</em>：导入器，同时实现两种接口的对象，在确定能加载
  所需模块时会返回自身</li>
</ul>
</blockquote>
<ul>
<li><p>导入机制通过<em>import hooks</em>实现扩展</p>
<ul>
<li>可以加入新的查找器以扩展模块搜索范围、作用域</li>
</ul>
</li>
<li><p>工作流程：在<code>sys.modules</code>缓存中无法找到指定名称模块时</p>
<ul>
<li>查找器若能找到指定名称模块，返回模块规格说明<em>spec</em></li>
<li>加载器将利用查找器返回的模块规格说明加载模块</li>
</ul>
</li>
</ul>
<h3 id="Import-Path"><a href="#Import-Path" class="headerlink" title="Import Path"></a><em>Import Path</em></h3><p>导入路径：文件系统路径、zip文件等<em>path term</em>组成的位置列表</p>
<ul>
<li><p>其中元素不局限于文件系统位置，可扩展为字符串指定的任意
可定位资源</p>
<ul>
<li>URL指定资源</li>
<li>数据库查询</li>
</ul>
</li>
<li><p>位置条目来源</p>
<ul>
<li>通常为<code>sys.path</code></li>
<li>对次级包可能来自上级包的<code>__path__</code>属性</li>
</ul>
</li>
<li><p>其中每个路径条目指定一个用于搜索模块的位置</p>
<ul>
<li><em>path based finder</em>将在其中查找导入目标</li>
</ul>
</li>
</ul>
<h4 id="sys-path"><a href="#sys-path" class="headerlink" title="sys.path"></a><code>sys.path</code></h4><p><code>sys.path</code>：模块、包搜索位置的字符串列表</p>
<ul>
<li><p>初始化自<code>PYTHONPATH</code>环境变量、特定安装和实现的默认设置、
执行脚本目录（或当前目录）</p>
</li>
<li><p>其中条目可以指定文件系统中目录、zip文件、可用于搜索模块
的潜在位置</p>
</li>
<li><p>只能出现字符串、字节串，其他数据类型被忽略</p>
<ul>
<li>字节串条目使用的编码由导入路径钩子、
<em>path entry finder</em>确定</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>所以可以修改<code>sys.path</code>值定制导入路径，CPython实现参见
  <em>cs_python/py3ref/import_system</em></li>
</ul>
</blockquote>
<h4 id="sys-path-import-cache"><a href="#sys-path-import-cache" class="headerlink" title="sys.path_import_cache"></a><code>sys.path_import_cache</code></h4><p><code>sys.path_importer_cache</code>：存放路径条目到路径条目查找器映射
的缓存</p>
<ul>
<li><p>减少查找路径条目对应路径条目查找器的消耗，对特定路径条目
查找对应路径条目查找只需进行一次</p>
</li>
<li><p>可从中移除缓存条目，以强制基于路径查找器执行路径条目搜索</p>
</li>
</ul>
<h3 id="Import-Hooks"><a href="#Import-Hooks" class="headerlink" title="Import Hooks"></a><em>Import Hooks</em></h3><ul>
<li><p><em>meta hooks</em>：元[路径]钩子</p>
<ul>
<li>导入过程开始时被调用，此时仅<code>sys.modules</code>缓存查找
发生，其他导入过程未发生</li>
<li>所以允许元钩子重载<code>sys.path</code>过程、冻结模块甚至内置
模块</li>
</ul>
<blockquote>
<ul>
<li><strong>元钩子即导入器/元路径查找器</strong></li>
<li><code>sys.meta_path</code>为元路径查找器列表，可在其中注册定制
 元钩子</li>
</ul>
</blockquote>
</li>
<li><p><em>path[ entry] hooks</em>：导入路径钩子</p>
<ul>
<li>是<code>sys.path</code>、<code>package.__path__</code>处理的一部分</li>
<li>基于路径的查找器调用其处理路径条目，以获取路径条目
查找器</li>
</ul>
<blockquote>
<ul>
<li><strong>导入路径钩子返回路径条目查找器</strong></li>
<li><code>sys.path_hooks</code>为导入路径钩子列表，可在其中注册
 定制导入路径钩子</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="默认元路径查找器-导入器"><a href="#默认元路径查找器-导入器" class="headerlink" title="默认元路径查找器/导入器"></a>默认元路径查找器/导入器</h3><p>python默认实现<code>sys.meta_path</code>有以下导入器（元路径查找器）</p>
<ul>
<li><code>BuiltinImporter</code>：定位、导入内置模块</li>
<li><code>FrozenImporter</code>：定位、导入冻结模块</li>
<li><code>PathFinder</code>：定位、导入来自<em>import path</em>中模块</li>
</ul>
<blockquote>
<ul>
<li>尝试导入模块时，内置模块、冻结模块导入器优先级较高，所以
  解释器首先搜索<strong>内置</strong>模块</li>
</ul>
</blockquote>
<h2 id="Finder"><a href="#Finder" class="headerlink" title="Finder"></a><em>Finder</em></h2><ul>
<li><p>指定名称模块在<code>sys.modules</code>找不到时，python继续搜索
<code>sys.meta_path</code>，按顺序调用其中元路径查找器</p>
</li>
<li><p>若<code>sys.meta_path</code>处理到列表末尾仍未返回说明对象，则
<code>raise ModuleNotFoundError</code></p>
</li>
</ul>
<blockquote>
<ul>
<li>导入过程中引发的任何异常直接向上传播，并放弃导入过程</li>
<li>对非最高层级模块的导入请求可能会多次遍历元路径</li>
</ul>
</blockquote>
<h3 id="Meta-Path-Finders"><a href="#Meta-Path-Finders" class="headerlink" title="Meta Path Finders"></a><em>Meta Path Finders</em></h3><p>元路径查找器：</p>
<ul>
<li><p>元路径查找器可使用任何策略确定其是否能处理给定名称模块</p>
<ul>
<li>若知道如何处理指定名称的模块，将返回模块规格说明</li>
<li>否则返回<code>None</code></li>
</ul>
</li>
<li><p>模块规格协议：元路径查找器应实现<code>find_spec()</code>方法</p>
<ul>
<li>接受名称、导入路径、目标模块作为参数</li>
<li>返回模块规格说明</li>
</ul>
</li>
</ul>
<h3 id="Spec"><a href="#Spec" class="headerlink" title="Spec"></a><em>Spec</em></h3><ul>
<li><p>模块规格[说明]：基于每个模块封装的模块导入相关信息</p>
<ul>
<li>模块规格中大部分信息对所有模块是公用的</li>
<li>模块规格说明作为模块对象的<code>__spec__</code>属性对外公开</li>
</ul>
</li>
<li><p>用途</p>
<ul>
<li>允许状态在导入系统各组件间传递，如：查询器和加载器</li>
<li>允许导入机制执行加载的样板操作，否则该由加载器负责</li>
</ul>
</li>
</ul>
<h3 id="find-spec"><a href="#find-spec" class="headerlink" title="find_spec"></a><code>find_spec</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">finder</span>.<span class="title">find_spec</span>(<span class="params">fullname, path=<span class="literal">None</span>, target=<span class="literal">None</span></span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>fullname</code>：被导入模块的完整限定名称</li>
<li><code>path</code>：供模块搜索使用的路径条目<ul>
<li>对最高层级模块应为<code>None</code></li>
<li>对子模块、子包应为父包<code>__path__</code>属性值，若
相应<code>__path__</code>属性无法访问将
<code>raise ModuleNotFoundError</code></li>
</ul>
</li>
<li><code>target</code>：将被作为稍后加载目标的现有模块对象<ul>
<li>导入系统仅在重加载期间传入目标模块</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>导入器的<code>find_spec()</code>返回模块规格说明中加载器为<code>self</code></li>
<li>有些元路径查找器仅支持顶级导入，<code>path</code>参数不为<code>None</code>时
  总返回<code>None</code></li>
</ul>
</blockquote>
<h2 id="Loaders"><a href="#Loaders" class="headerlink" title="Loaders"></a><em>Loaders</em></h2><ul>
<li>模块规格说明被找到时，导入机制将在加载该模块时使用<ul>
<li>其中包含的加载器将被使用，若存在</li>
</ul>
</li>
</ul>
<h3 id="加载流程"><a href="#加载流程" class="headerlink" title="加载流程"></a>加载流程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">module = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> spec.loader <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="built_in">hasattr</span>(spec.loader, <span class="string">&#x27;create_module&#x27;</span>):</span><br><span class="line">	<span class="comment"># 模块说明中包含加载器，使用加载器创建模块</span></span><br><span class="line">	module = spec.loader.create_module(spec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> module <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">	<span class="comment"># 否则创建空模块</span></span><br><span class="line">	module = types.ModuleType(spec.name)</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 设置模块导入相关属性</span></span><br><span class="line">_init_module_attrs(spec, module)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> spec.loader <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">	<span class="comment"># 模块说明中不包含加载器</span></span><br><span class="line">	<span class="comment"># 检查模块是否为为命名空间包</span></span><br><span class="line">	<span class="keyword">if</span> spec.submodule_search_locations <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">		<span class="comment"># 设置`sys.modules`</span></span><br><span class="line">		sys.modules[spec.name] = module</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">raise</span> ImportError</span><br><span class="line"><span class="keyword">elif</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(spec.loader, <span class="string">&quot;exec_module&quot;</span>):</span><br><span class="line">	<span class="comment"># 向下兼容现有`load_module`</span></span><br><span class="line">	module = spec.loader.load_module(spec.name)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	sys.modules[spec.name] = module</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		<span class="comment"># 模块执行</span></span><br><span class="line">		spec.loader.exec_module(module)</span><br><span class="line">	<span class="keyword">except</span> BaseException:</span><br><span class="line">		<span class="keyword">try</span>:</span><br><span class="line">			<span class="comment"># 加载模块失败则从`sys.modules`中移除</span></span><br><span class="line">			<span class="keyword">del</span> sys.modules[spec.name]</span><br><span class="line">		<span class="keyword">except</span> KeyError:</span><br><span class="line">			<span class="keyword">pass</span></span><br><span class="line">		<span class="keyword">raise</span></span><br><span class="line"><span class="keyword">return</span> sys.modules[spec.name]</span><br></pre></td></tr></table></figure>
<ul>
<li>创建模块对象</li>
<li>设置模块导入相关属性：在执行模块代码前设置</li>
<li><code>sys.modules</code>注册模块</li>
<li>模块执行：模块导入关键，填充模块命名空间</li>
</ul>
<h4 id="create-module创建模块对象"><a href="#create-module创建模块对象" class="headerlink" title="create_module创建模块对象"></a><code>create_module</code>创建模块对象</h4><ul>
<li><p>模块加载器可以选择通过实现<code>create_module</code>方法在加载
期间创建模块对象</p>
<ul>
<li>其应接受模块规格说明作为参数</li>
</ul>
</li>
<li><p>否则导入机制使用<code>types.ModuleType</code>自行创建模块对象</p>
</li>
</ul>
<h4 id="sys-modules注册模块"><a href="#sys-modules注册模块" class="headerlink" title="sys.modules注册模块"></a><code>sys.modules</code>注册模块</h4><ul>
<li>在加载器执行代码前注册，避免模块代码导入自身导致无限
递归、多次加载</li>
<li>若模块为命名空间包，直接注册空模块对象</li>
</ul>
<h4 id="exec-module模块执行"><a href="#exec-module模块执行" class="headerlink" title="exec_module模块执行"></a><code>exec_module</code>模块执行</h4><ul>
<li><p>导入机制调用<code>importlib.abc.Loader.exec_module()</code>方法执行
模块对象</p>
<blockquote>
<ul>
<li>CPython：<code>exec_module</code>不定返回传入模块，其返回值将被
 忽略<blockquote>
<ul>
<li><code>importlib</code>避免直接使用返回值，而是通过在
<code>sys.modules</code>中查找模块名称获取模块对象</li>
<li>可能会间接导致被导入模块可能在<code>sys.modules</code>中
替换其自身</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p>加载器应该该满足</p>
<ul>
<li><p>若模块是python模块（非内置、非动态加载），加载器应该
在模块全局命名空间<code>module.__dict__</code>中执行模块代码</p>
</li>
<li><p>若加载器无法执行指定模块，则应<code>raise ImportError</code>，
在<code>exec_module</code>期间引发的任何其他异常同样被传播</p>
</li>
</ul>
</li>
<li><p>加载失败时作为附带影响被成功加载的模块仍然保留</p>
<blockquote>
<ul>
<li>重新加载模块会保留加载失败模块（最近成功版本）</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="Path-Based-Finder—PathFinder"><a href="#Path-Based-Finder—PathFinder" class="headerlink" title="Path Based Finder—PathFinder"></a><em>Path Based Finder</em>—<code>PathFinder</code></h2><p>基于路径的查找器：在特定<em>path entry</em>中查找、加载指定的python
模块、包</p>
<ul>
<li><p>基于路径查找器只是遍历<em>import path</em>中的路径条目，将其
关联至处理特定类型路径的<em>path entry finder</em></p>
</li>
<li><p>默认路径条目查找器集合实现了在文件系统中查找模块的所有
语义，可以处理多种文件类型</p>
<ul>
<li>python源码<code>.py</code></li>
<li>python字节码<code>.pyc</code></li>
<li>共享库<code>.so</code></li>
<li>zip包装的上述文件类型（需要<code>zipimport</code>模块支持）</li>
</ul>
</li>
<li><p>作为元路径查找器</p>
<ul>
<li>实现有<code>find_spec</code>协议</li>
<li>并提供额外的钩子、协议以便能扩展、定制可搜索路径条目
的类型，定制模块从<em>import path</em>的查找、加载</li>
</ul>
</li>
</ul>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>导入机制调用基于路径的查找器的<code>find_spec()</code>迭代搜索
<em>import path</em>的路径条目，查找对应路径条目查找器</p>
<ul>
<li><p>先在<code>sys.path_impporter_cache</code>缓存中查找对应路径条目
查找器</p>
</li>
<li><p>若没有在缓存中找到，则迭代调用<code>sys.path_hooks</code>中
<em>Path Entry Hook</em></p>
</li>
<li><p>迭代结束后若没有返回路径条目查找器，则</p>
<ul>
<li>置<code>sys.path_importer_cache</code>对应值为<code>None</code></li>
<li>返回<code>None</code>，表示此元路径查找器无法找到该模块</li>
</ul>
</li>
</ul>
<h4 id="当前目录"><a href="#当前目录" class="headerlink" title="当前目录"></a>当前目录</h4><p>对空字符串表示的当前工作目录同<code>sys.path</code>中其他条目处理方式
有所不同</p>
<ul>
<li><p>若当前工作目录不存在，则<code>sys.path_importer_cache</code>
中不存放任何值</p>
</li>
<li><p>模块查找回对当前工作目录进行全新查找</p>
</li>
<li><p><code>sys.path_importer_cache</code>使用、
<code>importlib.machinery.PathFinder.find_spec()</code>返回路径将是
实际当前工作目录而非空字符串</p>
</li>
</ul>
<h3 id="Path-Entry-Hook"><a href="#Path-Entry-Hook" class="headerlink" title="Path Entry Hook"></a><em>Path Entry Hook</em></h3><p>路径条目钩子：根据路径条目查找对应路径条目查找器的可调用对象</p>
<ul>
<li><p>参数：字符串、字节串，表示要搜索的目录条目</p>
<ul>
<li>字节串的编码由钩子自行决定</li>
<li>若钩子无法解码参数，应<code>raise ImportError</code></li>
</ul>
</li>
<li><p>路径条目钩子返回值</p>
<ul>
<li>可处理路径条目的路径条目查找器</li>
<li><code>raise ImportError</code>：表示钩子无法找到与路径条目对应
路径条目查找器<ul>
<li>该异常会被忽略，并继续对<em>import path</em>迭代</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Path-Entry-Finder—PathEntryFinder"><a href="#Path-Entry-Finder—PathEntryFinder" class="headerlink" title="Path Entry Finder—PathEntryFinder"></a><em>Path Entry Finder</em>—<code>PathEntryFinder</code></h3><p>路径条目查找器：</p>
<blockquote>
<ul>
<li>元路径查找器作用于导入过程的开始，遍历<code>sys.meta_path</code>时</li>
<li>路径条目查找器某种意义上是<strong>基于路径查找器的实现细节</strong></li>
</ul>
</blockquote>
<h4 id="find-spec-1"><a href="#find-spec-1" class="headerlink" title="find_spec"></a><code>find_spec</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PathEntryFinder</span>.<span class="title">find_spec</span>(<span class="params">fullname, target=<span class="literal">None</span></span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>路径条目查找器协议：目录条目查找器需实现<code>find_spec</code>方法</p>
<ul>
<li>以支持模块、已初始化包的导入</li>
<li>给命名空间包提供组成部分</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><code>fullname</code>：要导入模块的完整限定名称</li>
<li><code>target</code>：目标模块</li>
</ul>
</li>
<li><p>返回值：完全填充好的模块规格说明</p>
<ul>
<li>模块规格说明总是包含加载器集合</li>
<li>但命名空间包的规格说明中<code>loader</code>会被设置为<code>None</code>，
并将<code>submodule_search_locations</code>设置为包含该部分的
列表，以告诉导入机制该规格说明为命名空间包的portion</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><em>Portion</em>：构成命名空间包的单个目录内文件集合</li>
<li>替代旧式<code>find_loader()</code>、<code>find_module()</code>方法</li>
</ul>
</blockquote>
<h3 id="替换标准导入系统"><a href="#替换标准导入系统" class="headerlink" title="替换标准导入系统"></a>替换标准导入系统</h3><ul>
<li><p>替换<code>sys.meta_path</code>为自定义元路径钩子</p>
<ul>
<li>替换整个导入系统最可靠机制</li>
</ul>
</li>
<li><p>替换内置<code>__import__()</code>函数</p>
<ul>
<li>仅改变导入语句行为而不影响访问导入系统其他接口</li>
<li>可以在某个模块层级替换，只改变某块内部导入语句行为</li>
</ul>
</li>
<li><p>替换<code>find_spec()</code>，引发<code>ModuleNotFoundError</code></p>
<ul>
<li>选择性的防止在元路径钩子导入某些模块</li>
</ul>
</li>
</ul>
<h3 id="main"><a href="#main" class="headerlink" title="__main__"></a><code>__main__</code></h3><ul>
<li><code>__main__</code>模块是在解释器启动时直接初始化，类似<code>sys</code>、
<code>builtins</code>，但是不被归类为内置模块，因为其初始化的方式
取决于启动解释器的旗标（命令行参数）</li>
</ul>
<h4 id="spec-1"><a href="#spec-1" class="headerlink" title="__spec__"></a><code>__spec__</code></h4><p>根据<code>__main__</code>被初始化的方式，<code>__main__.__spec__</code>被设置为
<code>None</code>或相应值</p>
<ul>
<li><p><code>-m</code>选项启动：以脚本方式执行模块</p>
<ul>
<li><p>此时<code>__spec__</code>被设置为相应模块、包规格说明</p>
</li>
<li><p><code>__spec__</code>会在<code>__main__</code>模块作为执行某个目录、zip
文件、其他<code>sys.path</code>条目的一部分加载时被填充</p>
</li>
<li><p>此时<code>__main__</code>对应可导入模块和<code>__main__</code>被视为不同
模块</p>
</li>
</ul>
</li>
<li><p>其余情况</p>
<ul>
<li><p><code>__spec__</code>被设置为<code>None</code></p>
</li>
<li><p>因为用于填充<code>__main__</code>的代码不直接与可导入模块相对应</p>
<ul>
<li>交互型提示</li>
<li><code>-c</code>选项</li>
<li>从stdin运行</li>
<li>从源码、字节码文件运行</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><code>-m</code>执行模块时<code>sys.path</code>首个值为空字符串，而直接执行脚本
  时首个值为脚本所在目录</li>
</ul>
</blockquote>
<h2 id="Import-Search-Path定制"><a href="#Import-Search-Path定制" class="headerlink" title="Import[ Search] Path定制"></a><em>Import[ Search] Path</em>定制</h2><h3 id="动态增加路径"><a href="#动态增加路径" class="headerlink" title="动态增加路径"></a>动态增加路径</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.insert(<span class="number">1</span>, /path/to/fold/contains/module)</span><br><span class="line">	<span class="comment"># 临时生效，对不经常使用的模块较好</span></span><br></pre></td></tr></table></figure>
<h3 id="修改PYTHONPATH环境变量"><a href="#修改PYTHONPATH环境变量" class="headerlink" title="修改PYTHONPATH环境变量"></a>修改<code>PYTHONPATH</code>环境变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"> #</span><span class="bash"> .bashrc</span></span><br><span class="line">export PYTHONPATH=$PYTHONPATH:/path/to/fold/contains/module</span><br></pre></td></tr></table></figure>
<ul>
<li>对许多程序都使用的模块可以采取此方式</li>
<li>会改变所有Python应用的搜索路径</li>
</ul>
<h3 id="增加-pth文件"><a href="#增加-pth文件" class="headerlink" title="增加.pth文件"></a>增加<code>.pth</code>文件</h3><p>在<code>/path/to/python/site-packages</code>（或其他查找路径目录）下
添加<code>.pth</code>配置文件，内容为需要添加的路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> # extras.pth</span><br><span class="line">/path/to/fold/contains/module</span><br></pre></td></tr></table></figure>
<ul>
<li>简单、推荐</li>
<li>python在遍历已知库文件目录过程中，遇到<code>.pth</code>文件会将其中
路径加入<code>sys.path</code>中</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-06-05T16:04:02.000Z" title="6/6/2019, 12:04:02 AM">2019-06-06</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-06-05T16:04:02.000Z" title="6/6/2019, 12:04:02 AM">2019-06-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Py3Ref/">Py3Ref</a></span><span class="level-item">42 minutes read (About 6291 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Py3Ref/expressions.html">表达式</a></h1><div class="content"><h2 id="Atoms"><a href="#Atoms" class="headerlink" title="Atoms"></a><em>Atoms</em></h2><p>原子：表达式最基本元素</p>
<ul>
<li><p>最简单原子</p>
<ul>
<li>标识符</li>
<li>字面值</li>
</ul>
</li>
<li><p>以圆括号、方括号、花括号包括的形式在语法上也被归为原子</p>
</li>
</ul>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">atom      ::=  identifier | literal | enclosure</span><br><span class="line">enclosure ::=  parenth_form | list_display | dict_display | set_display | generator_expression | yield_atom</span><br></pre></td></tr></table></figure>
<h3 id="Indentifiers-Names"><a href="#Indentifiers-Names" class="headerlink" title="Indentifiers/Names"></a><em>Indentifiers/Names</em></h3><p>名称：作为原子出现的标识符</p>
<ul>
<li>名称被绑定到对象时：对原子求值将返回相应对象</li>
<li>名称未绑定时：对原子求值将<code>raise NameError</code></li>
</ul>
<h4 id="Private-Name-Mangling"><a href="#Private-Name-Mangling" class="headerlink" title="Private Name Mangling"></a><em>Private Name Mangling</em></h4><blockquote>
<ul>
<li>类的私有名称：文本形式出现在类定义中以两个、更多下划线
  开头且不以两个、更多下划线结尾的标识符</li>
</ul>
</blockquote>
<p>私有名称转换：在为私有名称生成代码前，其被转换为更长形式</p>
<ul>
<li><p>转换方式：在名称前插入类名、下划线</p>
<ul>
<li>若转换后名称太长（超过255字符），<strong>某些实现中</strong>可能
发生截断</li>
</ul>
</li>
<li><p>转换独立于标识符使用的句法</p>
</li>
<li><p>若类名仅由下划线组成，则不会进行转换</p>
</li>
</ul>
<h3 id="Literals"><a href="#Literals" class="headerlink" title="Literals"></a><em>Literals</em></h3><p>字面值：</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">literal ::=  stringliteral | bytesliteral | integer | floatnumber | imagnumber</span><br></pre></td></tr></table></figure>
<ul>
<li><p>对字面值求值将返回改值对应类型的对象</p>
<ul>
<li>对浮点数、复数，值可能为近似值</li>
</ul>
</li>
<li><p>所有字面值都对应不可变数据类型</p>
<ul>
<li>所以对象标识的重要性不如其实际值</li>
</ul>
</li>
<li><p>多次对具有相同值的字面值求值，可能得到相同对象、或具有
相同值的不同对象</p>
<ul>
<li>元组是不可变对象，适用字面值规则：两次出现的空元组
产生对象可能相同、也可能不同<h1 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h1></li>
</ul>
</li>
</ul>
<h3 id="Parenthesized-Forms"><a href="#Parenthesized-Forms" class="headerlink" title="Parenthesized Forms"></a><em>Parenthesized Forms</em></h3><p>带括号形式：包含在<code>()</code>的<strong>可选表达式列表</strong></p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parenth_form ::= <span class="string">&quot;(&quot;</span> [starred_expression] <span class="string">&quot;)&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>带圆括号表达式列表将返回表达式所产生的任何东西</p>
<ul>
<li>内容为空的圆括号返回空元组对象</li>
<li>列表包含至少一个逗号，产生元组</li>
<li>否则，产生表达式列表对应的单一表达式</li>
</ul>
</li>
<li><p>元组不是由圆括号构建，实际是<code>,</code>逗号操作符起作用</p>
<ul>
<li>空元组是例外，此时圆括号必须，因为表达式中不带圆括号
的“空”会导致歧义</li>
</ul>
</li>
</ul>
<h3 id="List-Set-Dict-Generator-Tuple"><a href="#List-Set-Dict-Generator-Tuple" class="headerlink" title="List/Set/Dict/Generator-Tuple"></a><em>List/Set/Dict/Generator-Tuple</em></h3><blockquote>
<ul>
<li><em>display</em>：显式列出容器内容</li>
<li><em>comprehension</em>：推导式，通过循环、筛选指令计算</li>
</ul>
</blockquote>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">comprehension ::=  expression comp_for</span><br><span class="line">comp_for      ::=  [<span class="string">&quot;async&quot;</span>] <span class="string">&quot;for&quot;</span> target_list <span class="string">&quot;in&quot;</span> or_test [comp_iter]</span><br><span class="line">comp_iter     ::=  comp_for | comp_if</span><br><span class="line">comp_if       ::=  <span class="string">&quot;if&quot;</span> expression_nocond [comp_iter]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>推导式结构：单独表达式后加至少一个<code>for</code>子句以及零个、或
多个<code>for</code>或<code>if</code>子句</p>
<ul>
<li><code>for</code>、<code>if</code>子句视为代码块，按<strong>从左到右顺序嵌套</strong>
（类似<code>for</code>循环嵌套）</li>
<li>每次<strong>到达最内层代码块时</strong>对表达式求值以产生元素</li>
</ul>
</li>
<li><p>除最左边<code>for</code>子句中可迭代表达式，推导式在另一个隐式嵌套
作用域内执行</p>
<ul>
<li>确保赋给目标列表的名称不会“泄露”到外层作用域</li>
<li>最左边<code>for</code>子句中可迭代表达式直接在外层作用域中被
求值，然后作为参数传递给隐式嵌套作用域</li>
<li>后续<code>for</code>子句、最左侧<code>for</code>子句中任何筛选条件不能在
外层作用域中被求值，因为其可能依赖于从最左侧可迭代
对象中获得的值</li>
</ul>
</li>
<li><p>为确保推导式总能得到类型正确的容器，隐式嵌套作用域内禁止
使用<code>yield</code>、<code>yield from</code>表达式，因为其会对外层作用域
造成附加影响</p>
</li>
<li><p>若推导式包含<code>async for</code>子句、<code>await</code>表达式，则为异步
推导式</p>
</li>
</ul>
<h4 id="List-Displays"><a href="#List-Displays" class="headerlink" title="List Displays"></a><em>List Displays</em></h4><p>列表显式：用<code>[]</code>方括号括起的、可能为空的表达式系列</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_display ::= <span class="string">&quot;[&quot;</span> [starred_list | comprehesion] <span class="string">&quot;]&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>列表显式会产生新的列表对象，内容通过表达式、推导式指定</li>
<li>提供逗号分隔的表达式时：元素从左至右求值，按此顺序放入
列表对象</li>
<li>提供推导式时：根据推导式产生结果元素进行构建</li>
</ul>
<h4 id="Set-Displays"><a href="#Set-Displays" class="headerlink" title="Set Displays"></a><em>Set Displays</em></h4><p>集合显式：用<code>&#123;&#125;</code>花括号标明，与字典区别在于没有冒号分隔键值</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_display ::=  <span class="string">&quot;&#123;&quot;</span> (starred_list | comprehension) <span class="string">&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>集合显式产生可变集合对象，内容通过表达式、推导式指定</li>
<li>提供逗号分隔的表达式时：元素从左至右求值，按此顺序放入
列表对象</li>
<li>提供推导式时：根据推导式产生结果元素进行构建</li>
</ul>
<blockquote>
<ul>
<li>空集合不能使用<code>&#123;&#125;</code>构建，此构建的是空字典</li>
</ul>
</blockquote>
<h4 id="Dict-Displays"><a href="#Dict-Displays" class="headerlink" title="Dict Displays"></a><em>Dict Displays</em></h4><p>字典显式：用<code>&#123;&#125;</code>花括号括起来的、可能为空的键值对</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dict_display       ::=  <span class="string">&quot;&#123;&quot;</span> [key_datum_list | dict_comprehension] <span class="string">&quot;&#125;&quot;</span></span><br><span class="line">key_datum_list     ::=  key_datum (<span class="string">&quot;,&quot;</span> key_datum)* [<span class="string">&quot;,&quot;</span>]</span><br><span class="line">key_datum          ::=  expression <span class="string">&quot;:&quot;</span> expression | <span class="string">&quot;**&quot;</span> or_expr</span><br><span class="line">dict_comprehension ::=  expression <span class="string">&quot;:&quot;</span> expression comp_for</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>**</code>：映射拆包，操作数必须是映射</li>
</ul>
</blockquote>
<ul>
<li><p>字典显式产生新的字典对象</p>
</li>
<li><p>提供<code>,</code>分隔键值对序列</p>
<ul>
<li>从左至右被求值以定义字典条目</li>
<li>可多次指定相同键，最终值由最后给出键值对决定</li>
</ul>
</li>
<li><p>提供字典推导式</p>
<ul>
<li>以冒号分隔的两个表达式，后者带上标准<code>for</code>、<code>if</code>子句</li>
<li>作为结果键值对按产生顺序被加入新字典</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>键类型需要为hashable</li>
</ul>
</blockquote>
<h3 id="Generator-Expression"><a href="#Generator-Expression" class="headerlink" title="Generator Expression"></a><em>Generator Expression</em></h3><p>生成器表达式：用圆括号括起来的紧凑形式生成器（迭代器）标注</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">generator_expression ::=  <span class="string">&quot;(&quot;</span> expression comp_for <span class="string">&quot;)&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>生成器表达式会产生新的生成器（迭代器）对象</p>
<ul>
<li>句法同推导式，但使用圆括号括起</li>
<li>圆括号在只附带一个参数（省略<code>expression</code>）的调用中
可以被省略</li>
</ul>
</li>
<li><p>生成器表达式中使用的变量在生成器对象调用<code>__next__</code>方法
时以惰性方式被求值，同普通生成器</p>
<ul>
<li>最左侧<code>for</code>子句内可迭代对象会被立即求值，则其造成的
错误会在生成器表达式<strong>被定义时被检测到</strong></li>
</ul>
</li>
</ul>
<h3 id="Yield-Expression"><a href="#Yield-Expression" class="headerlink" title="Yield Expression"></a><em>Yield Expression</em></h3><p>yield表达式：将控制权交还给调度程序</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yield_atom       ::=  <span class="string">&quot;(&quot;</span> yield_expression <span class="string">&quot;)&quot;</span></span><br><span class="line">yield_expression ::=  <span class="string">&quot;yield&quot;</span> [expression_list | <span class="string">&quot;from&quot;</span> expression]</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>yield</code>：返回其后表达式求值</li>
<li>yield表达式是赋值语句右侧唯一表达式时，括号可以省略</li>
</ul>
</blockquote>
<ul>
<li><p>在定义生成器函数、异步生成器函数时才会用到，也只能在函数
定义内部使用yield表达式，将函数变为（异步）生成器函数</p>
</li>
<li><p>yield表达式会对外层作用域造成附带影响，不允许作为实现
推导式、生成器表达式隐式作用域的一部分</p>
</li>
</ul>
<blockquote>
<ul>
<li>生成器、异步生成器参见<em>cs_python/py3ref/dm_gfuncs</em></li>
</ul>
</blockquote>
<h4 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a><code>yield from</code></h4><p><code>yield from</code>：其后表达式视为子迭代器，将控制流委托给其</p>
<ul>
<li><p>类似<strong>管道</strong>，迭代器参数、异常都被传递给子迭代器</p>
<ul>
<li><strong>子迭代器依次迭代结果</strong>被传递给生成器方法调用者</li>
<li><code>.send</code>传递值、<code>.throw</code>生成异常被传递给子迭代器</li>
</ul>
</li>
<li><p><code>.send</code>传入值、<code>.throw</code>传入异常如果有适当方法将被传递给
下层迭代器，否则</p>
<ul>
<li><code>send</code>将<code>raise AttributeError</code>、<code>raise TypeError</code></li>
<li><code>throw</code>将立即引发传入异常</li>
</ul>
</li>
<li><p>子迭代器完成后引发的<code>StopIteration</code>实例的<code>value</code>属性将
作为yield表达式值</p>
<ul>
<li>可以在引发<code>StopIteration</code>时被显式设置#todo</li>
<li>在子迭代器是生成器时通过从子生成器返回值自动设置</li>
</ul>
</li>
<li><p>用途</p>
<ul>
<li>展开嵌套序列</li>
</ul>
</li>
</ul>
<h2 id="Primaries"><a href="#Primaries" class="headerlink" title="Primaries"></a><em>Primaries</em></h2><p>原型：代表编程语言中最紧密绑定的操作（优先级最高）</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">primary ::= atom | attributeref | subscription | slicing | call</span><br></pre></td></tr></table></figure>
<h3 id="Attributeref"><a href="#Attributeref" class="headerlink" title="Attributeref"></a><em>Attributeref</em></h3><p>属性引用：后面带有句点加名称的原型</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">attributeref ::= primary <span class="string">&quot;.&quot;</span> identifier</span><br></pre></td></tr></table></figure>
<ul>
<li>要求值为支持属性引用类型的对象（多数对象支持）</li>
<li>对象会被要求产生以指定标识符为名称的属性<ul>
<li>产生过程可以通过重载<code>__getattr__()</code>方法自定义</li>
</ul>
</li>
</ul>
<h3 id="Subscriptions"><a href="#Subscriptions" class="headerlink" title="Subscriptions"></a><em>Subscriptions</em></h3><p>抽取：在序列（字符串、元组、列表）、映射（字典）对象中选择
一项</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscription ::= primary <span class="string">&quot;[&quot;</span> expression_list <span class="string">&quot;]&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>要求值必须为支持抽取操作的对象</p>
<ul>
<li>可以定义<code>__getitem__()</code>方法支持抽取操作</li>
</ul>
</li>
<li><p>映射：表达式列表求值须为键值</p>
<ul>
<li>抽取操作选择映射中键对应值</li>
<li>表达式列表为元组，除非其中只有一项</li>
</ul>
</li>
<li><p>序列：表达式列表求值须为整数、或切片</p>
<ul>
<li>正式句法规则没有要求实现对负标号值处理，但内置序列
<code>__getitem__()</code>方法结合序列长度解析负标号</li>
<li>重载<code>__getitem__</code>的子类需要显式添加对负标号、切片
支持</li>
</ul>
</li>
</ul>
<h3 id="Slicings"><a href="#Slicings" class="headerlink" title="Slicings"></a><em>Slicings</em></h3><p>切片：在序列对象（字符串、元组、列表）中选择某个范围内的项</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slicing      ::=  primary <span class="string">&quot;[&quot;</span> slice_list <span class="string">&quot;]&quot;</span></span><br><span class="line">slice_list   ::=  slice_item (<span class="string">&quot;,&quot;</span> slice_item)* [<span class="string">&quot;,&quot;</span>]</span><br><span class="line">slice_item   ::=  expression | proper_slice</span><br><span class="line">proper_slice ::=  [lower_bound] <span class="string">&quot;:&quot;</span> [upper_bound] [ <span class="string">&quot;:&quot;</span> [stride] ]</span><br><span class="line">lower_bound  ::=  expression</span><br><span class="line">upper_bound  ::=  expression</span><br><span class="line">stride       ::=  expression</span><br></pre></td></tr></table></figure>
<ul>
<li><p>可以用作表达式赋值、<code>del</code>语句的目标</p>
</li>
<li><p>形似表达式列表的东西同样形似切片列表，所以任何抽取操作
都可以被解析为切片</p>
<ul>
<li>通过定义将此情况解析为抽取优先于切片以消除歧义</li>
</ul>
</li>
<li><p>原型使用<code>__getitem__</code>、根据切片列表构造的键进行索引</p>
<ul>
<li>切片列表包含逗号：键将为包含切片项转换的元组</li>
<li>否则：键为单个切片项的转换</li>
<li>切片项若为表达式：切片的转换即为切片对象</li>
</ul>
</li>
</ul>
<h3 id="Calling"><a href="#Calling" class="headerlink" title="Calling"></a><em>Calling</em></h3><p>调用：附带可能为空的一系列参数来执行可调用对象</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">call                 ::=  primary <span class="string">&quot;(&quot;</span> [argument_list [<span class="string">&quot;,&quot;</span>] | comprehension] <span class="string">&quot;)&quot;</span></span><br><span class="line">argument_list        ::=  positional_arguments [<span class="string">&quot;,&quot;</span> starred_and_keywords]</span><br><span class="line">                            [&quot;,&quot; keywords_arguments]</span><br><span class="line">                          | starred_and_keywords [&quot;,&quot; keywords_arguments]</span><br><span class="line">                          | keywords_arguments</span><br><span class="line">positional_arguments ::=  [<span class="string">&quot;*&quot;</span>] expression (<span class="string">&quot;,&quot;</span> [<span class="string">&quot;*&quot;</span>] expression)*</span><br><span class="line">starred_and_keywords ::=  (<span class="string">&quot;*&quot;</span> expression | keyword_item)</span><br><span class="line">                          (&quot;,&quot; &quot;*&quot; expression | &quot;,&quot; keyword_item)*</span><br><span class="line">keywords_arguments   ::=  (keyword_item | <span class="string">&quot;**&quot;</span> expression)</span><br><span class="line">                          (&quot;,&quot; keyword_item | &quot;,&quot; &quot;**&quot; expression)*</span><br><span class="line">keyword_item         ::=  identifier <span class="string">&quot;=&quot;</span> expression</span><br></pre></td></tr></table></figure>
<ul>
<li><p>要求值为可调用对象</p>
<ul>
<li>用户定义函数</li>
<li>内置函数</li>
<li>内置对象方法</li>
<li>类对象</li>
<li>类实例方法</li>
<li>任何具有<code>__call__()</code>方法的对象</li>
</ul>
</li>
<li><p>调用流程</p>
<ul>
<li>参数表达式在尝试调用前被求值</li>
<li>所有参数表达式被转换为参数列表</li>
<li>代码块将形参绑定到对应参数表达式值</li>
</ul>
</li>
<li><p>除非引发异常，调用总有返回值</p>
<ul>
<li>返回值可能为<code>None</code></li>
<li>返回值计算方式取决于可调用类型<ul>
<li>用户定义函数、实例方法、类实例：函数返回值</li>
<li>内置函数：依赖于编译器</li>
<li>内置对象方法：类新实例</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>在位置参数、关键字参数后加上括号不影响语义</li>
</ul>
</blockquote>
<h4 id="关键字实参转位置实参"><a href="#关键字实参转位置实参" class="headerlink" title="关键字实参转位置实参"></a>关键字实参转位置实参</h4><p>若存在关键字实参，会通过以下操作被转换为位置参数</p>
<ul>
<li>为正式参数创建<strong>未填充空位的列表</strong></li>
<li>若有N个位置参数：将其放入前N个空位</li>
<li>对每个关键字参数<ul>
<li>使用标识符确定对应的空位：若标识符与第k个正式
参数名相同，使用第k个空位</li>
<li>若空位已被填充：则<code>raise TypeError</code></li>
<li>否则将参数值放入空位进行填充</li>
</ul>
</li>
<li>所有参数处理完毕后，未填充空位使用默认值填充</li>
<li>若仍有未填充空位，则<code>raise TypeError</code>；否则<strong>填充完毕</strong>
列表被作为调用的参数列表</li>
</ul>
<h4 id="多余实参"><a href="#多余实参" class="headerlink" title="多余实参"></a>多余实参</h4><ul>
<li><p>若有关键字参数没有与之对应的正式参数名称，将
<code>raise TypeError</code>，除非有形参使用<code>**indentifier</code>句法</p>
<ul>
<li><code>identifier</code>将被初始化新的有序映射接收任何额外关键字
参数</li>
<li>若没有多余关键字实参，则为相同类型空映射</li>
</ul>
</li>
<li><p>若位置实参数目多余位置形参数目，将<code>raise TypeError</code>，
除非有形参使用<code>*identifier</code>句法</p>
<ul>
<li><code>identifier</code>将初始化为元组接受任何额外位置参数</li>
<li>没有多余位置实参，则为空元组</li>
</ul>
</li>
</ul>
<h4 id="实参解包"><a href="#实参解包" class="headerlink" title="实参解包"></a>实参解包</h4><ul>
<li><p>若实参中出现<code>*expression</code>句法</p>
<ul>
<li><code>expression</code>求值须为<code>iterable</code></li>
<li>来自该可迭代对象的元素被当作额外位置实参</li>
<li><p><code>*expression</code>可以放在关键字实参后而没有语法错误</p>
<ul>
<li><code>expression</code>会优先被迭代，元素用于填充参数列表</li>
<li>可能和关键字参数冲突，导致关键字参数对应空位被
填充</li>
</ul>
<blockquote>
<ul>
<li>一般位置实参必须位于关键字实参前，否则有语法错误</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>若实参中出现<code>**expresion</code>句法</p>
<ul>
<li><code>expression</code>求值须为<code>mapping</code></li>
<li>其内容被当作额外关键字参数<ul>
<li>若关键字已存在，将<code>raise TypeError</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li><p>运算符优先级：从低到高</p>
<p>|运算符|描述|
|——-|——-|
|<code>lambda</code>|lambda表达式|
|<code>if--else</code>|条件表达式|
|<code>or</code>|布尔逻辑或|
|<code>and</code>|布尔逻辑与|
|<code>not</code>|布尔逻辑非|
|<code>in</code>、<code>not in</code>、<code>is</code>、<code>is not</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>=&gt;</code>、<code>!=</code>、<code>==</code>|比较运算，包括成员检测、标识号检测|
|<code>|</code>|按位或|
|<code>^</code>|按位异或|
|<code>&amp;</code>|按位与|
|<code>&lt;&lt;</code>、<code>&gt;&gt;</code>|移位|
|<code>+</code>、<code>-</code>|加、减|
|<code>*</code>、<code>@</code>、<code>/</code>、<code>//</code>、<code>%</code>|乘、矩阵乘、除、整除、取余（字符串格式化）|
|<code>+x</code>、<code>-x</code>、<code>~x</code>|正、负、按位取反|
|<code>**</code>|幂次|
|<code>await</code>|await表达式|
|<code>x[index]</code>、<code>x[start:end]</code>、<code>x(arguments...)</code>|抽取、切片、调用、属性调用|
|<code>(expression...)</code>、<code>[expressions...]</code>、<code>&#123;key:value&#125;</code>、<code>&#123;expressions...&#125;</code>|绑定或元组、列表、字典、集合显示|</p>
</li>
<li><p>求值顺序：从左至右对表达式求值</p>
<ul>
<li>但赋值操作时，右侧先于左侧求值</li>
</ul>
</li>
<li><p>算术类型转换</p>
<ul>
<li>若任意参数为复数，另一参数转换为复数</li>
<li>否则，若任意参数为浮点数，另一参数为浮点数</li>
<li>否则，二者均为整数，不需要转换</li>
</ul>
</li>
</ul>
<h3 id="await"><a href="#await" class="headerlink" title="await"></a><code>await</code></h3><p><code>await</code>：挂起coroutine执行以等待awaitable对象</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await_expr ::= <span class="string">&quot;await&quot;</span> primary</span><br></pre></td></tr></table></figure>
<ul>
<li>只能在协程函数中使用</li>
</ul>
<h3 id="幂运算符"><a href="#幂运算符" class="headerlink" title="幂运算符"></a>幂运算符</h3><p>幂运算符</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">power ::= (await_expr | primary) [<span class="string">&quot;**&quot;</span> u_expr]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>优先级高于左侧一元运算符、低于右侧一元运算符</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">1</span> ** <span class="number">2</span> == -<span class="number">1</span></span><br><span class="line"><span class="number">0</span> ** <span class="number">0</span> == <span class="number">1</span></span><br><span class="line">	<span class="comment"># 编程语言得普遍做法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>语义同两个参数调用内置<code>power</code>函数</p>
<ul>
<li>左参数进行右参数所指定的幂次乘方运算</li>
<li>数值参数会转换为相同类型，返回转换后类型<ul>
<li><code>int</code>类型做负数幂次：参数转换为<code>float</code></li>
<li><code>0</code>进行负数幂次：<code>raise ZeroDivisionError</code></li>
<li>负数进行分数次幂次：返回<code>complex</code>类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="一元算术、位运算"><a href="#一元算术、位运算" class="headerlink" title="一元算术、位运算"></a>一元算术、位运算</h3><p>一元算术、位运算</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u_expr ::= power | <span class="string">&quot;-&quot;</span> u_expr | <span class="string">&quot;+&quot;</span> u_expr | <span class="string">&quot;~&quot;</span> u_expr</span><br></pre></td></tr></table></figure>
<ul>
<li>一元算数、位运算具有相同优先级</li>
<li>若参数类型不正确将<code>raise TypeError</code><ul>
<li><code>+</code>：产生数值参数相同的值</li>
<li><code>-</code>：产生数值参数的负值</li>
<li><code>~</code>：只作用于整数，对整数参数按位取反，返回<code>-(x+1)</code>
（即负值使用补码存储）</li>
</ul>
</li>
</ul>
<h3 id="二元算术运算符"><a href="#二元算术运算符" class="headerlink" title="二元算术运算符"></a>二元算术运算符</h3><p>二元算术运算符</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m_expr ::=  u_expr | m_expr <span class="string">&quot;*&quot;</span> u_expr | m_expr <span class="string">&quot;@&quot;</span> m_expr |</span><br><span class="line">            m_expr &quot;//&quot; u_expr | m_expr &quot;/&quot; u_expr |</span><br><span class="line">            m_expr &quot;%&quot; u_expr</span><br><span class="line">a_expr ::=  m_expr | a_expr <span class="string">&quot;+&quot;</span> m_expr | a_expr <span class="string">&quot;-&quot;</span> m_expr</span><br></pre></td></tr></table></figure>
<ul>
<li><p>二元算术运算符遵循传统优先级，除幂运算符外只有两个优先
级别</p>
<ul>
<li>乘法型</li>
<li>加法型</li>
</ul>
</li>
<li><p>python支持混合算术，二元运算符可以用于不同类型操作数</p>
<ul>
<li>精度较低者会被扩展为另一个操作数类型</li>
</ul>
</li>
</ul>
<h4 id="算符说明"><a href="#算符说明" class="headerlink" title="算符说明"></a>算符说明</h4><ul>
<li><p><code>@</code>：目标是用于矩阵乘法，没有内置类型实现此运算符</p>
</li>
<li><p><code>%</code>：模，输出第1个参数除以第2个参数的余数</p>
<ul>
<li>参数可以是浮点数</li>
<li>结果正负总是与第2个操作数一致、或为0</li>
<li>结果绝对值一定小于第2个操作数绝对值（数学上必然真，
但对浮点数而言由于舍入误差存在，数值上未必真）</li>
</ul>
</li>
<li><p><code>//</code>：整除，结果就是<code>floor</code>函数处理算术除法<code>/</code>的结果</p>
<ul>
<li>整除、模语义同内置函数<code>divmod(x,y) == (x//y, x%y)</code></li>
<li>若<code>x</code>接近<code>y</code>的整数倍，由于舍入误差的存在，<code>x//y</code>可能
大于<code>(x-x%y)//y</code>，此时python返回后一个结果，保证
<code>divmod(x,y)[0]*y + x % y</code>尽量接近<code>x</code></li>
</ul>
</li>
<li><p>某些运算符也作用于特定非数字类型</p>
<ul>
<li><code>*</code>：两个参数分别为整数、序列，执行<strong>序列重复</strong></li>
<li><code>%</code>：被字符串对象重载，用于执行旧式字符串格式化/插值</li>
<li><code>+</code>：两个参数为相同类型序列，执行序列拼接操作</li>
</ul>
</li>
</ul>
<h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><p>移位运算</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shift_expr ::= a_expr | shift_expr (<span class="string">&quot;&lt;&lt;&quot;</span> | <span class="string">&quot;&gt;&gt;&quot;</span>) a_expr</span><br></pre></td></tr></table></figure>
<ul>
<li>优先级低于算术运算</li>
<li>运算符接受整数参数<ul>
<li>将第一个参数左移、右移第二个参数指定的bit数</li>
<li>右移：<code>x &gt;&gt; n == x // power(2, n)</code></li>
<li>左移：<code>x &lt;&lt; n == x * power(2, n)</code></li>
</ul>
</li>
</ul>
<h3 id="二元位运算"><a href="#二元位运算" class="headerlink" title="二元位运算"></a>二元位运算</h3><p>二元位运算</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">and_expr ::=  shift_expr | and_expr <span class="string">&quot;&amp;&quot;</span> shift_expr</span><br><span class="line">xor_expr ::=  and_expr | xor_expr <span class="string">&quot;^&quot;</span> and_expr</span><br><span class="line">or_expr  ::=  xor_expr | or_expr <span class="string">&quot;|&quot;</span> xor_expr</span><br></pre></td></tr></table></figure>
<ul>
<li><p>三种位运算符具有不同的优先级</p>
</li>
<li><p>两个参数须为整数</p>
<ul>
<li><code>&amp;</code>：对两个参数进行按位<em>AND</em>运算</li>
<li><code>^</code>：对两个参数进行按位<em>XOR</em>运算</li>
<li><code>|</code>：对两个参数进行按位<em>OR</em>运算</li>
</ul>
</li>
</ul>
<h3 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h3><p>比较运算</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">comparison    ::=  or_expr (comp_operator or_expr)*</span><br><span class="line">comp_operator ::=  <span class="string">&quot;&lt;&quot;</span> | <span class="string">&quot;&gt;&quot;</span> | <span class="string">&quot;==&quot;</span> | <span class="string">&quot;&gt;=&quot;</span> | <span class="string">&quot;&lt;=&quot;</span> | <span class="string">&quot;!=&quot;</span></span><br><span class="line">                   | &quot;is&quot; [&quot;not&quot;] | [&quot;not&quot;] &quot;in&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>所有比较运算优先级相同（与C不同）</p>
<ul>
<li>低于任何算术、移位、位运算</li>
</ul>
</li>
<li><p>比较运算可以任意串联<code>a  op1 b op2 c ... y opN z</code>等价于
<code>a op1 b and b op2 c and ... and y opN z</code></p>
<ul>
<li><p>只是后者中每个表达式最多只被求值一次</p>
</li>
<li><p>例：<code>a &lt; b &gt;= c</code>类似表达式会被按照传统比较法则解读</p>
<ul>
<li>等价<code>a &lt; b and b &gt;= c</code></li>
<li>仍具有短路求值特性，<code>a &lt; b == false</code>时，<code>c</code>不会
被求值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="值比较"><a href="#值比较" class="headerlink" title="值比较"></a>值比较</h4><ul>
<li><p><code>&gt;</code>、<code>&lt;</code>、<code>==</code>、<code>!=</code>、<code>&lt;=</code>、<code>&gt;=</code>比较两个对象值</p>
<ul>
<li>不要求两个对象为相同类型</li>
</ul>
<blockquote>
<ul>
<li>比较运算符实现了<strong>特定对象值概念</strong>，可以认为是通过
 实现对象比较间接定义对象值</li>
</ul>
</blockquote>
</li>
<li><p>所有类型继承于<code>object</code>，从其继承了默认比较行为</p>
<ul>
<li><p><code>=</code>、<code>!=</code>：一致性比较，基于对象标识<code>id</code></p>
<ul>
<li>具有相同标识的实例一致性比较结果相等</li>
<li>此默认行为动机：希望对象都应该是自反射，即
<code>x is y</code>就意味着<code>x == y</code></li>
</ul>
</li>
<li><p><code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>：没有默认值提供</p>
<ul>
<li>尝试比较<code>raise TypeError</code></li>
<li>此默认行为动机：缺少一致性比较类似固定值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h5><p>数字类型：<code>int</code>、<code>float</code>、<code>complex</code>以及标准库类型
<code>fractions.Fraction</code>、<code>decimal.Decimal</code></p>
<ul>
<li><p>可进行类型内部、跨类型比较</p>
<ul>
<li>类型相关限制内按数学（算法）规则正确进行比较，且不会
有精度损失</li>
<li>复数不支持次序比较</li>
</ul>
</li>
<li><p>非数字值<code>float(&#39;NaN&#39;)</code>、<code>decimal.Decimal(&#39;NaN&#39;)</code></p>
<ul>
<li>同任何其他数字值比较均返回<code>False</code></li>
<li><strong>不等于自身</strong>，但是是同一个对象（标识相同）</li>
</ul>
<blockquote>
<ul>
<li>具体实现参见<em>cs_python/py3ref/#todo</em></li>
</ul>
</blockquote>
</li>
</ul>
<h5 id="二进制码序列"><a href="#二进制码序列" class="headerlink" title="二进制码序列"></a>二进制码序列</h5><p>二进制码序列：<code>bytes</code>、<code>bytearray</code></p>
<ul>
<li>可以进行类型内部、跨类型比较</li>
<li>使用元素数字值按字典序进行比较</li>
</ul>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>字符串：<code>str</code></p>
<ul>
<li>使用字符的Unicode码位数字值、按字典序比较</li>
<li>字符串、二进制码序列不能直接比较</li>
</ul>
<h5 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h5><p>序列：<code>tuple</code>、<code>list</code>、<code>range</code></p>
<ul>
<li><p>只能进行类型内部比较</p>
<ul>
<li>跨类型：一致性比较结果为否、次序比较将
<code>raise TypeError</code></li>
<li><code>range</code>不支持次序比较</li>
</ul>
</li>
<li><p>序列元素通过相应元素进行字典序比较</p>
<ul>
<li>序列相等：相同类型、相同长度，每对相应元素必须 相等</li>
<li>对支持次序比较序列：排序同第一个不相等元素排序，若
对应元素不同，较短序列排序较小</li>
</ul>
</li>
<li><p>强制规定元素自反射性：序列元素<code>x</code>，<code>x==x</code>总为真</p>
<ul>
<li><p>即序列元素比较比较时：须首先比较元素标识，仅会对不同
元素执行<code>==</code>严格比较运算</p>
</li>
<li><p>若序列元素为自反射元素，结果与严格比较相同；若序列
元素为非自反射元素，结果与严格比较不同</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nan = <span class="built_in">float</span>(<span class="string">&quot;NaN&quot;</span>)</span><br><span class="line">(nan <span class="keyword">is</span> nan) == <span class="literal">True</span></span><br><span class="line">(nan == nan) == <span class="literal">False</span></span><br><span class="line">([nan] == [nan]) == <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h5 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h5><p>映射：<code>dict</code></p>
<ul>
<li>映射相等：当且进行具有相同键值对<ul>
<li>键、值一致性比较强制规定自反射性</li>
</ul>
</li>
</ul>
<h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5><p>集合：<code>set</code>、<code>frozenset</code></p>
<ul>
<li><p>可进行类型内部、跨类型比较</p>
</li>
<li><p>比较运算符定义为子集、超集检测</p>
<ul>
<li>这类关系没有定义完全排序，如：<code>&#123;1,2&#125;</code>、<code>&#123;2,3&#125;</code>集合
不相等，也没有大小比较关系</li>
<li>所以，集合不应作为依赖完全排序的函数参数，如：
<code>min</code>、<code>max</code>、<code>sorted</code>，将产生未定义结果</li>
</ul>
</li>
<li><p>集合强制规定其元素自反射性</p>
</li>
</ul>
<h5 id="自定比较行为"><a href="#自定比较行为" class="headerlink" title="自定比较行为"></a>自定比较行为</h5><blockquote>
<ul>
<li>其他内置类型没有实现比较方法，继承<code>object</code>默认比较行为</li>
<li>可以通过实现<strong>富比较方法</strong>自定义类型的比较行为，最好
  遵守一些一致性规则（不强制）</li>
</ul>
</blockquote>
<ul>
<li><p>自反射：相同对象比较应该相等</p>
<ul>
<li><code>x is y</code>有<code>x == y</code></li>
</ul>
</li>
<li><p>对称性</p>
<ul>
<li><code>x == y</code>有<code>y == x</code></li>
<li><code>x != y</code>有<code>y != x</code></li>
<li><code>x &lt; y</code>有<code>y &gt; x</code></li>
<li><code>x &lt;= y</code>有<code>y &gt;= x</code></li>
</ul>
</li>
<li><p>可传递</p>
<ul>
<li><code>x &gt; y and y &gt; z</code>有<code>x &gt; z</code></li>
<li><code>x &lt; y and y &lt;= z</code>有<code>x &lt; z</code></li>
</ul>
</li>
<li><p>反向比较应该导致布尔取反</p>
<ul>
<li><code>x == y</code>有<code>not x != y</code></li>
<li><code>x &lt; y</code>有<code>not x &gt;= y</code>（对完全排序）</li>
<li><code>x &gt; y</code>有<code>not x &lt;= y</code>（对完全排序）</li>
</ul>
</li>
<li><p>相等对象应该具有相同hash值，或标记为不可hash</p>
</li>
</ul>
<blockquote>
<ul>
<li>具体实现参见<em>cs_python/py3ref/#todo</em></li>
</ul>
</blockquote>
<h4 id="成员检测"><a href="#成员检测" class="headerlink" title="成员检测"></a>成员检测</h4><p><code>in</code>、<code>not in</code>：成员检测，后者为前者取反</p>
<ul>
<li><p>对<code>list</code>、<code>tuple</code>、<code>set</code>、<code>frozenset</code>、<code>dict</code>、
<code>collections.deque</code>等<strong>内置</strong>容器类型</p>
<ul>
<li><code>x in y</code>同<code>any(x is e or x == e for e in y)</code></li>
<li>映射检测是否有给定键</li>
</ul>
</li>
<li><p>对字符串、字节串</p>
<ul>
<li>当且进当<code>x</code>为<code>y</code>其子串时<code>x in y</code>返回<code>True</code>，空字符串
总被视为其他字符串子串</li>
<li><code>x in y</code>等价于<code>y.find(x) != -1</code></li>
</ul>
</li>
<li><p>自定义类型可以自定义成员检测</p>
<ul>
<li><code>__contains__</code>方法返回值即为<code>x in y</code>返回值</li>
<li>未定义<code>__contains__</code>方法但定义<code>__iter__</code>，若迭代<code>y</code>
得到值<code>z == x</code>，则<code>x in y == True</code>，出现异常等同于
<code>in</code>引发异常</li>
</ul>
<blockquote>
<ul>
<li>具体实现参见<em>cs_python/py3ref/#todo</em></li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="标识号比较"><a href="#标识号比较" class="headerlink" title="标识号比较"></a>标识号比较</h4><p><code>is</code>、<code>is not</code>：对象标识号检测，后者为前者取反</p>
<ul>
<li>当且仅当<code>x</code>、<code>y</code>为同一对象<code>x is y == True</code></li>
</ul>
<h3 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h3><p>布尔运算</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">or_test  ::=  and_test | or_test <span class="string">&quot;or&quot;</span> and_test</span><br><span class="line">and_test ::=  not_test | and_test <span class="string">&quot;and&quot;</span> not_test</span><br><span class="line">not_test ::=  comparison | <span class="string">&quot;not&quot;</span> not_test</span><br></pre></td></tr></table></figure>
<ul>
<li><p>执行布尔运算、表达式用于流程控制语句时，以下值被解析为
假值，其余值被解析为真值</p>
<ul>
<li><code>False</code></li>
<li><code>None</code></li>
<li>所有数值类型的数值0</li>
<li>空字符串</li>
<li>空容器</li>
</ul>
</li>
<li><p><code>and</code>、<code>or</code><strong>返回最终求值参数</strong>而不是<code>False</code>、<code>True</code></p>
<ul>
<li><p><code>x and y</code>：首先对<code>x</code>求值</p>
<ul>
<li>对<code>x</code>求值，若为假直接返回<code>x</code><strong>求值</strong></li>
<li>否则对<code>y</code><strong>求值并返回</strong></li>
</ul>
</li>
<li><p><code>x or y</code>：首先对<code>x</code>求值</p>
<ul>
<li>对<code>x</code>求值，若为真直接返回<code>x</code><strong>求值</strong></li>
<li>否则对<code>y</code><strong>求值并返回结果值</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><code>not</code>必须创建新值，无论参数为和类型均范围布尔值<code>True</code>、
<code>False</code></p>
</li>
<li><p>可以通过自定义<code>__bool__</code>方法定制逻辑值</p>
<blockquote>
<ul>
<li>具体实现参见<em>cs_python/py3ref/#todo</em></li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><p>条件表达式：三元运算符</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conditional_expression ::=  or_test [<span class="string">&quot;if&quot;</span> or_test <span class="string">&quot;else&quot;</span> expression]</span><br><span class="line">expression             ::=  conditional_expression | lambda_expr</span><br><span class="line">expression_nocond      ::=  or_test | lambda_expr_nocond</span><br></pre></td></tr></table></figure>
<ul>
<li>在所有python运算中具有最低优先级</li>
<li><code>x if C else y</code><ul>
<li>首先对条件<code>C</code>求值</li>
<li>若<code>C</code>为真，<code>x</code>被求值并返回</li>
<li>否则将对<code>y</code>求值并返回</li>
</ul>
</li>
</ul>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a><code>lambda</code>表达式</h3><p><code>lambda</code>表达式：创建匿名函数</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lambda_expr        ::=  <span class="string">&quot;lambda&quot;</span> [parameter_list] <span class="string">&quot;:&quot;</span> expression</span><br><span class="line">lambda_expr_nocond ::=  <span class="string">&quot;lambda&quot;</span> [parameter_list] <span class="string">&quot;:&quot;</span> expression_nocond</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>lambda parameters: expression</code>返回函数对象，同</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> &lt;<span class="title">lambda</span>&gt;(<span class="params">parameters</span>):</span></span><br><span class="line">	<span class="keyword">return</span> expression</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<ul>
<li><code>lambda</code>表达式只是简单函数定义的简单写法</li>
</ul>
</blockquote>
<h3 id="表达式列表"><a href="#表达式列表" class="headerlink" title="表达式列表"></a>表达式列表</h3><p>表达式列表：除作为列表、集合显示的一部分，包含至少一个逗号
的列表表达式将生成元组</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expression_list    ::=  expression (<span class="string">&quot;,&quot;</span> expression)* [<span class="string">&quot;,&quot;</span>]</span><br><span class="line">starred_list       ::=  starred_item (<span class="string">&quot;,&quot;</span> starred_item)* [<span class="string">&quot;,&quot;</span>]</span><br><span class="line">starred_expression ::=  expression | (starred_item <span class="string">&quot;,&quot;</span>)* [starred_item]</span><br><span class="line">starred_item       ::=  expression | <span class="string">&quot;*&quot;</span> or_expr</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>末尾逗号仅在创建单独元组时需要，在其他情况下可选</li>
</ul>
</blockquote>
<ul>
<li><p>元组长度就是列表中表达式的数量</p>
<ul>
<li>表达式将从左至右被求值</li>
</ul>
</li>
<li><p><code>*</code>表示可迭代拆包：操作数必须为<em>iterable</em>（同实参调用）</p>
<ul>
<li>可迭代对象将被拆解为迭代项序列，并被包含于新建的元组
、列表、集合中</li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-06-05T12:46:24.000Z" title="6/5/2019, 8:46:24 PM">2019-06-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-06-05T12:46:24.000Z" title="6/5/2019, 8:46:24 PM">2019-06-05</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Py3std/">Py3std</a></span><span class="level-item">a few seconds read (About 67 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Py3std/README.html">Python标准库</a></h1><div class="content"><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><ul>
<li>内置类型相关参见<em>cs_python/py3ref/dm_basics</em></li>
</ul>
<h2 id="常用参数说明"><a href="#常用参数说明" class="headerlink" title="常用参数说明"></a>常用参数说明</h2><h3 id="Functional-Programming"><a href="#Functional-Programming" class="headerlink" title="Functional Programming"></a><em>Functional Programming</em></h3><ul>
<li><p><code>key=None/callable</code></p>
<ul>
<li>含义：key函数，接受一个参数，返回用于排序的值</li>
<li>默认：<code>None</code>，不处理</li>
</ul>
</li>
<li><p><code>iterable=iterable</code></p>
<ul>
<li>含义：可迭代对象</li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-06-05T03:05:43.000Z" title="6/5/2019, 11:05:43 AM">2019-06-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-02T03:44:48.000Z" title="8/2/2021, 11:44:48 AM">2021-08-02</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Py3Ref/">Py3Ref</a></span><span class="level-item">36 minutes read (About 5341 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Py3Ref/dm_basics.html">数据模型--基本数据类型</a></h1><div class="content"><h2 id="对象、值、类型"><a href="#对象、值、类型" class="headerlink" title="对象、值、类型"></a>对象、值、类型</h2><p>对象：python中对数据的抽象</p>
<ul>
<li><p>python中所有数据都是由对象、对象间关系表示</p>
<ul>
<li>按冯诺依曼“存储程序计算机”，代码本身也是由对象表示</li>
</ul>
</li>
</ul>
<h3 id="编号、类型、值"><a href="#编号、类型、值" class="headerlink" title="编号、类型、值"></a>编号、类型、值</h3><p>每个对象都有各自<strong>编号</strong>、<strong>类型</strong>、<strong>值</strong></p>
<ul>
<li><p>编号：可以视为对象在内存中地址，对象创建后不变</p>
<ul>
<li><code>id()</code>函数：获取代表对象编号的整形</li>
<li><code>is</code>算符：比较对象编号判断是否为同一对象</li>
</ul>
</li>
<li><p>类型：决定对象支持的操作、可能取值</p>
<ul>
<li>类型会影响对象行为几乎所有方面，甚至对象编号重要性
也受到影响，如：对于会得到新值的运算<ul>
<li>不可变类型：可能返回同类型、同取值现有对象引用<ul>
<li><code>a = b = 1</code>：<code>a</code>、<code>b</code>可能指向相同对象<code>1</code>
（取决于具体实现）</li>
</ul>
</li>
<li>可变类型：不允许返回已存在对象<ul>
<li><code>c=[];d=[]</code>：会保证<code>c</code>、<code>d</code>指向不同、单独
空列表（<code>c=d=[]</code>将同一对象赋给<code>c</code>、<code>d</code>）</li>
</ul>
</li>
</ul>
</li>
<li>对象创建后保持不变</li>
<li><code>type</code>：返回对象类型</li>
</ul>
<blockquote>
<ul>
<li>CPython：相同整形值都引用同一个对象</li>
</ul>
</blockquote>
</li>
<li><p>值：通过一些特征行为表征的抽象概念</p>
<ul>
<li><p>对象值在python中是抽象概念</p>
<ul>
<li>对象值没有规范的访问方法</li>
<li>不要求具有特定的构建方式，如：值由其全部数据
属性组成</li>
</ul>
</li>
<li><p>对象值可变性由其类型决定</p>
<ul>
<li>可变的：值可以改变的对象</li>
<li>不可变的：值（直接包含对象编号）不可改变的对象</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>比较运算符实现了<strong>特定对象值概念</strong>，可以认为是
 通过实现对象比较间接定义对象值</li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>CPython：<code>id(x)</code>返回存放<code>x</code>的地址</li>
</ul>
</blockquote>
<h3 id="对象销毁"><a href="#对象销毁" class="headerlink" title="对象销毁"></a>对象销毁</h3><p>对象不会被显式销毁（<code>del</code>仅是移除名称绑定）</p>
<ul>
<li><p>无法访问时<strong>可能</strong>被作为垃圾回收</p>
<ul>
<li>允许具体实现推迟垃圾回收或完全省略此机制</li>
<li>实现垃圾回收是质量问题，只要可访问对象不会被回收
即可</li>
<li>不要依赖不可访问对象的立即终结机制，应当总是显式
关闭外部资源引用</li>
</ul>
</li>
<li><p>以下情况下，正常应该被回收的对象可能继续存活</p>
<ul>
<li>使用实现的跟踪、调试功能</li>
<li>通过<code>try...except...</code>语句捕捉异常</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>CPython：使用带有（可选）<strong>延迟检测循环链接垃圾</strong>的
  引用计数方案<blockquote>
<ul>
<li>对象<strong>不可访问</strong>时立即回收其中大部分，但不保证
 回收包含<strong>循环引用</strong>的垃圾</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="标准类型层级结构"><a href="#标准类型层级结构" class="headerlink" title="标准类型层级结构"></a>标准类型层级结构</h3><blockquote>
<ul>
<li>以下是python内置类型的列表，扩展模块可以定义更多类型</li>
<li>以下有些类型有特殊属性，这些特殊属性不应用作通常使用，
  其定义在未来可能改变</li>
</ul>
</blockquote>
<h2 id="None"><a href="#None" class="headerlink" title="None"></a><code>None</code></h2><p><code>NoneType</code>：只有一种取值，<code>None</code>是具有此值的唯一对象</p>
<ul>
<li>通过内置名称<code>None</code>访问</li>
<li>多数情况表示空值，如<ul>
<li>未显式指明返回值函数返回<code>None</code></li>
</ul>
</li>
<li>逻辑值：假</li>
</ul>
<h2 id="NotImplemented"><a href="#NotImplemented" class="headerlink" title="NotImplemented"></a><code>NotImplemented</code></h2><p><code>NotImplementedType</code>：只有一种取值，<code>NotImplemented</code>是具有
此值的唯一对象</p>
<ul>
<li>通过内置名称<code>NotImplemented</code>访问</li>
<li>数值、富比较方法在操作数没有该实现操作时应返回此值<ul>
<li>返回<code>NotImplemented</code>前，解释器会依据运算符尝试反射
方法、委托回退方法</li>
</ul>
</li>
<li>逻辑值：真</li>
</ul>
<h2 id="Ellipsis"><a href="#Ellipsis" class="headerlink" title="Ellipsis"></a><code>Ellipsis</code></h2><p><code>ellipsis</code>：只有一种取值，<code>Ellipsis</code>是具有此值的唯一对象</p>
<ul>
<li>通过字面值<code>...</code>、内置名称<code>Ellipsis</code>访问</li>
<li>逻辑值：真</li>
</ul>
<h2 id="numbers-Number"><a href="#numbers-Number" class="headerlink" title="numbers.Number"></a><code>numbers.Number</code></h2><p><code>number.Number</code>：由数字字面值创建，被作为算法运算符、算数
内置函数返回结果</p>
<ul>
<li>不可变：一旦创建其值不再改变</li>
<li>类似数学中数字，但也受限于计算机对数字的表示方法</li>
</ul>
<h3 id="numbers-Integral"><a href="#numbers-Integral" class="headerlink" title="numbers.Integral"></a><code>numbers.Integral</code></h3><p><code>numbers.Integral</code>：表示数学中整数集合</p>
<ul>
<li><p><code>int</code>：整形，表示<strong>任意大小数字，仅受限于可用内存</strong></p>
<ul>
<li>变换、掩码运算中以二进制表示</li>
<li>负数以2的补码表示（类似符号位向左延伸补满空位）</li>
</ul>
</li>
<li><p><code>bool</code>：布尔型，表示逻辑值真、假</p>
<ul>
<li><code>True</code>、<code>False</code>是唯二两个布尔对象</li>
<li>整形子类型：在各类场合中行为类似整形<code>1</code>、<code>0</code>，仅在
转换为字符串时返回<code>&quot;True&quot;</code>、<code>&quot;False&quot;</code></li>
</ul>
</li>
</ul>
<h4 id="方法、函数"><a href="#方法、函数" class="headerlink" title="方法、函数"></a>方法、函数</h4><ul>
<li><code>int.bit_length()</code>：不包括符号位、开头0位长</li>
<li><code>int.to_bytes(length, byteorder, *, signed=False)</code></li>
<li><code>class int.from_bytes(bytes, byteorder, *, signed=False)</code></li>
</ul>
<blockquote>
<ul>
<li>详细说明参见<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#additional-methods-on-integer-types">https://docs.python.org/zh-cn/3/library/stdtypes.html#additional-methods-on-integer-types</a></li>
</ul>
</blockquote>
<h3 id="numbers-Real-float"><a href="#numbers-Real-float" class="headerlink" title="numbers.Real(float)"></a><code>numbers.Real(float)</code></h3><p><code>float</code>：表示机器级<strong>双精度浮点数</strong></p>
<ul>
<li>接受的取值返回、溢出处理取决于底层结构、python实现</li>
<li>python不支持单精度浮点</li>
</ul>
<blockquote>
<ul>
<li>没必要因为节省处理器、内存消耗而增加语言复杂度</li>
</ul>
</blockquote>
<h4 id="特殊取值"><a href="#特殊取值" class="headerlink" title="特殊取值"></a>特殊取值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">infty = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">neg_infty = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">	<span class="comment"># 正/负无穷大</span></span><br><span class="line">nan = <span class="built_in">float</span>(<span class="string">&quot;nan&quot;</span>)</span><br><span class="line">	<span class="comment"># Not a Number</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>特殊取值根据定义<code>==</code>、<code>is</code>肯定返回<code>False</code></p>
<ul>
<li><code>float.__eq__</code>内部应该有做检查，保证<code>==</code>返回<code>False</code></li>
<li>每次会创建“新”的<code>nan/infty</code></li>
</ul>
<blockquote>
<ul>
<li>连续执行<code>id(float(&quot;nan&quot;))</code>返回值可能相等，这是因为
 每次生成的<code>float(&quot;nan&quot;)</code>对象被回收，不影响</li>
</ul>
</blockquote>
</li>
<li><p><code>np.nan is np.nan</code>返回<code>True</code>，应该是<code>numpy</code>初始化的时候
创建了一个<code>float(&quot;nan&quot;)</code>，每次都是使用同一个<em>nan</em></p>
</li>
</ul>
<h4 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h4><blockquote>
<ul>
<li>详细参考<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#additional-methods-on-float">https://docs.python.org/zh-cn/3/library/stdtypes.html#additional-methods-on-float</a></li>
<li>更多数字运算参考<code>math</code>、<code>cmath</code>模块</li>
</ul>
</blockquote>
<ul>
<li><code>float.as_integer_ratio()</code></li>
<li><code>float.is_integer()</code></li>
<li><code>float.hex()</code></li>
<li><code>classmethod float.fromhex(s)</code></li>
<li><code>round(f[,n])</code></li>
<li><code>math.trunc(f)</code></li>
<li><code>math.floor(f)</code></li>
<li><code>math.ceil(f)</code></li>
</ul>
<h3 id="numbers-Complex-complex"><a href="#numbers-Complex-complex" class="headerlink" title="numbers.Complex(complex)"></a><code>numbers.Complex(complex)</code></h3><p><code>complex</code>：以一对机器级双精度浮点数表示复数值</p>
<ul>
<li>实部、虚部：可通过只读属性<code>z.real</code>、<code>z.imag</code>获取</li>
</ul>
<h2 id="Iterators"><a href="#Iterators" class="headerlink" title="Iterators"></a><em>Iterators</em></h2><p>迭代器类型</p>
<ul>
<li>迭代器对象需要自身支持以下两个方法，其共同组成迭代器协议<ul>
<li><code>iterator.__iter__()</code></li>
<li><code>iterator.__next__()</code></li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>方法详细参考<em>cs_python/py3ref/cls_special_method</em></li>
</ul>
</blockquote>
<h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a><em>Generator</em></h3><p>生成器类型：提供了实现迭代器协议的便捷形式</p>
<ul>
<li>将容器对象的<code>__iter__()</code>方法实现为生成器，方便实现容器对
迭代器支持</li>
</ul>
<blockquote>
<ul>
<li>创建、使用参见<em>cs_python/py3ref/dm_gfuncs</em></li>
</ul>
</blockquote>
<h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><p>序列：表示以非负整数作为索引的<strong>有限有序集</strong></p>
<ul>
<li><p>不可变序列类型：对象一旦创建不能改变</p>
<ul>
<li>若包含其他可变对象引用，则可变对象“可改变”</li>
<li>但不可变对象所<strong>直接引用的对象集是不可变的</strong></li>
<li>包括<ul>
<li><code>str</code></li>
<li><code>tuple</code></li>
<li><code>bytes</code></li>
<li><code>range</code>：非基本序列类型</li>
</ul>
</li>
</ul>
</li>
<li><p>可变序列：创建后仍可被改变值</p>
<ul>
<li><code>list</code></li>
<li><code>bytesarray</code></li>
</ul>
</li>
</ul>
<h3 id="通用序列操作"><a href="#通用序列操作" class="headerlink" title="通用序列操作"></a>通用序列操作</h3><ul>
<li><p><code>x in s</code>、<code>x not in s</code></p>
<ul>
<li><code>str</code>、<code>bytes</code>、<code>bytearray</code>支持子序列检测</li>
</ul>
</li>
<li><p><code>s + t</code>：拼接</p>
<ul>
<li>拼接不可变总会生成新对象</li>
<li>重复拼接构建序列的运行时开销将基于序列总长度乘方</li>
</ul>
</li>
<li><p><code>s * n</code>、<code>n * s</code>：<code>s</code>自身拼接<code>n</code>次</p>
<ul>
<li><code>n&lt;0</code>被当作<code>0</code>处理</li>
<li><code>s</code>中项不会被复制，而是被多次引用</li>
</ul>
</li>
<li><p><code>s[i]</code>、<code>s[i:j]</code>、<code>s[i:j:step]</code></p>
<ul>
<li><code>i&lt;0</code>索引为负值：索引顺序相对于序列<code>s</code>末尾，等价于
对序列长度取模</li>
<li>序列切片：与序列类型相同的新序列<ul>
<li>索引从0开始</li>
<li>左闭右开</li>
</ul>
</li>
<li>某些序列支持<code>a[i:j:step]</code>扩展切片</li>
</ul>
</li>
<li><p><code>s.index(x[, i[, j]])</code></p>
<ul>
<li>仅部分序列支持</li>
<li>类似<code>s[i:j].index(x)</code>，但返回值是相对序列开头</li>
</ul>
</li>
<li><p><code>s.count(x)</code>：序列中元素<code>x</code>数目</p>
</li>
<li><p><code>len(s)</code>：返回序列条目数量</p>
</li>
<li><p><code>min(s)</code>、<code>max(s)</code>：序列最小、最大值</p>
</li>
</ul>
<blockquote>
<ul>
<li>序列比较运算默认实现参见<em>cs_python/py3ref/expressions</em></li>
<li>以上运算自定义实现参见
  <em>cs_python/py3ref/cls_special_methods</em></li>
</ul>
</blockquote>
<h4 id="不可变序列"><a href="#不可变序列" class="headerlink" title="不可变序列"></a>不可变序列</h4><p>不可变序列普遍实现而可变序列未实现的操作</p>
<ul>
<li><code>hash()</code>内置函数</li>
</ul>
<h4 id="可变序列"><a href="#可变序列" class="headerlink" title="可变序列"></a>可变序列</h4><ul>
<li><code>s[i]=x</code>、<code>s[i:j]=t</code>、<code>s[i:j:k]=t</code>：下标、切片被赋值<ul>
<li><code>s[i:j:k]=t</code>中<code>t</code>长度必须和被替换切片长度相同</li>
</ul>
</li>
<li><code>del s[i:j]</code>、<code>del s[i:j:k]</code>：移除元素<ul>
<li>作为<code>del</code>语句的目标</li>
<li>等同于<code>s[i:j]=[]</code></li>
</ul>
</li>
<li><code>s.append()</code>：添加元素<ul>
<li>等同于<code>s[len(s):len(s)] = [x]</code></li>
</ul>
</li>
<li><code>s.clear()</code>：移除所有项<ul>
<li>等同于<code>del s[:]</code></li>
</ul>
</li>
<li><code>s.copy()</code>：浅拷贝<ul>
<li>等同于<code>s[:]</code></li>
</ul>
</li>
<li><code>s.extend(t)</code>：扩展（合并）序列<ul>
<li>基本上等于<code>s += t</code></li>
</ul>
</li>
<li><code>s.insert(i, x)</code>：向序列中插入元素<ul>
<li>等同于<code>s[i:i] = [x]</code></li>
</ul>
</li>
<li><code>s.pop(i=-1)</code>：弹出序列中元素</li>
<li><code>s.remove(x)</code>：删除序列中首个值为<code>x</code>的项</li>
<li><code>s.reverse()</code>：反转序列<ul>
<li>反转大尺寸序列时，会原地修改序列</li>
<li>为提醒用户此操作通过间接影响进行，不会返回反转后序列</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><code>array</code>、<code>collections</code>模块提供额外可变序列类型</li>
<li>可利用<code>collections.abc.MutableSequence</code>抽象类简化自定义
  序列操作</li>
</ul>
</blockquote>
<h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a><code>tuple</code></h3><p>元组</p>
<ul>
<li>元组中条目可以是任意python对象</li>
<li>元组创建<ul>
<li>一对圆括号创建空元组</li>
<li>逗号分隔<ul>
<li>单项元组：后缀逗号<code>a,</code>、<code>(a,)</code></li>
<li>多项元组：<code>a,b,c</code>、<code>(a,b,c)</code></li>
</ul>
</li>
<li>内置构建器：<code>tuple</code>、<code>tuple(iterable)</code></li>
</ul>
</li>
</ul>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a><code>list</code></h3><p>列表</p>
<ul>
<li>列表中条目可以是任意python对象</li>
<li>构建方式<ul>
<li>方括号括起、项以逗号分隔：<code>[]</code>、<code>[a]</code>、<code>[a,b]</code></li>
<li>列表推导式：<code>[x for x in iterable]</code></li>
<li>类型构造器：<code>list(iterable)</code></li>
</ul>
</li>
</ul>
<h4 id="相关操作-1"><a href="#相关操作-1" class="headerlink" title="相关操作"></a>相关操作</h4><h5 id="sort"><a href="#sort" class="headerlink" title=".sort"></a><code>.sort</code></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list</span>.<span class="title">sort</span>(<span class="params">*, key=<span class="literal">None</span>, reverse=<span class="literal">False</span></span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：对列表<strong>原地排序</strong></p>
<ul>
<li>使用<code>&lt;</code>进行各项之间比较</li>
<li>不屏蔽异常：若有比较操作失败，整个排序操作将失败，
此时列表可能处于<strong>部分被修改状态</strong></li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><code>key</code>：带参数函数，遍历处理每个元素提取比较键<ul>
<li><code>None</code>：默认，直接使用列表项排序</li>
</ul>
</li>
</ul>
</li>
<li><p>说明</p>
<ul>
<li><code>.sort</code>保序，有利于多重排序</li>
<li>为提醒用户此方法原地修改序列保证空间经济性，其不返回
排序后序列（可考虑使用<code>sorted</code>显式请求）</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>CPython：列表排序期间尝试改变、检测会造成未定义影响，
  CPython将列表排序期间显式为空，若列表排序期间被改变将
  <code>raise ValueError</code></li>
</ul>
</blockquote>
<h3 id="str"><a href="#str" class="headerlink" title="str"></a><code>str</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">str</span>(<span class="params"><span class="built_in">object</span>=<span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line"><span class="class">	# 返回`<span class="title">object</span>.<span class="title">__str__</span>()`、`<span class="title">object</span>.<span class="title">__repr__</span>()`</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">str</span>(<span class="params"><span class="built_in">object</span>=<span class="string">b&quot;&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>, errors=<span class="string">&quot;strict&quot;</span></span>)</span></span><br><span class="line"><span class="class">	# 给出`<span class="title">encoding</span>`、`<span class="title">errors</span>`之一，须为<span class="title">bytes</span>-<span class="title">like</span>对象</span></span><br><span class="line"><span class="class">	# 等价于`<span class="title">bytes</span>.<span class="title">decode</span>(<span class="params">encoding, errors</span>)`</span></span><br></pre></td></tr></table></figure>
<p>字符串：由Unicode码位值组成不可变序列（应该是<em>UTF16-bl</em>编码）</p>
<ul>
<li>范围在<code>U+0000~U+10FFFF</code>内所有码位值均可在字符串中使用</li>
<li>不存在单个“字符”类型<ul>
<li>字符串中单个字符为长度为1字符串</li>
</ul>
</li>
<li>不存在可变字符串类型<ul>
<li>可以用<code>str.join()</code>、<code>io.StringIO</code>高效连接多个字符串
片段</li>
</ul>
</li>
<li>字符串构建<ul>
<li>字符串字面值：<em>cs_python/py3ref/lexical_analysis</em></li>
<li>内置构造器<code>str()</code></li>
</ul>
</li>
</ul>
<h4 id="相关操作-2"><a href="#相关操作-2" class="headerlink" title="相关操作"></a>相关操作</h4><blockquote>
<ul>
<li>参见<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#string-methods">https://docs.python.org/zh-cn/3/library/stdtypes.html#string-methods</a></li>
</ul>
</blockquote>
<ul>
<li><code>ord()</code>：转换单个字符字符串为（整形）码位</li>
<li><code>chr()</code>：转换（整形）码位为单个字符字符串</li>
</ul>
<h5 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h5><ul>
<li><code>str.isalnum()</code></li>
<li><code>str.isalpha()</code></li>
<li><code>str.isascii()</code></li>
<li><code>str.isdecimal()</code></li>
<li><code>str.isdigit()</code></li>
<li><code>str.isidentifier()</code></li>
<li><code>str.islower()</code></li>
<li><code>str.isnumeric()</code></li>
<li><code>str.isprintable()</code></li>
<li><code>str.isspace()</code></li>
<li><code>str.istitle()</code></li>
<li><code>str.isupper()</code></li>
</ul>
<h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><ul>
<li><code>str.rfind(sub[, start[, end]])</code></li>
<li><code>str.rindex(sub[, start[, end]])</code></li>
<li><code>str.startswith(prefix[, start[, end]])</code></li>
<li><code>str.endwith(suffix[, start[, end]])</code></li>
<li><code>str.count(sub[, start[, end]])</code>：子串出现次数</li>
<li><code>str.find(sub[, start[, end]])</code><ul>
<li>仅检查<code>sub</code>是否为子串，应使用<code>in</code></li>
<li>找不到子串时返回<code>-1</code></li>
</ul>
</li>
<li><code>str.index(sub[, start[, end]])</code><ul>
<li>类似<code>str.find</code>，但找不到子串时<code>raise ValueError</code></li>
</ul>
</li>
</ul>
<h5 id="分隔"><a href="#分隔" class="headerlink" title="分隔"></a>分隔</h5><ul>
<li><code>str.partition(sep)</code></li>
<li><code>str.rpartition(sep)</code></li>
<li><code>str.rsplit(sep=None, maxsplit=-11)</code></li>
<li><code>str.split(sep=None, maxsplit=-1)</code></li>
<li><code>str.splitline([keepends])</code></li>
</ul>
<h5 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h5><ul>
<li><code>str.join(iterable)</code></li>
<li><code>str.strip([chars])</code></li>
<li><code>str.lstrip([chars])</code></li>
<li><code>str.rstrip([chars])</code></li>
<li><code>str.rstrip([chars])</code></li>
</ul>
<h5 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h5><ul>
<li><code>str.lower()</code></li>
<li><code>str.upper()</code></li>
<li><code>str.swapcase()</code></li>
<li><code>str.translate(table)</code></li>
<li><code>str.replace(old, new[, count])</code></li>
<li><code>static str.maketrans(x[, y[, z]])</code></li>
<li><code>str.encode(encoding=&quot;utf-8&quot;, errors=&quot;strict&quot;)</code>：使用
指定编码方案编码为<code>bytes</code></li>
<li><code>str.expandtabs(tabsize=8)</code></li>
<li><code>str.capitalize()</code>：首字符大写副本</li>
<li><code>str.casefold()</code>：消除大小写副本</li>
<li><code>str.center(width[, fillchar])</code>：字符串位于中间的字符串</li>
<li><code>str.title()</code></li>
</ul>
<h5 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h5><ul>
<li><code>str.ljust(width[, fillchar])</code></li>
<li><code>str.rjust(width[, fillchar])</code></li>
<li><code>str.zfill(width)</code></li>
<li><code>str.format(*args, **kwargs)</code></li>
<li><code>str.format_map(mapping)</code><ul>
<li>类似<code>str.format(**mapping)</code>，但<code>mapping</code>不会被复制
到<code>dict</code>中<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Default</span>(<span class="params"><span class="built_in">dict</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__missing__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">		<span class="keyword">return</span> key</span><br><span class="line"><span class="string">&quot;&#123;name&#125; was born in &#123;country&#125;&quot;</span>.format_map(Default(name=<span class="string">&quot;Guido&quot;</span>))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h5 id="printf风格字符串格式化"><a href="#printf风格字符串格式化" class="headerlink" title="printf风格字符串格式化"></a><em>printf</em>风格字符串格式化</h5><ul>
<li><p><code>format % values</code>中：<code>format</code>中<code>%</code>转换标记符将被转换
为<code>values</code>中条目</p>
<ul>
<li>效果类似于<code>sprintf</code></li>
<li><code>values</code>为与<code>format</code>中指定转换符数量等长元组、或映射
对象，除非<code>format</code>要求单个参数</li>
</ul>
</li>
<li><p>转换标记符按以下顺序构成</p>
<ul>
<li><code>%</code>字符：标记转换符起始</li>
<li>映射键：可选，圆括号<code>()</code>括起字符序列<ul>
<li><code>values</code>为映射时，映射键必须</li>
</ul>
</li>
<li>转换旗标：可选，影响某些类型转换效果<ul>
<li><code>#</code>：值转换使用“替代形式”</li>
<li><code>0</code>：为数字值填充<code>0</code>字符</li>
<li><code>-</code>：转换值左对齐（覆盖<code>0</code>）</li>
<li><code> </code>：符号位转换产生整数（空字符串）将留出空格</li>
<li><code>+</code>：符号字符显示在开头（覆盖<code> </code>）</li>
</ul>
</li>
<li>最小字段宽度：可选<ul>
<li><code>*</code>：从<code>values</code>读取下个元素</li>
</ul>
</li>
<li>精度：可选，<code>.</code>之后加精度值<ul>
<li><code>*</code>：从<code>values</code>读取下个元素</li>
</ul>
</li>
<li>长度修饰符：可选</li>
<li>转换类型<ul>
<li><code>d</code>/<code>u</code>/<code>i</code>：十进制整形</li>
<li><code>o</code>：8进制整形<ul>
<li><code>#</code>替代形式，前端添加<code>0o</code></li>
</ul>
</li>
<li><code>x</code>/<code>X</code>：小/大写16进制整形<ul>
<li><code>#</code>替代形式，前端添加<code>0x/0X</code></li>
</ul>
</li>
<li><code>e</code>/<code>E</code>：小/大写浮点指数<ul>
<li><code>#</code>替代形式，总是包含小数点</li>
</ul>
</li>
<li><code>f</code>/`F：浮点10进制<ul>
<li><code>#</code>替代形式，总是包含小数点</li>
</ul>
</li>
<li><code>g</code>/<code>G</code>：指数小于-4、不小于精度使用指数格式<ul>
<li><code>#</code>替代形式，总是包含小数点，末尾<code>0</code>不移除</li>
</ul>
</li>
<li><code>c</code>：单个字符（接收整数、单个字符字符串）</li>
<li><code>r</code>/<code>s</code>/<code>a</code>：字符串（<code>repr</code>/<code>str</code>/<code>ascii</code>转换）<ul>
<li>按输出精度截断</li>
</ul>
</li>
<li><code>%</code>：输出<code>%</code>字符</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h4><ul>
<li>快速字符串拼接<ul>
<li>构建包含字符串的列表，利用<code>str.join()</code>方法</li>
<li>写入<code>io.StringIO</code>实例，结束时获取值</li>
</ul>
</li>
</ul>
<h3 id="bytes-bytearray"><a href="#bytes-bytearray" class="headerlink" title="bytes/bytearray"></a><code>bytes</code>/<code>bytearray</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bytes</span>(<span class="params">[source[, encoding[, errors]]]</span>)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>字节串：单个字节构成的不可变序列</li>
<li>字节数组：字节串可变对应版本，其他同不可变<code>bytes</code></li>
</ul>
</blockquote>
<ul>
<li><p>字节串构建</p>
<ul>
<li>字节串字面值：<em>cs_python/py3ref/lexical_analysis</em></li>
<li>内置构造器<code>bytes()</code><ul>
<li>指定长度零值填充：<code>bytes(10)</code></li>
<li>整数组成可迭代对象：<code>bytes(range(20))</code></li>
<li>通过缓冲区协议复制现有二进制数据：<code>bytes(obj)</code></li>
</ul>
</li>
</ul>
</li>
<li><p>字节数组构建</p>
<ul>
<li>字节数组没有字面值语法，只能通过构造器构造</li>
<li>可变，构建空字节数组有意义</li>
</ul>
</li>
<li><p>类似整数构成序列</p>
<ul>
<li>每个条目都是8位字节</li>
<li>取值范围<code>0~255</code>，但只允许ASCII字符<em>0~127</em></li>
<li><code>b[0]</code>产生整数，切片返回<code>bytes</code>对象</li>
<li>可通过<code>list(bytes)</code>将<code>bytes</code>对象转换为整数构成列表</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>由<code>memeoryview</code>提供支持</li>
</ul>
</blockquote>
<h4 id="相关函数、方法"><a href="#相关函数、方法" class="headerlink" title="相关函数、方法"></a>相关函数、方法</h4><ul>
<li><code>bytes.decode</code>：解码为相关字符串</li>
<li><code>classmethod bytes.fromhex(string)</code></li>
<li><code>bytes.hex()</code></li>
</ul>
<blockquote>
<ul>
<li>其他类似字符串，包括<em>printf</em>风格格式化</li>
<li>参见<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes-and-bytearray-operations">https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes-and-bytearray-operations</a></li>
</ul>
</blockquote>
<h4 id="技巧-1"><a href="#技巧-1" class="headerlink" title="技巧"></a>技巧</h4><ul>
<li>快速字节串拼接<ul>
<li>构建包含字节串的列表，利用<code>bytes.join()</code>方法</li>
<li>写入<code>io.BytesIO</code>实例，结束时获取值</li>
<li>使用<code>betaarray</code>对象进行原地拼接</li>
</ul>
</li>
</ul>
<h3 id="memoryview"><a href="#memoryview" class="headerlink" title="memoryview"></a><code>memoryview</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">memoryview</span>(<span class="params">obj</span>)</span></span><br></pre></td></tr></table></figure>
<p>内存视图：允许python代码访问对象内部数据</p>
<ul>
<li><p>若对象支持缓冲区协议，则无需拷贝</p>
<ul>
<li>支持缓冲区协议的内置对象包括<code>bytes</code>、<code>bytesarray</code></li>
</ul>
</li>
<li><p>内存视图元素：原始对象<code>obj</code>处理的基本内存单元</p>
<ul>
<li>对简单<code>bytes</code>、<code>bytesarray</code>对象，一个元素就是一字节</li>
<li><code>array.array</code>等类型可能有更大元素</li>
</ul>
</li>
<li><p>内存视图支持索引抽取、切片</p>
<ul>
<li>若下层对象可选，则支持赋值，但切片赋值不允许改变大小</li>
</ul>
</li>
</ul>
<h4 id="相关操作-3"><a href="#相关操作-3" class="headerlink" title="相关操作"></a>相关操作</h4><blockquote>
<ul>
<li>参见<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#memory-views">https://docs.python.org/zh-cn/3/library/stdtypes.html#memory-views</a></li>
</ul>
</blockquote>
<ul>
<li><code>mv.__eq__(exporter)</code></li>
<li><code>mv.__len__()</code></li>
<li><code>mv.tobyte()</code></li>
<li><code>mv.hex()</code></li>
<li><code>mv.tolist()</code></li>
<li><code>mv.release()</code></li>
<li><code>mv.cast(format[, shape])</code>：将内存视图转换新格式形状</li>
</ul>
<h4 id="可用属性"><a href="#可用属性" class="headerlink" title="可用属性"></a>可用属性</h4><p>以下属性均只读</p>
<ul>
<li><code>mv.obj</code>：内存视图的下层对象</li>
<li><code>mv.nbytes</code><ul>
<li><code>== product(shape) * itemsize = len(mv.tobytes())</code></li>
</ul>
</li>
<li><code>mv.readonly</code></li>
<li><code>mv.format</code>：内存视图中元素格式<ul>
<li>表示为<code>struct</code>模块格式</li>
</ul>
</li>
<li><code>mv.itemsize</code></li>
<li><code>mv.ndim</code></li>
<li><code>mv.shape</code></li>
<li><code>mv.strides</code></li>
<li><code>mv.suboffsets</code></li>
<li><code>mv.c_contiguous</code></li>
<li><code>mv.f_contiguous</code></li>
<li><code>mv.contiguous</code></li>
</ul>
<h3 id="Slices-Object"><a href="#Slices-Object" class="headerlink" title="Slices Object"></a><em>Slices Object</em></h3><p>切片对象：表示<code>__getitem__()</code>方法得到的切片</p>
<ul>
<li>可以使用内置的<code>slice()</code>函数创建</li>
<li><code>a[start: stop]</code>形式的调用被转换为
<code>a[slice(start, stop, None)]</code></li>
</ul>
<blockquote>
<ul>
<li>切片对象是内部类型，参见<em>cs_python/py3ref/dm_exec</em>，也
  不是序列类型</li>
</ul>
</blockquote>
<h4 id="特殊只读属性"><a href="#特殊只读属性" class="headerlink" title="特殊只读属性"></a>特殊只读属性</h4><ul>
<li><code>start</code>：下界</li>
<li><code>stop</code>：上界</li>
<li><code>step</code>：步长值</li>
</ul>
<blockquote>
<ul>
<li>属性可以具有任意类型</li>
</ul>
</blockquote>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li><code>.indices(self, length)</code>：计算切片对象被应用到<code>length</code>
长度序列时切片相关信息<ul>
<li>返回值：<code>(start, stop, step)</code>三元组</li>
<li>索引号缺失、越界按照正规连续切片方式处理</li>
</ul>
</li>
</ul>
<h3 id="range"><a href="#range" class="headerlink" title="range"></a><code>range</code></h3><p><code>range</code>：不可变数字序列类型（非不是基本序列类型）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">range</span>(<span class="params">stop</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">range</span>(<span class="params">start=<span class="number">0</span>, stop[, step=<span class="number">1</span>]</span>)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数：必须均为整数（<code>int</code>或实现<code>__index__</code>方法）</p>
<ul>
<li><code>step &gt; 0</code>：对range对象<code>r[i]=start + step * i</code>，其中
<code>i &gt;= 0, r[i] &lt; stop</code></li>
<li><code>step &lt; 0</code>：对range对象<code>r[i]=start + step * i</code>，其中
<code>i &gt;= 0, r[i] &gt; stop</code></li>
<li><code>step = 0</code>：<code>raise ValueError</code></li>
</ul>
</li>
<li><p>说明</p>
<ul>
<li>允许元素绝对值大于<code>sys.maxsize</code>，但是某些特性如：
<code>len()</code>可能<code>raise OverflowError</code></li>
<li><code>range</code>类型根据需要计算单项、切片值<ul>
<li>相较于常规<code>list</code>、<code>tuple</code>占用内存较小，且和表示
范围大小无关</li>
<li>只能表示符合严格模式的序列</li>
</ul>
</li>
<li><code>range</code>类型实现了<code>collections.abc.Sequence</code>抽象类<ul>
<li>基本实现序列所有操作：检测、索引查找、切片等</li>
<li>除拼接、重复：拼接、重复通常会违反严格模式</li>
</ul>
</li>
<li><code>!=</code>、<code>==</code>将<code>range</code>对象视为序列比较，即提供相同值即
认为相等</li>
</ul>
</li>
</ul>
<h2 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h2><ul>
<li><p>表示<strong>不重复</strong>、<strong>不可变</strong>对象组成的无序、有限集合</p>
<ul>
<li>不能通过下标索引</li>
<li>可以迭代</li>
<li>可以通过内置函数<code>len</code>返回集合中条目数量</li>
</ul>
</li>
<li><p>常用于</p>
<ul>
<li>快速成员检测、去除序列中重复项</li>
<li>进行交、并、差、对称差等数学运算</li>
</ul>
</li>
</ul>
<h3 id="公用操作"><a href="#公用操作" class="headerlink" title="公用操作"></a>公用操作</h3><blockquote>
<ul>
<li>参见<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#set-types-set-frozenset">https://docs.python.org/zh-cn/3/library/stdtypes.html#set-types-set-frozenset</a></li>
</ul>
</blockquote>
<ul>
<li><code>len(s)</code></li>
<li><code>x [not ]in s</code></li>
<li><code>s.isdisjoint(other)</code></li>
<li><code>s.issubset(other)</code>/<code>s &lt;= other</code></li>
<li><code>s &lt; other</code></li>
<li><code>s.issuperset(other)</code>/<code>s &gt;= other</code></li>
<li><code>s &gt; other</code></li>
<li><code>s.union(*others)</code>/<code>s | other |...</code></li>
<li><code>s.intersection(*others)</code>/<code>s &amp; other &amp;...</code></li>
<li><code>s.difference(*other)</code>/<code>s - other - other</code></li>
<li><code>s.symmetric_difference(other)</code>/<code>s ^ other</code></li>
<li><code>s.copy()</code></li>
</ul>
<blockquote>
<ul>
<li>集合比较仅定义偏序，集合列表排序无意义</li>
</ul>
</blockquote>
<h4 id="可变集合独有"><a href="#可变集合独有" class="headerlink" title="可变集合独有"></a>可变集合独有</h4><ul>
<li><code>s.update(*others)</code>/<code>s |= other |...</code></li>
<li><code>s.intersection_update(*others)</code>/<code>s &amp;= other &amp;...</code></li>
<li><code>s.difference_udpate(*others)</code>/<code>s -= other |...</code></li>
<li><code>s.symmetric_difference_update(other)</code>/<code>set ^= other</code></li>
<li><code>s.add(elem)</code></li>
<li><code>s.remove(elem)</code></li>
<li><code>s.discard(elem)</code></li>
<li><code>s.pop()</code></li>
<li><code>s.clear()</code></li>
</ul>
<h3 id="set-frozenset"><a href="#set-frozenset" class="headerlink" title="set/frozenset"></a><code>set</code>/<code>frozenset</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">set</span>(<span class="params">[iterable]</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">frozenset</span>(<span class="params">[iterable]</span>)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>集合：由具有唯一性的<em>hashable</em>对象组成的多项无序集</li>
<li>冻结集合：不可变集合，可哈希，可以用作集合元素、字典键</li>
</ul>
</blockquote>
<ul>
<li><p>创建集合</p>
<ul>
<li><code>set()</code>内置构造器</li>
<li>花括号包括、逗号分隔元组列表：<code>&#123;a, b&#125;</code></li>
</ul>
</li>
<li><p>创建冻结集合</p>
<ul>
<li><code>frozenset()</code>内置构造器</li>
</ul>
</li>
<li><p>python中集合类似<code>dict</code>通过hash实现</p>
<ul>
<li>集合元素须遵循同字典键的不可变规则</li>
<li>数字：相等的数字<code>1==1.0</code>，同一集合中只能包含一个</li>
</ul>
</li>
</ul>
<h4 id="操作说明"><a href="#操作说明" class="headerlink" title="操作说明"></a>操作说明</h4><ul>
<li><p><code>.remove</code>、<code>.__contains__</code>、<code>discard</code>等可以接收<code>set</code>类型
参数，其将被转换为临时<code>frozenset</code>对象</p>
</li>
<li><p>非运算符版本操作可以接受任意可迭代对象作为参数，运算符
版本只能接受集合类型作为参数</p>
</li>
</ul>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>映射：表示任何索引集合所索引的对象的集合</p>
<ul>
<li>通过下标<code>a[k]</code>可在映射<code>a</code>中选择索引为<code>k</code>的条目<ul>
<li>可在表达式中使用</li>
<li>可以作为赋值语句、<code>del</code>语句的目标</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><code>dbm.ndbm</code>、<code>dbm.gnu</code>、<code>collections</code>模块提供额外映射类型</li>
</ul>
</blockquote>
<h3 id="通用操作"><a href="#通用操作" class="headerlink" title="通用操作"></a>通用操作</h3><blockquote>
<ul>
<li>参见<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#mapping-types-dict">https://docs.python.org/zh-cn/3/library/stdtypes.html#mapping-types-dict</a></li>
</ul>
</blockquote>
<ul>
<li><code>len(d)</code></li>
<li><code>d[key]</code></li>
<li><code>key [not ]in d</code></li>
<li><code>iter(d)</code></li>
<li><code>d.keys()</code>：返回字典视图对象</li>
<li><code>d.values()</code>：返回字典视图对象</li>
<li><code>d.items()</code>：返回字典视图对象</li>
<li><code>d.get(key[, default])</code></li>
<li><code>d.copy()</code></li>
<li><code>classmethod fromkey(iterable[, value])</code></li>
</ul>
<h4 id="可变映射独有"><a href="#可变映射独有" class="headerlink" title="可变映射独有"></a>可变映射独有</h4><ul>
<li><code>d[key]=value</code></li>
<li><code>del d[key]</code></li>
<li><code>d.clear()</code></li>
<li><code>d.setdefault(key[, default])</code></li>
<li><code>d.pop()</code></li>
<li><code>d.popitem()</code></li>
<li><code>d.copy()</code></li>
<li><code>d.update()</code></li>
</ul>
<h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a><code>dict</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dict</span>(<span class="params">**kwargs</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">dict</span>(<span class="params">mapping, **kwargs</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">dict</span>(<span class="params">iterable, **kwargs</span>)</span></span><br></pre></td></tr></table></figure>
<p>字典：可由<strong>几乎任意值作为索引</strong>的有限个对象可变集合</p>
<ul>
<li><p>字典的高效实现要求使用键hash值以保持一致性</p>
<ul>
<li>不可作为键的值类型<ul>
<li>包含列表、字典的值</li>
<li>其他通过对象编号而不是值比较的可变对象</li>
</ul>
</li>
<li>数字：相等的数字<code>1==1.0</code>索引相同字典条目</li>
</ul>
</li>
<li><p>创建字典</p>
<ul>
<li>花括号括起、逗号分隔键值对：<code>&#123;key:value,&#125;</code></li>
<li>内置字典构造器：<code>dict()</code></li>
</ul>
</li>
</ul>
<h4 id="字典视图对象"><a href="#字典视图对象" class="headerlink" title="字典视图对象"></a>字典视图对象</h4><p>字典视图对象：提供字典条目的<strong>动态视图</strong>，随字典改变而改变</p>
<ul>
<li><code>len(dictview)</code></li>
<li><code>iter(dictview)</code></li>
<li><code>x in dictview</code></li>
</ul>
<blockquote>
<ul>
<li>参见<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#dictionary-view-objects">https://docs.python.org/zh-cn/3/library/stdtypes.html#dictionary-view-objects</a></li>
</ul>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-06-04T15:11:44.000Z" title="6/4/2019, 11:11:44 PM">2019-06-04</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-06-04T15:11:44.000Z" title="6/4/2019, 11:11:44 PM">2019-06-04</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Data-Structure/">Data Structure</a></span><span class="level-item">20 minutes read (About 3057 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Data-Structure/hash_table.html">Hashing</a></h1><div class="content"><h2 id="Hashing-Table"><a href="#Hashing-Table" class="headerlink" title="Hashing Table"></a><em>Hashing Table</em></h2><blockquote>
<ul>
<li>哈希表/散列表：可根据哈希值<strong>直接访问</strong>的数据结构</li>
</ul>
</blockquote>
<ul>
<li><p>原理：以哈希值做为地址，缩小搜索空间、提高查找效率</p>
<ul>
<li>使用哈希函数为每个键计算哈希值，得到位于
$0, \cdots, m-1$之间整数</li>
<li>按照哈希值把键分布在$H[0, \cdots, m-1]$哈希表中</li>
<li>查找匹配键时，以查找键<strong>哈希值作为起点</strong>在哈希表中
搜索</li>
</ul>
</li>
<li><p>应选择合适的哈希函数、哈希表长度，尽量把键尽量均分在
哈希表中</p>
<ul>
<li>哈希函数$hash$：参见<em>math_algebra/#todo</em><ul>
<li>对闭散列：减少冲突</li>
<li>对开散列：避免数据集中</li>
</ul>
</li>
<li>散列表长度$m$：常为质数（方便双散列）</li>
</ul>
</li>
</ul>
<h3 id="Load-Factor"><a href="#Load-Factor" class="headerlink" title="Load Factor"></a><em>Load Factor</em></h3><p>负载因子：$\alpha = \frac {noempty} {m}$</p>
<blockquote>
<ul>
<li>$m$：哈希表中slots数量（长度）（哈希桶数量）</li>
<li>$noempty$：非空数量</li>
</ul>
</blockquote>
<ul>
<li><p>闭散列：负载因子反映哈希表冲突可能性、查找效率</p>
<ul>
<li>负载因子过小：冲突可能性小，查找效率高，但浪费空间</li>
<li>负载因子过大：冲突可能性大，查找效率低，空间利用率高</li>
<li>负载因子取值最大为1</li>
<li>应适当平衡负载因子，负载因子接近1时重散列，避免冲突
过多影响查找效率</li>
</ul>
<blockquote>
<ul>
<li>Java中<code>HashMap</code>初始负载值为0.75</li>
</ul>
</blockquote>
</li>
<li><p>开散列：负载因子反映查找效率</p>
<ul>
<li>但应该无法反映冲突可能性（也无必要）<ul>
<li>开散列往往被用于应对大规模数据，冲突总是存在</li>
<li>查找效率更多取决于数据（哈希值）偏倚程度</li>
</ul>
</li>
<li>负载因子可以大于1</li>
</ul>
</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li>字典/映射实现：<em>cs_algorithm/data_structure/set</em></li>
</ul>
<h2 id="Open-Addressing"><a href="#Open-Addressing" class="headerlink" title="Open Addressing"></a><em>Open Addressing</em></h2><p>闭散列/开放寻址：所有键存储在散列表本身中，不扩展存储空间</p>
<ul>
<li><p>哈希表$m$至少要和哈希键数量$n$一样大</p>
</li>
<li><p>冲突问题解决：根据一定规则计算下个地址</p>
</li>
<li><p><em>cluster</em>：聚合，散列表接近满时，一序列连续单元格被占据</p>
<ul>
<li>线性探查性能恶化，操作效率降低</li>
<li>聚合越来的越大时，新元素插入聚类可能性增加</li>
<li>聚合可能被新插入元素连接，导致更大程度聚合</li>
</ul>
</li>
</ul>
<h3 id="增量类型"><a href="#增量类型" class="headerlink" title="增量类型"></a>增量类型</h3><p>增量类型：碰撞发生后，根据一定规则对原哈希值修正</p>
<script type="math/tex; mode=display">
H_i = (hash(key) + d_i) mod m, i=1,2,\cdots</script><blockquote>
<ul>
<li>$d_i = i$：<em>linear probing</em>，线性探查</li>
<li>$d_i = i^2, -i^2$：<em>quadratic probing</em>，二次探查</li>
<li>$d_i = 伪随机数$：伪随机探查</li>
<li>$d_i = i <em> hash_2(K), i=0,1,2,\cdots$：</em>double hashing*
  ，再散列法</li>
</ul>
</blockquote>
<ul>
<li>再散列法说明：为保证哈希表中每个位置被探查，增量$s(K)$
必须互质<ul>
<li>$m$为质数时自动满足</li>
<li>文献推荐：$s(K) = m - 2 - K mod (m-2)$</li>
<li>对较小散列：$s(K) = 8 - (K mod 8)$</li>
<li>对较大散列：$s(K) = K mod 97 + 1$</li>
</ul>
</li>
</ul>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ul>
<li><p>插入：依次检查哈希值$h(K)$、探查目标序列，直至找到空
单元格放置键</p>
</li>
<li><p>查找：给定查找键K，计算哈希值$h(K)$、探查目标序列，比较
K和单元格中键值</p>
<ul>
<li>若查找到匹配键，查找成功</li>
<li>遇到空单元格，查找失败</li>
</ul>
</li>
<li><p>删除：<strong>延迟删除</strong>，用特殊符号标记曾经被占用过、现被删除
的位置</p>
<ul>
<li>不能直接删除，否则的中间出现空单元格，影响查找正确性</li>
</ul>
</li>
</ul>
<h4 id="算法效率"><a href="#算法效率" class="headerlink" title="算法效率"></a>算法效率</h4><ul>
<li><p>成功查找访问次数：
$S \approx \frac 1 2 (1+\frac 1 {(1-\alpha)})$</p>
</li>
<li><p>失败查找访问次数：
$U \approx \frac 1 2 [1+\frac 1 {(1-\alpha)^2}]$</p>
</li>
</ul>
<blockquote>
<ul>
<li>简化版本近似结论（散列规模越大，近似结论越正确）</li>
<li>无法避免散列表趋满时性能恶化</li>
<li>再哈希法数学分析困难，经验表明优秀的散列函数（两个），
  性能较线性探查好</li>
</ul>
</blockquote>
<h3 id="Multi-Hashing"><a href="#Multi-Hashing" class="headerlink" title="Multi Hashing"></a><em>Multi Hashing</em></h3><p>多重哈希：使用一组哈希函数$h_0,\cdots,h_n$依次计算哈希值，
确定插入、查找地址</p>
<ul>
<li>类似增量类型方法，仅各次地址独立使用哈希函数计算</li>
</ul>
<h3 id="增大空间"><a href="#增大空间" class="headerlink" title="增大空间"></a>增大空间</h3><h4 id="Rehashing"><a href="#Rehashing" class="headerlink" title="Rehashing"></a><em>Rehashing</em></h4><p>重散列：扫描当前表，将所有键重新放置在更大的表中</p>
<ul>
<li>散列表趋满时唯一解决办法</li>
</ul>
<h4 id="Overflow-Area"><a href="#Overflow-Area" class="headerlink" title="Overflow Area"></a><em>Overflow Area</em></h4><p>建立公共溢出区：将哈希表分为基本表、溢出表两部分</p>
<ul>
<li>将发生冲突的元素都放入溢出区</li>
<li>基本表中可以考虑为为每个哈希值设置多个slots<ul>
<li>即基本表直接存储哈希桶</li>
</ul>
</li>
</ul>
<p><img src="/imgs/hash_overflow_area.png" alt="hash_overflow_area"></p>
<h2 id="Chaining"><a href="#Chaining" class="headerlink" title="Chaining"></a><em>Chaining</em></h2><p>开散列/分离链：哈希表作为目录，使用额外数据空间组织哈希键</p>
<h3 id="拉链法-分桶法"><a href="#拉链法-分桶法" class="headerlink" title="拉链法/分桶法"></a>拉链法/分桶法</h3><p>拉链法/分桶法：哈希表作为目录项存储指向hash桶的指针，hash桶
中存储哈希键</p>
<ul>
<li><p>目录项表：顺序表，连续存储空间</p>
<ul>
<li>可以通过hash值在常数时间内定位：一般其索引位置就是
hash值</li>
<li>目录项越多，数据分布相对越稀疏、碰撞概率越小、效率
越高</li>
</ul>
</li>
<li><p>hash桶：存储具有相同哈希值元素的顺序表</p>
<ul>
<li>目录项存储chain为顺序表：每个链即为hash桶</li>
<li>目录项存储chain为顺序表链：链中每个顺序表为hash桶<ul>
<li>即每个目录项对应多个hash值，链接多个hash桶</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h4><ul>
<li>查找<ul>
<li>对查找键K，使用同样散列函数计算键散的函数值$h(K)$</li>
<li>遍历相应单元格附着链表，查找是否存在键K</li>
</ul>
</li>
<li>插入：计算键对应桶，在链表尾部添加键即可</li>
<li>删除：查找需要删除的键，从链表中移除即可</li>
</ul>
<h4 id="算法效率-1"><a href="#算法效率-1" class="headerlink" title="算法效率"></a>算法效率</h4><ul>
<li><p>效率取决于链表长度，而链表长度取决于字典、散列表长度
和散列函数质量</p>
<ul>
<li>成功查找需要检查指针次数$S = 1 + \alpha / 2$</li>
<li>不成功查找需要检查指针次数$U = \alpha$</li>
<li>计算散列函数值是常数时间操作</li>
<li>若n和m大致相等，平均情况下$\in \Theta(1)$</li>
</ul>
</li>
<li><p>算法查找的高效是以额外空间为代价的</p>
</li>
</ul>
<h3 id="Perfect-Hashing"><a href="#Perfect-Hashing" class="headerlink" title="Perfect Hashing"></a><em>Perfect Hashing</em></h3><p>完美哈希：采用两级全域哈希，目录项链接独立哈希表的拉链哈希表</p>
<p><img src="/imgs/hash_perfect_structure.png" alt="hash_perfect_structure"></p>
<ul>
<li><p>二级哈希表开头部分存储哈希表元信息</p>
<ul>
<li>$m = n^2$：哈希表槽数，$n$为映射至该槽元素数量
（此时由全域哈希性质：冲突次数期望小于0.5）</li>
<li>$a, b$：全域哈希参数</li>
</ul>
</li>
<li><p>复杂度</p>
<ul>
<li>时间复杂度：最坏情况下查找为$O(1)$</li>
<li>空间复杂度：期望空间为线性
$E(\sum_{i=1}^{m-1} \theta(n_i^2) = \theta(n)$</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>完美哈希没有冲突的概率至少为0.5</li>
<li>全域哈希参见<em>math_algebra/hash_funcs</em></li>
</ul>
</blockquote>
<h2 id="Dynamic-Hashing"><a href="#Dynamic-Hashing" class="headerlink" title="Dynamic Hashing"></a><em>Dynamic Hashing</em></h2><p>动态hash：在hash表中元素增加同时，动态调整hash桶数目</p>
<ul>
<li>在原hash表基础上进行动态桶扩展</li>
<li>不需要遍历表元素重复执行插入操作</li>
<li><strong>开散列法在大规模、在线数据的扩展</strong></li>
</ul>
<h3 id="多hash表"><a href="#多hash表" class="headerlink" title="多hash表"></a>多hash表</h3><p>多hash表：通过建立多个hash表的方式扩展原hash表</p>
<ul>
<li>思想、实现简单</li>
<li>占用空间大，数据分布偏斜程度较大时，桶利用率不高</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>操作时需要考虑多个hash表</p>
<ul>
<li><p>插入</p>
<ul>
<li>若存在hash相应桶中存在空闲区域，直接插入
<img src="/imgs/multi_hash_table_ori.png" alt="multi_hash_table_ori"></li>
<li>否则分裂，新建hash表，插入元素至空闲区域
<img src="/imgs/multi_hash_table_splited.png" alt="multi_hash_table_splited"></li>
</ul>
</li>
<li><p>查找：需要查找所有hash表相应桶才能确定</p>
<ul>
<li>当表中元素较多时，可以考虑并行执行查找操作</li>
</ul>
</li>
<li><p>删除操作：若删除元素导致某hash表空，可考虑删除该表</p>
</li>
</ul>
<h3 id="可扩展动态hash"><a href="#可扩展动态hash" class="headerlink" title="可扩展动态hash"></a>可扩展动态hash</h3><p>可扩展动态hash：只分裂将要溢出的桶，<strong>使用目录项作为索引</strong></p>
<ul>
<li>多个目录项可能指向同一个桶</li>
<li>分裂时代价较小<ul>
<li>翻倍目录项替代翻倍整个hash表</li>
<li>每次只分裂将要溢出桶</li>
<li>只需要进行局部重散列，重分布需要分裂的桶</li>
</ul>
</li>
<li>目录指数级增长<ul>
<li>数据分布不均时，会使得目录项很大</li>
</ul>
</li>
</ul>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><blockquote>
<ul>
<li><code>D</code>：全局位深度，hash值截断长度，为局部桶深度最大值</li>
<li><code>L_i</code>：桶局部深度，等于指向其目录项数目</li>
</ul>
</blockquote>
<ul>
<li><p>若对应桶存在空闲位，则直接插入</p>
<p><img src="/imgs/dynamic_scalable_hash_table_ori.png" alt="dynamic_scalable_hash_table_ori"></p>
</li>
<li><p>否则分裂桶：分裂后两桶局部深度加1</p>
<p><img src="/imgs/dynamic_scalable_hash_table_splited.png" alt="dynamic_scalable_hash_table_splited"></p>
<ul>
<li><p>若分裂桶局部深度不大于全局位深度</p>
<ul>
<li>创建新桶</li>
<li>重散列原始桶中数据</li>
<li>更新目录项中对应指针：分别指向分裂后桶</li>
</ul>
</li>
<li><p>若分类桶局部深度大于全局位深度</p>
<ul>
<li>更新全局位深度</li>
<li>目录项翻倍</li>
<li>创建新桶</li>
<li>重散列原始桶中数据</li>
<li>更新目录项中对应指针<ul>
<li>（新增）无关目录项仍然指向对应桶</li>
<li>相关目录项指向分别指向分裂后桶</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><ul>
<li>计算原始hash值</li>
<li>按照全局位深度截断</li>
<li>寻找相应目录项，找到对应桶，在桶中进行比较、查找</li>
</ul>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ul>
<li>计算原始hash值</li>
<li>按照全局位深度截断</li>
<li>寻找相应目录项，找到对应桶，在桶中进行比较、删除<ul>
<li>若删除后发现桶为空，考虑与其兄弟桶合并，并使局部深度
减1</li>
</ul>
</li>
</ul>
<h3 id="线性散列"><a href="#线性散列" class="headerlink" title="线性散列"></a>线性散列</h3><p>线性散列：按次序分裂桶，<strong>保证整个建表过程类似完全二叉树</strong></p>
<ul>
<li><p>整个哈希表建表过程<strong>始终保持为完全二叉树</strong></p>
<ul>
<li>每次分裂的桶是完全二叉树编号最小的叶子节点</li>
<li>分裂前后桶间均为有序</li>
</ul>
</li>
<li><p>相较于可扩展散列</p>
<ul>
<li>无需存放数据桶指针的专门目录项，节省空间</li>
<li>能更自然的处理数据桶满的情况</li>
<li>允许更灵活的选择桶分裂时机</li>
<li>但若数据散列后分布不均，则问题可能比可扩散散列严重</li>
</ul>
</li>
<li><p>实现相较而言更复杂</p>
</li>
</ul>
<h4 id="桶分裂"><a href="#桶分裂" class="headerlink" title="桶分裂"></a>桶分裂</h4><blockquote>
<ul>
<li><code>N</code>：hash表中初始桶数目，应为2的幂次</li>
<li><code>d = log_2N</code>：表示桶数目需要位数</li>
<li><code>level</code>：分裂轮数，初始值为0，则每轮初始桶数为
  $N * 2^{level}$</li>
<li><code>Next</code>：下次要发生分裂的桶编号</li>
</ul>
</blockquote>
<p><img src="/imgs/linear_hash_ori.png" alt="linear_hash_ori"></p>
<ul>
<li><p>每次同分裂条件可以灵活选择</p>
<ul>
<li>设置桶填充因子，桶中记录数达到该值时进行分裂</li>
<li>桶满时发生分裂</li>
</ul>
</li>
<li><p>每次发生的分裂的桶总是由<code>Next</code>决定
<img src="/imgs/linear_hash_splited_bucket.png" alt="linear_hash_splited_bucket"></p>
<ul>
<li>与当前被插入的桶溢出无关，可引入溢出页处理桶溢出</li>
<li>每次只分裂<code>Next</code>指向的桶，桶分裂后<code>Next += 1</code></li>
<li>后续产生映像桶总是位于上次产生映像桶之后</li>
</ul>
</li>
<li><p>“轮转分裂进化”：各桶轮流进行分裂，一轮分裂完成后进入下轮
分裂
<img src="/imgs/linear_hash_splited_level.png" alt="linear_hash_splited_level"></p>
</li>
</ul>
<h4 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h4><ul>
<li><p>根据<code>N</code>、<code>level</code>计算当前<code>d</code>值，截取原始hash值</p>
</li>
<li><p>若hash值位于<code>Next</code>、<code>N</code>之间，说明该轮对应桶还未分裂，
直接在桶中查找</p>
</li>
<li><p>若hash值小于<code>Next</code>，说明该轮对应桶已经分裂，hash值向前
多取一位，在对应桶中查找</p>
</li>
</ul>
<h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><blockquote>
<ul>
<li>删除操作是插入操作的逆操作</li>
</ul>
</blockquote>
<ul>
<li>若删除元素后溢出块为空，可直接释放</li>
<li>若删除元素后某个桶元素为空，<code>Next -= 1</code><ul>
<li>当<code>Next</code>减少到0，且最后桶也是空时，<code>Next = N/2 - 1</code>
，同时<code>level -= 1</code></li>
</ul>
</li>
</ul>
<p> 1`</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-06-04T15:11:44.000Z" title="6/4/2019, 11:11:44 PM">2019-06-04</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-06-04T15:11:44.000Z" title="6/4/2019, 11:11:44 PM">2019-06-04</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Data-Structure/">Data Structure</a></span><span class="level-item">5 minutes read (About 795 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Data-Structure/tree_derived.html">二叉树衍生</a></h1><div class="content"><h2 id="Huffman-Tree"><a href="#Huffman-Tree" class="headerlink" title="Huffman Tree"></a><em>Huffman Tree</em></h2><p>哈夫曼树/最优树：带权路径长度WPL最短的树</p>
<ul>
<li>哈夫曼树中没有度为1的结点，又称为严格的（正则的）二叉树</li>
</ul>
<blockquote>
<ul>
<li>树带权路径长度：树中所有叶子结点的带权路径长度之和
  $WPL = \sum_{k=1}^n w_k l_k$</li>
</ul>
</blockquote>
<h3 id="哈夫曼算法"><a href="#哈夫曼算法" class="headerlink" title="哈夫曼算法"></a>哈夫曼算法</h3><p>哈夫曼算法：构建最小加权路径二叉树</p>
<blockquote>
<ul>
<li>输入：给定的n个权值${w_1, w_2, \cdots, w_n}$</li>
</ul>
</blockquote>
<ul>
<li>初始化n个单节点二叉树集合$F={T_1, T_2, \cdots, T_n}$</li>
<li>合并权重最小的两棵树，将其权重之和作为新树权重记录于新树
根节点中</li>
<li>重复，直至生成单独一棵树</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>贪婪算法</li>
<li>Huffman算法构建的最优二叉树是只有叶子节点有权值，若所有
节点都有权值的<strong>最优二叉查找树</strong>，需要使用动态规划算法，
参见<em>cs_algorithm/data_structure/tree_search</em></li>
</ul>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><blockquote>
<ul>
<li>哈夫曼编码：编码总长度最短的二进制前缀编码</li>
<li>前缀编码：任意编码都不是其他编码的前缀，此时编码可以</li>
</ul>
</blockquote>
<ul>
<li><p>前缀编码可以使用二叉树设计，叶子结点代表字符，根节点到
叶子结点路径上分支代表的二进制串即为其二进制编码</p>
</li>
<li><p>对给定出现频率$P[1..n]$的字符集$C[1..n]$，生成哈夫曼树
即可得到哈夫曼编码</p>
</li>
</ul>
<h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HTNode</span>&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> weight;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">HTNode</span> *<span class="title">parent</span>, *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;HTNode, *HuffmanTree;</span><br></pre></td></tr></table></figure>
<h2 id="选拔树"><a href="#选拔树" class="headerlink" title="选拔树"></a>选拔树</h2><h3 id="优胜树"><a href="#优胜树" class="headerlink" title="优胜树"></a>优胜树</h3><p>优胜树：非叶结点取值是两个孩子中较小者的完全二叉树</p>
<p><img src="/imgs/tree_winner_structure.png" alt="tree_winner_structure"></p>
<ul>
<li>根据定义，根节点的取值是整个树的最小值</li>
<li><strong>从叶节点</strong>构建/重构优胜树的过程中<ul>
<li>每对兄弟结点捉对比赛，胜利者晋升为父亲结点</li>
<li>胜者逐级向上直到根节点为止</li>
<li>调整优胜树的时间效率$\in \Theta(logk)$</li>
</ul>
</li>
</ul>
<h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> SqBiTree SqVictTree;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>数组实现的二叉树可以通过完全二叉树性质迅速计算父节点、
  孩子节点位置</li>
</ul>
</blockquote>
<h3 id="淘汰树"><a href="#淘汰树" class="headerlink" title="淘汰树"></a>淘汰树</h3><p>淘汰树：非叶结点值是两个孩子结点中较大者，即指向失败者的
选拔树</p>
<p><img src="/imgs/tree_loser_structure.png" alt="tree_loser_structure"></p>
<ul>
<li>可以简化选拔树重构过程</li>
<li>需要额外结点记录/指向胜者</li>
</ul>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><h4 id="归并多路有序序列"><a href="#归并多路有序序列" class="headerlink" title="归并多路有序序列"></a>归并多路有序序列</h4><blockquote>
<ul>
<li>问题：k路有序（降序）序列，要将其归并为一组有序序列，
  归并过程每轮输出一个最小关键字记录
  （显然只能是当前k路序列中第一个记录）</li>
</ul>
</blockquote>
<ul>
<li><p>以k路序列首k个元素建立k个叶节点的选拔树</p>
</li>
<li><p>构建选拔树，输出最小元素值</p>
<p><img src="/imgs/tree_winner_structure.png" alt="tree_winner_structure"></p>
</li>
<li><p>用其所属序列下个元素替换其所在叶节点值，重构选拔</p>
<p><img src="/imgs/tree_winner_reconstruct.png" alt="tree_winner_reconstruct"></p>
</li>
<li><p>重复n轮：所有k轮归并总时间为$\in \Theta(nlogk)$</p>
</li>
</ul>
<p>)$</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-06-04T15:11:44.000Z" title="6/4/2019, 11:11:44 PM">2019-06-04</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-02T10:11:00.000Z" title="8/2/2021, 6:11:00 PM">2021-08-02</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Data-Structure/">Data Structure</a></span><span class="level-item">26 minutes read (About 3859 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Data-Structure/tree.html">Tree</a></h1><div class="content"><h2 id="树-amp-森林"><a href="#树-amp-森林" class="headerlink" title="树&amp;森林"></a>树&amp;森林</h2><h3 id="Free-tree"><a href="#Free-tree" class="headerlink" title="Free tree"></a><em>Free tree</em></h3><p>自由树：<strong>连通</strong>、<strong>无回路图</strong>，具有一些其他图不具有的重要
特性</p>
<ul>
<li><p>边数总比顶点数少一：$|E|=|V|-1$</p>
<ul>
<li>这个是图为一棵树的必要条件，但不充分</li>
<li>若图是连通的，则是充分条件</li>
</ul>
</li>
<li><p>任意两个顶点之间总是存在简单路径</p>
</li>
</ul>
<h3 id="Rooted-Tree"><a href="#Rooted-Tree" class="headerlink" title="(Rooted)Tree"></a><em>(Rooted)Tree</em></h3><p>（有根）树：存在根节点的自由树</p>
<script type="math/tex; mode=display">
Tree = (root, F)</script><blockquote>
<ul>
<li>$root$：根节点数据元素</li>
<li>$F=(T_1, T_2, \cdots, T_m)$：森林</li>
<li>$T_i=(r_i, F_i)$：根root的第i棵子树</li>
</ul>
</blockquote>
<ul>
<li><p>在任意一棵非空树中</p>
<ul>
<li>有且仅有一个特定称为根的节点</li>
<li>节点数n&gt;1时，其余节点可以分为m个<strong>互不相交</strong>的有限集
，每个集合本身又是一棵树，称为根的子树</li>
</ul>
</li>
<li><p>树中任何两个节点间<strong>总存在简单路径</strong>，所以可以任选自由树
中某节点，作为有根树的根</p>
</li>
<li><p>有根树远远比自由树重要，所以也简称为树</p>
<ul>
<li>根一般放在树的顶层，第0层</li>
<li>之后节点根据和根的距离放在相应层数</li>
</ul>
</li>
</ul>
<h3 id="Forest"><a href="#Forest" class="headerlink" title="Forest"></a><em>Forest</em></h3><p>森林：<strong>无回路</strong>但不一定连通的图</p>
<ul>
<li>其每个连通分量是一棵树</li>
<li>对树中每个节点，其子树集合即为森林</li>
</ul>
<h3 id="Ordered-Tree"><a href="#Ordered-Tree" class="headerlink" title="Ordered Tree"></a>Ordered Tree</h3><p>有序树：所有顶点的所有子女都是有序（不能交换次序）的有根树</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li><p>常用于描述层次关系</p>
<ul>
<li>文件目录</li>
<li>企业的组织结构</li>
<li>字典的实现</li>
<li>超大型的数据集合的高效存储</li>
<li>数据编码</li>
</ul>
</li>
<li><p>用于分析递归算法</p>
<ul>
<li><em>state-space tree</em>：状态空间树，强调了两种算法设计
技术：回溯、分支界限</li>
</ul>
</li>
</ul>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ul>
<li><em>ancestor</em>：从根到该顶点上的简单路径上的所有顶点</li>
<li><em>proper ancestor</em>：除自身外的所有祖先顶点</li>
<li><em>parent</em>：从根到顶点简单路径中，最后一条边的另一端节点</li>
<li><em>parental</em>：至少有一个子女的顶点</li>
<li><em>child</em>：</li>
<li><em>sibling</em>：具有相同父母的顶点</li>
<li><em>leaf</em>：没有子女的顶点</li>
<li><em>descendent</em>：所有以该顶点为祖先的顶点</li>
<li><em>proper descendent</em>：不包括顶点自身的子孙</li>
<li><em>subtree</em>：顶点的所有子孙、连接子孙的边构成以该顶点为根的
子树</li>
<li><em>depth</em>：根到该顶点的简单路径的长度</li>
<li><em>height</em>：根到叶节点的最长简单路径的长度</li>
</ul>
<h3 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><ul>
<li>链表结点代表树中一个顶点，其中至少包含：数据域、指向子女
的指针域</li>
<li>链表头指针指向二叉树根节点</li>
</ul>
<h4 id="双亲表存储"><a href="#双亲表存储" class="headerlink" title="双亲表存储"></a>双亲表存储</h4><p>双亲表示法</p>
<ul>
<li>利用除根节点外，每个结点只有一个双亲，给所有结点添加一个
指向双亲的指针域</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span>&#123;</span></span><br><span class="line">	TElemType data;</span><br><span class="line">	<span class="keyword">int</span> parent;</span><br><span class="line">&#125;PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">	<span class="keyword">int</span> r, n;</span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure>
<ul>
<li>求结点双亲时是常数时间</li>
<li>求结点孩子时需要遍历整个结构</li>
</ul>
<h4 id="孩子链表存储"><a href="#孩子链表存储" class="headerlink" title="孩子链表存储"></a>孩子链表存储</h4><p>孩子表示法</p>
<ul>
<li><p>把每个结点的孩子结点排列起来，视为线性表，以单链表作为
存储结构</p>
<ul>
<li><p>否则结点同构则浪费空间，不同构时操作不方便</p>
<p><img src="/imgs/tree_child_representation_node.png" alt="tree_child_representation_node"></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">	<span class="comment">// 逻辑意义的结点，存储兄弟关系</span></span><br><span class="line">	<span class="keyword">int</span> child;</span><br><span class="line">		<span class="comment">// 结点位置，`nodes`中序号</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span></span><br><span class="line">		<span class="comment">// 指示下个兄弟结点</span></span><br><span class="line">&#125;*ChildPtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="comment">// 实际存储信息的结点</span></span><br><span class="line">	TElemType data;</span><br><span class="line">	ChildPtr firstchild;</span><br><span class="line">		<span class="comment">// 孩子链表头指针</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">	<span class="keyword">int</span> n, r;</span><br><span class="line">		<span class="comment">// 节点数，根节点位置</span></span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/tree_child_representation.png" alt="tree_child_representation"></p>
<h4 id="二叉链表存储"><a href="#二叉链表存储" class="headerlink" title="二叉链表存储"></a>二叉链表存储</h4><p><em>First Child-next Silbling Representaion</em>：孩子兄弟/二叉链表
/二叉树表示法</p>
<blockquote>
<ul>
<li>每个节点只包含两个指针，左指针指向第一个子女，右指针指向
  节点的下一个兄弟</li>
<li>节点的所有兄弟通过节点右指针被单独的链表连接</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125;CSNode, *CSTree;</span><br></pre></td></tr></table></figure>
<ul>
<li>可高效的将有序树改造成一棵二叉树，称为<strong>关联二叉树</strong></li>
<li>易于实现某些操作<ul>
<li>寻找孩子结点</li>
</ul>
</li>
</ul>
<h3 id="森林与二叉树转换"><a href="#森林与二叉树转换" class="headerlink" title="森林与二叉树转换"></a>森林与二叉树转换</h3><ul>
<li><p>给定一棵树，可以以二叉链表为媒介导出树与二叉树之间的对应
关系，即可以找到唯一一棵二叉树和与之对应</p>
<ul>
<li>任何一棵树对应的二叉树，其右子树必然为空</li>
</ul>
</li>
<li><p>将森林中各棵树的根节点看作兄弟结点，则可以得到森林和
二叉树的对应关系</p>
</li>
</ul>
<h4 id="森林转换为二叉树"><a href="#森林转换为二叉树" class="headerlink" title="森林转换为二叉树"></a>森林转换为二叉树</h4><p>森林$F={T_1, T_2, \cdots, T_M}$转换为二叉树的
$B=(root, LB, RB)$</p>
<ul>
<li>若F为空，即m=0，则B为空树</li>
<li>若F非空<ul>
<li>root即为森林中第一个树的根$ROOT(T_1)$</li>
<li>LB是从$T_1$中根节点的子树森林转换而成的二叉树</li>
<li>RB是从森林$F^{‘}$转换而来的二叉树</li>
</ul>
</li>
</ul>
<h4 id="二叉树转换为森林"><a href="#二叉树转换为森林" class="headerlink" title="二叉树转换为森林"></a>二叉树转换为森林</h4><p>二叉树的$B=(root, LB, RB)$转换为森林
$F={T_1, T_2, \cdots, T_M}$</p>
<ul>
<li>若B为空，即m=0，则F为空树</li>
<li>若B非空<ul>
<li>F中第一棵树根$ROOT(T_1)$即为二叉树根root</li>
<li>$T_1$中根节点的子树森林$F_1$是由B的左子树LB转换来的
子树森林</li>
<li>F中除$T_1$外的其余树组成的森林$F^{‘}$是由B的右子树
RB转换而来的子树森林</li>
</ul>
</li>
</ul>
<h3 id="树、森林遍历"><a href="#树、森林遍历" class="headerlink" title="树、森林遍历"></a>树、森林遍历</h3><ul>
<li>以二叉链表作树、森林的存储结构式，树、森林的先（根）序
遍历、后（根）序遍历对应二叉树先序、后序遍历</li>
</ul>
<h2 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary Tree"></a>Binary Tree</h2><p>二叉树：所有顶点子女个数不超过2个，每个子女不是父母的
<em>left child</em>就是<em>right child</em>的有序树</p>
<ul>
<li>二叉树的根是另一棵二叉树顶点的左（右）子女</li>
<li>左右子树也是二叉树，所以二叉树可以递归定义</li>
<li>涉及二叉树的问题可以用递归算法解决</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>二叉树第i层之多有$2^{i-1}$个节点</li>
<li>深度为k的二叉树最多有$2^k-1$节点</li>
<li><p>对任何二叉树$T$，如果其终端节点数$n_0$，度为2的节点数为
$n_2$，则$n_0=n_2+1$</p>
<script type="math/tex; mode=display">\left. \begin{array}{r}
   考虑节点数：n = n_0 + n_1 + n_2 \\
   考虑分支数：n = n_1 + 2n_2 + 1
\end{array} \right \} \rightarrow
n_0 = n_2 + 1</script><blockquote>
<ul>
<li>$n, n_0, n_1, n_2$：总结点数、终端节点数、度1节点数
 、度2节点数</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>顺序存储结构：顺序存储<strong>完全二叉树</strong>结点元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> TElemType SqBiTree[MAX_TREE_SIZE];</span><br><span class="line">SqBiTree bt;</span><br></pre></td></tr></table></figure>
<ul>
<li>将完全二叉树编号为i的结点存储在一维数组中下标为i-1分量中</li>
<li>一般二叉树则将每个结点与完全二叉树结点相对照，存储在相应
分量中，并标记不存在的结点<ul>
<li>对某些二叉树空间利用效率极低</li>
<li>所以顺序存储结构只适合完全二叉树</li>
</ul>
</li>
</ul>
<h3 id="链式存储结构-1"><a href="#链式存储结构-1" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><ul>
<li>二叉树的链表节点中至少包含3个域：数据域、左右指针域</li>
<li>链表头指针指向二叉树根节点<ul>
<li>为方便，也可以添加一个头结点，其<code>lchild</code>指针域指向
根结点</li>
</ul>
</li>
</ul>
<h4 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">	TElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>
<ul>
<li>含有n个结点的二叉链表中有n+1个空链域</li>
</ul>
<h4 id="三叉链表"><a href="#三叉链表" class="headerlink" title="三叉链表"></a>三叉链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTriNode</span>&#123;</span></span><br><span class="line">	TElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTriNode</span> *<span class="title">parent</span>, *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTriNode, *BiTriTree;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>在二叉链表基础上增加指向双亲结点的指针域</li>
</ul>
</blockquote>
<h4 id="二叉线索链表"><a href="#二叉线索链表" class="headerlink" title="二叉线索链表"></a>二叉线索链表</h4><p><em>Threaded Binary Tree</em>：线索二叉树/线索化树</p>
<blockquote>
<ul>
<li>使用二叉链表中的n+1个空链域存放二叉树遍历的前驱、后继
  信息</li>
<li>附设标记域区分指针域存放子孙结点、前驱/后继</li>
</ul>
</blockquote>
<ul>
<li>适合经常需要遍历的二叉树、查找遍历所得线性序列中前驱、
后继<ul>
<li>时间复杂度常数系数小</li>
<li>无需设栈</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">PointerTag</span>&#123;</span>Link, Thread&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span>&#123;</span></span><br><span class="line">	TElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BitThrNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">	PointerTag LTag, RTag;</span><br><span class="line">&#125;BiThrNode, *BiThrTree;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>后序线索化树找后继时需要知道双亲，应该使用带标志域的
  三叉链表</li>
</ul>
</blockquote>
<h3 id="Complete-Binary-Tree"><a href="#Complete-Binary-Tree" class="headerlink" title="Complete Binary Tree"></a><em>Complete Binary Tree</em></h3><blockquote>
<ul>
<li><p>满二叉树：深度为k且有$2^k-1$节点的二叉树，每层上的节点数
  都是最大节点数</p>
</li>
<li><p>完全二叉树：<em>essentially complete</em>，树的每层都是满的，除
  最后一层最右边的元素（一个或多个）可能有缺位</p>
</li>
</ul>
</blockquote>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p><strong>只存在一棵</strong>n个节点完全二叉树，高度为
$\lfloor log_2 n \rfloor$</p>
<ul>
<li>深度为k、节点数为n的完全二叉树同深度为k的满二叉树中
1-n号节点一一对应</li>
<li>叶子节点只可能在层次最大的两层上出现</li>
<li>对任一节点，其左分支只能和右分支深度相同或大1</li>
</ul>
</li>
<li><p>从上到下、从左到右对结点编号，即使用数组H存储完全二叉树
（从1开始编号，数组H[0]不存储节点值，或存放限位器）</p>
<ul>
<li><p>父母节点键会位于数组前$\lfloor n/2 \rfloor$个位置中
，叶子节点位于后$\lceil n/2 \rceil$</p>
</li>
<li><p>对位于父母位置i的键，其子女位于2i、2i+1，相应的对于
子女位置i的键，父母位于$\lfloor i/2 \rfloor$</p>
</li>
</ul>
</li>
</ul>
<h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><ul>
<li>堆</li>
</ul>
<h3 id="二叉树高度"><a href="#二叉树高度" class="headerlink" title="二叉树高度"></a>二叉树高度</h3><blockquote>
<ul>
<li>将空树高度定义为-1</li>
</ul>
</blockquote>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Height(T):</span><br><span class="line">	<span class="comment">// 递归计算二叉树的高度</span></span><br><span class="line">	<span class="comment">// 输入：二叉树T</span></span><br><span class="line">	<span class="comment">// 输出：T的高度</span></span><br><span class="line">	<span class="keyword">if</span> T = null_set</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> max&#123;Height(T_left), Height(T_right)&#125; + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>检查树是否为空是这个算法中最频繁的操作</p>
</li>
<li><p>算法时间效率</p>
<ul>
<li><p>树的节点数为n，则根据加法操作次数满足递推式
$A(n(T))=A(n(T<em>{left})) + A(n(T</em>{right})) + 1$，
得到$A(n(T)) = n$</p>
</li>
<li><p>考虑为树中每个节点的<strong>空子树</strong>添加<strong>外部节点</strong>得到
扩展树，则外部节点数量x满足$x=n+1$</p>
</li>
<li><p>检查树是否为空次数即为扩展树节点数目
$C(n(T))=n+x=2x+1$</p>
</li>
</ul>
</li>
</ul>
<h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><ul>
<li><p>不是所有关于二叉树的算法都需要遍历两棵子树，如：查找、
插入、删除只需要遍历两颗子树中的一棵，所以这些操作属于
减可变规模（减治法）</p>
</li>
<li><p>先序、中序、后序遍历都需要用到栈</p>
</li>
<li><p>中序遍历得到的序列称为中序置换/中序序列，先序、后序类似</p>
</li>
</ul>
<h4 id="递归版本"><a href="#递归版本" class="headerlink" title="递归版本"></a>递归版本</h4><ul>
<li><p><em>Preorder Traversal</em>：先序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PreOrder(T):</span><br><span class="line">	visit(T)</span><br><span class="line">	<span class="keyword">if</span> T_left <span class="keyword">not</span> null:</span><br><span class="line">		PreOrder(T_left)</span><br><span class="line">	<span class="keyword">if</span> T_right <span class="keyword">not</span> null:</span><br><span class="line">		PreOrder(T_right)</span><br></pre></td></tr></table></figure>
</li>
<li><p><em>Inorder Traversal</em>：中序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InOrder(T):</span><br><span class="line">	<span class="keyword">if</span> T_left <span class="keyword">not</span> null:</span><br><span class="line">		InOrder(T_left)</span><br><span class="line">	visit(T)</span><br><span class="line">	<span class="keyword">if</span> T_right <span class="keyword">not</span> null:</span><br><span class="line">		InOrder(T_right)</span><br></pre></td></tr></table></figure>
</li>
<li><p><em>Postorder Traversal</em>：后序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PostOrder(T):</span><br><span class="line">	<span class="keyword">if</span> T_left <span class="keyword">not</span> null:</span><br><span class="line">		PostOrder(T_left)</span><br><span class="line">	visit(T)</span><br><span class="line">	<span class="keyword">if</span> T_right <span class="keyword">not</span> null:</span><br><span class="line">		PostOrder(T_right)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="栈非递归"><a href="#栈非递归" class="headerlink" title="栈非递归"></a>栈非递归</h4><ul>
<li><p>先序遍历</p>
<ul>
<li><p>深度优先入栈：左子树优先入栈</p>
<ul>
<li>节点先访问后入栈，栈内存已访问节点</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PreOrder(T):</span><br><span class="line">	s = InitStack()</span><br><span class="line">	cur = T</span><br><span class="line">	<span class="keyword">while</span> s.not_empty() <span class="keyword">or</span> cur:</span><br><span class="line">		<span class="keyword">while</span> cur:</span><br><span class="line">			visit(cur)</span><br><span class="line">			s.push_back(cur)</span><br><span class="line">			cur = cur.left</span><br><span class="line">		cur = s.pop()</span><br><span class="line">		cur = cur.right</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价写法，仅使用`if`利用外层循环</span></span><br><span class="line">PreOrder(T):</span><br><span class="line">	s = InitStack()</span><br><span class="line">	cur = T</span><br><span class="line">	<span class="keyword">while</span> s.not_empty() <span class="keyword">or</span> cur:</span><br><span class="line">		<span class="keyword">if</span> cur:</span><br><span class="line">			visit(cur)</span><br><span class="line">			s.push_back(cur)</span><br><span class="line">			cur = cur.left</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			cur = s.pop()</span><br><span class="line">			cur = cur.right</span><br></pre></td></tr></table></figure>
<ul>
<li>基于对遍历性质的考虑</li>
<li>扩展性较好，可以扩展到中序、后序遍历</li>
</ul>
</li>
<li><p>广度优先入栈：同层右、左节点先后入栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PreOrder(T):</span><br><span class="line">	s = InitStack()</span><br><span class="line">	s.push_back(T)</span><br><span class="line">	<span class="keyword">while</span> s.not_empty():</span><br><span class="line">		cur = s.pop()</span><br><span class="line">		<span class="keyword">if</span> cur.right:</span><br><span class="line">			s.push_back(cur.right)</span><br><span class="line">		<span class="keyword">if</span> cur.left:</span><br><span class="line">			s.push_back(cur.left)</span><br><span class="line">		visit(cur)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>中序遍历</p>
<ul>
<li><p>深度优先入栈</p>
<ul>
<li>节点先入栈后访问，栈内存未访问节点</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">InOrder(T):</span><br><span class="line">	s = InitStack()</span><br><span class="line">	cur = T</span><br><span class="line">	<span class="keyword">while</span> s.not_empty() <span class="keyword">or</span> cur:</span><br><span class="line">		<span class="keyword">while</span> cur:</span><br><span class="line">			s.push_back(cur)</span><br><span class="line">			cur = cur.left</span><br><span class="line">		cur = s.pop()</span><br><span class="line">		visit(cur)</span><br><span class="line">		cur = cur.right</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价写法，仅使用`if`利用外层循环</span></span><br><span class="line">InOrder(T):</span><br><span class="line">	s = InitStack()</span><br><span class="line">	cur = T</span><br><span class="line">	<span class="keyword">while</span> s.not_empty() <span class="keyword">or</span> cur:</span><br><span class="line">		<span class="keyword">if</span> cur:</span><br><span class="line">			s.push_back(cur)</span><br><span class="line">			cur = cur.left</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			cur = s.pop()</span><br><span class="line">			visit(cur)</span><br><span class="line">			cur = cur.right</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>后序：需要标记当前节点左、右子树是否被访问</p>
<ul>
<li><p>深度优先入栈</p>
<ul>
<li>节点先入栈后访问，栈内存未访问节点</li>
<li>记录最后一次访问节点，判断右子树是否被访问
（若右子树被访问，右子节点必然是上个被访问节点）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PostOrder(T):</span><br><span class="line">	s = InitStack()</span><br><span class="line">	cur = T</span><br><span class="line">	last = <span class="literal">NULL</span></span><br><span class="line">	<span class="keyword">while</span> s.not_empty() <span class="keyword">or</span> cur:</span><br><span class="line">		<span class="keyword">while</span> cur:</span><br><span class="line">			s.push_back(cur)</span><br><span class="line">			cur = cur.left</span><br><span class="line">		cur = s.top()</span><br><span class="line">		<span class="comment">// 检查右子树是否被访问过</span></span><br><span class="line">		<span class="keyword">if</span> cur.right == <span class="literal">NULL</span> <span class="keyword">or</span> cur.right == last:</span><br><span class="line">			visit(cur)</span><br><span class="line">			last = s.pop()	<span class="comment">// 此时再弹出`cur`</span></span><br><span class="line">			cur = <span class="literal">NULL</span>		<span class="comment">// 置`cur`为`NULL`，否则</span></span><br><span class="line">							<span class="comment">// 再次访问左子树，死循环</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			cur = cur.right</span><br></pre></td></tr></table></figure>
</li>
<li><p>或者为每个节点附设标志位</p>
</li>
</ul>
</li>
</ul>
<h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h4><ul>
<li><p>队列实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 判断节点是否存在、再填充至队列</span><br><span class="line">LevelTraversal(T):</span><br><span class="line">	q = InitQueue()</span><br><span class="line">	cur = T</span><br><span class="line">	<span class="keyword">while</span> q.not_empty() <span class="keyword">or</span> cur:</span><br><span class="line">		<span class="keyword">if</span> cur.left:</span><br><span class="line">			q.push_back(cur.left)</span><br><span class="line">		<span class="keyword">if</span> cur.right:d</span><br><span class="line">			q.push_back(cur.right)</span><br><span class="line">		visit(cur)</span><br><span class="line">		cur = q.pop_first()</span><br><span class="line"></span><br><span class="line"># 先填充、再判断节点是否为`None`</span><br><span class="line"># 填充可保证、适合节点位置和满二叉树对应</span><br><span class="line">LevelTraversal(T):</span><br><span class="line">	q = InitQueue()</span><br><span class="line">	q.push(T)</span><br><span class="line">	# 层次遍历使用队列实现，所以无需像栈一样使用</span><br><span class="line">		# 两个判断条件`q.not_empty <span class="keyword">or</span> cur`</span><br><span class="line">	<span class="keyword">while</span> q.not_empty():</span><br><span class="line">		cur = q.pop_first()</span><br><span class="line">		# 弹出时判断节点是否有效</span><br><span class="line">		<span class="keyword">if</span> cur:</span><br><span class="line">			visit(cur)</span><br><span class="line">			q.push_back(cur.left)</span><br><span class="line">			q.push_back(cur.right)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>严格分层遍历</strong>：记录队列长度、遍历固定长度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LevelTraversal(T):</span><br><span class="line">	q = InitQueue()</span><br><span class="line">	q.push(T)</span><br><span class="line">	<span class="keyword">while</span> q.not_empty():</span><br><span class="line">		# 记录当前开始时队列长度</span><br><span class="line">		# 每轮遍历该长度数目元素，严格分层遍历节点</span><br><span class="line">		<span class="keyword">for</span> i=<span class="number">0</span> to len(q):</span><br><span class="line">			cur_node = q.pop_left()</span><br><span class="line">			visit(cur_node)</span><br><span class="line">			<span class="keyword">if</span> cur.left:</span><br><span class="line">				q.push_back(cur.left)</span><br><span class="line">			<span class="keyword">if</span> cur.right:</span><br><span class="line">				q.push_back(cur.right)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="树的计数"><a href="#树的计数" class="headerlink" title="树的计数"></a>树的计数</h3><blockquote>
<ul>
<li>二叉树相似：二者为空树或二者均不为空树，且其左右子树分别
  相似</li>
<li>二叉树等价：二者不仅相似，而且所有对应结点上的数据元素
  均相同</li>
</ul>
</blockquote>
<ul>
<li>二叉树的计数：n个结点、互不相似的二叉树数量$b_n$</li>
<li>树和一棵没有右子树的二叉树一一对应，所以具有n个结点不同
形态的树的数目，等于具有n-1个结点互不相似的二叉树数目</li>
</ul>
<h4 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h4><p>二叉树可以看作是根节点、i个结点的左子树、n-i-1个结点的右子树
组成，所有有如下递推</p>
<script type="math/tex; mode=display">\left \{ \begin{array}{l}
b_0 & = 1 \\
b_n & = \sum_{i=0}^{n-1} b_i b_{n-i-1}, & n \geq 1
\end{array} \right.</script><p>求解得</p>
<script type="math/tex; mode=display">
b_n = \frac 1 {n+1} \frac {(2n)!} {n!n!} = 
    \frac 1 {n+1} C_{2n}^n</script><h4 id="遍历性质"><a href="#遍历性质" class="headerlink" title="遍历性质"></a>遍历性质</h4><ul>
<li><p>给定结点的前序序列、中序序列，可以唯一确定一棵二叉树</p>
</li>
<li><p>n个结点，不同形态二叉树数目恰是前序序列为$1 \cdots n$
二叉树能得到的中序序列数目</p>
</li>
<li><p>中序遍历过程实质是结点进栈、出栈的过程，序列$1 \cdots n$
按不同顺序进栈、出栈能得到排列的数目即为中序置换数目
$C<em>{2n}^n - C</em>{2n}^{n-1} = \frac 1 {n+1} C_{2n}^n$</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-06-04T15:11:44.000Z" title="6/4/2019, 11:11:44 PM">2019-06-04</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-06-04T15:11:44.000Z" title="6/4/2019, 11:11:44 PM">2019-06-04</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Data-Structure/">Data Structure</a></span><span class="level-item">12 minutes read (About 1791 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Data-Structure/tree_high_dimension.html">高维检索树</a></h1><div class="content"><h2 id="K-dimentional-Tree"><a href="#K-dimentional-Tree" class="headerlink" title="K-dimentional Tree"></a><em>K-dimentional Tree</em></h2><p>Kd树：循环遍历各维度，按该维度取值二分数据</p>
<ul>
<li><p>对高维数据进行<strong>快速搜索</strong>二叉树</p>
<ul>
<li>超平面都垂直于轴的BSPTree</li>
</ul>
</li>
<li><p>Kd树对样本点的组织表示对k维空间的划分</p>
<ul>
<li>每个节点对应k维空间中超矩形区域</li>
<li>构造kd树相当于用垂直于坐标轴超平面不断划分k维空间，
得到一系列超矩形区域</li>
</ul>
</li>
<li><p>Kd树构建目标</p>
<ul>
<li>树应该尽量平衡，即分割应尽量均匀</li>
<li>最大化邻域搜索的剪枝</li>
</ul>
</li>
</ul>
<h3 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h3><blockquote>
<ul>
<li>输入：数据点$X_i, i=1,2,\cdots,N$</li>
</ul>
</blockquote>
<ul>
<li>确定划分维度（轴）<ul>
<li>选择方差最大的轴，使得数据尽量分散</li>
<li>按次序循环遍历所有轴：方便查找时定位轴</li>
</ul>
</li>
<li>选择该维度上数值中位数作为划分点<ul>
<li>中位数查找方法<ul>
<li>各维度统一全体排序、记录</li>
<li>抽样，使用样本中位数</li>
</ul>
</li>
<li>小于中位数的数据点划分至左子树，否则划分至右子树</li>
</ul>
</li>
<li>递归建立左、右子树直至无法继续划分<ul>
<li>节点中包含数据项数量小于阈值</li>
</ul>
</li>
</ul>
<h3 id="查找K近邻"><a href="#查找K近邻" class="headerlink" title="查找K近邻"></a>查找K近邻</h3><blockquote>
<ul>
<li>输入：Kd树、目标点x</li>
</ul>
</blockquote>
<ul>
<li><p>在Kd树中找出包含目标点x的叶节点，以之为近邻点</p>
<ul>
<li>从根节点出发，与节点比较对应坐标值，递归访问至叶节点
为止</li>
<li>目标点在训练样本中不存在，必然能够访问到叶节点</li>
</ul>
</li>
<li><p>沿树回溯，检查节点是否距离目标点更近，尝试更新</p>
</li>
<li><p>检查该节点<strong>另一子区域是否可能</strong>具有更近距离的点</p>
<ul>
<li>即考察以目标点为圆心、当前近邻距离为半径圆，同划分轴
是否相交</li>
<li>则只需比较目标点同相应切分平面距离、近邻距离</li>
</ul>
</li>
<li><p>若目标点同该对应切分平面距离小于近邻距离</p>
<ul>
<li>则将目标节点视为<strong>属于</strong>该子区域中的点</li>
<li>从节点未访问子树开始重复以上步骤，进行近邻搜索</li>
</ul>
</li>
<li><p>否则继续回退</p>
</li>
<li><p>退回到根节点时，搜索结束，近邻点</p>
</li>
</ul>
<blockquote>
<ul>
<li>回溯过程中需要盘对子域是否访问过，可以通过标记、比较相应
  轴坐标等方式判断</li>
<li>k&gt;1的情况类似，不过检测时使用最远近邻，新近邻需要和所有
  原近邻依次比较</li>
</ul>
</blockquote>
<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><h4 id="插入新节点"><a href="#插入新节点" class="headerlink" title="插入新节点"></a>插入新节点</h4><ul>
<li>从根节点出发，根据待插入节点、当前节点在对应维度取值确定
插入左、右子树</li>
<li>遍历直至叶子节点，插入</li>
</ul>
<h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><ul>
<li><p>简单方法：将待删除节点子节点组成新集合，对其重新构建，
将新子树挂载在原被删节点位置</p>
</li>
<li><p>分类讨论：设删除节点T对应划分维度为D</p>
<ul>
<li>节点无子树：直接删除</li>
<li>节点有右子树<ul>
<li>在右子树寻找维度D取值最小节点P，替换被删除节点T</li>
<li>在右子树<strong>递归处理</strong>删除节点P</li>
</ul>
</li>
<li>节点无右子树有左子树<ul>
<li>在左子树寻找维度D取值最小节点P，替换被删除节点T</li>
<li>将T的左子树作为P的右子树</li>
<li>在右子树递归处理删除节点P</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="查找维度D最小点"><a href="#查找维度D最小点" class="headerlink" title="查找维度D最小点"></a>查找维度D最小点</h4><ul>
<li>若当前结点切分维度为D：只需查找左子树</li>
<li>否则需要对左、右子树分别递归搜索</li>
</ul>
<h2 id="Vantage-Point-Tree"><a href="#Vantage-Point-Tree" class="headerlink" title="Vantage Point Tree"></a><em>Vantage Point Tree</em></h2><p>VP树：任选样本点，按照数据点与该点距离二分数据</p>
<ul>
<li><p>对高维数据进行<strong>快速搜索</strong>二叉树</p>
</li>
<li><p>VP树对样本点的组织表示对k维空间的划分</p>
<ul>
<li>每个节点对应k维空间中一个球形划分</li>
<li>构造kd树相当于用以给定样本点为球心不断划分k维空间，
得到一系列球内、球外区域</li>
</ul>
</li>
</ul>
<h3 id="建树-1"><a href="#建树-1" class="headerlink" title="建树"></a>建树</h3><blockquote>
<ul>
<li>输入：数据$X_i, i=1,2,\cdots,n$</li>
</ul>
</blockquote>
<ul>
<li>选择某数据点$X_v$作为划分球心</li>
<li>计算其他数据点距离$D_i = d(X_i, X_v)$</li>
<li>求出$D_i$中位数$M$<ul>
<li>与$X_v$距离$D_i \leq M$的数据点$D_i$划分至左子树</li>
<li>与$X_v$距离$D_i \gt M$的数据点$D_i$划分至右子树</li>
</ul>
</li>
</ul>
<h2 id="Rectangle-Tree"><a href="#Rectangle-Tree" class="headerlink" title="Rectangle Tree"></a><em>Rectangle Tree</em></h2><p>R树：将空间划分为有重叠的</p>
<ul>
<li>B树高维推广<ul>
<li>类似B树将一维区间划分为多个不重叠的子区间</li>
<li>同样是平衡树，所有叶子位于同一层上</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>R树退化至1维有分割区间重叠问题，效果不如B树</li>
</ul>
</blockquote>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><blockquote>
<ul>
<li>$M$：节点中最大键数量</li>
<li>$m \leq \frac M 2$：节点中条目最小数量</li>
</ul>
</blockquote>
<ul>
<li><p>非根叶节点包含$m-M$索引记录：$I$表示可在空间中完全覆盖
节点中条目点的MBR</p>
</li>
<li><p>非根、非叶节点包含$m-m$个子节点：$I$表示可在空间中完全
覆盖节点中条目矩形的MBR</p>
</li>
<li><p>根节点条目数$[2, m]$，除非为叶子节点</p>
</li>
</ul>
<blockquote>
<ul>
<li><em>minimal bounding rectangle</em>：<em>MBR</em>，最小边界矩形</li>
</ul>
</blockquote>
<h4 id="节点结构"><a href="#节点结构" class="headerlink" title="节点结构"></a>节点结构</h4><ul>
<li><p>叶子节点结构：$(I, tuple-ids)$</p>
<p><img src="/imgs/tree_hd_rtree_node_structure.png" alt="tree_hd_rtree_node_structure"></p>
<ul>
<li>$I((s_1, e_1), (s_2, e_2), \cdots, (s_n, e_n))$：
n维空间中矩形</li>
<li>$tuple-ids$：节点包含的记录</li>
</ul>
</li>
<li><p>非叶节点：$(I, child-pointer)$</p>
</li>
</ul>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="建树-2"><a href="#建树-2" class="headerlink" title="建树"></a>建树</h4><h4 id="矩形搜索"><a href="#矩形搜索" class="headerlink" title="矩形搜索"></a>矩形搜索</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SearchRect(T, S, ret):</span><br><span class="line">	<span class="comment">// 利用R树搜索矩形范围中包含的记录点</span></span><br><span class="line">	<span class="comment">// 输入：R树根节点T、待搜索矩形S</span></span><br><span class="line">	<span class="comment">// 输出：矩形S覆盖的条目</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> T.I join S == <span class="literal">NULL</span>:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若T不是叶子节点，检查其每个条目E</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> T.is_leaf():</span><br><span class="line">		<span class="keyword">for</span> E in T.entries:</span><br><span class="line">			<span class="comment">// 对与S相交E.I对应条目E，递归调用搜索</span></span><br><span class="line">			<span class="keyword">if</span> T.I join S != <span class="literal">NULL</span>:</span><br><span class="line">				SearchRect(E, S, ret)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若T是叶子节点且T.I与S相交，检查其每个记录点</span></span><br><span class="line">	elif T.I join S != <span class="literal">NULL</span>:</span><br><span class="line">		<span class="keyword">for</span> E in T.entries:</span><br><span class="line">			<span class="keyword">if</span> E in S:</span><br><span class="line">				ret.add(E)</span><br></pre></td></tr></table></figure>
<h4 id="选择所属叶子"><a href="#选择所属叶子" class="headerlink" title="选择所属叶子"></a>选择所属叶子</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ChooseLeaf(T, E):</span><br><span class="line">	<span class="comment">// 在R树中寻找新索引条目所属叶子节点</span></span><br><span class="line">	<span class="comment">// 输入：R树根节点T、索引条目E</span></span><br><span class="line">	<span class="comment">// 输出：E所属R树中叶子节点</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> T.is_leaf():</span><br><span class="line">		Assert(E.is_subset(T))</span><br><span class="line">		<span class="keyword">return</span> T</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">for</span> T_E in T.entries:</span><br><span class="line">			<span class="keyword">if</span> E.is_subset(T_E)</span><br><span class="line">				<span class="keyword">return</span> ChooseLeaf(T_E, E) <span class="keyword">or</span> T_E</span><br></pre></td></tr></table></figure>
<h4 id="插入新条目"><a href="#插入新条目" class="headerlink" title="插入新条目"></a>插入新条目</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Insert(T, E):</span><br><span class="line">	<span class="comment">// 向R树中插入新条目</span></span><br><span class="line">	<span class="comment">// 输出：R树根T、新条目E</span></span><br><span class="line"></span><br><span class="line">	L = ChooseLeaf(T, E)</span><br><span class="line">	<span class="keyword">if</span> L.has_slot():</span><br><span class="line">		L.add(E)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		LL = L.split()</span><br><span class="line">		L.add(E)</span><br><span class="line">		P = L.get_parent()</span><br><span class="line">		</span><br></pre></td></tr></table></figure>
<h4 id="调整树"><a href="#调整树" class="headerlink" title="调整树"></a>调整树</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AdjustTree(T, L):</span><br><span class="line">	<span class="comment">// 从不满足节点开始调整R树至满足要求</span></span><br><span class="line">	<span class="comment">// 输入：R树根T、不满足要求节点L</span></span><br><span class="line">	<span class="comment">// 输出：</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> L.is_root():</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">	P = L.get_parent_node()</span><br><span class="line">	<span class="keyword">if</span> L.splitted():</span><br><span class="line">		NN = L.get_split_node()</span><br><span class="line">		<span class="keyword">if</span> P.</span><br><span class="line">	<span class="comment">// 调整节点L在父节点中矩形框I大小</span></span><br><span class="line">	addjust_I(P.L.I)</span><br></pre></td></tr></table></figure>
<h2 id="R-tree"><a href="#R-tree" class="headerlink" title="R*-tree"></a>R*-tree</h2><h2 id="X-tree"><a href="#X-tree" class="headerlink" title="X-tree"></a><em>X-tree</em></h2><h2 id="SS-tree"><a href="#SS-tree" class="headerlink" title="SS-tree"></a><em>SS-tree</em></h2><h2 id="SR-Tree"><a href="#SR-Tree" class="headerlink" title="SR-Tree"></a><em>SR-Tree</em></h2><h2 id="Metric-tree"><a href="#Metric-tree" class="headerlink" title="Metric-tree"></a><em>Metric-tree</em></h2></div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/21/">Previous</a></div><div class="pagination-next"><a href="/page/23/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/21/">21</a></li><li><a class="pagination-link is-current" href="/page/22/">22</a></li><li><a class="pagination-link" href="/page/23/">23</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/40/">40</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">36</span></span></a><ul><li><a class="level is-mobile" href="/categories/Algorithm/Data-Structure/"><span class="level-start"><span class="level-item">Data Structure</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Heuristic/"><span class="level-start"><span class="level-item">Heuristic</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Issue/"><span class="level-start"><span class="level-item">Issue</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Problem/"><span class="level-start"><span class="level-item">Problem</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Specification/"><span class="level-start"><span class="level-item">Specification</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/C-C/"><span class="level-start"><span class="level-item">C/C++</span></span><span class="level-end"><span class="level-item tag">34</span></span></a><ul><li><a class="level is-mobile" href="/categories/C-C/Cppref/"><span class="level-start"><span class="level-item">Cppref</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/Cstd/"><span class="level-start"><span class="level-item">Cstd</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/MPI/"><span class="level-start"><span class="level-item">MPI</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/STL/"><span class="level-start"><span class="level-item">STL</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/CS/"><span class="level-start"><span class="level-item">CS</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/CS/Character/"><span class="level-start"><span class="level-item">Character</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Parallel/"><span class="level-start"><span class="level-item">Parallel</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Program-Design/"><span class="level-start"><span class="level-item">Program Design</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Storage/"><span class="level-start"><span class="level-item">Storage</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Daily-Life/"><span class="level-start"><span class="level-item">Daily Life</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/Daily-Life/Maxism/"><span class="level-start"><span class="level-item">Maxism</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Database/"><span class="level-start"><span class="level-item">Database</span></span><span class="level-end"><span class="level-item tag">27</span></span></a><ul><li><a class="level is-mobile" href="/categories/Database/Hadoop/"><span class="level-start"><span class="level-item">Hadoop</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Database/SQL-DB/"><span class="level-start"><span class="level-item">SQL DB</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Database/Spark/"><span class="level-start"><span class="level-item">Spark</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/Scala/"><span class="level-start"><span class="level-item">Scala</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">42</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Bash-Programming/"><span class="level-start"><span class="level-item">Bash Programming</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Configuration/"><span class="level-start"><span class="level-item">Configuration</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/File-System/"><span class="level-start"><span class="level-item">File System</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/IPC/"><span class="level-start"><span class="level-item">IPC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Process-Schedual/"><span class="level-start"><span class="level-item">Process Schedual</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Shell/"><span class="level-start"><span class="level-item">Shell</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Tool/"><span class="level-start"><span class="level-item">Tool</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Tool/Vi/"><span class="level-start"><span class="level-item">Vi</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Model/"><span class="level-start"><span class="level-item">ML Model</span></span><span class="level-end"><span class="level-item tag">21</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Model/Linear-Model/"><span class="level-start"><span class="level-item">Linear Model</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Model-Component/"><span class="level-start"><span class="level-item">Model Component</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Nolinear-Model/"><span class="level-start"><span class="level-item">Nolinear Model</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Unsupervised-Model/"><span class="level-start"><span class="level-item">Unsupervised Model</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/"><span class="level-start"><span class="level-item">ML Specification</span></span><span class="level-end"><span class="level-item tag">17</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/Click-Through-Rate/"><span class="level-start"><span class="level-item">Click Through Rate</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/Click-Through-Rate/Recommandation-System/"><span class="level-start"><span class="level-item">Recommandation System</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/Computer-Vision/"><span class="level-start"><span class="level-item">Computer Vision</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Specification/FinTech/"><span class="level-start"><span class="level-item">FinTech</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/FinTech/Risk-Control/"><span class="level-start"><span class="level-item">Risk Control</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/Graph-Analysis/"><span class="level-start"><span class="level-item">Graph Analysis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Specification/NLP/"><span class="level-start"><span class="level-item">NLP</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Technique/"><span class="level-start"><span class="level-item">ML Technique</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Technique/Feature-Engineering/"><span class="level-start"><span class="level-item">Feature Engineering</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Technique/Neural-Network/"><span class="level-start"><span class="level-item">Neural Network</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Theory/"><span class="level-start"><span class="level-item">ML Theory</span></span><span class="level-end"><span class="level-item tag">11</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Theory/Loss/"><span class="level-start"><span class="level-item">Loss</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Theory/Model-Enhencement/"><span class="level-start"><span class="level-item">Model Enhencement</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Theory/Optimization/"><span class="level-start"><span class="level-item">Optimization</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Algebra/"><span class="level-start"><span class="level-item">Math Algebra</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Algebra/Linear-Algebra/"><span class="level-start"><span class="level-item">Linear Algebra</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Algebra/Universal-Algebra/"><span class="level-start"><span class="level-item">Universal Algebra</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Analysis/"><span class="level-start"><span class="level-item">Math Analysis</span></span><span class="level-end"><span class="level-item tag">23</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Analysis/Fourier-Analysis/"><span class="level-start"><span class="level-item">Fourier Analysis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Functional-Analysis/"><span class="level-start"><span class="level-item">Functional Analysis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Optimization/"><span class="level-start"><span class="level-item">Optimization</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Real-Analysis/"><span class="level-start"><span class="level-item">Real Analysis</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Mixin/"><span class="level-start"><span class="level-item">Math Mixin</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Mixin/Statistics/"><span class="level-start"><span class="level-item">Statistics</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Mixin/Time-Series/"><span class="level-start"><span class="level-item">Time Series</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Probability/"><span class="level-start"><span class="level-item">Probability</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">89</span></span></a><ul><li><a class="level is-mobile" href="/categories/Python/Cookbook/"><span class="level-start"><span class="level-item">Cookbook</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Jupyter/"><span class="level-start"><span class="level-item">Jupyter</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Keras/"><span class="level-start"><span class="level-item">Keras</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Matplotlib/"><span class="level-start"><span class="level-item">Matplotlib</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Numpy/"><span class="level-start"><span class="level-item">Numpy</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Pandas/"><span class="level-start"><span class="level-item">Pandas</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Py3Ref/"><span class="level-start"><span class="level-item">Py3Ref</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Py3std/"><span class="level-start"><span class="level-item">Py3std</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Pywin32/"><span class="level-start"><span class="level-item">Pywin32</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Readme/"><span class="level-start"><span class="level-item">Readme</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/TensorFlow/"><span class="level-start"><span class="level-item">TensorFlow</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Twists/"><span class="level-start"><span class="level-item">Twists</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/RLang/"><span class="level-start"><span class="level-item">RLang</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Rust/"><span class="level-start"><span class="level-item">Rust</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Set/"><span class="level-start"><span class="level-item">Set</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/"><span class="level-start"><span class="level-item">Tool</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/Tool/Editor/"><span class="level-start"><span class="level-item">Editor</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Markup-Language/"><span class="level-start"><span class="level-item">Markup Language</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Web-Browser/"><span class="level-start"><span class="level-item">Web Browser</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Windows/"><span class="level-start"><span class="level-item">Windows</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/Web/CSS/"><span class="level-start"><span class="level-item">CSS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/NPM/"><span class="level-start"><span class="level-item">NPM</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/Proxy/"><span class="level-start"><span class="level-item">Proxy</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/Thrift/"><span class="level-start"><span class="level-item">Thrift</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://octodex.github.com/images/hula_loop_octodex03.gif" alt="UBeaRLy"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">UBeaRLy</p><p class="is-size-6 is-block">Protector of Proxy</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">392</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">93</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">522</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/xyy15926" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/xyy15926"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-04T15:07:54.896Z">2021-08-04</time></p><p class="title"><a href="/uncategorized/README.html"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-03T07:46:51.000Z">2021-08-03</time></p><p class="title"><a href="/Web/NPM/hexo_config.html">Hexo 建站</a></p><p class="categories"><a href="/categories/Web/">Web</a> / <a href="/categories/Web/NPM/">NPM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-03T02:32:45.000Z">2021-08-03</time></p><p class="title"><a href="/Web/NPM/config.html">NPM 总述</a></p><p class="categories"><a href="/categories/Web/">Web</a> / <a href="/categories/Web/NPM/">NPM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-02T08:11:11.000Z">2021-08-02</time></p><p class="title"><a href="/Python/Py3std/internet_data.html">互联网数据</a></p><p class="categories"><a href="/categories/Python/">Python</a> / <a href="/categories/Python/Py3std/">Py3std</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-29T13:55:00.000Z">2021-07-29</time></p><p class="title"><a href="/Linux/Shell/sh_apps.html">Shell 应用程序</a></p><p class="categories"><a href="/categories/Linux/">Linux</a> / <a href="/categories/Linux/Shell/">Shell</a></p></div></article></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">Advertisement</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5385776267343559" data-ad-slot="6995841235" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="UBeaRLy" height="28"></a><p class="is-size-7"><span>&copy; 2021 UBeaRLy</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/xyy15926/proxy"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>