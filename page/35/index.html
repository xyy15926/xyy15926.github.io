<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>UBeaRLy</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="UBeaRLy&#039;s Proxy"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="UBeaRLy&#039;s Proxy"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="UBeaRLy"><meta property="og:url" content="https://xyy15926.github.io/"><meta property="og:site_name" content="UBeaRLy"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://xyy15926.github.io/img/og_image.png"><meta property="article:author" content="UBeaRLy"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xyy15926.github.io"},"headline":"UBeaRLy","image":["https://xyy15926.github.io/img/og_image.png"],"author":{"@type":"Person","name":"UBeaRLy"},"publisher":{"@type":"Organization","name":"UBeaRLy","logo":{"@type":"ImageObject","url":"https://xyy15926.github.io/img/logo.svg"}},"description":""}</script><link rel="alternate" href="/atom.xml" title="UBeaRLy" type="application/atom+xml"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/darcula.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><script data-ad-client="pub-5385776267343559" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><meta name="follow_it-verification-code" content="SVBypAPPHxjjr7Y4hHfn"><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="UBeaRLy" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Visit on GitHub" href="https://github.com/xyy15926/proxy"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:37.000Z" title="3/21/2019, 5:27:37 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-02-17T03:57:07.000Z" title="2/17/2019, 11:57:07 AM">2019-02-17</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/TensorFlow/">TensorFlow</a></span><span class="level-item">10 minutes read (About 1432 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/TensorFlow/README.html">TensorFlow Readme</a></h1><div class="content"><h2 id="常用参数说明"><a href="#常用参数说明" class="headerlink" title="常用参数说明"></a>常用参数说明</h2><ul>
<li><p>函数书写声明同Python全局</p>
</li>
<li><p>以下常用参数如不特殊注明，按照此解释</p>
</li>
</ul>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><ul>
<li><p><code>target = &quot;&quot;/str</code></p>
<ul>
<li>含义：执行引擎</li>
</ul>
</li>
<li><p><code>graph = None/tf.Graph</code></p>
<ul>
<li>含义：Session中加载的图</li>
<li>默认：缺省为当前默认图</li>
</ul>
</li>
<li><p><code>config = None/tf.ConfigProto</code></p>
<ul>
<li>含义：包含Session配置的<em>Protocal Buffer</em></li>
<li>默认：<code>None</code>，默认配置</li>
</ul>
</li>
<li><p><code>fetches = tf.OPs/[tf.OPs]</code></p>
<ul>
<li>含义：需要获得/计算的OPs值列表</li>
<li>默认：无</li>
</ul>
</li>
<li><p><code>feed_dict = None/dict</code></p>
<ul>
<li>含义：替换/赋值Graph中feedable OPs的tensor字典</li>
<li>默认：无</li>
<li>说明<ul>
<li>键为图中节点名称、值为向其赋的值</li>
<li>可向所有可赋值OPs传递值</li>
<li>常配合<code>tf.placeholder</code>（强制要求）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h3><ul>
<li><p><code>name = None/str</code></p>
<ul>
<li>含义：Operations名</li>
<li>默认：<code>None/OP类型</code>，后加上顺序后缀</li>
<li>说明<ul>
<li>重名时TF自动加上<code>_[num]</code>后缀</li>
</ul>
</li>
</ul>
</li>
<li><p><code>axis = None/0/int</code></p>
<ul>
<li>含义：指定张量轴</li>
<li>默认<ul>
<li><code>None</code>：大部分，表示在整个张量上运算</li>
<li><code>0</code>：有些运算难以推广到整个张量，表示在首轴（维）</li>
</ul>
</li>
</ul>
</li>
<li><p><code>keepdims=False/True</code></p>
<ul>
<li>含义：是否保持维度数目</li>
<li>默认：<code>False</code>不保持</li>
</ul>
</li>
<li><p><code>dtype=tf.int32/tf.float32/...</code></p>
<ul>
<li>含义：数据类型</li>
<li>默认：根据其他参数、函数名推断</li>
</ul>
</li>
<li><p><code>shape/dims=(int)/[int]</code></p>
<ul>
<li>含义：各轴维数</li>
<li>默认：<code>None/1</code>???</li>
<li>说明<ul>
<li><code>-1</code>表示该轴维数由TF计算得到</li>
<li>有些情况下，此参数可省略，由TF隐式计算得到，
但显式指明方便debug</li>
</ul>
</li>
</ul>
</li>
<li><p><code>start=int</code></p>
<ul>
<li>含义：起始位置</li>
<li>默认：<code>0</code></li>
</ul>
</li>
<li><p><code>stop=int</code></p>
<ul>
<li>含义：终点位置</li>
<li>默认：一般无</li>
</ul>
</li>
</ul>
<h2 id="TensorFlow基本概念"><a href="#TensorFlow基本概念" class="headerlink" title="TensorFlow基本概念"></a>TensorFlow基本概念</h2><blockquote>
<ul>
<li>TensorFlow将计算的定义、执行分开</li>
</ul>
</blockquote>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><h4 id="组合计算图"><a href="#组合计算图" class="headerlink" title="组合计算图"></a>组合计算图</h4><ul>
<li>为输入、标签创建placeholder</li>
<li>创建weigth、bias</li>
<li>指定模型</li>
<li>指定损失函数</li>
<li>创建Opitmizer</li>
</ul>
<h4 id="在会话中执行图中操作"><a href="#在会话中执行图中操作" class="headerlink" title="在会话中执行图中操作"></a>在会话中执行图中操作</h4><ul>
<li>初始化Variable</li>
<li>运行优化器</li>
<li>使用<code>FileWriter</code>记录log</li>
<li>查看TensorBoard</li>
</ul>
<h2 id="PyTF-模块"><a href="#PyTF-模块" class="headerlink" title="PyTF 模块"></a>PyTF 模块</h2><h3 id="tf-nn"><a href="#tf-nn" class="headerlink" title="tf.nn"></a><code>tf.nn</code></h3><p><code>tf.nn</code>：神经网络功能支持模块</p>
<ul>
<li><code>rnn_cell</code>：构建循环神经网络子模块</li>
</ul>
<h3 id="tf-contrib"><a href="#tf-contrib" class="headerlink" title="tf.contrib"></a><code>tf.contrib</code></h3><p><code>tf.contrib</code>：包含易于变动、实验性质的功能</p>
<ul>
<li><code>bayesflow</code>：包含贝叶斯计算</li>
<li><code>cloud</code>：云操作</li>
<li><code>cluster_resolver</code>：集群求解</li>
<li><code>compiler</code>：控制TF/XLA JIT编译器</li>
<li><code>copy_graph</code>：在不同计算图之间复制元素</li>
<li><code>crf</code>：条件随机场</li>
<li><code>cudnn_rnn</code>：Cudnn层面循环神经网络</li>
<li><code>data</code>：构造输入数据流水线</li>
<li><code>decision_trees</code>：决策树相关模块</li>
<li><code>deprecated</code>：已经、将被替换的summary函数</li>
<li><code>distributions</code>：统计分布相关操作</li>
<li><code>estimator</code>：自定义标签、预测的对错度量方式</li>
<li><code>factorization</code>：聚类、因子分解</li>
<li><code>ffmpeg</code>：使用FFmpeg处理声音文件</li>
<li><code>framework</code>：框架类工具，包含变量操作、命令空间、
checkpoint操作</li>
<li><code>gan</code>：对抗生成相关</li>
<li><code>graph_editor</code>：计算图操作</li>
<li><code>grid_rnn</code>：GridRNN相关</li>
<li><code>image</code>：图像操作</li>
<li><code>input_pipeline</code>：输入流水线</li>
<li><code>integrate</code>：求解常微分方程</li>
<li><code>keras</code>：Keras相关API</li>
<li><code>kernel_methods</code>：核映射相关方法</li>
<li><code>kfac</code>：KFAC优化器</li>
<li><code>labeled_tensor</code>：有标签的Tensor</li>
<li><code>layers</code>：类似nn里面的函数，经典CNN方法重构</li>
<li><code>learn</code>：类似ski-learn的高级API</li>
<li><code>legacy_seq2seq</code>：经典seq2seq模型</li>
<li><code>linalg</code>：线性代数</li>
<li><code>linear_optimizer</code>：训练线性模型、线性优化器</li>
<li><code>lookup</code>：构建快速查找表</li>
<li><code>losses</code>：loss相关</li>
<li><code>memory_stats</code>：设备内存使用情况</li>
<li><code>meta_graph_transform</code>：计算图转换</li>
<li><code>metrics</code>：各种度量模型表现的方法</li>
<li><code>nccl</code>：收集结果的操作</li>
<li><code>ndlstm</code>：ndlstm相关</li>
<li><code>nn</code>：<code>tf.nn</code>某些方法的其他版本</li>
<li><code>opt</code>：某些优化器的其他版本</li>
<li><code>predictor</code>：构建预测器</li>
<li><code>reduce_slice_ops</code>：切片规约</li>
<li><code>remote_fused_graph</code></li>
<li><code>resampler</code>：重抽样</li>
<li><code>rnn</code>：某些循环神经网络其他版本</li>
<li><code>saved_model</code>：更加易用的模型保存、继续训练、模型转换</li>
<li><code>seq2seq</code>：seq2seq相关模型</li>
<li><code>session_bundle</code></li>
<li><code>signal</code>：信号处理相关</li>
<li><code>slim</code>：contrib主模块交互方式、主要入口</li>
<li><code>solvers</code>：贝叶斯计算</li>
<li><code>sparsemax</code>：稀疏概率激活函数、相关loss</li>
<li><code>specs</code></li>
<li><code>staging</code>：分段输入</li>
<li><code>stat_summarizer</code>：查看运行状态</li>
<li><code>statless</code>：伪随机数</li>
<li><code>tensor_forest</code>：可视化工具</li>
<li><code>testing</code>：单元测试工具</li>
<li><code>tfprof</code>：查看模型细节工具</li>
<li><code>timeseries</code>：时间序列工具</li>
<li><code>tpu</code>：TPU配置</li>
<li><code>training</code>：训练及输入相关工具</li>
<li><code>util</code>：Tensors处理相关工具</li>
</ul>
<h3 id="tf-train"><a href="#tf-train" class="headerlink" title="tf.train"></a><code>tf.train</code></h3><p><code>tf.train</code>：训练模型支持</p>
<ul>
<li><p>优化器</p>
<ul>
<li><code>AdadeltaOptimizer</code>：Adadelta优化器</li>
<li><code>AdamOptimizer</code>：Adam优化器</li>
<li><code>GradientDescentOptimizer</code>：SGD优化器</li>
<li><code>MomentumOptimizer</code>：动量优化器</li>
<li><code>RMSPropOptimizer</code>：RMSProp优化器</li>
</ul>
</li>
<li><p>数据处理</p>
<ul>
<li><code>Coordinator</code>：线程管理器</li>
<li><code>QueueRunner</code>：管理读写队列线程</li>
<li><code>NanTensorHook</code>：loss是否为NaN的捕获器</li>
<li><code>create_global_step</code>：创建global step</li>
<li><code>match_filenames_once</code>：寻找符合规则文件名称</li>
<li><code>start_queue_runners</code>：启动计算图中所有队列</li>
</ul>
</li>
<li><p>tfrecord数据</p>
<ul>
<li><code>Example</code>：tfrecord生成模板</li>
<li><code>batch</code>：生成tensor batch</li>
<li><code>shuffle_batch</code>：创建随机tensor batch</li>
</ul>
</li>
<li><p>模型保存、读取</p>
<ul>
<li><code>Saver</code>：保存模型、变量类</li>
<li><code>NewCheckpointReader</code>：checkpoint文件读取</li>
<li><code>get_checkpoint_state</code>：从checkpoint文件返回模型状态</li>
<li><code>init_from_checkpoint</code>：从checkpoint文件初始化变量</li>
<li><code>latest_checkpoint</code>：寻找最后checkpoint文件</li>
<li><code>list_variable</code>：返回checkpoint文件变量为列表</li>
<li><code>load_variable</code>：返回checkpoint文件某个变量值</li>
</ul>
</li>
</ul>
<h3 id="tf-summary"><a href="#tf-summary" class="headerlink" title="tf.summary"></a><code>tf.summary</code></h3><p><code>tf.summary</code>：配合tensorboard展示模型信息</p>
<ul>
<li><code>FileWriter</code>：文件生成类</li>
<li><code>Summary</code></li>
<li><code>get_summary_description</code>：获取计算节点信息</li>
<li><code>histogram</code>：展示变量分布信息</li>
<li><code>image</code>：展示图片信息</li>
<li><code>merge</code>：合并某个summary信息</li>
<li><code>merge_all</code>：合并所有summary信息至默认计算图</li>
<li><code>scalar</code>：展示标量值</li>
<li><code>text</code>：展示文本信息</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:37.000Z" title="3/21/2019, 5:27:37 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-04T11:38:46.000Z" title="8/4/2021, 7:38:46 PM">2021-08-04</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/TensorFlow/">TensorFlow</a></span><span class="level-item">2 minutes read (About 317 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/TensorFlow/tf_config.html">TensorFlow 安装配置</a></h1><div class="content"><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="CUDA、CUDNN、CUDAtookit、NVCC"><a href="#CUDA、CUDNN、CUDAtookit、NVCC" class="headerlink" title="CUDA、CUDNN、CUDAtookit、NVCC"></a>CUDA、CUDNN、CUDAtookit、NVCC</h3><ul>
<li>CUDA：compute unified device architecture，通用并行计算
平台和编程模型，方便使用GPU进行通用计算</li>
<li>cuDNN：深度学习加速库，计算设计的库、中间件<ul>
<li>C++STL的thrust的实现</li>
<li>cublas：GPU版本blas</li>
<li>cuSparse：稀疏矩阵运算</li>
<li>cuFFT：快速傅里叶变换</li>
<li>cuDNN：深度学习网络加速</li>
</ul>
</li>
<li>CUDA Toolkit：包括以下组件<ul>
<li>编译器<code>nvcc</code>：CUDA-C、CUDA-C++编译器，依赖<code>nvvm</code>
优化器
（<code>nvvm</code>本身依赖<code>llvm</code>编译器）</li>
<li>·<code>debuggers</code>、<code>profiler</code>等工具</li>
<li>科学库、实用程序库<ul>
<li>cudart</li>
<li>cudadevrt</li>
<li>cupti</li>
<li>nvml</li>
<li>nvrtc</li>
<li>cublas</li>
<li>cublas_device</li>
</ul>
</li>
<li>示例</li>
<li>驱动：</li>
</ul>
</li>
</ul>
<h2 id="TensorBoard"><a href="#TensorBoard" class="headerlink" title="TensorBoard"></a>TensorBoard</h2><p>TensorBoard是包括在TensorFlow中可视化组件</p>
<ul>
<li>运行启动了TB的TF项目时，操作都会输出为事件日志文件</li>
<li>TB能够把这些日志文件以可视化的方式展示出来<ul>
<li>模型图</li>
<li>运行时行为、状态</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tensorboard --logdir=/path/to/logdir --port XXXX</span><br></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><blockquote>
<p>   Your CPU supports instructions that this TensorFlow binary was not cmpiled to use: SSE1.4, SSE4.2, AVX AVX2 FMA</p>
</blockquote>
<ul>
<li>没从源代码安装以获取这些指令集的支持<ul>
<li>从源代码编译安装</li>
<li>或者设置log级别<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&quot;TF_CPP_MIN_LOG_LEVEL&quot;</span>] = <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:37.000Z" title="3/21/2019, 5:27:37 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-02-17T03:57:08.000Z" title="2/17/2019, 11:57:08 AM">2019-02-17</time></span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a></span><span class="level-item">4 minutes read (About 631 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Rust/crate_mod.html">Crate、Mod、可见性、文件结构</a></h1><div class="content"><h2 id="文件结构规则"><a href="#文件结构规则" class="headerlink" title="文件结构规则"></a>文件结构规则</h2><h3 id="拆分文件"><a href="#拆分文件" class="headerlink" title="拆分文件"></a>拆分文件</h3><p>Rust一般库中<strong>文件名/文件夹</strong>都表示mod
（测试文件规则比较特殊）</p>
<ul>
<li>mod<code>foo</code>在其父mod<code>bar</code>中声明 </li>
<li>如果mod<code>foo</code>没有子mod，将其实现放在<code>foo.rs</code>文件中</li>
<li>若mod<code>foo</code>有子mod，创建文件夹<code>foo</code>，将其实现放在
<code>foo/mod.rs</code>中</li>
</ul>
<p>以上是文件拆分规则，也可以不拆分文件</p>
<h3 id="库Crate"><a href="#库Crate" class="headerlink" title="库Crate"></a>库Crate</h3><p>库crate中<code>lib.rs</code>相当于该crate顶层mod（根mod）</p>
<ul>
<li>所有的mod直接或间接（祖先mod）声明于此，否则不能识别</li>
<li>从引用库crate的外部crate角度来看，其名称和库crate同名
<code>extern crate crate_name;</code>的同时就<code>use crate_name;</code>，
此时可将引用其的mod视为根mod的父mod</li>
</ul>
<h3 id="库、二进制Crate"><a href="#库、二进制Crate" class="headerlink" title="库、二进制Crate"></a>库、二进制Crate</h3><p>crate中可以同时有lib.rs和main.rs，此时库crate和二进制
crate应该看作相互<strong>独立</strong></p>
<ul>
<li><p>在两处都使用<code>mod</code>关键字<strong>声明定义</strong>mod（不能在<code>main.rs</code>
中使用<code>use</code><strong>声明使用</strong>mod）</p>
</li>
<li><p>在<code>main.rs</code>中使用<code>extern crate crate_name</code>引入
“外部”库crate</p>
</li>
</ul>
<h2 id="可见性规则"><a href="#可见性规则" class="headerlink" title="可见性规则"></a>可见性规则</h2><h3 id="Mod默认私有"><a href="#Mod默认私有" class="headerlink" title="Mod默认私有"></a>Mod默认私有</h3><ul>
<li>默认仅crate内部可见<ul>
<li>父mod处直接可用</li>
<li>兄弟mod、子mod可以通过“回溯“声明使用</li>
</ul>
</li>
<li><code>pub</code>声明为公用后，对外部crate也可见</li>
</ul>
<h3 id="Fn默认私有"><a href="#Fn默认私有" class="headerlink" title="Fn默认私有"></a>Fn默认私有</h3><ul>
<li>默认仅mod“内部”可见（包括后代mod）<ul>
<li>当前mod内直接可用</li>
<li>子mod可以通过“回溯”声明可用</li>
</ul>
</li>
<li><code>pub</code>声明为公用后，对外部mod也可见</li>
</ul>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li>项（mod、fn）的声明使用路径都是相对于当前项，即默认调用
其后代项（mod、fn），通过以下“回溯”方式调用非直接后代项<ul>
<li><code>super</code>直接父mod路径起始：<code>super::child_mod</code></li>
<li><code>::</code>根mod起始：<code>::child_mod</code></li>
</ul>
</li>
<li>fn和mod的可见规则相似的，只是注意：fn是否可见只与mod有关
，mod是否可见只有crate有关。从这个意义上说，crate不能
看作是“大号“的mod</li>
</ul>
<h2 id="相关关键字"><a href="#相关关键字" class="headerlink" title="相关关键字"></a>相关关键字</h2><p>好像都是单一用途（意义），罕见</p>
<ul>
<li><code>extern</code>：<strong>引入</strong>外部crate（同时包含<code>use crate_name;</code>）</li>
<li><code>crate</code>：标记外部crate</li>
<li><code>mod</code>/<code>fn</code>：<strong>声明定义（注册）</strong>mod/fn（同crate内仅一次
，位于其父mod处）</li>
<li><code>use</code>：<strong>声明使用</strong>项（mod、fn），用于缩略代码</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:37.000Z" title="3/21/2019, 5:27:37 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-02-17T03:57:08.000Z" title="2/17/2019, 11:57:08 AM">2019-02-17</time></span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a></span><span class="level-item">3 minutes read (About 456 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Rust/error_handling.html">Rust 错误（Panic）处理规范</a></h1><div class="content"><h2 id="panic-与不可预期（不可恢复）错误"><a href="#panic-与不可预期（不可恢复）错误" class="headerlink" title="panic!与不可预期（不可恢复）错误"></a>panic!与不可预期（不可恢复）错误</h2><p><code>panic!</code>时程序默认开始展开（unwinding）、回溯栈并清理函数据</p>
<p>如果希望二进制文件尽量小，可以选择“终止（abort）”，此时
程序内存由操作系统进行清理，在<code>Cargo.toml</code>中添加</p>
<pre><code>[profile]
panic=&#39;abort&#39;

[profile.release]
panic=&#39;abort&#39;
</code></pre><p>前者是配置debug时，后者配置release版本</p>
<h2 id="Result与潜在（可预期、可恢复）错误"><a href="#Result与潜在（可预期、可恢复）错误" class="headerlink" title="Result与潜在（可预期、可恢复）错误"></a>Result与潜在（可预期、可恢复）错误</h2><h3 id="Result枚举类型"><a href="#Result枚举类型" class="headerlink" title="Result枚举类型"></a>Result枚举类型</h3><pre><code>Result&lt;T, E&gt;&#123;
    Ok&lt;T&gt;,
    Err&lt;E&gt;,
&#125;
</code></pre><ul>
<li><code>T</code>：成功时<code>Ok</code>成员中的数据类型</li>
<li><code>E</code>：失败时<code>Err</code>成员中返回的数据类型</li>
</ul>
<h3 id="直接处理"><a href="#直接处理" class="headerlink" title="直接处理"></a>直接处理</h3><ul>
<li><p>对<code>Result</code>值进行模式匹配，分别处理</p>
<p>let f = File::open(“hello.txt”);
let mut f = match f {
   Ok(file) =&gt; file,
   Err(error) =&gt; panic!(“error:{:?}”, error),
}</p>
</li>
<li><p>使用<code>Result</code>上定义的方法（类似以上）</p>
<ul>
<li><p><code>Result.unwrap()</code></p>
<ul>
<li><code>T = Ok&lt;T&gt;.unwrap()</code></li>
<li><code>Err&lt;E&gt;.unwrap()</code>使用默认信息调用<code>panic</code></li>
</ul>
</li>
<li><p><code>Result.expect(&amp;str)</code></p>
<ul>
<li><code>T = Ok&lt;T&gt;.expect(&amp;str)</code></li>
<li><code>Err&lt;E&gt;.expect(&amp;str)</code>使用<code>&amp;str</code>调用<code>!panic</code></li>
</ul>
</li>
<li><p><code>Result.unwrap_or_else</code></p>
<p>  Result.unwrap_or_else(|err|{</p>
<pre><code>  clojure...
</code></pre><p>  })</p>
<ul>
<li><code>T = Ok&lt;T&gt;.unwrap_or_else()</code></li>
<li><code>Err&lt;E&gt;.unwrap_or_else()</code>将<code>E</code>作为闭包参数调用
闭包</li>
</ul>
</li>
<li><p><code>Result.is_err()</code></p>
<ul>
<li><code>False = Ok&lt;T&gt;.is_err()</code></li>
<li><code>True = Err&lt;E&gt;.is_err()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="传播错误（Propagating）"><a href="#传播错误（Propagating）" class="headerlink" title="传播错误（Propagating）"></a>传播错误（Propagating）</h3><p>对<code>Result</code>对象进行匹配，提前返回<code>Err&lt;E&gt;</code>，需要注意返回值
类型问题，尤其是在可能存在多处潜在错误需要返回</p>
<pre><code>let f = File:open(&quot;hello.txt&quot;);
let mut f match f &#123;
    Ok(file) =&gt; file,
    Err(error) =&gt; return Err(error),
&#125;
</code></pre><p><code>?</code>简略写法（效果同上）</p>
<pre><code>let mut f = File::open(&quot;hello.txt&quot;)?
</code></pre><ul>
<li><code>?</code>会把<code>Err(error)</code>传递给<code>from</code>函数（定义在标准库<code>From</code>
trait中），将错误从转换为函数<strong>返回值</strong>中的类型，潜在
错误类型都实现了<code>from</code>函数</li>
<li><code>?</code>只能用于返回值为<code>Result</code>类型的函数内，因为其”返回值”
就是<code>Err(E)</code>（如果有）</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:37.000Z" title="3/21/2019, 5:27:37 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-02-17T03:57:08.000Z" title="2/17/2019, 11:57:08 AM">2019-02-17</time></span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a></span><span class="level-item">21 minutes read (About 3104 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Rust/ownership.html">Rust 所有权、引用、生命周期</a></h1><div class="content"><h2 id="变量、值、所有权"><a href="#变量、值、所有权" class="headerlink" title="变量、值、所有权"></a>变量、值、所有权</h2><h3 id="变量、值"><a href="#变量、值" class="headerlink" title="变量、值"></a>变量、值</h3><blockquote>
<ul>
<li>变量：用来代表值进行操作、没有对应内存空间的字符串，
  如：a，b</li>
<li>值：在内存中有对应的空间，如：5，”asdf”</li>
</ul>
</blockquote>
<p>变量默认不可变</p>
<ul>
<li><p>var变量绑定的<strong>值1</strong>不能更改，对应的内存数据不能改变</p>
<ul>
<li><p>不允许赋值操作，但是变量的声明和绑定可以分开，即使
声明不可变变量，也可以之后绑定值，注意区分</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">ret_int</span></span>() -&gt; <span class="built_in">i32</span>&#123; <span class="number">5</span> &#125;</span><br><span class="line"><span class="comment">// 以下代码可编译，且正确</span></span><br><span class="line"><span class="keyword">let</span> num = &amp;<span class="keyword">mut</span> ret_int();</span><br><span class="line">*num += <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 以下不可</span></span><br><span class="line"><span class="keyword">let</span> num;</span><br><span class="line">num = &amp;<span class="keyword">mut</span> ret_int();</span><br><span class="line">*num += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h1 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h1></li>
<li><p>不允许获取可变引用、所有权转移给可变变量（对函数
即限制参数类型，类似于默认const)</p>
</li>
</ul>
<p>若其中包含（或就是）引用，引用值是可以更改的</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">ref</span> = &amp;<span class="keyword">mut</span> ori;</span><br><span class="line">*<span class="keyword">ref</span> += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是变量var可以重新绑定为其他的值</p>
<ul>
<li><p>虽然<strong>值1</strong>不能更改，但是var变量可以绑定其他值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> var = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> var = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>此时虽然<strong>值1</strong>虽然无法被访问、使用，但是离开作用域
之前不会被丢弃，只是被“隐藏”</p>
</li>
</ul>
</li>
</ul>
<h3 id="所有权规则"><a href="#所有权规则" class="headerlink" title="所有权规则"></a>所有权规则</h3><ul>
<li><p>每个值（内存）都有一个称为<strong>所有者（owner）</strong>的变量</p>
</li>
<li><p>值（内存）有且只有一个所有者</p>
<ul>
<li>如果多个变量拥有某值（内存）所有权，有可能会多次释放
同一内存，造成内存二次污染</li>
<li>rust中只有一个变量拥有所有权避免内存污染问题</li>
</ul>
</li>
<li><p>所有者（变量）离开作用域，值将被丢弃（内存被回收）
（rust为其调用<code>drop</code>函数）</p>
<blockquote>
<p>   在生命周期结束时释放资源的方法在C++称为RAII
   （Resource Aquistion Is Initialization），这里的
   initialization是指对资源跟踪、管理初始化，RAII就是
   将对象（变量）同资源生命周期相关联，在C++中体现为
   析构函数</p>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>rust的所有权管理是编译是进行检查，没有runtime性能损失</li>
<li>相较于gc（垃圾回收）性能影响较小</li>
<li>相较于手动分配、释放内存不容易代码疏忽导致的内存问题</li>
</ul>
</blockquote>
<h3 id="所有权转移"><a href="#所有权转移" class="headerlink" title="所有权转移"></a>所有权转移</h3><h4 id="Drop和Copytrait"><a href="#Drop和Copytrait" class="headerlink" title="Drop和Copytrait"></a><code>Drop</code>和<code>Copy</code>trait</h4><ul>
<li><code>Drop</code>：值离开作用域时rust自动调用</li>
<li><code>Copy</code>：赋值时调用，赋值之后原变量仍然可以继续使用</li>
</ul>
<p>需要分配内存、本身就是某种资源形式不会实现<code>Copy</code> trait，实现
<code>Copy</code> trait类型有</p>
<ul>
<li>存储在stack上的类型，值拷贝速度快，定长</li>
<li>整型、bool型、浮点型这样（标量）原生数据类型</li>
<li>所有元素都copy的tuple</li>
</ul>
<p>rust不允许任何类型同时同时实现<code>Drop</code>和<code>Copy</code>trait</p>
<h4 id="所有权转移-1"><a href="#所有权转移-1" class="headerlink" title="所有权转移"></a>所有权转移</h4><p>对于没有实现<code>Copy</code>trait的类型：赋值（包括函数传参、返回值）
操作会将原变量所有权转移（move）给新变量，之后不允许使用
原变量，编译时即报错，这样就避免了同时释放同一内存造成
二次污染</p>
<blockquote>
<p>   有些情况下所有权不允许转移，如vec中元素</p>
</blockquote>
<p>实现了<code>Copy</code>trait的类型，赋值（包括函数传参）操作将按照
<code>Copy</code>trait复制一个新值，将新值（包括所有权）赋给新变量，
如此原变量可以之后继续使用，没有违反rust的所有权规则，因为
实际上两个值（内存）</p>
<h2 id="Reference（引用）"><a href="#Reference（引用）" class="headerlink" title="Reference（引用）"></a>Reference（引用）</h2><p>引用（references，&amp;，获取引用作为函数参数称为<strong>借用</strong>）</p>
<p>单一所有权情况下，仅仅想使用值而不获取所有权，尤其是函数
传参，虽然可以获取所有权之后再将所有权转移，但是操作麻烦，
而且函数返回值可能有其他用途</p>
<h3 id="引用特点"><a href="#引用特点" class="headerlink" title="引用特点"></a>引用特点</h3><ul>
<li>引用允许变量使用值但是不获取所有权</li>
<li>引用离开作用域时不会丢弃其指向的值，不会内存二次污染</li>
<li>分为可变引用、不可变引用，类似于变量绑定</li>
</ul>
<h3 id="引用规则"><a href="#引用规则" class="headerlink" title="引用规则"></a>引用规则</h3><ul>
<li>任意时间内，特定作用域、特定变量只允许<ul>
<li>一个可变引用</li>
<li>任意数量不可变引用</li>
</ul>
</li>
<li>引用必须总是有效的</li>
</ul>
<p>注意：<strong>获取可变引用</strong>和<strong>引用赋值给可变变量</strong>的区别</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> n = &amp;m;</span><br><span class="line">	<span class="comment">//将引用赋值给可变变量</span></span><br><span class="line"><span class="keyword">let</span> n = &amp;<span class="keyword">mut</span> m;</span><br><span class="line">	<span class="comment">//获取可变引用赋值给变量，这里会报错，因为`m`是不可变</span></span><br><span class="line">	<span class="comment">//变量，不允许通过其获取可变引用</span></span><br></pre></td></tr></table></figure>
<h4 id="规则1"><a href="#规则1" class="headerlink" title="规则1"></a>规则1</h4><p>第一条规则避免以下情况导致的数据竞争</p>
<blockquote>
<ul>
<li>多个指针可以访问同一数据</li>
<li>至少有一个指针可以写入数据</li>
<li>没有有效的同步数据访问机制</li>
</ul>
</blockquote>
<p>这条规则在<strong>显式</strong>的赋值、声明易发现、遵守，需要注意的是</p>
<ul>
<li><strong>函数调用</strong>创建可变引用</li>
<li><strong>自运算符</strong>创建可变引用（<code>+=</code>、<code>*=</code>）</li>
</ul>
<h4 id="规则2"><a href="#规则2" class="headerlink" title="规则2"></a>规则2</h4><p>rust会在编译时检查引用是否有效，即引用是否是悬垂指针</p>
<blockquote>
<p>   悬垂指针：指向的内存已经被分配给其他所有者或值被丢弃，
    常见于函数中返回局部变量</p>
</blockquote>
<p>对于rust中的“变量（有所有权）”而言则不存此问题</p>
<ul>
<li>赋值操作要么转移所有权，值不会被丢弃</li>
<li>要么实现<code>copy</code>trait，返回新值</li>
</ul>
<h3 id="解引用"><a href="#解引用" class="headerlink" title="解引用"></a>解引用</h3><p>rust中引用更像c中的指针</p>
<ul>
<li><p>引用有对应的解引用（dereferance），且“多层次”引用也需要
”多层次“解引用</p>
</li>
<li><p>教程上的引用附图也是引用“指向”原“变量”，不是“值（内存）”</p>
</li>
</ul>
<h4 id="自动引用和解引用"><a href="#自动引用和解引用" class="headerlink" title="自动引用和解引用"></a>自动引用和解引用</h4><ul>
<li>方法中<code>self</code></li>
<li><code>+</code>自己实现了解引用（不知道是否算自动解引用）<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Add&lt;&amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span>&gt; <span class="keyword">for</span> <span class="built_in">i32</span>&#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> Add&lt;<span class="built_in">i32</span>&gt; <span class="keyword">for</span> <span class="built_in">i32</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><h1 id="todo-1"><a href="#todo-1" class="headerlink" title="todo"></a>todo</h1></li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul>
<li>rust<strong>每个引用</strong>都有生命周期，即引用保持有效的作用域
（避免悬垂引用）</li>
<li><p>大部分情况下，生命周期是隐含、可推断的
（类似于类型可推断）</p>
<ul>
<li>借用检查器（编译器一部分）可以分析函数代码得到引用的
生命周期，通过作用域确保借用有效</li>
<li>但是函数被调用、被函数之外的代码引用时，每次生命周期
都不一样，rust无法分析</li>
</ul>
</li>
<li><p>有时也会出现引用生命周期以一些不同的方式相关联，此时需要
使用<strong>泛型</strong>生命周期参数标注关系</p>
</li>
</ul>
<h3 id="生命周期注解语法"><a href="#生命周期注解语法" class="headerlink" title="生命周期注解语法"></a>生命周期注解语法</h3><ul>
<li>生命周期参数必须以”’“开头（和一般泛型参数区别）</li>
<li>参数名称通常小写</li>
<li>位于引用”&amp;“之后，”mut“（如果存在）之前</li>
</ul>
<h3 id="函数生命周期注解"><a href="#函数生命周期注解" class="headerlink" title="函数生命周期注解"></a>函数生命周期注解</h3><p>只存在于函数<strong>签名</strong>中</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> x.len() &gt; y.len()&#123;</span><br><span class="line">		x</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		y</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>生命周期注解并不改变参数、返回值的生命周期，只是在
函数签名中增加了生命周期“协议”</p>
<ul>
<li>函数体中返回值不遵守“协议”，函数体编译错误</li>
<li>传参、<strong>返回值接收变量</strong>不遵守“协议”，调用处编译错误</li>
<li>生命周期注解是用于联系函数不同参数和返回值的生命
周期，一旦形成某种联系，编译器就能获取足够信息判断
引用是否有效（是否内存安全、产生悬垂指针）</li>
</ul>
</li>
<li><p>生命周期注解是为了保证函数<strong>返回值</strong>引用有效，同函数
用途有关，因此以下签名也可以通过编译</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>, y: &amp;<span class="built_in">str</span>) -&gt; &amp;a&#x27; <span class="built_in">str</span>&#123;</span><br><span class="line">	x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="生命周期注解省略规则"><a href="#生命周期注解省略规则" class="headerlink" title="生命周期注解省略规则"></a>生命周期注解省略规则</h3><ul>
<li>每个是引用的<strong>参数</strong>都有自己的输入生命周期参数</li>
<li>如果只有一个输入生命周期参数，会被赋予所有输出生命周期
参数</li>
<li>若<strong>方法</strong>存在多个输入生命周期参数，且首个参数<code>self</code>
为引用（<code>&amp;self</code>、<code>&amp;mut self</code>），将其生命周期参数赋给
所有输出生命周期参数</li>
</ul>
<p>编译器检查完以上三条规则之后，所有引用均有生命周期参数，则
无需额外生命周期注解，但是若函数体返回值不遵守“协议”，仍
无法编译通过</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; stct&lt;<span class="symbol">&#x27;a</span>&gt;&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">other_str</span></span>(&amp;<span class="keyword">self</span>, &amp;str1) -&gt; &amp;<span class="built_in">str</span>&#123;</span><br><span class="line">		str1</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查完规则之后，所有引用均有注解，但是</span></span><br><span class="line"><span class="comment">// 函数体中的生命周期和签名中不一致</span></span><br></pre></td></tr></table></figure>
<p>这个例子说明生命周期注解不只是“注解”，是真的需要例子考虑
返回值的生命周期</p>
<h3 id="结构体生命周期注解"><a href="#结构体生命周期注解" class="headerlink" title="结构体生命周期注解"></a>结构体生命周期注解</h3><p>在结构体成员为引用时需要增加生命周期注解</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImportantExcerpt</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;&#123;</span><br><span class="line">	part: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此类结构体在实现方法时不能省略生命周期注解，方法签名可根据
规则省略注解</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt;&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> </span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泛型结构体（枚举）作为函数参数、返回值类型时，替换泛型参数
为引用时也需要添加生命周期注解</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(args: &amp;[<span class="built_in">String</span>]) -&gt; <span class="built_in">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>&gt;&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">search</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="built_in">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>) -&gt; <span class="built_in">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态生命周期（-39-static）"><a href="#静态生命周期（-39-static）" class="headerlink" title="静态生命周期（&#39;static）"></a>静态生命周期（<code>&#39;static</code>）</h3><ul>
<li>存活于整个程序生命期间</li>
<li>所有的<code>&amp;str</code>（字符串字面值）都拥有<code>&#39;static</code>生命周期</li>
<li>可以用于指定引用的生命周期，但是使用之前三思，应先考虑
悬垂引用、生命周期不匹配的问题</li>
</ul>
<h3 id="高级生命周期"><a href="#高级生命周期" class="headerlink" title="高级生命周期"></a>高级生命周期</h3><h4 id="Lifetime-Subtyping"><a href="#Lifetime-Subtyping" class="headerlink" title="Lifetime Subtyping"></a>Lifetime Subtyping</h4><p>生命周期子类型：确保某个生命周期长于另一个生命周期</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Context</span></span>&lt;<span class="symbol">&#x27;s</span>&gt;(&amp;<span class="symbol">&#x27;s</span> <span class="built_in">str</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Parser</span></span>&lt;<span class="symbol">&#x27;c</span>, <span class="symbol">&#x27;s</span>: <span class="symbol">&#x27;c</span>&gt;&#123;</span><br><span class="line">	<span class="comment">//`&#x27;s: &#x27;c`声明一个不短于`&#x27;c`的生命周期`&#x27;s`</span></span><br><span class="line">	context: &amp;<span class="symbol">&#x27;c</span> Context&lt;<span class="symbol">&#x27;s</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;c</span>, <span class="symbol">&#x27;s</span>: <span class="symbol">&#x27;c</span>&gt; Parser&lt;<span class="symbol">&#x27;c</span>, <span class="symbol">&#x27;s</span>: <span class="symbol">&#x27;c</span>&gt;&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">parse</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;(), &amp;<span class="symbol">&#x27;s</span> <span class="built_in">str</span>&gt;&#123;</span><br><span class="line">		<span class="comment">//根据生命周期省略规则，若`&#x27;s`省略，则赋予`&amp;self`的</span></span><br><span class="line">		<span class="comment">//生命周期</span></span><br><span class="line">		<span class="comment">//使用生命周期子类型语法，指定（要求）`&amp;str`生命周期</span></span><br><span class="line">		<span class="comment">//长于`&amp;Context`</span></span><br><span class="line">		<span class="literal">Err</span>(&amp;<span class="keyword">self</span>.context.<span class="number">0</span>[<span class="number">1</span>..]</span><br><span class="line">		<span class="comment">//这里没有考虑字符串切片的有效性，如果这个切片不是</span></span><br><span class="line">		<span class="comment">//有效的unicode字符串（utf8字节序列），会panic</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">parse_context</span></span>(context: Context) -&gt; <span class="built_in">Result</span>&lt;(), &amp;<span class="built_in">str</span>&gt;&#123;</span><br><span class="line">	<span class="comment">//方法获取`context`的所有权</span></span><br><span class="line">	Parser&#123; context: &amp;Context &#125;.parse()</span><br><span class="line">	<span class="comment">//`&amp;Context`的生命周期只有整个函数内</span></span><br><span class="line">	<span class="comment">//函数体中的返回值是`context.0[1..]`，为保证返回值有效，</span></span><br><span class="line">	<span class="comment">//其生命周期必须长于整个函数</span></span><br><span class="line">	<span class="comment">//返回值中的`&amp;str`类型的生命周期是`&#x27;s`，长于context`&#x27;c`</span></span><br><span class="line">	<span class="comment">//满足返回值的生命周期长于函数的要求，能编译通过</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Lifetime-Bounds"><a href="#Lifetime-Bounds" class="headerlink" title="Lifetime Bounds"></a>Lifetime Bounds</h4><p>生命周期bounds：帮助Rust验证泛型引用不会比其引用的数据存在
更久</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ref</span></span>&lt;<span class="symbol">&#x27;a</span>, T: <span class="symbol">&#x27;a</span>&gt; &#123; &amp;<span class="symbol">&#x27;a</span> T &#125;;</span><br><span class="line">	<span class="comment">//为`T`增加生命周期bound，指定`T`引用的生命周期不短于</span></span><br><span class="line">	<span class="comment">//`&#x27;a`，保证结构体成员有效</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StaticRef</span></span>&lt;T: <span class="symbol">&#x27;static</span>&gt; &#123; &amp;<span class="symbol">&#x27;static</span> T &#125;;</span><br><span class="line">	<span class="comment">//限制`T`为只拥有`&#x27;static`生命周期的引用或没有引用的类型</span></span><br></pre></td></tr></table></figure>
<h4 id="trait对象生命周期推断"><a href="#trait对象生命周期推断" class="headerlink" title="trait对象生命周期推断"></a>trait对象生命周期推断</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Red</span></span> &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ball</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">	diameter: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Red <span class="keyword">for</span> Ball&lt;<span class="symbol">&#x27;a</span>&gt; &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> num = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">let</span> obj = <span class="built_in">Box</span>::new(Ball &#123;diameter: &amp;num&#125;) <span class="keyword">as</span> <span class="built_in">Box</span>&lt;Red&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码能编译通过，因为生命周期和trait对象必须遵守：</p>
<ul>
<li>trait对象默认的生命周期为<code>&#39;static</code></li>
<li>若有<code>&amp;&#39;a X</code>或<code>&amp;&#39;a mut x</code>，则默认生命周期为<code>&#39;a</code></li>
<li>如有<code>T: &#39;a</code>从句，则默认生命周期为<code>&#39;a</code></li>
<li>若有多个类似<code>T: &#39;a</code>从句，则需明确指定trait对象生命周期，
<code>Box&lt;Red + &#39;a&gt;</code>或<code>Box&lt;Red + &#39;static&gt;</code><h1 id="todo-2"><a href="#todo-2" class="headerlink" title="todo"></a>todo</h1></li>
</ul>
<p>正如其他bound，任何<code>Red</code>trait的实现内部包含引用，必须拥有和
trait对象bound中所指定的相同的生命周期</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:37.000Z" title="3/21/2019, 5:27:37 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-02T03:09:57.000Z" title="8/2/2021, 11:09:57 AM">2021-08-02</time></span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a></span><span class="level-item">4 minutes read (About 673 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Rust/test.html">Rust 测试</a></h1><div class="content"><h2 id="测试常用宏、属性注解"><a href="#测试常用宏、属性注解" class="headerlink" title="测试常用宏、属性注解"></a>测试常用宏、属性注解</h2><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><ul>
<li><code>assert!(exp,...)</code></li>
<li><code>assert_eq!(val1, val2,...)</code></li>
<li><code>assert_ne!(val1, val2,...)</code>
以上宏均可以传入自定义信息，所有的<code>...</code>中参数都将传递给
<code>format!</code>宏</li>
</ul>
<h3 id="属性注解"><a href="#属性注解" class="headerlink" title="属性注解"></a>属性注解</h3><ul>
<li><p><code>#[test]</code>：<code>$&gt;cargo test</code>时将测试此函数 </p>
</li>
<li><p><code>#[ignore]</code>：除非指定，否则<code>$&gt;cargo test</code>默认不测试此
函数（仍需和<code>#[test]</code>注解）</p>
</li>
<li><p><code>#[should_panic(expected=&amp;str)]</code>：测试中出现<code>panic</code>测试
通过，可以传递<code>expected</code>参数，当参数为<code>panic</code>信息的起始
子串才通过</p>
</li>
</ul>
<h2 id="cargo-test命令"><a href="#cargo-test命令" class="headerlink" title="cargo test命令"></a><code>cargo test</code>命令</h2><p>命令行参数和可执行文件参数用“—”分隔</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt;cargo <span class="built_in">test</span> cargo_params -- bin_params </span><br></pre></td></tr></table></figure>
<h3 id="可执行文件常用参数"><a href="#可执行文件常用参数" class="headerlink" title="可执行文件常用参数"></a>可执行文件常用参数</h3><ul>
<li>控制测试线程数目<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt;cargo <span class="built_in">test</span> -- --test-thread=1（不使用任何并行机制）</span><br></pre></td></tr></table></figure></li>
<li>禁止捕获输出（测试函数中的标准输出）<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt;cargo <span class="built_in">test</span> -- --nocapture</span><br></pre></td></tr></table></figure></li>
<li>测试<code>#[ignore]</code>标注的测试函数<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt;cargo <span class="built_in">test</span> -- --ignore</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="命令行常用参数"><a href="#命令行常用参数" class="headerlink" title="命令行常用参数"></a>命令行常用参数</h3><ul>
<li>指定部分测试函数<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt;cargo <span class="built_in">test</span> function_name（cargo匹配以此开头的函数）</span><br></pre></td></tr></table></figure></li>
<li>指定部分集成测试文件<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt;cargo <span class="built_in">test</span> --<span class="built_in">test</span> test_filename</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="单元测试、集成测试"><a href="#单元测试、集成测试" class="headerlink" title="单元测试、集成测试"></a>单元测试、集成测试</h2><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>在隔离环境中一次测试一个模块，可以测试私有接口，常用做法是
在每个文件中创建包含测试函数的tests模块，并使用
<code>#[cfg(test)]</code>标注，告诉rust仅在<code>cargo test</code>时才编译该mod</p>
<h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><p>相当于外部库，和用户使用代码的方式相同，只能测试公有接口，
可以同时测试多个模块</p>
<p>新建<code>/project/tests</code>目录（和<code>src</code>同级），cargo自动寻找此目录
中集成测试文件</p>
<ul>
<li><p>cargo将每个<strong>文件</strong>当作单独的<strong>crate</strong>编译（模仿用户）
其中的<strong>文件</strong>也不能共享相同的行为（fn、mod）</p>
<ul>
<li><p>需要像外部用户一样<code>extern crate</code>引入外部文件，因此
如果二进制库没有<code>lib.rs</code>文件，无法集成测试，推荐
采用<code>main.rs</code>调用<code>lib.rs</code>的逻辑结构</p>
</li>
<li><p>不需要添加任何<code>#[cfg(test)]</code>注解，cargo会自动将
<code>tests</code>中文件只在cargo test时编译</p>
</li>
<li><p>即使文件中不存在任何<code>#[test]</code>注解的测试函数，仍然会
对其进行测试，只是结果永远是通过</p>
</li>
</ul>
</li>
<li><p>而文件夹则不会当作<strong>测试crate</strong>编译</p>
<ul>
<li><p><code>cargo test</code>不会将文件夹视为<strong>测试crate</strong>，而是看作
一个mod</p>
</li>
<li><p>所以可以创建<code>tests/common/mod.rs</code>，并在测试文件中
通过<code>mod common;</code>声明定义<code>common mod</code>共享行为
（相当于所有的测试crate = 测试文件 + <code>common mod</code>）</p>
</li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:37.000Z" title="3/21/2019, 5:27:37 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-02-17T03:57:08.000Z" title="2/17/2019, 11:57:08 AM">2019-02-17</time></span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a></span><span class="level-item">a few seconds read (About 66 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Rust/twistes.html">Rust技巧</a></h1><div class="content"><h2 id="代码省略"><a href="#代码省略" class="headerlink" title="代码省略"></a>代码省略</h2><ul>
<li><code>for i in i.iter()</code></li>
<li><code>array[m..n]</code></li>
</ul>
<h2 id="问题明确"><a href="#问题明确" class="headerlink" title="问题明确"></a>问题明确</h2><ul>
<li>rust中slice也是左闭右开区间</li>
</ul>
<h2 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h2><ul>
<li>随便定义变量数据类型，编译后通过编译器给出的信息得到
某个函数返回值类型</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:37.000Z" title="3/21/2019, 5:27:37 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-02-17T03:57:08.000Z" title="2/17/2019, 11:57:08 AM">2019-02-17</time></span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a></span><span class="level-item">13 minutes read (About 1983 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Rust/unsafe_rust.html">Unsafe Rust</a></h1><div class="content"><p>不安全的Rust存在原因</p>
<ul>
<li>Rust在编译时强制执行内存安全保证，但这样的静态分析是
保守的，有些代码编译器认为不安全，但其实合法</li>
<li>底层计算机硬件的固有的不安全性，必须进行某些不安全操作
才能完成任务</li>
</ul>
<p>因此需要通过<code>unsafe</code>关键字切换到<strong>不安全的Rust</strong>，开启存放
不安全代码的块，只能在不安全Rust中进行的操作如下</p>
<ul>
<li>解引用裸指针，</li>
<li>调用不安全的函数、方法</li>
<li>访问或修改可变静态变量</li>
<li>实现不安全trait</li>
</ul>
<p>需要注意的是，<code>unsafe</code>不会关闭借用检查器或其它Rust安全检查，
在不安全Rust中仍然会检查引用，<code>unsafe</code>关键字只告诉编译器忽略
上述4中情况的内存安全检查，此4种的内存安全由用户自己保证，
这就保证出现内存安全问题只需要检查<code>unsafe</code>块。可以将不安全
代码封装进安全的抽象并提供API，隔离不安全代码。</p>
<h2 id="解引用裸指针（raw-pointer）"><a href="#解引用裸指针（raw-pointer）" class="headerlink" title="解引用裸指针（raw pointer）"></a>解引用裸指针（raw pointer）</h2><ul>
<li><code>*const T</code>：<code>T</code>类型不可变裸指针</li>
<li><code>*mut T</code>：<code>T</code>类型可变裸指针</li>
</ul>
<p>裸指针的上下文中，裸指针意味着指针解引用后不能直接赋值，
裸指针和引用、智能指针的区别</p>
<ul>
<li>允许忽略借用规则，允许同时拥有不可变和可变指针，或者
多个相同位置（值）的可变指针</li>
<li>不保证指向有效的内存</li>
<li>允许为空</li>
<li>不能实现任何自动清理功能</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> num = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> r1 = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;</span><br><span class="line"><span class="keyword">let</span> r2 = &amp;num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">i32</span>;</span><br><span class="line">	<span class="comment">//`as`将不可变引用和可变引用强转为对应的裸指针类型</span></span><br><span class="line">	<span class="comment">//同时创建`num`的可变裸指针和不可变裸指针</span></span><br><span class="line">	<span class="comment">//创建裸指针是安全的</span></span><br><span class="line"><span class="keyword">unsafe</span>&#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;r1 is: &#123;&#125;&quot;</span>, *r1);</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;r2 is: &#123;&#125;&quot;</span>, *r2);</span><br><span class="line">		<span class="comment">//解引用裸指针是不安全的，需要放在`unsafe`块中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> address = <span class="number">0x012345usize</span>;</span><br><span class="line">	<span class="comment">//创建任意地址</span></span><br><span class="line"><span class="keyword">let</span> r = address  <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;</span><br><span class="line">	<span class="comment">//创建指向任意内存地址的裸指针</span></span><br></pre></td></tr></table></figure>
<h2 id="调用不安全的函数或方法"><a href="#调用不安全的函数或方法" class="headerlink" title="调用不安全的函数或方法"></a>调用不安全的函数或方法</h2><p>不安全函数和方法类似常规，在开头有<code>unsafe</code>关键字标记，表示
函数含有<em>内存不安全</em>的内容，Rust不再保证此函数内存安全，需要
程序员保证。</p>
<p>但是包含不安全代码并不意味着整个函数都需要标记为不安全，相反
将不安全代码封装于安全函数中是隔离<code>unsafe</code>代码的方法。应该
将<strong>不安全代码与调用有关</strong>的函数标记为<code>unsafe</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">dangerous</span></span>() &#123;&#125;</span><br><span class="line">	<span class="comment">//`unsafe`关键字表示此函数为不安全函数，含有内存不安全</span></span><br><span class="line">	<span class="comment">//内容，需要程序员自身保证其内存安全</span></span><br><span class="line">	<span class="comment">//但是，包含不安全代码的函数不意味着整个函数都需要标记为</span></span><br><span class="line">	<span class="comment">//不安全，相反的，将不安全代码封装进安全函数是常用的</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//不安全函数体也是`unsafe`块，在其中进行不安全操作时，</span></span><br><span class="line">	<span class="comment">//不需要包裹于`unsafe`块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span>&#123;</span><br><span class="line">	dangerous();</span><br><span class="line">	<span class="comment">//调用不安全函数也需要在`unsafe`块中，表示调用者确认此</span></span><br><span class="line">	<span class="comment">//“不安全”函数在此上下文中是*内存安全*</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用不安全的函数时也需要放在<code>unsafe</code>中，表示程序员确认此函数
在调用上下文中是内存安全的。</p>
<h3 id="split-at-mut的实现"><a href="#split-at-mut的实现" class="headerlink" title="split_at_mut的实现"></a><code>split_at_mut</code>的实现</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> r = &amp;<span class="keyword">mut</span> v[..];</span><br><span class="line"><span class="keyword">let</span> (a, b)  r.split_at_mut(<span class="number">3</span>);</span><br><span class="line">	<span class="comment">//以index=3分隔为两个列表引用（左开右闭）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(a, &amp;<span class="keyword">mut</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="built_in">assert_eq!</span>(b, &amp;<span class="keyword">mut</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br></pre></td></tr></table></figure>
<p><code>split_at_mut</code>方法无法指通过安全Rust实现，一个大概的“函数”
实现可以如此</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::slice;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">split_at_mut</span></span>(slice: &amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>], mid: <span class="built_in">usize</span>) -&gt; (&amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>], &amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>]) &#123;</span><br><span class="line">	<span class="comment">//这里根据生命周期省略规则省略了生命周期注解</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//在所有权里就有提到，这里不也是可变引用吗，为啥这样</span></span><br><span class="line">	<span class="comment">//还可以通过编译，是对方法中的`self`有特殊的处理吗</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> len = slice.len();</span><br><span class="line">	<span class="keyword">let</span> ptr = slice.as_mut_ptr();</span><br><span class="line">		<span class="comment">//`as_mut_ptr`返回`*mut T`可变裸指针</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">assert!</span>(mid &lt;= len);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">unsafe</span>&#123;</span><br><span class="line">		(slice::from_raw_parts_mut(ptr, mid),</span><br><span class="line">			<span class="comment">//`from_raw_parts_mut`根据裸指针和长度两个参数</span></span><br><span class="line">			<span class="comment">//创建slice，其是不安全的，因为其参数是一个</span></span><br><span class="line">			<span class="comment">//裸指针，无法保证内存安全，另外长度也不总是有效</span></span><br><span class="line">		slice::from_raw_parts_mut(ptr.offset(mid <span class="keyword">as</span> <span class="built_in">isize</span>), len - mid))</span><br><span class="line">			<span class="comment">//`offset`同样是不安全的，其参数地址偏移量无法</span></span><br><span class="line">			<span class="comment">//保证始终有效</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用extern函数调用外部代码"><a href="#使用extern函数调用外部代码" class="headerlink" title="使用extern函数调用外部代码"></a>使用<code>extern</code>函数调用外部代码</h3><p><code>extern</code>关键字用于创建、使用外部函数接口</p>
<blockquote>
<ul>
<li>外部函数接口FFI：foreign function interface，编程语言
用以定义函数的方式，允许不同（外部）编程语言调用这些
函数</li>
<li>应用程序接口ABI：application binary interface，定义了
  如何在汇编层面调用函数</li>
</ul>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">	<span class="comment">//`&quot;C&quot;`定义了外部函数所使用的ABI</span></span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">abs</span></span>(input: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>;</span><br><span class="line">	<span class="comment">//希望调用的其他语言中的（外部）函数签名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">unsafe</span>&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;absolute value of -3 according to C: &#123;&#125;&quot;</span>, abs(-<span class="number">3</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>extern</code>块中声明的函数总是不安全的，因为其他语言并不强制执行
Rust的内存安全规则，且Rust无法检查，因此调用时需要放在
<code>unsafe</code>块中，程序员需要确保其安全</p>
<h3 id="通过其他语言调用Rust函数"><a href="#通过其他语言调用Rust函数" class="headerlink" title="通过其他语言调用Rust函数"></a>通过其他语言调用Rust函数</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line">	<span class="comment">//告诉Rust编译器不要mangle此函数名称</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">call_from_c</span></span>()&#123;</span><br><span class="line">	<span class="comment">//此函数编译器为动态库并从C语言中链接，就可在C代码中访问</span></span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;just called a Rust function from C!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>   mangle发生于编译器将函数名修改为不同的名称，这会增加
    用于其他编译器过程中的额外信息，但是会使其名称难以阅读
    而不同的编程语言的编译器mangle函数名的方式可能不同</p>
</blockquote>
<h2 id="访问或修改可变静态变量"><a href="#访问或修改可变静态变量" class="headerlink" title="访问或修改可变静态变量"></a>访问或修改可变静态变量</h2><p>全局变量：Rust中称为静态（static）变量</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> HELLO_WORLD: &amp;<span class="built_in">str</span> = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">	<span class="comment">//静态变量（不可变）</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;name is: &#123;&#125;&quot;</span>, HELLO_WORLD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>名称采用<code>SCREAMING_SNAKE_CASE</code>写法，必须标注变量类型</li>
<li>只能存储<code>‘static</code>生命周期的引用，因此无需显著标注</li>
<li>不可变静态变量和常量（不可变变量）有些类似<ul>
<li>静态变量值有固定的内存地址，使用其总会访问相同地址</li>
<li>常量则允许在任何被用到的时候复制数据</li>
</ul>
</li>
</ul>
<p>访问不可变静态变量是安全的，但访问、修改不可变静态变量都是
不安全的，因为可全局访问的可变数据难以保证不存在数据竞争，
因此在任何可能情况，优先使用智能指针，借助编译器避免数据竞争</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> COUNTER： <span class="built_in">u32</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//可变静态变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add_to_count</span></span>(inc: <span class="built_in">u32</span>)&#123;</span><br><span class="line">	<span class="keyword">unsafe</span> &#123;</span><br><span class="line">		COUNTER += inc;</span><br><span class="line">		<span class="comment">//修改可变静态变量</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	add_to_count(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsafe</span>&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;COUNTER: &#123;&#125;&quot;</span>, COUNTER);</span><br><span class="line">		<span class="comment">//访问可变静态变量</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现不安全trait"><a href="#实现不安全trait" class="headerlink" title="实现不安全trait"></a>实现不安全trait</h2><p>存在方法中包含编译器不能验证的不变量的trait时不安全的，可以
在<code>trait</code>前增加<code>unsafe</code>将trait生命为<code>unsafe</code>，且实现trait
也需要标记为<code>unsafe</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="class"><span class="keyword">trait</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> Foo <span class="keyword">for</span> <span class="built_in">i32</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如为裸指针类型实现（标记）<code>Send</code>、<code>Sync</code>trait时需要标记
<code>unsafe</code>，因为Rust不能验证此类型可以安全跨线程发送或多线程
访问，需要自行检查</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:37.000Z" title="3/21/2019, 5:27:37 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-04T03:25:02.000Z" title="8/4/2021, 11:25:02 AM">2021-08-04</time></span><span class="level-item"><a class="link-muted" href="/categories/Math-Analysis/">Math Analysis</a><span> / </span><a class="link-muted" href="/categories/Math-Analysis/Optimization/">Optimization</a></span><span class="level-item">11 minutes read (About 1640 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Math-Analysis/Optimization/conjugate_gradient.html">Conjugate Gradient Method</a></h1><div class="content"><h2 id="共轭方向"><a href="#共轭方向" class="headerlink" title="共轭方向"></a>共轭方向</h2><blockquote>
<ul>
<li><p>设G为$n * n$阶正定对称矩阵，若$d^{(1)}, d^{(2)}$满足</p>
<script type="math/tex; mode=display">(d^{(1)})^T G d^{(2)} = 0</script><p>  则称$d^{(1)}, d^{(2)}$关于G共轭</p>
</li>
<li><p>类似正交方向，若$d^{(1)},\cdots,d^{(k)}(k \leq n)$关于
  G两两共轭，则称其为G的k个共轭方向</p>
</li>
</ul>
</blockquote>
<ul>
<li>特别的，$G=I$时，共轭方向就是正交方向</li>
</ul>
<h3 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h3><blockquote>
<ul>
<li>设目标函数为<script type="math/tex; mode=display">
  f(w) = \frac 1 2 w^T w + r^T w + \sigma</script>  $q^{(1)}, \cdots, q^{(k)}$是$k, k \leq n$个非零正交方向
  ，从任意初始点$w^{(1)}$出发，依次沿着以上正交方向做
  <strong>精确一维搜索</strong>，得到$w^{(1)}, \cdots, w^{(k+1)}$，
  则$w^{(k+1)}$是$f(w)$在线性流形<script type="math/tex; mode=display">
  \bar W_k = \{w = w^{(1)} + \sum_{i=1}^k \alpha_i q^{(i)}
      | -\infty < \alpha_i < +\infty \}</script>  上的唯一极小点，特别的k=n时，$w^{(n+1)}$是$f(w)$在整个
  空间上的唯一极小点</li>
</ul>
</blockquote>
<ul>
<li><p>$\bar W_k$上的存在唯一极小点$\hat w^{(k)}$，在所有方向
都是极小点，所以有</p>
<script type="math/tex; mode=display">
<\triangledown f(\hat w^{(k)}), q^{(i)}> = 0, i=1,2,..</script></li>
<li><p>将$\hat w^{(k)}$由正交方向表示带入梯度，求出系数表达式</p>
</li>
<li><p>解精确搜索步长，得到$w^{(k+1)}$系数表达式</p>
</li>
</ul>
<h3 id="扩展子空间定理"><a href="#扩展子空间定理" class="headerlink" title="扩展子空间定理"></a>扩展子空间定理</h3><blockquote>
<ul>
<li>设目标函数为<script type="math/tex; mode=display">
  f(w) = \frac 1 2 x^T G x + r^T x + \sigma</script>  $d^{(1)}, \cdots, d^{(k)}$是$k, k \leq n$个非零正交方向
  ，从任意初始点$x^{(1)}$出发，依次沿着以上正交方向做
  <strong>精确一维搜索</strong>，得到$x^{(1)}, \cdots, x^{(k+1)}$，
  则$x^{(k+1)}$是$f(x)$在线性流形<script type="math/tex; mode=display">
  \bar x_k = \{x = x^{(1)} + \sum_{i=1}^k \alpha_i d^{(i)}
      | -\infty < \alpha_i < +\infty \}</script>  上的唯一极小点，特别的k=n时，$x^{(n+1)}$是$f(x)$在整个
  空间上的唯一极小点</li>
</ul>
</blockquote>
<ul>
<li>引进变换$w = \sqrt G x$即可证</li>
</ul>
<blockquote>
<ul>
<li>在以上假设下，有<script type="math/tex; mode=display">
  <\triangledown f(x^{(k+1)}), d^{(i)}> = 0, i=1,2...</script></li>
</ul>
</blockquote>
<h2 id="Conjugate-Gradient-Method"><a href="#Conjugate-Gradient-Method" class="headerlink" title="Conjugate Gradient Method"></a><em>Conjugate Gradient Method</em></h2><p>共轭梯度法</p>
<h3 id="对正定二次函数函数"><a href="#对正定二次函数函数" class="headerlink" title="对正定二次函数函数"></a>对正定二次函数函数</h3><script type="math/tex; mode=display">
f(x) = \frac 1 2 x^T G x + r^T x + \sigma</script><ul>
<li><p>任取初始点$x^{(1)}$，若$\triangledown f(x^{(1)}) = 0$，
停止计算，得到极小点$x^{(1)}$，否则取</p>
<script type="math/tex; mode=display">
d^{(1)} = -\triangledown f(x^{(1)})</script></li>
<li><p>沿着$d^{(1)}$方向进行精确一维搜索得到$x^{(2)}$，若
$\triangledown f(x^{(2)}) \neq 0$，令</p>
<script type="math/tex; mode=display">
d^{(2)} = -\triangledown f(x^{(2)}) + \beta_1^{(2)}
   d^{(1)}</script><p>且满足$(d^{(1)})^T G d^{(2)} = 0$，即二者共轭，可得</p>
<script type="math/tex; mode=display">
\beta_1^{(2)} = \frac {(d^{(1)})^T G \triangledown
   f(x^{(2)})} {((d^{(1)})^T G d^{(1)})}</script><ul>
<li>这里$d^{(2)}$方向的构造方式是为类似构造后面$d^{(k)}$
，得到能方便表示的系数</li>
<li>类似于将向量组$\triangledown f(x^{(i)})$正交化</li>
</ul>
</li>
<li><p>如此重复搜索，若$\triangledown f^(x^{i)}) \neq 0$，构造
$x^{(k)}$处搜索方向$d^{(k)}$如下</p>
<script type="math/tex; mode=display">\begin{align*}
0 & = (d^{(i)})^T G d^{(k)} \\
& = -(d^{(i)})T G \triangledown f(x^{(k)}) +
   \sum_{j=1}^{k-1} \beta_j^{(k)} (d^{(i)})^T G d^{(j)} \\
& = -(d^{(i)})^T G \triangledown f(x^{(k)}) +
   \beta_i^{(k)} (d^{(i)})^T G d^{(i)}
\end{align*}</script><p>可得</p>
<script type="math/tex; mode=display">
\beta_i^{(k)} = \frac {(d^{(i)})^T G \triangledown
   f(x^{(k)})} {(d^{(i)})^T G d^{(i)}}</script><p>此时$d^{(k)}$与前k-1个方向均关于G共轭，此k个方向是G的k个
共轭方向，由扩展空间子定理，$x^{(k+1)}$是整个空间上极小</p>
</li>
</ul>
<h4 id="计算公式简化"><a href="#计算公式简化" class="headerlink" title="计算公式简化"></a>计算公式简化</h4><p>期望简化$d^{(k)}$的计算公式</p>
<ul>
<li><p>由扩展子空间定理推论有
$\triangledown f(x^{(k)})^T d^{(i)} = 0, i=1,2…,k-1$
结合以上$d^{(k)}$的构造公式，有</p>
<script type="math/tex; mode=display">\begin{align*}
& \triangledown f(x^{(k)})^T \triangledown f(x^{(i)}) \\
= & \triangledown f(x^{(k)})^T ( -d^{(i)} +
   \beta_1^{(i)} d^{(1)} + \cdots +
   \beta_{i-1}^{(i)} d^{(i-1)} ) \\
= & 0, i=1,2,...,k-1
\end{align*}</script></li>
<li><p>则有</p>
<script type="math/tex; mode=display">\begin{align*}
(d^{(i)})^T G \triangledown f(x^{(k)}) & =
   \triangledown f(x^{(k)})^T G d^{(i)} \\
& = \frac 1 {\alpha_i} \triangledown f(x^{(k)})^T
   G (x^{(i+1)} - x^{(i)}) \\
& = \frac 1 {\alpha_i} \triangledown f(x^{(k)})^T
   (\triangledown f(x^{(i+1)}) -
   \triangledown f(x^{(i)})) \\
& = 0, i=1,2,\cdots,k-2
\end{align*}</script><blockquote>
<ul>
<li>$d^{(k)} = \frac 1 {\alpha_i} x^{(i+1)} - x^{(i)}$</li>
</ul>
</blockquote>
</li>
<li><p>所以上述$d^{(k)}$构造公式可以简化为</p>
<script type="math/tex; mode=display">
d^{(k)} = -\triangledown f(x^{(k)}) + \beta_{k-1}
   d^{(k-1)}</script></li>
<li><p>类似以上推导有</p>
<script type="math/tex; mode=display">\begin{align*}
(d^{(k-1)})^T G \triangledown f(x^{(k)}) & =
   \frac 1 {\alpha_i} \triangledown f(x^{(k)})^T
   (\triangledown f(x^{(k)}) -
   \triangledown f(x^{(k-1)})) \\
& = \frac 1 {\alpha_i} \triangledown f(x^{(k)})^T
   \triangledown f(x^{(k)}) \\
\end{align*}</script><script type="math/tex; mode=display">\begin{align*}
(d^{(k-1)})^T G d^{(k-1)} & = \frac 1 {\alpha_i}
   (d^{(k-1)})^T (\triangledown f(x^{(k)}) -
   \triangledown f(x^{(k-1)})) \\
& = -\frac 1 {\alpha_i} (d^{(k-1)})^T
   \triangledown f(x^{(x-1)}) \\
& = -\frac 1 {\alpha_i} (\triangledown f(x^{(k-1)}) -
   \beta_{k-2}d^{(k-2)})^T \triangledown f(x^{(x-1)}) \\
& = -\frac 1 {\alpha_i} \triangledown f(x^{(k-1)})^T
   \triangledown f(x^{(k-1)})
\end{align*}</script><p>最终的得到简化后系数$\beta_{k-1}, k&gt;1$的PRP公式</p>
<script type="math/tex; mode=display">
\beta_{k-1} = \frac {\triangledown f(x^{(k)})^T
   (\triangledown f(x^{(k)}) -
   \triangledown f(x^{(k-1)}))}
   {\triangledown f(x^{(k-1)})^T
       \triangledown f(x^{(k-1)})}</script><p>或FR公式</p>
<script type="math/tex; mode=display">
\beta_{k-1} = \frac {\|\triangledown f(x^{(k)})\|^2}
   {\|\triangledown f(x^{(k-1)}) \|^2}</script></li>
</ul>
<blockquote>
<ul>
<li><p>以上推导虽然是根据正定二次函数得出的推导，但是仍适用于
  一般可微函数</p>
</li>
<li><p>$\beta _ {k-1}$给出两种计算方式，应该是考虑到目标函数
  可能不是标准正定二次函数、一维搜索数值计算不精确性</p>
</li>
<li><p>将$\beta _ {k-1}$分子、分母推导到不同程度可以得到其他
  公式</p>
</li>
</ul>
</blockquote>
<ul>
<li><p>Growder-Wolfe公式</p>
<script type="math/tex; mode=display">
\beta_{k-1} = \frac {\triangledown f(x^{(k)})^T
   (\triangledown f(x^{(k)}) -
   \triangledown f(x^{(k-1)}))}
   {(d^{(k-1)})^T (\triangledown f(x^{(k)}) -
   \triangledown f(x^{(k-1)}))}</script></li>
<li><p>Dixon公式</p>
<script type="math/tex; mode=display">
\beta_{k-1} = \frac {\triangledown f(x^{(k)})^T
   \triangledown f(x^{(k)})}
   {(d^{(k-1)})^T \triangledown f(x^{(k-1)})}</script></li>
</ul>
<h3 id="FR-PRP算法"><a href="#FR-PRP算法" class="headerlink" title="FR/PRP算法"></a>FR/PRP算法</h3><ol>
<li><p>初始点$x^{(1)}$、精度要求$\epsilon$，置k=1</p>
</li>
<li><p>若$|\triangledown f(x^{(k)}) | \leq \epsilon$，停止
计算，得到解$x^{(k)}$，否则置</p>
<script type="math/tex; mode=display">
d^{(k)} = -\triangledown f(x^{(k)}) + \beta_{k-1}d^{(k-1)}</script><p>其中$\beta_{k-1}=0, k=1$，或由上述公式计算</p>
</li>
<li><p>一维搜索，求解一维问题</p>
<script type="math/tex; mode=display">
\arg\min_{\alpha} \phi(\alpha) = f(x^{(k)} -
  \alpha d^{(k)})</script><p>得$\alpha_k$，置$x^{(k+1)} = x^{(k)} + \alpha_k d^{(k)}$</p>
</li>
<li><p>置k=k+1，转2</p>
</li>
</ol>
<blockquote>
<ul>
<li>实际计算中，n步重新开始的FR算法优于原始FR算法</li>
<li>PRP算法中
  $\triangledown f(x^{(k)}) \approx \triangledown f(x^{(k-1)})$
  时，有$\beta_{k-1} \approx 0$，即
  $d^{(k)} \approx -\triangledown f(x^{(k)})$，自动重新开始</li>
<li>试验表明，对大型问题，PRP算法优于FR算法</li>
</ul>
</blockquote>
<h3 id="共轭方向下降性"><a href="#共轭方向下降性" class="headerlink" title="共轭方向下降性"></a>共轭方向下降性</h3><blockquote>
<ul>
<li>设$f(x)$具有连续一阶偏导，假设一维搜索是精确的，使用共轭
  梯度法求解无约束问题，若$\triangledown f(x^{(k)}) \neq 0$
  则搜索方向$d^{(k)}$是$x^{(k)}$处的下降方向</li>
</ul>
</blockquote>
<ul>
<li>将$d^{(k)}$导入即可</li>
</ul>
<h3 id="算法二次终止性"><a href="#算法二次终止性" class="headerlink" title="算法二次终止性"></a>算法二次终止性</h3><blockquote>
<ul>
<li>若一维搜索是精确的，则共轭梯度法具有二次终止性</li>
</ul>
</blockquote>
<ul>
<li><p>对正定二次函数，共轭梯度法至多n步终止，否则</p>
<ul>
<li>目标函数不是正定二次函数</li>
<li>或目标函数没有进入正定二次函数区域，</li>
</ul>
</li>
<li><p>此时共轭没有意义，搜索方向应该重新开始，即令</p>
<script type="math/tex; mode=display">
d^{(k)} = -\triangledown f(x^{(k)})</script><p>即算法每n次重新开始一次，称为n步重新开始策略</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:37.000Z" title="3/21/2019, 5:27:37 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-03-16T02:42:12.000Z" title="3/16/2019, 10:42:12 AM">2019-03-16</time></span><span class="level-item"><a class="link-muted" href="/categories/Math-Analysis/">Math Analysis</a><span> / </span><a class="link-muted" href="/categories/Math-Analysis/Optimization/">Optimization</a></span><span class="level-item">14 minutes read (About 2091 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Math-Analysis/Optimization/line_search.html">Line Search</a></h1><div class="content"><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>一维搜索/线搜索：单变量函数最优化，即求一维问题</p>
<script type="math/tex; mode=display">
\arg\min _ {\alpha} \phi(\alpha) = f(x^{(k)} +
    \alpha d^{(k)})</script><p>最优解的$\alpha_k$的数值方法</p>
<ul>
<li><p><em>exact line search</em>：精确一维搜索，求得<strong>最优步长</strong>
$\alpha_k$使得目标函数沿着$d^{(k)}$方向达到极小，即</p>
</li>
<li><p><em>inexact line search</em>：非精确一维搜索，求得$\alpha_k$
使得</p>
<script type="math/tex; mode=display">\begin{align*}
f(x^{(k)} + \alpha_k d^{(k)}) & < f(x^{(k)}) \\
\phi(\alpha_k) & < \phi(0)
\end{align*}</script></li>
</ul>
<h3 id="一维搜索基本结构"><a href="#一维搜索基本结构" class="headerlink" title="一维搜索基本结构"></a>一维搜索基本结构</h3><ul>
<li>确定搜索区间</li>
<li>用某种方法缩小搜索区间</li>
<li>得到所需解</li>
</ul>
<h3 id="搜索区间"><a href="#搜索区间" class="headerlink" title="搜索区间"></a>搜索区间</h3><blockquote>
<ul>
<li>搜索区间：设$\alpha^{ <em> }$是$\phi(\alpha)$极小点，若存在
  <strong>闭区间</strong>$[a, b]$使得$\alpha^{ </em> } \in [a, b]$，则称
  $[a, b]$是$phi(\alpha)$的搜索区间</li>
</ul>
</blockquote>
<h4 id="确定搜索区间的进退法"><a href="#确定搜索区间的进退法" class="headerlink" title="确定搜索区间的进退法"></a>确定搜索区间的进退法</h4><ol>
<li><p>取初始步长$\alpha$，置初始值</p>
<script type="math/tex; mode=display">
\mu_3 = 0, \phi_3 = \phi(\mu_3), k = 0</script></li>
<li><p>置</p>
<script type="math/tex; mode=display">
\mu = \mu_3 + \alpha, \phi = \phi(\mu), k = k+1</script></li>
<li><p>若$\phi &lt; \phi_3$，置</p>
<script type="math/tex; mode=display">
\mu_2 = \mu_3, \phi_2 = \phi_3 \\
\mu_3 = \mu, \phi_3 = \phi \\
\alpha = 2\alpha, k = k+1</script></li>
<li><p>若k =1，置</p>
<script type="math/tex; mode=display">
\mu_2 = mu, \phi_2 = \phi, \alpha = -\alpha</script><p>转2，否则置</p>
<script type="math/tex; mode=display">
\mu_1 = \mu_2, \phi_1 = \phi_2 \\
\mu_2 = \mu_3, \phi_2 = \phi_3 \\
\mu_3 = \mu, \phi_3 = \phi</script><p>并令$a=min{\mu_1,\mu_3}, b=max{\mu_1,\mu_3}$，停止搜索</p>
</li>
</ol>
<blockquote>
<ul>
<li>通常认为目标函数此算法得到搜索区间就是单峰函数</li>
</ul>
</blockquote>
<h2 id="试探法"><a href="#试探法" class="headerlink" title="试探法"></a>试探法</h2><ul>
<li>在搜索区间内选择<strong>两个点</strong>，计算目标函数值<ul>
<li>需要获得两个点取值才能判断极值点的所属区间</li>
</ul>
</li>
<li>去掉<strong>函数值较大者至离其较近端点</strong>段</li>
</ul>
<h3 id="0-618法"><a href="#0-618法" class="headerlink" title="0.618法"></a>0.618法</h3><ol>
<li><p>置初始搜索区间$[a, b]$，置精度要求$\epsilon$，计算左右
试探点</p>
<script type="math/tex; mode=display">\begin{align*}
a_l & = a + (1 - \tau)(b - a) \\
a_r & = a + \tau(b - a)
\end{align*}</script><p>其中$\tau = \frac {\sqrt 5 - 1} 2$，及相应函数值</p>
<script type="math/tex; mode=display">\begin{align*}
\phi_l & = \phi(a_l) \\
\phi_r & = \phi(a_r)
\end{align*}</script></li>
<li><p>若$\phi_l&lt;\phi_r$，置</p>
<script type="math/tex; mode=display">
b= a_r, a_r = a_l, \phi_l = \phi_l</script><p>并计算</p>
<script type="math/tex; mode=display">
a_l = a + (1 - \tau)(b - a), \phi_l = \phi(a_l)</script><p>否则置</p>
<script type="math/tex; mode=display">
a = a_l, a_l = a_r, \phi_l = \phi_r</script><p>并计算</p>
<script type="math/tex; mode=display">
a_r = a + \tau(b - a), \phi_r = \phi(a_r)</script></li>
<li><p>若$|b - a| \geq \epsilon$</p>
<ul>
<li>若$\phi_l &lt; \phi_r$，置$\mu = a_l$</li>
<li>否则置$\mu = \alpha_r$
得到问题解$\mu$，否则转2</li>
</ul>
</li>
</ol>
<ul>
<li>0.618法除第一次外，每次只需要计算一个新试探点、一个新
函数值，大大提高了算法效率</li>
<li>收敛速率线性，收敛比为$\tau = \frac {\sqrt 5 - 1} 2$常数</li>
</ul>
<h3 id="Fibonacci方法"><a href="#Fibonacci方法" class="headerlink" title="Fibonacci方法"></a>Fibonacci方法</h3><ol>
<li><p>置初始搜索区间$[a, b]$，置精度要求$\epsilon$，选取分离
间隔$\sigma &lt; \epsilon$，求最小正整数n，使得
$F_n &gt; \frac {b - a} \epsilon$，计算左右试探点</p>
<p>$\begin{align<em>}
a<em>l &amp; = a + \frac {F</em>{n-2}} {F<em>n} (b - a)\
a_r &amp; = a + \frac {F</em>{n-1}} {F_n} (b - a)
\end{align</em>}</p>
</li>
<li><p>置n=n-1</p>
</li>
<li><p>若$\phi_l &lt; \phi_r$，置</p>
<script type="math/tex; mode=display">
b = a_r, a_r = a_l , \phi_r = \phi_l</script><ul>
<li><p>若n&gt;2，计算</p>
<script type="math/tex; mode=display">\begin{align*}
a_l & = a + \frac {F_{n-2}} {F_n} (b - a) \\
\phi_r & = \phi(a_l)
\end{align*}</script></li>
<li><p>否则计算</p>
<script type="math/tex; mode=display">\begin{align*}
a_l & = a_r - \sigma \\
\phi_l & = \phi(a_l)
\end{align*}</script></li>
</ul>
</li>
<li><p>若$\phi_l \geq \phi_r$，置</p>
<script type="math/tex; mode=display">
a = a_l, a_l = a_r , \phi_l = \phi_r</script><ul>
<li><p>若n&gt;2，计算</p>
<script type="math/tex; mode=display">\begin{align*}
a_l & = a + \frac {F_{n-1}} {F_n} (b - a) \\
\phi_r & = \phi(a_r)
\end{align*}</script></li>
<li><p>否则计算</p>
<script type="math/tex; mode=display">\begin{align*}
a_r & = a_l + \sigma \\
\phi_r & = \phi(a_r)
\end{align*}</script></li>
</ul>
</li>
<li><p>若n=1</p>
<ul>
<li>若$\phi_l &lt; \phi_r$，置$\mu = a_r$</li>
<li>否则置$\mu = a_r$</li>
</ul>
<p>得到极小点$\mu$，停止计算，否则转2</p>
</li>
</ol>
<ul>
<li>Finonacci方法是选取实验点的最佳策略，即在实验点个数相同
情况下，最终的极小区间最小的策略</li>
</ul>
<blockquote>
<ul>
<li>Finonacci法最优性质可通过设最终区间长度为1，递推使得原始
  估计区间最大的取实验点方式，得出</li>
</ul>
</blockquote>
<h2 id="插值法"><a href="#插值法" class="headerlink" title="插值法"></a>插值法</h2><ul>
<li>利用搜索区间上某点的信息构造插值多项式（通常不超过3次）
$\hat \phi(\alpha)$</li>
<li>逐步用$\hat \phi(\alpha)$的极小点逼近$\phi(\alpha)$
极小点$\alpha^{*}$</li>
</ul>
<blockquote>
<ul>
<li>$\phi^{ * }$解析性质比较好时，插值法较试探法效果好</li>
</ul>
</blockquote>
<h3 id="三点二次插值法"><a href="#三点二次插值法" class="headerlink" title="三点二次插值法"></a>三点二次插值法</h3><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><p>以过三个点$(\mu_1,\phi_1), (\mu_2,\phi_2), (\mu_3,\phi_3)$
的二次插值函数逼近目标函数</p>
<script type="math/tex; mode=display">\begin{align*}
\hat \phi(\alpha) & = \phi_1 \frac {(\alpha - \mu_2)
    (\alpha - \mu_3)} {(\mu_1 - \mu_2)(\mu_1 - \mu_3)} \\
& + \phi_2 \frac {(\alpha - \mu_1) (\alpha - \mu_3)}
    {(\mu_2 - \mu_1)(\mu_2 - \mu_3)} \\
& + \phi_3 \frac {(\alpha - \mu_1) (\alpha - \mu_2)}
    {(\mu_3 - \mu_1)(\mu_3 - \mu_2)}
\end{align*}</script><ul>
<li><p>求导，得到$\hat \phi(\alpha)$的极小点</p>
<script type="math/tex; mode=display">
\mu = \frac {2[\phi_1(\mu_2-\mu_3) + \phi_2(\mu_3-\mu_1)
   + \phi_3(\mu_1 - \mu_2)]}
   {[\phi_1 (\mu_2^2-\mu_3^2) + \phi_2(\mu_3^2-\mu_1^2)
   + \phi_3(\mu_1^2 - \mu_2^2)]}</script></li>
<li><p>若插值结果不理想，继续构造插值函数求极小点近似值</p>
</li>
</ul>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ol>
<li><p>取初始点$\mu_1&lt;\mu_2&lt;\mu_3$，计算$\phi_i=\phi(\mu_i)$，
且满足$\phi_1 &gt; \phi_2, \phi_3 &gt; \phi_2$，置精度要求
$\epsilon$</p>
</li>
<li><p>计算</p>
<script type="math/tex; mode=display">
A = 2[\phi_1(\mu_2 - \mu_3) + \phi_2(\mu_3 - \mu_1) +
  \phi_3(\mu_1 - \mu_2)]</script><ul>
<li>若A=0，置$\mu = \mu_2, \phi = \phi_2$，停止计算，
输出$\mu, \phi$</li>
</ul>
</li>
<li><p>计算</p>
<script type="math/tex; mode=display">
\mu = [\phi_1 (\mu_2^2 - \mu_3^2) + \phi_2(\mu_3^2 -
  \mu_1^2) + \phi_3(\mu_1^2 - \mu_2^2)] / A</script><ul>
<li>若$\mu&lt;\mu_1 或 \mu&gt;\mu_3,\mu \notin (\mu_1,\mu_3)$
，停止计算，输出$\mu, \phi$</li>
</ul>
</li>
<li><p>计算$\phi = \phi(\mu)$，若$|\mu - \mu_2| &lt; \epsilon$，
停止计算，得到极小点$\mu$</p>
</li>
<li><p>若$\mu \in (\mu_2, \mu_3)$</p>
<ul>
<li>若$\phi &lt; \phi_2$，置<script type="math/tex; mode=display">
\mu_1=\mu_2, \phi_1=\phi_2, \mu_2=\mu, \phi_2=\phi</script></li>
<li>否则置<script type="math/tex; mode=display">\mu_3 = \mu, \phi_3 = \phi</script></li>
</ul>
<p>否则</p>
<ul>
<li><p>若$\phi &lt; \phi_2$，置</p>
<script type="math/tex; mode=display">
\mu_3=\mu_2, \phi_3=\phi_2, \mu_2=\mu, \phi_2=\phi</script></li>
<li><p>否则置</p>
<script type="math/tex; mode=display">
\mu_1 = \mu, \phi_1 = \phi</script></li>
</ul>
</li>
<li><p>转2</p>
</li>
</ol>
<h3 id="两点二次插值法"><a href="#两点二次插值法" class="headerlink" title="两点二次插值法"></a>两点二次插值法</h3><h4 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h4><p>以$\phi(\alpha)$在两点处$\mu_1, \mu_2$函数值
$\phi_1=\phi(\mu_1)$、一点处导数值
$\phi_1^{‘}=\phi^{‘}(\mu_1) &lt; 0$构造二次函数逼近原函数</p>
<script type="math/tex; mode=display">\begin{align*}
\hat \phi(\alpha) & = A(\alpha - \mu_1)^2 + B(\alpha - \mu_1)
    + C \\
A & = \frac {\phi_2 - \phi_1 - \phi_1^{'}(\mu_2 - \mu_1)}
    {(\mu_2 - \mu_1)^2} \\
B & = \phi_1^{'} \\
C & = \phi_1
\end{align*}</script><ul>
<li><p>为保证$[\mu_1, \mu_2]$中极小点，须有
$\phi_2 &gt; \phi_1 + \phi_1^{‘}(\mu_2 - \mu_1)$</p>
</li>
<li><p>求解，得到$\hat \phi (\mu)$极小值为</p>
<script type="math/tex; mode=display">
\mu = \mu_1 - \frac {\phi_1^{'}(\mu_2 - \mu_1)^2}
   {2[\phi_2 - \phi_1 - \phi_1^{'}(\mu_2 - \mu_1)]}</script></li>
<li><p>若插值不理想，继续构造插值函数求极小点的近似值</p>
</li>
</ul>
<h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><ol>
<li><p>初始点$\mu_1$、初始步长$d$、步长缩减因子$\rho$、精度要求
$\epsilon$，计算</p>
<script type="math/tex; mode=display">\phi_1 = \phi(\mu_1), \phi_2 = \phi_(\mu_2)</script></li>
<li><p>若$\phi_1^{‘} &lt; 0$，置$d = |d|$，否则置$d = -|d|$</p>
</li>
<li><p>计算</p>
<script type="math/tex; mode=display">\mu_2 = \mu_1 + d, \phi_2 = \phi(\mu_2)</script></li>
<li><p>若$\phi_2 \leq \phi_1 + \phi_1^{‘}(\mu_2 - \mu_1)$，置
$d = 2d$，转3</p>
</li>
<li><p>计算</p>
<script type="math/tex; mode=display">
\mu = \mu_1 - \frac {\phi_1^{'}(\mu_2 - \mu_1)^2}
  {2[\phi_2 - \phi_1 - \phi_1^{'}(\mu_2 - \mu_1)]} \\
\phi = \phi(\mu), \phi^{'} = \phi^{'}(\mu)</script></li>
<li><p>若$|phi^{‘}| \leq \epsilon$，停止计算，得到极小点$\mu$，
否则置</p>
<script type="math/tex; mode=display">\mu_1 = \mu, \phi_1 = \phi, \phi_1^{'} = \phi^{'},
  \alpha = \rho \alpha</script></li>
</ol>
<blockquote>
<ul>
<li>其中通常取$d = 1, \rho = 0.1$</li>
</ul>
</blockquote>
<h3 id="两点三次插值法"><a href="#两点三次插值法" class="headerlink" title="两点三次插值法"></a>两点三次插值法</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>以两点$\mu_1, \mu_2$处函数值$\phi_i = \phi(\mu_i)$和其导数值
$\phi_i^{‘} = \phi^{‘}(\mu_i)$，由<em>Himiter</em>插值公式可以构造
三次插值多项式$\hat \phi(\alpha)$</p>
<ul>
<li><p>求导置0，得到$\hat \phi(\alpha)$极小点</p>
<script type="math/tex; mode=display">\begin{align*}
\mu & = \mu_1 + (\mu_2 - \mu_1)(1 - \frac {\phi_2^{'}
   + w + z} {\phi_2^{'} - \phi_1^{'} + 2w}) \\
z & = \frac {3(\phi_2 - \phi_1)} {\mu_2 - \mu_1} -
   \phi_1^{'} - \phi_2^{'} \\
w & = sign(\mu_2 - \mu_1) \sqrt {z^2 -
   \phi_1^{'} \phi_2^{'}}
\end{align*}</script></li>
</ul>
<h4 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h4><ol>
<li><p>初始值$\mu_1$、初始步长$d$、步长缩减因子$\rho$、精度要求
$\epsilon$，计算</p>
<script type="math/tex; mode=display">\phi_1 = \phi(\mu_1), \phi_1^{'} = \phi^{'}(\mu_1)</script></li>
<li><p>若$\phi_1^{‘} &gt; 0$，置$d = -|d|$，否则置$d = |d|$</p>
</li>
<li><p>置$\mu_2 = \mu_1 + \alpha$，计算</p>
<script type="math/tex; mode=display">\phi_2 = \phi(\mu_2), \phi_2^{'} = \phi^{'}(\mu_2)</script></li>
<li><p>若$\phi_1^{‘} \phi_2{‘} &gt; 0$，置</p>
<script type="math/tex; mode=display">
d = 2d, \mu_1 = \mu_2, \phi_1 = \phi_2,
  \phi_1^{'} = \phi_2^{'}</script><p>转3</p>
</li>
<li><p>计算</p>
<script type="math/tex; mode=display">\begin{align*}
\mu & = \mu_1 + (\mu_2 - \mu_1)(1 - \frac {\phi_2^{'}
  + w + z} {\phi_2^{'} - \phi_1^{'} + 2w}) \\
z & = \frac {3(\phi_2 - \phi_1)} {\mu_2 - \mu_1} -
  \phi_1^{'} - \phi_2^{'} \\
w & = sign(\mu_2 - \mu_1) \sqrt {z^2 -
  \phi_1^{'} \phi_2^{'}} \\
\phi & = \phi(\mu) \\
\phi^{'} = \phi^{'}(\mu)
\end{align*}</script></li>
<li><p>若$|\phi^{‘}| &lt; \epsilon$，停止计算，得到极小点$\mu$，
否则置</p>
<script type="math/tex; mode=display">
d = \rho d, \mu_1 = \mu, \phi_1 = \phi,
  \phi_1^{'} = \phi^{'}</script><p>转2</p>
</li>
</ol>
<blockquote>
<ul>
<li>通常取$d = 1, \rho = 0.1$</li>
</ul>
</blockquote>
<h2 id="非精确一维搜索"><a href="#非精确一维搜索" class="headerlink" title="非精确一维搜索"></a>非精确一维搜索</h2><ul>
<li><p>对无约束问题整体而言，又是不要求得到极小点，只需要一定
下降量，缩短一维搜索时间，使整体效果最好</p>
</li>
<li><p>求满足$\phi(\mu) &lt; \phi(0)$、大小合适的$\mu$</p>
<ul>
<li>$\mu$过大容易不稳定</li>
<li>$\mu$过小速度慢</li>
</ul>
</li>
</ul>
<h3 id="GoldStein方法"><a href="#GoldStein方法" class="headerlink" title="GoldStein方法"></a>GoldStein方法</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><ul>
<li><p>预先指定精度要求$0&lt; \beta_1 &lt; \beta_2 &lt; 1$</p>
</li>
<li><p>以以下不等式限定步长</p>
<script type="math/tex; mode=display">\begin{align*}
\phi(\mu) & \leq \phi(0) + \mu\beta_1 \phi^{'}(0) \\
\phi(\mu) & \geq \phi(0) + \mu\beta_2 \phi^{'}(0)
\end{align*}</script></li>
</ul>
<p><img src="/imgs/line_search_goldstein.png" alt="line_search_goldstein"></p>
<h4 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h4><ol>
<li><p>初始试探点$\mu$，置$\mu<em>{min} = 0, \mu</em>{max} = \infty$，
置精度要求$0 &lt; \beta_1 &lt; \beta_2 &lt; 1$</p>
</li>
<li><p>对$\phi(mu)$</p>
<ul>
<li><p>若$\phi(\mu) &gt; \phi(0) + \beta<em>1 \phi^{‘}(0) \mu$，
置$\mu</em>{max} = \mu$</p>
</li>
<li><p>否则若$\phi(\mu) &gt; \phi(0) + \beta_2 \phi^{‘}(0)\mu$
，则停止计算，得到非精确最优解$\mu$</p>
</li>
<li><p>否则置$\mu_{min} = \mu$</p>
</li>
</ul>
</li>
<li><p>若$\mu<em>{max} &lt; \infty$，置
$\mu = \frac 1 2 (\mu</em>{min} + \mu<em>{max})$，否则置
$\mu = 2 \mu</em>{min}$</p>
</li>
<li><p>转2</p>
</li>
</ol>
<h3 id="Armijo方法"><a href="#Armijo方法" class="headerlink" title="Armijo方法"></a>Armijo方法</h3><p>Armijo方法是Goldstein方法的变形</p>
<ul>
<li><p>预先取$M &gt; 1, 0 &lt; \beta_1 &lt; 1$</p>
</li>
<li><p>选取$\mu$使得其满足以下，而$M\mu$不满足</p>
<script type="math/tex; mode=display">\phi(\mu) \leq \phi(0) + \mu \beta_1 \phi^{'}(0)</script></li>
</ul>
<blockquote>
<ul>
<li>M通常取2至10</li>
</ul>
</blockquote>
<p><img src="/imgs/line_search_armijo.png" alt="line_search_armijo"></p>
<h3 id="Wolfe-Powell方法"><a href="#Wolfe-Powell方法" class="headerlink" title="Wolfe-Powell方法"></a>Wolfe-Powell方法</h3><ul>
<li><p>预先指定参数$0 &lt; \beta_1 &lt; \beta_2 &lt;1$</p>
</li>
<li><p>选取$\mu$满足</p>
<script type="math/tex; mode=display">\begin{align*}
\phi(\mu) & \leq \phi(0) + \mu \beta_1 \phi^{'}(0) \\
\phi^{'}(\mu) & \geq \beta_2 \phi^{'}(0)
\end{align*}</script></li>
</ul>
<blockquote>
<ul>
<li>能保证可接受解中包含最优解，而Goldstein方法不能保证</li>
</ul>
</blockquote>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/34/">Previous</a></div><div class="pagination-next"><a href="/page/36/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/34/">34</a></li><li><a class="pagination-link is-current" href="/page/35/">35</a></li><li><a class="pagination-link" href="/page/36/">36</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/40/">40</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">36</span></span></a><ul><li><a class="level is-mobile" href="/categories/Algorithm/Data-Structure/"><span class="level-start"><span class="level-item">Data Structure</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Heuristic/"><span class="level-start"><span class="level-item">Heuristic</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Issue/"><span class="level-start"><span class="level-item">Issue</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Problem/"><span class="level-start"><span class="level-item">Problem</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Specification/"><span class="level-start"><span class="level-item">Specification</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/C-C/"><span class="level-start"><span class="level-item">C/C++</span></span><span class="level-end"><span class="level-item tag">34</span></span></a><ul><li><a class="level is-mobile" href="/categories/C-C/Cppref/"><span class="level-start"><span class="level-item">Cppref</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/Cstd/"><span class="level-start"><span class="level-item">Cstd</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/MPI/"><span class="level-start"><span class="level-item">MPI</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/STL/"><span class="level-start"><span class="level-item">STL</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/CS/"><span class="level-start"><span class="level-item">CS</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/CS/Character/"><span class="level-start"><span class="level-item">Character</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Parallel/"><span class="level-start"><span class="level-item">Parallel</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Program-Design/"><span class="level-start"><span class="level-item">Program Design</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Storage/"><span class="level-start"><span class="level-item">Storage</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Daily-Life/"><span class="level-start"><span class="level-item">Daily Life</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/Daily-Life/Maxism/"><span class="level-start"><span class="level-item">Maxism</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Database/"><span class="level-start"><span class="level-item">Database</span></span><span class="level-end"><span class="level-item tag">27</span></span></a><ul><li><a class="level is-mobile" href="/categories/Database/Hadoop/"><span class="level-start"><span class="level-item">Hadoop</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Database/SQL-DB/"><span class="level-start"><span class="level-item">SQL DB</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Database/Spark/"><span class="level-start"><span class="level-item">Spark</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/Scala/"><span class="level-start"><span class="level-item">Scala</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">42</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Bash-Programming/"><span class="level-start"><span class="level-item">Bash Programming</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Configuration/"><span class="level-start"><span class="level-item">Configuration</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/File-System/"><span class="level-start"><span class="level-item">File System</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/IPC/"><span class="level-start"><span class="level-item">IPC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Process-Schedual/"><span class="level-start"><span class="level-item">Process Schedual</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Shell/"><span class="level-start"><span class="level-item">Shell</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Tool/"><span class="level-start"><span class="level-item">Tool</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Tool/Vi/"><span class="level-start"><span class="level-item">Vi</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Model/"><span class="level-start"><span class="level-item">ML Model</span></span><span class="level-end"><span class="level-item tag">21</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Model/Linear-Model/"><span class="level-start"><span class="level-item">Linear Model</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Model-Component/"><span class="level-start"><span class="level-item">Model Component</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Nolinear-Model/"><span class="level-start"><span class="level-item">Nolinear Model</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Unsupervised-Model/"><span class="level-start"><span class="level-item">Unsupervised Model</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/"><span class="level-start"><span class="level-item">ML Specification</span></span><span class="level-end"><span class="level-item tag">17</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/Click-Through-Rate/"><span class="level-start"><span class="level-item">Click Through Rate</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/Click-Through-Rate/Recommandation-System/"><span class="level-start"><span class="level-item">Recommandation System</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/Computer-Vision/"><span class="level-start"><span class="level-item">Computer Vision</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Specification/FinTech/"><span class="level-start"><span class="level-item">FinTech</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/FinTech/Risk-Control/"><span class="level-start"><span class="level-item">Risk Control</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/Graph-Analysis/"><span class="level-start"><span class="level-item">Graph Analysis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Specification/NLP/"><span class="level-start"><span class="level-item">NLP</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Technique/"><span class="level-start"><span class="level-item">ML Technique</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Technique/Feature-Engineering/"><span class="level-start"><span class="level-item">Feature Engineering</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Technique/Neural-Network/"><span class="level-start"><span class="level-item">Neural Network</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Theory/"><span class="level-start"><span class="level-item">ML Theory</span></span><span class="level-end"><span class="level-item tag">11</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Theory/Loss/"><span class="level-start"><span class="level-item">Loss</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Theory/Model-Enhencement/"><span class="level-start"><span class="level-item">Model Enhencement</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Theory/Optimization/"><span class="level-start"><span class="level-item">Optimization</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Algebra/"><span class="level-start"><span class="level-item">Math Algebra</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Algebra/Linear-Algebra/"><span class="level-start"><span class="level-item">Linear Algebra</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Algebra/Universal-Algebra/"><span class="level-start"><span class="level-item">Universal Algebra</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Analysis/"><span class="level-start"><span class="level-item">Math Analysis</span></span><span class="level-end"><span class="level-item tag">23</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Analysis/Fourier-Analysis/"><span class="level-start"><span class="level-item">Fourier Analysis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Functional-Analysis/"><span class="level-start"><span class="level-item">Functional Analysis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Optimization/"><span class="level-start"><span class="level-item">Optimization</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Real-Analysis/"><span class="level-start"><span class="level-item">Real Analysis</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Mixin/"><span class="level-start"><span class="level-item">Math Mixin</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Mixin/Statistics/"><span class="level-start"><span class="level-item">Statistics</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Mixin/Time-Series/"><span class="level-start"><span class="level-item">Time Series</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Probability/"><span class="level-start"><span class="level-item">Probability</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">89</span></span></a><ul><li><a class="level is-mobile" href="/categories/Python/Cookbook/"><span class="level-start"><span class="level-item">Cookbook</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Jupyter/"><span class="level-start"><span class="level-item">Jupyter</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Keras/"><span class="level-start"><span class="level-item">Keras</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Matplotlib/"><span class="level-start"><span class="level-item">Matplotlib</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Numpy/"><span class="level-start"><span class="level-item">Numpy</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Pandas/"><span class="level-start"><span class="level-item">Pandas</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Py3Ref/"><span class="level-start"><span class="level-item">Py3Ref</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Py3std/"><span class="level-start"><span class="level-item">Py3std</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Pywin32/"><span class="level-start"><span class="level-item">Pywin32</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Readme/"><span class="level-start"><span class="level-item">Readme</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/TensorFlow/"><span class="level-start"><span class="level-item">TensorFlow</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Twists/"><span class="level-start"><span class="level-item">Twists</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/RLang/"><span class="level-start"><span class="level-item">RLang</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Rust/"><span class="level-start"><span class="level-item">Rust</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Set/"><span class="level-start"><span class="level-item">Set</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/"><span class="level-start"><span class="level-item">Tool</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/Tool/Editor/"><span class="level-start"><span class="level-item">Editor</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Markup-Language/"><span class="level-start"><span class="level-item">Markup Language</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Web-Browser/"><span class="level-start"><span class="level-item">Web Browser</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Windows/"><span class="level-start"><span class="level-item">Windows</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/Web/CSS/"><span class="level-start"><span class="level-item">CSS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/NPM/"><span class="level-start"><span class="level-item">NPM</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/Proxy/"><span class="level-start"><span class="level-item">Proxy</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/Thrift/"><span class="level-start"><span class="level-item">Thrift</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://octodex.github.com/images/hula_loop_octodex03.gif" alt="UBeaRLy"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">UBeaRLy</p><p class="is-size-6 is-block">Protector of Proxy</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">392</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">93</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">522</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/xyy15926" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/xyy15926"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-04T15:07:54.896Z">2021-08-04</time></p><p class="title"><a href="/uncategorized/README.html"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-03T07:46:51.000Z">2021-08-03</time></p><p class="title"><a href="/Web/NPM/hexo_config.html">Hexo 建站</a></p><p class="categories"><a href="/categories/Web/">Web</a> / <a href="/categories/Web/NPM/">NPM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-03T02:32:45.000Z">2021-08-03</time></p><p class="title"><a href="/Web/NPM/config.html">NPM 总述</a></p><p class="categories"><a href="/categories/Web/">Web</a> / <a href="/categories/Web/NPM/">NPM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-02T08:11:11.000Z">2021-08-02</time></p><p class="title"><a href="/Python/Py3std/internet_data.html">互联网数据</a></p><p class="categories"><a href="/categories/Python/">Python</a> / <a href="/categories/Python/Py3std/">Py3std</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-29T13:55:00.000Z">2021-07-29</time></p><p class="title"><a href="/Linux/Shell/sh_apps.html">Shell 应用程序</a></p><p class="categories"><a href="/categories/Linux/">Linux</a> / <a href="/categories/Linux/Shell/">Shell</a></p></div></article></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">Advertisement</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="pub-5385776267343559" data-ad-slot="6995841235" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="https://api.follow.it/subscription-form/WWxwMVBsOUtoNTdMSlJ4Z1lWVnRISERsd2t6ek9MeVpEUWs0YldlZGxUdXlKdDNmMEZVV1hWaFZFYWFSNmFKL25penZodWx3UzRiaVkxcnREWCtOYUJhZWhNbWpzaUdyc1hPangycUh5RTVjRXFnZnFGdVdSTzZvVzJBcTJHKzl8aXpDK1ROWWl4N080YkFEK3QvbEVWNEJuQjFqdWdxODZQcGNoM1NqbERXST0=/8" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="UBeaRLy" height="28"></a><p class="is-size-7"><span>&copy; 2021 UBeaRLy</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/xyy15926/proxy"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>