<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Tag: Rust - UBeaRLy</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="UBeaRLy&#039;s Proxy"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="UBeaRLy&#039;s Proxy"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="UBeaRLy"><meta property="og:url" content="https://xyy15926.github.io/"><meta property="og:site_name" content="UBeaRLy"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://xyy15926.github.io/img/og_image.png"><meta property="article:author" content="UBeaRLy"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xyy15926.github.io"},"headline":"UBeaRLy","image":["https://xyy15926.github.io/img/og_image.png"],"author":{"@type":"Person","name":"UBeaRLy"},"publisher":{"@type":"Organization","name":"UBeaRLy","logo":{"@type":"ImageObject","url":"https://xyy15926.github.io/img/logo.svg"}},"description":""}</script><link rel="alternate" href="/atom.xml" title="UBeaRLy" type="application/atom+xml"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/darcula.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><script data-ad-client="ca-pub-5385776267343559" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><meta name="follow_it-verification-code" content="SVBypAPPHxjjr7Y4hHfn"><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="UBeaRLy" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Visit on GitHub" href="https://github.com/xyy15926/proxy"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">Tags</a></li><li class="is-active"><a href="#" aria-current="page">Rust</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:37.000Z" title="3/21/2019, 5:27:37 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-02-17T03:57:08.000Z" title="2/17/2019, 11:57:08 AM">2019-02-17</time></span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a></span><span class="level-item">4 minutes read (About 631 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Rust/crate_mod.html">Crate、Mod、可见性、文件结构</a></h1><div class="content"><h2 id="文件结构规则"><a href="#文件结构规则" class="headerlink" title="文件结构规则"></a>文件结构规则</h2><h3 id="拆分文件"><a href="#拆分文件" class="headerlink" title="拆分文件"></a>拆分文件</h3><p>Rust一般库中<strong>文件名/文件夹</strong>都表示mod
（测试文件规则比较特殊）</p>
<ul>
<li>mod<code>foo</code>在其父mod<code>bar</code>中声明 </li>
<li>如果mod<code>foo</code>没有子mod，将其实现放在<code>foo.rs</code>文件中</li>
<li>若mod<code>foo</code>有子mod，创建文件夹<code>foo</code>，将其实现放在
<code>foo/mod.rs</code>中</li>
</ul>
<p>以上是文件拆分规则，也可以不拆分文件</p>
<h3 id="库Crate"><a href="#库Crate" class="headerlink" title="库Crate"></a>库Crate</h3><p>库crate中<code>lib.rs</code>相当于该crate顶层mod（根mod）</p>
<ul>
<li>所有的mod直接或间接（祖先mod）声明于此，否则不能识别</li>
<li>从引用库crate的外部crate角度来看，其名称和库crate同名
<code>extern crate crate_name;</code>的同时就<code>use crate_name;</code>，
此时可将引用其的mod视为根mod的父mod</li>
</ul>
<h3 id="库、二进制Crate"><a href="#库、二进制Crate" class="headerlink" title="库、二进制Crate"></a>库、二进制Crate</h3><p>crate中可以同时有lib.rs和main.rs，此时库crate和二进制
crate应该看作相互<strong>独立</strong></p>
<ul>
<li><p>在两处都使用<code>mod</code>关键字<strong>声明定义</strong>mod（不能在<code>main.rs</code>
中使用<code>use</code><strong>声明使用</strong>mod）</p>
</li>
<li><p>在<code>main.rs</code>中使用<code>extern crate crate_name</code>引入
“外部”库crate</p>
</li>
</ul>
<h2 id="可见性规则"><a href="#可见性规则" class="headerlink" title="可见性规则"></a>可见性规则</h2><h3 id="Mod默认私有"><a href="#Mod默认私有" class="headerlink" title="Mod默认私有"></a>Mod默认私有</h3><ul>
<li>默认仅crate内部可见<ul>
<li>父mod处直接可用</li>
<li>兄弟mod、子mod可以通过“回溯“声明使用</li>
</ul>
</li>
<li><code>pub</code>声明为公用后，对外部crate也可见</li>
</ul>
<h3 id="Fn默认私有"><a href="#Fn默认私有" class="headerlink" title="Fn默认私有"></a>Fn默认私有</h3><ul>
<li>默认仅mod“内部”可见（包括后代mod）<ul>
<li>当前mod内直接可用</li>
<li>子mod可以通过“回溯”声明可用</li>
</ul>
</li>
<li><code>pub</code>声明为公用后，对外部mod也可见</li>
</ul>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li>项（mod、fn）的声明使用路径都是相对于当前项，即默认调用
其后代项（mod、fn），通过以下“回溯”方式调用非直接后代项<ul>
<li><code>super</code>直接父mod路径起始：<code>super::child_mod</code></li>
<li><code>::</code>根mod起始：<code>::child_mod</code></li>
</ul>
</li>
<li>fn和mod的可见规则相似的，只是注意：fn是否可见只与mod有关
，mod是否可见只有crate有关。从这个意义上说，crate不能
看作是“大号“的mod</li>
</ul>
<h2 id="相关关键字"><a href="#相关关键字" class="headerlink" title="相关关键字"></a>相关关键字</h2><p>好像都是单一用途（意义），罕见</p>
<ul>
<li><code>extern</code>：<strong>引入</strong>外部crate（同时包含<code>use crate_name;</code>）</li>
<li><code>crate</code>：标记外部crate</li>
<li><code>mod</code>/<code>fn</code>：<strong>声明定义（注册）</strong>mod/fn（同crate内仅一次
，位于其父mod处）</li>
<li><code>use</code>：<strong>声明使用</strong>项（mod、fn），用于缩略代码</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:37.000Z" title="3/21/2019, 5:27:37 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-02-17T03:57:08.000Z" title="2/17/2019, 11:57:08 AM">2019-02-17</time></span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a></span><span class="level-item">3 minutes read (About 456 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Rust/error_handling.html">Rust 错误（Panic）处理规范</a></h1><div class="content"><h2 id="panic-与不可预期（不可恢复）错误"><a href="#panic-与不可预期（不可恢复）错误" class="headerlink" title="panic!与不可预期（不可恢复）错误"></a>panic!与不可预期（不可恢复）错误</h2><p><code>panic!</code>时程序默认开始展开（unwinding）、回溯栈并清理函数据</p>
<p>如果希望二进制文件尽量小，可以选择“终止（abort）”，此时
程序内存由操作系统进行清理，在<code>Cargo.toml</code>中添加</p>
<pre><code>[profile]
panic=&#39;abort&#39;

[profile.release]
panic=&#39;abort&#39;
</code></pre><p>前者是配置debug时，后者配置release版本</p>
<h2 id="Result与潜在（可预期、可恢复）错误"><a href="#Result与潜在（可预期、可恢复）错误" class="headerlink" title="Result与潜在（可预期、可恢复）错误"></a>Result与潜在（可预期、可恢复）错误</h2><h3 id="Result枚举类型"><a href="#Result枚举类型" class="headerlink" title="Result枚举类型"></a>Result枚举类型</h3><pre><code>Result&lt;T, E&gt;&#123;
    Ok&lt;T&gt;,
    Err&lt;E&gt;,
&#125;
</code></pre><ul>
<li><code>T</code>：成功时<code>Ok</code>成员中的数据类型</li>
<li><code>E</code>：失败时<code>Err</code>成员中返回的数据类型</li>
</ul>
<h3 id="直接处理"><a href="#直接处理" class="headerlink" title="直接处理"></a>直接处理</h3><ul>
<li><p>对<code>Result</code>值进行模式匹配，分别处理</p>
<p>let f = File::open(“hello.txt”);
let mut f = match f {
   Ok(file) =&gt; file,
   Err(error) =&gt; panic!(“error:{:?}”, error),
}</p>
</li>
<li><p>使用<code>Result</code>上定义的方法（类似以上）</p>
<ul>
<li><p><code>Result.unwrap()</code></p>
<ul>
<li><code>T = Ok&lt;T&gt;.unwrap()</code></li>
<li><code>Err&lt;E&gt;.unwrap()</code>使用默认信息调用<code>panic</code></li>
</ul>
</li>
<li><p><code>Result.expect(&amp;str)</code></p>
<ul>
<li><code>T = Ok&lt;T&gt;.expect(&amp;str)</code></li>
<li><code>Err&lt;E&gt;.expect(&amp;str)</code>使用<code>&amp;str</code>调用<code>!panic</code></li>
</ul>
</li>
<li><p><code>Result.unwrap_or_else</code></p>
<p>  Result.unwrap_or_else(|err|{</p>
<pre><code>  clojure...
</code></pre><p>  })</p>
<ul>
<li><code>T = Ok&lt;T&gt;.unwrap_or_else()</code></li>
<li><code>Err&lt;E&gt;.unwrap_or_else()</code>将<code>E</code>作为闭包参数调用
闭包</li>
</ul>
</li>
<li><p><code>Result.is_err()</code></p>
<ul>
<li><code>False = Ok&lt;T&gt;.is_err()</code></li>
<li><code>True = Err&lt;E&gt;.is_err()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="传播错误（Propagating）"><a href="#传播错误（Propagating）" class="headerlink" title="传播错误（Propagating）"></a>传播错误（Propagating）</h3><p>对<code>Result</code>对象进行匹配，提前返回<code>Err&lt;E&gt;</code>，需要注意返回值
类型问题，尤其是在可能存在多处潜在错误需要返回</p>
<pre><code>let f = File:open(&quot;hello.txt&quot;);
let mut f match f &#123;
    Ok(file) =&gt; file,
    Err(error) =&gt; return Err(error),
&#125;
</code></pre><p><code>?</code>简略写法（效果同上）</p>
<pre><code>let mut f = File::open(&quot;hello.txt&quot;)?
</code></pre><ul>
<li><code>?</code>会把<code>Err(error)</code>传递给<code>from</code>函数（定义在标准库<code>From</code>
trait中），将错误从转换为函数<strong>返回值</strong>中的类型，潜在
错误类型都实现了<code>from</code>函数</li>
<li><code>?</code>只能用于返回值为<code>Result</code>类型的函数内，因为其”返回值”
就是<code>Err(E)</code>（如果有）</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:37.000Z" title="3/21/2019, 5:27:37 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-02-17T03:57:08.000Z" title="2/17/2019, 11:57:08 AM">2019-02-17</time></span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a></span><span class="level-item">21 minutes read (About 3104 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Rust/ownership.html">Rust 所有权、引用、生命周期</a></h1><div class="content"><h2 id="变量、值、所有权"><a href="#变量、值、所有权" class="headerlink" title="变量、值、所有权"></a>变量、值、所有权</h2><h3 id="变量、值"><a href="#变量、值" class="headerlink" title="变量、值"></a>变量、值</h3><blockquote>
<ul>
<li>变量：用来代表值进行操作、没有对应内存空间的字符串，
  如：a，b</li>
<li>值：在内存中有对应的空间，如：5，”asdf”</li>
</ul>
</blockquote>
<p>变量默认不可变</p>
<ul>
<li><p>var变量绑定的<strong>值1</strong>不能更改，对应的内存数据不能改变</p>
<ul>
<li><p>不允许赋值操作，但是变量的声明和绑定可以分开，即使
声明不可变变量，也可以之后绑定值，注意区分</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">ret_int</span></span>() -&gt; <span class="built_in">i32</span>&#123; <span class="number">5</span> &#125;</span><br><span class="line"><span class="comment">// 以下代码可编译，且正确</span></span><br><span class="line"><span class="keyword">let</span> num = &amp;<span class="keyword">mut</span> ret_int();</span><br><span class="line">*num += <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 以下不可</span></span><br><span class="line"><span class="keyword">let</span> num;</span><br><span class="line">num = &amp;<span class="keyword">mut</span> ret_int();</span><br><span class="line">*num += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h1 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h1></li>
<li><p>不允许获取可变引用、所有权转移给可变变量（对函数
即限制参数类型，类似于默认const)</p>
</li>
</ul>
<p>若其中包含（或就是）引用，引用值是可以更改的</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">ref</span> = &amp;<span class="keyword">mut</span> ori;</span><br><span class="line">*<span class="keyword">ref</span> += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是变量var可以重新绑定为其他的值</p>
<ul>
<li><p>虽然<strong>值1</strong>不能更改，但是var变量可以绑定其他值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> var = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> var = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>此时虽然<strong>值1</strong>虽然无法被访问、使用，但是离开作用域
之前不会被丢弃，只是被“隐藏”</p>
</li>
</ul>
</li>
</ul>
<h3 id="所有权规则"><a href="#所有权规则" class="headerlink" title="所有权规则"></a>所有权规则</h3><ul>
<li><p>每个值（内存）都有一个称为<strong>所有者（owner）</strong>的变量</p>
</li>
<li><p>值（内存）有且只有一个所有者</p>
<ul>
<li>如果多个变量拥有某值（内存）所有权，有可能会多次释放
同一内存，造成内存二次污染</li>
<li>rust中只有一个变量拥有所有权避免内存污染问题</li>
</ul>
</li>
<li><p>所有者（变量）离开作用域，值将被丢弃（内存被回收）
（rust为其调用<code>drop</code>函数）</p>
<blockquote>
<p>   在生命周期结束时释放资源的方法在C++称为RAII
   （Resource Aquistion Is Initialization），这里的
   initialization是指对资源跟踪、管理初始化，RAII就是
   将对象（变量）同资源生命周期相关联，在C++中体现为
   析构函数</p>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>rust的所有权管理是编译是进行检查，没有runtime性能损失</li>
<li>相较于gc（垃圾回收）性能影响较小</li>
<li>相较于手动分配、释放内存不容易代码疏忽导致的内存问题</li>
</ul>
</blockquote>
<h3 id="所有权转移"><a href="#所有权转移" class="headerlink" title="所有权转移"></a>所有权转移</h3><h4 id="Drop和Copytrait"><a href="#Drop和Copytrait" class="headerlink" title="Drop和Copytrait"></a><code>Drop</code>和<code>Copy</code>trait</h4><ul>
<li><code>Drop</code>：值离开作用域时rust自动调用</li>
<li><code>Copy</code>：赋值时调用，赋值之后原变量仍然可以继续使用</li>
</ul>
<p>需要分配内存、本身就是某种资源形式不会实现<code>Copy</code> trait，实现
<code>Copy</code> trait类型有</p>
<ul>
<li>存储在stack上的类型，值拷贝速度快，定长</li>
<li>整型、bool型、浮点型这样（标量）原生数据类型</li>
<li>所有元素都copy的tuple</li>
</ul>
<p>rust不允许任何类型同时同时实现<code>Drop</code>和<code>Copy</code>trait</p>
<h4 id="所有权转移-1"><a href="#所有权转移-1" class="headerlink" title="所有权转移"></a>所有权转移</h4><p>对于没有实现<code>Copy</code>trait的类型：赋值（包括函数传参、返回值）
操作会将原变量所有权转移（move）给新变量，之后不允许使用
原变量，编译时即报错，这样就避免了同时释放同一内存造成
二次污染</p>
<blockquote>
<p>   有些情况下所有权不允许转移，如vec中元素</p>
</blockquote>
<p>实现了<code>Copy</code>trait的类型，赋值（包括函数传参）操作将按照
<code>Copy</code>trait复制一个新值，将新值（包括所有权）赋给新变量，
如此原变量可以之后继续使用，没有违反rust的所有权规则，因为
实际上两个值（内存）</p>
<h2 id="Reference（引用）"><a href="#Reference（引用）" class="headerlink" title="Reference（引用）"></a>Reference（引用）</h2><p>引用（references，&amp;，获取引用作为函数参数称为<strong>借用</strong>）</p>
<p>单一所有权情况下，仅仅想使用值而不获取所有权，尤其是函数
传参，虽然可以获取所有权之后再将所有权转移，但是操作麻烦，
而且函数返回值可能有其他用途</p>
<h3 id="引用特点"><a href="#引用特点" class="headerlink" title="引用特点"></a>引用特点</h3><ul>
<li>引用允许变量使用值但是不获取所有权</li>
<li>引用离开作用域时不会丢弃其指向的值，不会内存二次污染</li>
<li>分为可变引用、不可变引用，类似于变量绑定</li>
</ul>
<h3 id="引用规则"><a href="#引用规则" class="headerlink" title="引用规则"></a>引用规则</h3><ul>
<li>任意时间内，特定作用域、特定变量只允许<ul>
<li>一个可变引用</li>
<li>任意数量不可变引用</li>
</ul>
</li>
<li>引用必须总是有效的</li>
</ul>
<p>注意：<strong>获取可变引用</strong>和<strong>引用赋值给可变变量</strong>的区别</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> n = &amp;m;</span><br><span class="line">	<span class="comment">//将引用赋值给可变变量</span></span><br><span class="line"><span class="keyword">let</span> n = &amp;<span class="keyword">mut</span> m;</span><br><span class="line">	<span class="comment">//获取可变引用赋值给变量，这里会报错，因为`m`是不可变</span></span><br><span class="line">	<span class="comment">//变量，不允许通过其获取可变引用</span></span><br></pre></td></tr></table></figure>
<h4 id="规则1"><a href="#规则1" class="headerlink" title="规则1"></a>规则1</h4><p>第一条规则避免以下情况导致的数据竞争</p>
<blockquote>
<ul>
<li>多个指针可以访问同一数据</li>
<li>至少有一个指针可以写入数据</li>
<li>没有有效的同步数据访问机制</li>
</ul>
</blockquote>
<p>这条规则在<strong>显式</strong>的赋值、声明易发现、遵守，需要注意的是</p>
<ul>
<li><strong>函数调用</strong>创建可变引用</li>
<li><strong>自运算符</strong>创建可变引用（<code>+=</code>、<code>*=</code>）</li>
</ul>
<h4 id="规则2"><a href="#规则2" class="headerlink" title="规则2"></a>规则2</h4><p>rust会在编译时检查引用是否有效，即引用是否是悬垂指针</p>
<blockquote>
<p>   悬垂指针：指向的内存已经被分配给其他所有者或值被丢弃，
    常见于函数中返回局部变量</p>
</blockquote>
<p>对于rust中的“变量（有所有权）”而言则不存此问题</p>
<ul>
<li>赋值操作要么转移所有权，值不会被丢弃</li>
<li>要么实现<code>copy</code>trait，返回新值</li>
</ul>
<h3 id="解引用"><a href="#解引用" class="headerlink" title="解引用"></a>解引用</h3><p>rust中引用更像c中的指针</p>
<ul>
<li><p>引用有对应的解引用（dereferance），且“多层次”引用也需要
”多层次“解引用</p>
</li>
<li><p>教程上的引用附图也是引用“指向”原“变量”，不是“值（内存）”</p>
</li>
</ul>
<h4 id="自动引用和解引用"><a href="#自动引用和解引用" class="headerlink" title="自动引用和解引用"></a>自动引用和解引用</h4><ul>
<li>方法中<code>self</code></li>
<li><code>+</code>自己实现了解引用（不知道是否算自动解引用）<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Add&lt;&amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span>&gt; <span class="keyword">for</span> <span class="built_in">i32</span>&#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> Add&lt;<span class="built_in">i32</span>&gt; <span class="keyword">for</span> <span class="built_in">i32</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><h1 id="todo-1"><a href="#todo-1" class="headerlink" title="todo"></a>todo</h1></li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul>
<li>rust<strong>每个引用</strong>都有生命周期，即引用保持有效的作用域
（避免悬垂引用）</li>
<li><p>大部分情况下，生命周期是隐含、可推断的
（类似于类型可推断）</p>
<ul>
<li>借用检查器（编译器一部分）可以分析函数代码得到引用的
生命周期，通过作用域确保借用有效</li>
<li>但是函数被调用、被函数之外的代码引用时，每次生命周期
都不一样，rust无法分析</li>
</ul>
</li>
<li><p>有时也会出现引用生命周期以一些不同的方式相关联，此时需要
使用<strong>泛型</strong>生命周期参数标注关系</p>
</li>
</ul>
<h3 id="生命周期注解语法"><a href="#生命周期注解语法" class="headerlink" title="生命周期注解语法"></a>生命周期注解语法</h3><ul>
<li>生命周期参数必须以”’“开头（和一般泛型参数区别）</li>
<li>参数名称通常小写</li>
<li>位于引用”&amp;“之后，”mut“（如果存在）之前</li>
</ul>
<h3 id="函数生命周期注解"><a href="#函数生命周期注解" class="headerlink" title="函数生命周期注解"></a>函数生命周期注解</h3><p>只存在于函数<strong>签名</strong>中</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> x.len() &gt; y.len()&#123;</span><br><span class="line">		x</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		y</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>生命周期注解并不改变参数、返回值的生命周期，只是在
函数签名中增加了生命周期“协议”</p>
<ul>
<li>函数体中返回值不遵守“协议”，函数体编译错误</li>
<li>传参、<strong>返回值接收变量</strong>不遵守“协议”，调用处编译错误</li>
<li>生命周期注解是用于联系函数不同参数和返回值的生命
周期，一旦形成某种联系，编译器就能获取足够信息判断
引用是否有效（是否内存安全、产生悬垂指针）</li>
</ul>
</li>
<li><p>生命周期注解是为了保证函数<strong>返回值</strong>引用有效，同函数
用途有关，因此以下签名也可以通过编译</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>, y: &amp;<span class="built_in">str</span>) -&gt; &amp;a&#x27; <span class="built_in">str</span>&#123;</span><br><span class="line">	x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="生命周期注解省略规则"><a href="#生命周期注解省略规则" class="headerlink" title="生命周期注解省略规则"></a>生命周期注解省略规则</h3><ul>
<li>每个是引用的<strong>参数</strong>都有自己的输入生命周期参数</li>
<li>如果只有一个输入生命周期参数，会被赋予所有输出生命周期
参数</li>
<li>若<strong>方法</strong>存在多个输入生命周期参数，且首个参数<code>self</code>
为引用（<code>&amp;self</code>、<code>&amp;mut self</code>），将其生命周期参数赋给
所有输出生命周期参数</li>
</ul>
<p>编译器检查完以上三条规则之后，所有引用均有生命周期参数，则
无需额外生命周期注解，但是若函数体返回值不遵守“协议”，仍
无法编译通过</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; stct&lt;<span class="symbol">&#x27;a</span>&gt;&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">other_str</span></span>(&amp;<span class="keyword">self</span>, &amp;str1) -&gt; &amp;<span class="built_in">str</span>&#123;</span><br><span class="line">		str1</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查完规则之后，所有引用均有注解，但是</span></span><br><span class="line"><span class="comment">// 函数体中的生命周期和签名中不一致</span></span><br></pre></td></tr></table></figure>
<p>这个例子说明生命周期注解不只是“注解”，是真的需要例子考虑
返回值的生命周期</p>
<h3 id="结构体生命周期注解"><a href="#结构体生命周期注解" class="headerlink" title="结构体生命周期注解"></a>结构体生命周期注解</h3><p>在结构体成员为引用时需要增加生命周期注解</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImportantExcerpt</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;&#123;</span><br><span class="line">	part: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此类结构体在实现方法时不能省略生命周期注解，方法签名可根据
规则省略注解</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt;&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> </span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泛型结构体（枚举）作为函数参数、返回值类型时，替换泛型参数
为引用时也需要添加生命周期注解</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(args: &amp;[<span class="built_in">String</span>]) -&gt; <span class="built_in">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>&gt;&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">search</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="built_in">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>) -&gt; <span class="built_in">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态生命周期（-39-static）"><a href="#静态生命周期（-39-static）" class="headerlink" title="静态生命周期（&#39;static）"></a>静态生命周期（<code>&#39;static</code>）</h3><ul>
<li>存活于整个程序生命期间</li>
<li>所有的<code>&amp;str</code>（字符串字面值）都拥有<code>&#39;static</code>生命周期</li>
<li>可以用于指定引用的生命周期，但是使用之前三思，应先考虑
悬垂引用、生命周期不匹配的问题</li>
</ul>
<h3 id="高级生命周期"><a href="#高级生命周期" class="headerlink" title="高级生命周期"></a>高级生命周期</h3><h4 id="Lifetime-Subtyping"><a href="#Lifetime-Subtyping" class="headerlink" title="Lifetime Subtyping"></a>Lifetime Subtyping</h4><p>生命周期子类型：确保某个生命周期长于另一个生命周期</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Context</span></span>&lt;<span class="symbol">&#x27;s</span>&gt;(&amp;<span class="symbol">&#x27;s</span> <span class="built_in">str</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Parser</span></span>&lt;<span class="symbol">&#x27;c</span>, <span class="symbol">&#x27;s</span>: <span class="symbol">&#x27;c</span>&gt;&#123;</span><br><span class="line">	<span class="comment">//`&#x27;s: &#x27;c`声明一个不短于`&#x27;c`的生命周期`&#x27;s`</span></span><br><span class="line">	context: &amp;<span class="symbol">&#x27;c</span> Context&lt;<span class="symbol">&#x27;s</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;c</span>, <span class="symbol">&#x27;s</span>: <span class="symbol">&#x27;c</span>&gt; Parser&lt;<span class="symbol">&#x27;c</span>, <span class="symbol">&#x27;s</span>: <span class="symbol">&#x27;c</span>&gt;&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">parse</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;(), &amp;<span class="symbol">&#x27;s</span> <span class="built_in">str</span>&gt;&#123;</span><br><span class="line">		<span class="comment">//根据生命周期省略规则，若`&#x27;s`省略，则赋予`&amp;self`的</span></span><br><span class="line">		<span class="comment">//生命周期</span></span><br><span class="line">		<span class="comment">//使用生命周期子类型语法，指定（要求）`&amp;str`生命周期</span></span><br><span class="line">		<span class="comment">//长于`&amp;Context`</span></span><br><span class="line">		<span class="literal">Err</span>(&amp;<span class="keyword">self</span>.context.<span class="number">0</span>[<span class="number">1</span>..]</span><br><span class="line">		<span class="comment">//这里没有考虑字符串切片的有效性，如果这个切片不是</span></span><br><span class="line">		<span class="comment">//有效的unicode字符串（utf8字节序列），会panic</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">parse_context</span></span>(context: Context) -&gt; <span class="built_in">Result</span>&lt;(), &amp;<span class="built_in">str</span>&gt;&#123;</span><br><span class="line">	<span class="comment">//方法获取`context`的所有权</span></span><br><span class="line">	Parser&#123; context: &amp;Context &#125;.parse()</span><br><span class="line">	<span class="comment">//`&amp;Context`的生命周期只有整个函数内</span></span><br><span class="line">	<span class="comment">//函数体中的返回值是`context.0[1..]`，为保证返回值有效，</span></span><br><span class="line">	<span class="comment">//其生命周期必须长于整个函数</span></span><br><span class="line">	<span class="comment">//返回值中的`&amp;str`类型的生命周期是`&#x27;s`，长于context`&#x27;c`</span></span><br><span class="line">	<span class="comment">//满足返回值的生命周期长于函数的要求，能编译通过</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Lifetime-Bounds"><a href="#Lifetime-Bounds" class="headerlink" title="Lifetime Bounds"></a>Lifetime Bounds</h4><p>生命周期bounds：帮助Rust验证泛型引用不会比其引用的数据存在
更久</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ref</span></span>&lt;<span class="symbol">&#x27;a</span>, T: <span class="symbol">&#x27;a</span>&gt; &#123; &amp;<span class="symbol">&#x27;a</span> T &#125;;</span><br><span class="line">	<span class="comment">//为`T`增加生命周期bound，指定`T`引用的生命周期不短于</span></span><br><span class="line">	<span class="comment">//`&#x27;a`，保证结构体成员有效</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StaticRef</span></span>&lt;T: <span class="symbol">&#x27;static</span>&gt; &#123; &amp;<span class="symbol">&#x27;static</span> T &#125;;</span><br><span class="line">	<span class="comment">//限制`T`为只拥有`&#x27;static`生命周期的引用或没有引用的类型</span></span><br></pre></td></tr></table></figure>
<h4 id="trait对象生命周期推断"><a href="#trait对象生命周期推断" class="headerlink" title="trait对象生命周期推断"></a>trait对象生命周期推断</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Red</span></span> &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ball</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">	diameter: &amp;<span class="symbol">&#x27;a</span> <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Red <span class="keyword">for</span> Ball&lt;<span class="symbol">&#x27;a</span>&gt; &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> num = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">let</span> obj = <span class="built_in">Box</span>::new(Ball &#123;diameter: &amp;num&#125;) <span class="keyword">as</span> <span class="built_in">Box</span>&lt;Red&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码能编译通过，因为生命周期和trait对象必须遵守：</p>
<ul>
<li>trait对象默认的生命周期为<code>&#39;static</code></li>
<li>若有<code>&amp;&#39;a X</code>或<code>&amp;&#39;a mut x</code>，则默认生命周期为<code>&#39;a</code></li>
<li>如有<code>T: &#39;a</code>从句，则默认生命周期为<code>&#39;a</code></li>
<li>若有多个类似<code>T: &#39;a</code>从句，则需明确指定trait对象生命周期，
<code>Box&lt;Red + &#39;a&gt;</code>或<code>Box&lt;Red + &#39;static&gt;</code><h1 id="todo-2"><a href="#todo-2" class="headerlink" title="todo"></a>todo</h1></li>
</ul>
<p>正如其他bound，任何<code>Red</code>trait的实现内部包含引用，必须拥有和
trait对象bound中所指定的相同的生命周期</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:37.000Z" title="3/21/2019, 5:27:37 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-02T03:09:57.000Z" title="8/2/2021, 11:09:57 AM">2021-08-02</time></span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a></span><span class="level-item">4 minutes read (About 673 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Rust/test.html">Rust 测试</a></h1><div class="content"><h2 id="测试常用宏、属性注解"><a href="#测试常用宏、属性注解" class="headerlink" title="测试常用宏、属性注解"></a>测试常用宏、属性注解</h2><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><ul>
<li><code>assert!(exp,...)</code></li>
<li><code>assert_eq!(val1, val2,...)</code></li>
<li><code>assert_ne!(val1, val2,...)</code>
以上宏均可以传入自定义信息，所有的<code>...</code>中参数都将传递给
<code>format!</code>宏</li>
</ul>
<h3 id="属性注解"><a href="#属性注解" class="headerlink" title="属性注解"></a>属性注解</h3><ul>
<li><p><code>#[test]</code>：<code>$&gt;cargo test</code>时将测试此函数 </p>
</li>
<li><p><code>#[ignore]</code>：除非指定，否则<code>$&gt;cargo test</code>默认不测试此
函数（仍需和<code>#[test]</code>注解）</p>
</li>
<li><p><code>#[should_panic(expected=&amp;str)]</code>：测试中出现<code>panic</code>测试
通过，可以传递<code>expected</code>参数，当参数为<code>panic</code>信息的起始
子串才通过</p>
</li>
</ul>
<h2 id="cargo-test命令"><a href="#cargo-test命令" class="headerlink" title="cargo test命令"></a><code>cargo test</code>命令</h2><p>命令行参数和可执行文件参数用“—”分隔</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt;cargo <span class="built_in">test</span> cargo_params -- bin_params </span><br></pre></td></tr></table></figure>
<h3 id="可执行文件常用参数"><a href="#可执行文件常用参数" class="headerlink" title="可执行文件常用参数"></a>可执行文件常用参数</h3><ul>
<li>控制测试线程数目<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt;cargo <span class="built_in">test</span> -- --test-thread=1（不使用任何并行机制）</span><br></pre></td></tr></table></figure></li>
<li>禁止捕获输出（测试函数中的标准输出）<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt;cargo <span class="built_in">test</span> -- --nocapture</span><br></pre></td></tr></table></figure></li>
<li>测试<code>#[ignore]</code>标注的测试函数<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt;cargo <span class="built_in">test</span> -- --ignore</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="命令行常用参数"><a href="#命令行常用参数" class="headerlink" title="命令行常用参数"></a>命令行常用参数</h3><ul>
<li>指定部分测试函数<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt;cargo <span class="built_in">test</span> function_name（cargo匹配以此开头的函数）</span><br></pre></td></tr></table></figure></li>
<li>指定部分集成测试文件<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt;cargo <span class="built_in">test</span> --<span class="built_in">test</span> test_filename</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="单元测试、集成测试"><a href="#单元测试、集成测试" class="headerlink" title="单元测试、集成测试"></a>单元测试、集成测试</h2><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>在隔离环境中一次测试一个模块，可以测试私有接口，常用做法是
在每个文件中创建包含测试函数的tests模块，并使用
<code>#[cfg(test)]</code>标注，告诉rust仅在<code>cargo test</code>时才编译该mod</p>
<h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><p>相当于外部库，和用户使用代码的方式相同，只能测试公有接口，
可以同时测试多个模块</p>
<p>新建<code>/project/tests</code>目录（和<code>src</code>同级），cargo自动寻找此目录
中集成测试文件</p>
<ul>
<li><p>cargo将每个<strong>文件</strong>当作单独的<strong>crate</strong>编译（模仿用户）
其中的<strong>文件</strong>也不能共享相同的行为（fn、mod）</p>
<ul>
<li><p>需要像外部用户一样<code>extern crate</code>引入外部文件，因此
如果二进制库没有<code>lib.rs</code>文件，无法集成测试，推荐
采用<code>main.rs</code>调用<code>lib.rs</code>的逻辑结构</p>
</li>
<li><p>不需要添加任何<code>#[cfg(test)]</code>注解，cargo会自动将
<code>tests</code>中文件只在cargo test时编译</p>
</li>
<li><p>即使文件中不存在任何<code>#[test]</code>注解的测试函数，仍然会
对其进行测试，只是结果永远是通过</p>
</li>
</ul>
</li>
<li><p>而文件夹则不会当作<strong>测试crate</strong>编译</p>
<ul>
<li><p><code>cargo test</code>不会将文件夹视为<strong>测试crate</strong>，而是看作
一个mod</p>
</li>
<li><p>所以可以创建<code>tests/common/mod.rs</code>，并在测试文件中
通过<code>mod common;</code>声明定义<code>common mod</code>共享行为
（相当于所有的测试crate = 测试文件 + <code>common mod</code>）</p>
</li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:37.000Z" title="3/21/2019, 5:27:37 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-02-17T03:57:08.000Z" title="2/17/2019, 11:57:08 AM">2019-02-17</time></span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a></span><span class="level-item">a few seconds read (About 66 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Rust/twistes.html">Rust技巧</a></h1><div class="content"><h2 id="代码省略"><a href="#代码省略" class="headerlink" title="代码省略"></a>代码省略</h2><ul>
<li><code>for i in i.iter()</code></li>
<li><code>array[m..n]</code></li>
</ul>
<h2 id="问题明确"><a href="#问题明确" class="headerlink" title="问题明确"></a>问题明确</h2><ul>
<li>rust中slice也是左闭右开区间</li>
</ul>
<h2 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h2><ul>
<li>随便定义变量数据类型，编译后通过编译器给出的信息得到
某个函数返回值类型</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:37.000Z" title="3/21/2019, 5:27:37 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-02-17T03:57:08.000Z" title="2/17/2019, 11:57:08 AM">2019-02-17</time></span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a></span><span class="level-item">13 minutes read (About 1983 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Rust/unsafe_rust.html">Unsafe Rust</a></h1><div class="content"><p>不安全的Rust存在原因</p>
<ul>
<li>Rust在编译时强制执行内存安全保证，但这样的静态分析是
保守的，有些代码编译器认为不安全，但其实合法</li>
<li>底层计算机硬件的固有的不安全性，必须进行某些不安全操作
才能完成任务</li>
</ul>
<p>因此需要通过<code>unsafe</code>关键字切换到<strong>不安全的Rust</strong>，开启存放
不安全代码的块，只能在不安全Rust中进行的操作如下</p>
<ul>
<li>解引用裸指针，</li>
<li>调用不安全的函数、方法</li>
<li>访问或修改可变静态变量</li>
<li>实现不安全trait</li>
</ul>
<p>需要注意的是，<code>unsafe</code>不会关闭借用检查器或其它Rust安全检查，
在不安全Rust中仍然会检查引用，<code>unsafe</code>关键字只告诉编译器忽略
上述4中情况的内存安全检查，此4种的内存安全由用户自己保证，
这就保证出现内存安全问题只需要检查<code>unsafe</code>块。可以将不安全
代码封装进安全的抽象并提供API，隔离不安全代码。</p>
<h2 id="解引用裸指针（raw-pointer）"><a href="#解引用裸指针（raw-pointer）" class="headerlink" title="解引用裸指针（raw pointer）"></a>解引用裸指针（raw pointer）</h2><ul>
<li><code>*const T</code>：<code>T</code>类型不可变裸指针</li>
<li><code>*mut T</code>：<code>T</code>类型可变裸指针</li>
</ul>
<p>裸指针的上下文中，裸指针意味着指针解引用后不能直接赋值，
裸指针和引用、智能指针的区别</p>
<ul>
<li>允许忽略借用规则，允许同时拥有不可变和可变指针，或者
多个相同位置（值）的可变指针</li>
<li>不保证指向有效的内存</li>
<li>允许为空</li>
<li>不能实现任何自动清理功能</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> num = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> r1 = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;</span><br><span class="line"><span class="keyword">let</span> r2 = &amp;num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">i32</span>;</span><br><span class="line">	<span class="comment">//`as`将不可变引用和可变引用强转为对应的裸指针类型</span></span><br><span class="line">	<span class="comment">//同时创建`num`的可变裸指针和不可变裸指针</span></span><br><span class="line">	<span class="comment">//创建裸指针是安全的</span></span><br><span class="line"><span class="keyword">unsafe</span>&#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;r1 is: &#123;&#125;&quot;</span>, *r1);</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;r2 is: &#123;&#125;&quot;</span>, *r2);</span><br><span class="line">		<span class="comment">//解引用裸指针是不安全的，需要放在`unsafe`块中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> address = <span class="number">0x012345usize</span>;</span><br><span class="line">	<span class="comment">//创建任意地址</span></span><br><span class="line"><span class="keyword">let</span> r = address  <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;</span><br><span class="line">	<span class="comment">//创建指向任意内存地址的裸指针</span></span><br></pre></td></tr></table></figure>
<h2 id="调用不安全的函数或方法"><a href="#调用不安全的函数或方法" class="headerlink" title="调用不安全的函数或方法"></a>调用不安全的函数或方法</h2><p>不安全函数和方法类似常规，在开头有<code>unsafe</code>关键字标记，表示
函数含有<em>内存不安全</em>的内容，Rust不再保证此函数内存安全，需要
程序员保证。</p>
<p>但是包含不安全代码并不意味着整个函数都需要标记为不安全，相反
将不安全代码封装于安全函数中是隔离<code>unsafe</code>代码的方法。应该
将<strong>不安全代码与调用有关</strong>的函数标记为<code>unsafe</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">dangerous</span></span>() &#123;&#125;</span><br><span class="line">	<span class="comment">//`unsafe`关键字表示此函数为不安全函数，含有内存不安全</span></span><br><span class="line">	<span class="comment">//内容，需要程序员自身保证其内存安全</span></span><br><span class="line">	<span class="comment">//但是，包含不安全代码的函数不意味着整个函数都需要标记为</span></span><br><span class="line">	<span class="comment">//不安全，相反的，将不安全代码封装进安全函数是常用的</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//不安全函数体也是`unsafe`块，在其中进行不安全操作时，</span></span><br><span class="line">	<span class="comment">//不需要包裹于`unsafe`块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span>&#123;</span><br><span class="line">	dangerous();</span><br><span class="line">	<span class="comment">//调用不安全函数也需要在`unsafe`块中，表示调用者确认此</span></span><br><span class="line">	<span class="comment">//“不安全”函数在此上下文中是*内存安全*</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用不安全的函数时也需要放在<code>unsafe</code>中，表示程序员确认此函数
在调用上下文中是内存安全的。</p>
<h3 id="split-at-mut的实现"><a href="#split-at-mut的实现" class="headerlink" title="split_at_mut的实现"></a><code>split_at_mut</code>的实现</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> r = &amp;<span class="keyword">mut</span> v[..];</span><br><span class="line"><span class="keyword">let</span> (a, b)  r.split_at_mut(<span class="number">3</span>);</span><br><span class="line">	<span class="comment">//以index=3分隔为两个列表引用（左开右闭）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(a, &amp;<span class="keyword">mut</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="built_in">assert_eq!</span>(b, &amp;<span class="keyword">mut</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br></pre></td></tr></table></figure>
<p><code>split_at_mut</code>方法无法指通过安全Rust实现，一个大概的“函数”
实现可以如此</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::slice;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">split_at_mut</span></span>(slice: &amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>], mid: <span class="built_in">usize</span>) -&gt; (&amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>], &amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>]) &#123;</span><br><span class="line">	<span class="comment">//这里根据生命周期省略规则省略了生命周期注解</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//在所有权里就有提到，这里不也是可变引用吗，为啥这样</span></span><br><span class="line">	<span class="comment">//还可以通过编译，是对方法中的`self`有特殊的处理吗</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> len = slice.len();</span><br><span class="line">	<span class="keyword">let</span> ptr = slice.as_mut_ptr();</span><br><span class="line">		<span class="comment">//`as_mut_ptr`返回`*mut T`可变裸指针</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">assert!</span>(mid &lt;= len);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">unsafe</span>&#123;</span><br><span class="line">		(slice::from_raw_parts_mut(ptr, mid),</span><br><span class="line">			<span class="comment">//`from_raw_parts_mut`根据裸指针和长度两个参数</span></span><br><span class="line">			<span class="comment">//创建slice，其是不安全的，因为其参数是一个</span></span><br><span class="line">			<span class="comment">//裸指针，无法保证内存安全，另外长度也不总是有效</span></span><br><span class="line">		slice::from_raw_parts_mut(ptr.offset(mid <span class="keyword">as</span> <span class="built_in">isize</span>), len - mid))</span><br><span class="line">			<span class="comment">//`offset`同样是不安全的，其参数地址偏移量无法</span></span><br><span class="line">			<span class="comment">//保证始终有效</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用extern函数调用外部代码"><a href="#使用extern函数调用外部代码" class="headerlink" title="使用extern函数调用外部代码"></a>使用<code>extern</code>函数调用外部代码</h3><p><code>extern</code>关键字用于创建、使用外部函数接口</p>
<blockquote>
<ul>
<li>外部函数接口FFI：foreign function interface，编程语言
用以定义函数的方式，允许不同（外部）编程语言调用这些
函数</li>
<li>应用程序接口ABI：application binary interface，定义了
  如何在汇编层面调用函数</li>
</ul>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">	<span class="comment">//`&quot;C&quot;`定义了外部函数所使用的ABI</span></span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">abs</span></span>(input: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>;</span><br><span class="line">	<span class="comment">//希望调用的其他语言中的（外部）函数签名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">unsafe</span>&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;absolute value of -3 according to C: &#123;&#125;&quot;</span>, abs(-<span class="number">3</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>extern</code>块中声明的函数总是不安全的，因为其他语言并不强制执行
Rust的内存安全规则，且Rust无法检查，因此调用时需要放在
<code>unsafe</code>块中，程序员需要确保其安全</p>
<h3 id="通过其他语言调用Rust函数"><a href="#通过其他语言调用Rust函数" class="headerlink" title="通过其他语言调用Rust函数"></a>通过其他语言调用Rust函数</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line">	<span class="comment">//告诉Rust编译器不要mangle此函数名称</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">fn</span> <span class="title">call_from_c</span></span>()&#123;</span><br><span class="line">	<span class="comment">//此函数编译器为动态库并从C语言中链接，就可在C代码中访问</span></span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;just called a Rust function from C!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>   mangle发生于编译器将函数名修改为不同的名称，这会增加
    用于其他编译器过程中的额外信息，但是会使其名称难以阅读
    而不同的编程语言的编译器mangle函数名的方式可能不同</p>
</blockquote>
<h2 id="访问或修改可变静态变量"><a href="#访问或修改可变静态变量" class="headerlink" title="访问或修改可变静态变量"></a>访问或修改可变静态变量</h2><p>全局变量：Rust中称为静态（static）变量</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> HELLO_WORLD: &amp;<span class="built_in">str</span> = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">	<span class="comment">//静态变量（不可变）</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;name is: &#123;&#125;&quot;</span>, HELLO_WORLD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>名称采用<code>SCREAMING_SNAKE_CASE</code>写法，必须标注变量类型</li>
<li>只能存储<code>‘static</code>生命周期的引用，因此无需显著标注</li>
<li>不可变静态变量和常量（不可变变量）有些类似<ul>
<li>静态变量值有固定的内存地址，使用其总会访问相同地址</li>
<li>常量则允许在任何被用到的时候复制数据</li>
</ul>
</li>
</ul>
<p>访问不可变静态变量是安全的，但访问、修改不可变静态变量都是
不安全的，因为可全局访问的可变数据难以保证不存在数据竞争，
因此在任何可能情况，优先使用智能指针，借助编译器避免数据竞争</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> COUNTER： <span class="built_in">u32</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//可变静态变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add_to_count</span></span>(inc: <span class="built_in">u32</span>)&#123;</span><br><span class="line">	<span class="keyword">unsafe</span> &#123;</span><br><span class="line">		COUNTER += inc;</span><br><span class="line">		<span class="comment">//修改可变静态变量</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	add_to_count(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsafe</span>&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;COUNTER: &#123;&#125;&quot;</span>, COUNTER);</span><br><span class="line">		<span class="comment">//访问可变静态变量</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现不安全trait"><a href="#实现不安全trait" class="headerlink" title="实现不安全trait"></a>实现不安全trait</h2><p>存在方法中包含编译器不能验证的不变量的trait时不安全的，可以
在<code>trait</code>前增加<code>unsafe</code>将trait生命为<code>unsafe</code>，且实现trait
也需要标记为<code>unsafe</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="class"><span class="keyword">trait</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> Foo <span class="keyword">for</span> <span class="built_in">i32</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如为裸指针类型实现（标记）<code>Send</code>、<code>Sync</code>trait时需要标记
<code>unsafe</code>，因为Rust不能验证此类型可以安全跨线程发送或多线程
访问，需要自行检查</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:37.000Z" title="3/21/2019, 5:27:37 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-02-17T03:57:08.000Z" title="2/17/2019, 11:57:08 AM">2019-02-17</time></span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a></span><span class="level-item">37 minutes read (About 5483 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Rust/grammer.html">Rust 语法</a></h1><div class="content"><h2 id="Rust是基于表达式的语言"><a href="#Rust是基于表达式的语言" class="headerlink" title="Rust是基于表达式的语言"></a>Rust是基于表达式的语言</h2><p>表达式返回一个值，而语句不返回，rust中除两种语句外，全是
表达式</p>
<ul>
<li><code>let</code>引入绑定<ul>
<li>可变绑定赋值是表达式，返回空tuple</li>
<li>声明后初始化绑定？#todo</li>
</ul>
</li>
<li>表达式语句：表达式后跟分号转换为语句</li>
</ul>
<p>代码中rust希望语句后跟语句，使用分号分隔表达式，所以rust
看起来和其他大部分分号结尾语言相似</p>
<p><code>&#123;&#125;</code>包裹的代码块内最后一“句”没有以”;”结尾，那么是表达式，且
返回该表达式的值，整个代码块可以看作是表达式，否则为语句，
没有返回值，函数同</p>
<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><h3 id="Refutability（可反驳性）"><a href="#Refutability（可反驳性）" class="headerlink" title="Refutability（可反驳性）"></a>Refutability（可反驳性）</h3><ul>
<li>refutable（可反驳的）：对某些可能值匹配失败的模式，
<code>if let</code>、<code>while let</code>只能接受可反驳的模式，因为这就用于
处理可能的失败</li>
<li>irrefutable（不可反驳的）：能匹配任何传递的可能值，<code>let</code>
语句、函数参数、<code>for</code>循环只能接受不可反驳的模式，因为
通过不匹配值的程序无意义</li>
</ul>
<blockquote>
<p>   可能值是指“类型”相同，可用于匹配的值</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="literal">Some</span>(x) = some_optiona_value;</span><br><span class="line">	<span class="comment">//`Some(x)`是refutable模式，若`some_optional_value`为</span></span><br><span class="line">	<span class="comment">//None，则此时无法成功匹配，此语句可能无法正常工作</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> x = <span class="number">5</span> &#123;</span><br><span class="line">	<span class="comment">//`x`是inrefutable模式，对所有可能值都可以匹配，此语句</span></span><br><span class="line">	<span class="comment">//无意义</span></span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Refutable"><a href="#Refutable" class="headerlink" title="Refutable"></a>Refutable</h3><h4 id="match控制流"><a href="#match控制流" class="headerlink" title="match控制流"></a><code>match</code>控制流</h4><ul>
<li>各分支模式同值“类型”必须完全一致才能匹配</li>
<li>返回类型必须一致，如果有返回值</li>
<li>匹配必须是穷尽的，可以使用通配符<code>_</code>（匹配所有的值）代替<ul>
<li>match是匹配到就退出，不像switch一样会继续下沉</li>
<li>通配符不总是需要的，对于枚举类型只要含有所有枚举
成员的分支即可</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> x&#123;</span><br><span class="line">	<span class="literal">Some</span>(<span class="number">50</span>) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;got 50&quot;</span>),</span><br><span class="line">		<span class="comment">//`Some(50)`这个模式规定了“值”</span></span><br><span class="line">	<span class="literal">Some</span>(y) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;matched, y = &#123;:?&#125;&quot;</span>, y),</span><br><span class="line">		<span class="comment">//match表达式作用域中的`y`会覆盖周围环境的`y`</span></span><br><span class="line">	_ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;default case, x = &#123;:?&#125;&quot;</span>, x),</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;at the end: x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br></pre></td></tr></table></figure>
<h4 id="if-let-else-简洁控制流"><a href="#if-let-else-简洁控制流" class="headerlink" title="if let[else]简洁控制流"></a><code>if let[else]</code>简洁控制流</h4><ul>
<li>只匹配关心的一个模式</li>
<li>可以添加<code>else</code>语句，类似<code>match</code>通配符匹配</li>
<li><code>if let</code>、<code>else if</code>、<code>else if let</code>等相互组合可以提供更多
的灵活性<ul>
<li><code>else if</code>可以不是模式匹配</li>
<li>各<code>if</code>后的比较的值可以没有关联</li>
</ul>
</li>
<li>没有穷尽性检查，可能会遗漏一些情况</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> favorite_color: <span class="built_in">Option</span>&lt;&amp;<span class="built_in">str</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">	<span class="keyword">let</span> is_tuesday = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">let</span> age: <span class="built_in">Result</span>&lt;<span class="built_in">u8</span>, _&gt; = <span class="string">&quot;34&quot;</span>.parse();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(color) = favorite_color&#123;</span><br><span class="line">		<span class="comment">//模式匹配</span></span><br><span class="line">		<span class="comment">//注意这里是`=`而不是一般值比较`==`</span></span><br><span class="line">		<span class="comment">//`while`同</span></span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;favorite color is &#123;&#125;&quot;</span>, color&#125;;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> is_tuesday&#123;</span><br><span class="line">		<span class="comment">//普通`if`条件语句</span></span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;Tuesday is green day!&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Ok</span>(age) = age&#123;</span><br><span class="line">		<span class="comment">//`age`变量覆盖原变量</span></span><br><span class="line">		<span class="comment">//此时`age`是`u8`类型</span></span><br><span class="line">		<span class="keyword">if</span> age &gt; <span class="number">30</span> &#123;</span><br><span class="line">			<span class="comment">//因此此条件不能提出，因为两个`age`变量不同，</span></span><br><span class="line">			<span class="comment">//不能共存在同一条语句中</span></span><br><span class="line">			<span class="built_in">println!</span>(<span class="string">&quot;Using purple as the background color&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">println!</span>(<span class="string">&quot;Using orange as the background color&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;Using blue as the background color&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Irrefutable"><a href="#Irrefutable" class="headerlink" title="Irrefutable"></a>Irrefutable</h3><h4 id="while-let条件循环"><a href="#while-let条件循环" class="headerlink" title="while let条件循环"></a><code>while let</code>条件循环</h4><p>和<code>if let</code>条件表达式类似，循环直到模式不匹配</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> stack = <span class="built_in">Vec</span>::new();</span><br><span class="line">	stack.push(<span class="number">1</span>);</span><br><span class="line">	stack.push(<span class="number">2</span>);</span><br><span class="line">	stack.push(<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(top) = stack.pop()&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, top);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="for解构"><a href="#for解构" class="headerlink" title="for解构"></a><code>for</code>解构</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">	<span class="keyword">for</span> (index, value) <span class="keyword">in</span> v.iter().enumerate()&#123;</span><br><span class="line">		<span class="comment">//解构tuple</span></span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; is at index &#123;&#125;&quot;</span>, value, index);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="let解构"><a href="#let解构" class="headerlink" title="let解构"></a><code>let</code>解构</h4><p><code>let</code>语句本“应该“看作是模式匹配</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> PARTTERN = EXPRESSION;</span><br><span class="line">	<span class="comment">//这样就和`if let`模式匹配中`=`一致</span></span><br><span class="line">	<span class="comment">//应该可以把`=`看作是模式匹配的符号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">	<span class="comment">//这里`x`是一个模式“变量”</span></span><br><span class="line"><span class="keyword">let</span> (x, y, z) = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">	<span class="comment">//`(x, y, z)`是模式“3元元组“</span></span><br><span class="line">	<span class="comment">//解构元组</span></span><br></pre></td></tr></table></figure>
<h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>类似于<code>let</code>语句，函数参数也“应该”看作是模式匹配</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(x: <span class="built_in">i32</span>)&#123;</span><br><span class="line">	<span class="comment">//`x`表示模式“变量”</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_coordinates</span></span>(&amp;(x, y): &amp;(<span class="built_in">i32</span>, <span class="built_in">i32</span>))&#123;</span><br><span class="line">	<span class="comment">//这里`(x, y)`是模式“元组”</span></span><br><span class="line">	<span class="comment">//但是这里处于函数变量类型的要求，有点像元组结构体</span></span><br><span class="line">	<span class="comment">//调用时使用元组即可</span></span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;Current location: (&#123;&#125;, &#123;&#125;)&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模式匹配用法"><a href="#模式匹配用法" class="headerlink" title="模式匹配用法"></a>模式匹配用法</h3><h4 id="、-“或“"><a href="#、-“或“" class="headerlink" title="|、...“或“"></a><code>|</code>、<code>...</code>“或“</h4><ul>
<li><code>|</code>“或”匹配多个模式</li>
<li><code>...</code>闭区间范围模式，仅适用于数值、<code>char</code>值</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">	<span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one&quot;</span>),</span><br><span class="line">		<span class="comment">//`1`是模式“字面值”</span></span><br><span class="line">	<span class="number">2</span> | <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;two or three&quot;</span>),</span><br><span class="line">		<span class="comment">//`|`分隔，匹配多个模式</span></span><br><span class="line">	<span class="number">5</span>...<span class="number">10</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;through 5 to 10&quot;</span>),</span><br><span class="line">		<span class="comment">//`...`表示匹配一个**闭区间**范围的值</span></span><br><span class="line">		<span class="comment">//这个语法只能用于数字或者是`char`值，因为编译器会</span></span><br><span class="line">		<span class="comment">//检查范围不为空，而只有数字、`char`值rust可以判断</span></span><br><span class="line">	_ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;anything&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">	<span class="string">&#x27;a&#x27;</span>...<span class="string">&#x27;j&#x27;</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;early ASCII letter&quot;</span>),</span><br><span class="line">	<span class="string">&#x27;k&#x27;</span>...<span class="string">&#x27;z&#x27;</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;late ASCII letter&quot;</span>),</span><br><span class="line">	_ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;something else&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="、-”忽略“"><a href="#、-”忽略“" class="headerlink" title="_、..”忽略“"></a><code>_</code>、<code>..</code>”忽略“</h4><ul>
<li><p><code>_</code>忽略整个值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(_: <span class="built_in">i32</span>, y: <span class="built_in">i32</span>)&#123;</span><br><span class="line">	<span class="comment">//函数签名中忽略整个值</span></span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;this code only use the y parameter: &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	foo(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> setting_value = <span class="literal">Some</span>(<span class="number">5</span>); <span class="keyword">let</span> new_setting_value = <span class="literal">Some</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">match</span> (setting_value, new_setting_value)&#123;</span><br><span class="line">		(<span class="literal">Some</span>(_), <span class="literal">Some</span>()) =&gt; &#123;</span><br><span class="line">			<span class="comment">//嵌套`_`忽略部分值</span></span><br><span class="line">			<span class="comment">//此时没有任何值所有权</span></span><br><span class="line">			<span class="built_in">println!</span>(<span class="string">&quot;can&#x27;t overwrite an exsiting customized value&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		_ =&gt; &#123;</span><br><span class="line">			setting_value = new_setting_value;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;setting is &#123;:?&#125;&quot;</span>, setting_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>_var</code>变量名前添加下划线忽略未使用变量，此时值所有权
仍然会转移，只是相当于告诉编译器忽略该未使用变量</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> _x = <span class="number">5</span>;</span><br><span class="line">		<span class="comment">//两个变量未使用，但是编译时只有一个warning</span></span><br><span class="line">	<span class="keyword">let</span> y = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> s = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(_s) = s &#123;</span><br><span class="line">		<span class="comment">//值所有权已转移，`s`不能继续使用</span></span><br><span class="line">		<span class="comment">//编译器忽略未使用`_s`，不给出warning</span></span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;get a integer&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>..</code>忽略剩余值</p>
<ul>
<li><code>..</code>的使用必须无歧义</li>
<li>对于结构体即使只有一个field，需使用<code>..</code>忽略剩余值，
不能使用<code>_</code><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> numbers = (<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>);</span><br><span class="line">	<span class="keyword">match</span> numbers&#123;</span><br><span class="line">		(first, .., last) =&gt; &#123;</span><br><span class="line">			<span class="built_in">println!</span>(<span class="string">&quot;Some numbers: &#123;&#125;, &#123;&#125;&quot;</span>, first, last);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (x, _, z) = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">	<span class="comment">//`_`忽略模式中各一个值</span></span><br><span class="line"><span class="keyword">let</span> (x, .., z) = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">	<span class="comment">//`..`忽略模式中多个值</span></span><br></pre></td></tr></table></figure>
<h4 id="解构结构体"><a href="#解构结构体" class="headerlink" title="解构结构体"></a>解构结构体</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">	x: <span class="built_in">i32</span>,</span><br><span class="line">	y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> p = Point&#123;x: <span class="number">0</span>, y: <span class="number">7</span>&#125;;</span><br><span class="line">	<span class="keyword">let</span> Point&#123;x: a, y: b&#125; = p;</span><br><span class="line">		<span class="comment">//`Point&#123;x: a, y: b&#125;`是模式”Point结构体“</span></span><br><span class="line">		<span class="comment">//解构结构体</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> p = Point&#123;x: <span class="number">0</span>, y: <span class="number">7</span>&#125;;</span><br><span class="line">	<span class="keyword">let</span> Point&#123;x, y&#125; = p;</span><br><span class="line">		<span class="comment">//模式匹配解构结构体简写</span></span><br><span class="line">		<span class="comment">//只要列出结构体字段，模式创建相同名称的变量</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> p = Point&#123;x: <span class="number">0</span>, y: <span class="number">7</span>&#125;;</span><br><span class="line">	<span class="keyword">match</span> p &#123;</span><br><span class="line">		Point &#123;x, y: <span class="number">0</span>&#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;on the x axis at &#123;&#125;&quot;</span>, x),</span><br><span class="line">		Point &#123;x: <span class="number">0</span>, y&#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;on the y axis at &#123;&#125;&quot;</span>, y),</span><br><span class="line">		Point &#123;x, y&#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;on neither axis: (&#123;&#125;, &#123;&#125;)&quot;</span>, x, y),</span><br><span class="line">			<span class="comment">//这里没有`_`通配符，因为`Point &#123;x, y&#125;`模式已经</span></span><br><span class="line">			<span class="comment">//是irrefutable，不需要</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解构枚举"><a href="#解构枚举" class="headerlink" title="解构枚举"></a>解构枚举</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">	Quit,</span><br><span class="line">	Move&#123;x: <span class="built_in">i32</span>, y:<span class="built_in">i32</span>&#125;,</span><br><span class="line">	Write(<span class="built_in">String</span>),</span><br><span class="line">	ChangeColor(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> msg = Message::ChangeColor(<span class="number">0</span>, <span class="number">160</span>, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> p = <span class="keyword">match</span> msg&#123;</span><br><span class="line">		<span class="comment">//这里`match`返回值必须类型完全相同</span></span><br><span class="line">		Message::Move&#123;x, y&#125; <span class="keyword">if</span> x == <span class="number">0</span> =&gt; (x, y),</span><br><span class="line">			<span class="comment">//对于`Message`中的匿名结构体类型的成员，匿名</span></span><br><span class="line">			<span class="comment">//结构体没有枚举类型外的定义、名称，无法、也</span></span><br><span class="line">			<span class="comment">//不应该直接获取结构体</span></span><br><span class="line">		Message::Write(<span class="keyword">ref</span> <span class="built_in">str</span>) =&gt; &#123;</span><br><span class="line">			<span class="comment">//`Message::Write`不是`Message`的一个枚举成员</span></span><br><span class="line">			<span class="comment">//必须`Message::Write(str)`才是（能够匹配）</span></span><br><span class="line">			<span class="built_in">println!</span>(<span class="string">&quot;write &#123;&#125;&quot;</span>, <span class="built_in">str</span>);</span><br><span class="line">			(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">		Message::ChangeColor(..) =&gt; (<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">			<span class="comment">//类似的，需要使用`..`忽略值，仅`ChangeColor`</span></span><br><span class="line">			<span class="comment">//不是`Message`成员</span></span><br><span class="line">		_ =&gt; &#123;</span><br><span class="line">			<span class="built_in">println!</span>(<span class="string">&quot;quit&quot;</span>);</span><br><span class="line">			(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="amp-、ref、ref-mut”引用“"><a href="#amp-、ref、ref-mut”引用“" class="headerlink" title="&amp;、ref、ref mut”引用“"></a><code>&amp;</code>、<code>ref</code>、<code>ref mut</code>”引用“</h4><ul>
<li><p><code>&amp;</code>匹配引用，“获得”值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> points = <span class="built_in">vec!</span>[</span><br><span class="line">	Point &#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;,</span><br><span class="line">	Point &#123;x: <span class="number">1</span>, y: <span class="number">5</span>&#125;,</span><br><span class="line">	Point &#123;x: <span class="number">10</span>, y: -<span class="number">3</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sum_of_squares: <span class="built_in">i32</span> = points</span><br><span class="line">	.iter()</span><br><span class="line">	.map(|&amp;Point &#123;x, y&#125;| x * x + y * y)</span><br><span class="line">		<span class="comment">//`&amp;`匹配一个引用</span></span><br><span class="line">	.sum();</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ref</code>匹配值，“获得”不可变引用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> robot_name = <span class="literal">Some</span>(<span class="built_in">String</span>::from(<span class="string">&quot;Bors&quot;</span>));</span><br><span class="line"><span class="keyword">match</span> robot_name&#123;</span><br><span class="line">	<span class="literal">Some</span>(<span class="keyword">ref</span> name) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;found a name: &#123;&#125;&quot;</span>, name),</span><br><span class="line">		<span class="comment">//使用`ref`获取不可变引用才能编译成功</span></span><br><span class="line">		<span class="comment">//否则所有权转移，之后报错</span></span><br><span class="line">	<span class="literal">None</span> =&gt; (),</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;robot_name is: &#123;:?&#125;&quot;</span>, robot_name);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ref mut</code>匹配值，“获得”可变引用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> robot_name = <span class="literal">Some</span>(<span class="built_in">String</span>::from(<span class="string">&quot;Bors&quot;</span>));</span><br><span class="line"><span class="keyword">match</span> robot_name&#123;</span><br><span class="line">	<span class="literal">Some</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> name) =&gt; *name = <span class="built_in">String</span>::from(<span class="string">&quot;NewName&quot;</span>),</span><br><span class="line">	<span class="literal">None</span> =&gt; (),</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;robot_name is: &#123;:?&#125;&quot;</span>, robot_name);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="ifmatch-guard"><a href="#ifmatch-guard" class="headerlink" title="ifmatch guard"></a><code>if</code>match guard</h4><p>匹配守卫<em>match guard</em>：放在<code>=&gt;</code>之前的<code>if</code>语句，<code>match</code>
分支的额外条件，条件为真才会继续执行分支代码</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="literal">Some</span>(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">match</span> num&#123;</span><br><span class="line">	<span class="literal">Some</span>(x) <span class="keyword">if</span> x &lt; y =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#x27;less than y: &#123;&#125;&quot;</span>, x),</span><br><span class="line">	<span class="literal">Some</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x),</span><br><span class="line">	<span class="literal">None</span> =&gt; (),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">	<span class="number">4</span> | <span class="number">5</span> | <span class="number">6</span> <span class="keyword">if</span> y =&gt; <span class="built_in">println!</span>(<span class="string">&quot;yes&quot;</span>),</span><br><span class="line">		<span class="comment">//`4 | 5 | 6`整体作为一个模式，match guard作用于</span></span><br><span class="line">		<span class="comment">//模式整体，而不是单独的`6`</span></span><br><span class="line">	_ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;no&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="绑定"><a href="#绑定" class="headerlink" title="@绑定"></a><code>@</code>绑定</h4><p><code>@</code>允许在创建存放值的变量时，同时测试值是否匹配模式</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">	Hello &#123; id: <span class="built_in">i32</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> msg = Message::Hello &#123; id: <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">match</span> msg&#123;</span><br><span class="line">	Message::Hello&#123; id: id_variable @ <span class="number">3</span>...<span class="number">7</span> &#125; =&gt; &#123;</span><br><span class="line">		<span class="comment">//匹配结构体模式（值绑定`id_variable`）&amp;&amp;值在`3...7`范围</span></span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;Found an id in range: &#123;&#125;&quot;</span>, id_variable)</span><br><span class="line">	&#125;,</span><br><span class="line">	Message::Hello&#123; id: <span class="number">10</span>...<span class="number">12</span> &#125; =&gt; &#123;</span><br><span class="line">		<span class="comment">//此分支模式指定了值的范围，但是没有绑定值给变量`id`</span></span><br><span class="line">		<span class="comment">//结构体匹配简略写法不能应用与此</span></span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;Found an id in another range&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	Message::Hello&#123; id &#125; =&gt; &#123;</span><br><span class="line">		<span class="comment">//此分支结构体匹配简略写法，值绑定于`id`</span></span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;Found some other id: &#123;&#125;&quot;</span>, id)</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="闭包closures和函数指针"><a href="#闭包closures和函数指针" class="headerlink" title="闭包closures和函数指针"></a>闭包closures和函数指针</h2><p>闭包是可以保存进变量或作为参数传递给其他函数的匿名函数，
可以在一个地方创建闭包，而在不同的上下文执行闭包。和函数
的区别在于，其可以捕获调用者作用域中的值，当然这会有性能
损失，如果不需要捕获调用者作用域中的值可以考虑使用函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> closures = |param1, param2|&#123;</span><br><span class="line">	...</span><br><span class="line">	expression</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>闭包参数：<strong>调用者</strong>使用，<ul>
<li>创建闭包赋值给变量，再通过变量调用闭包</li>
<li>创建闭包作为参数传递，其他函数调用</li>
</ul>
</li>
<li>捕获环境变量：创建闭包作为参数传递，直接使用周围环境变量</li>
</ul>
<h3 id="闭包类型推断和注解"><a href="#闭包类型推断和注解" class="headerlink" title="闭包类型推断和注解"></a>闭包类型推断和注解</h3><p>闭包不要求像函数一样需要在参数和返回值上注明类型，函数需要
类型注解因为其是需要暴露给的显示接口的一部分，而闭包不用于
作为对外暴露的接口</p>
<ul>
<li>作为匿名函数直接使用，或者存储在变量中</li>
<li>通常很短，使用场景上下文比较简单，编译器能够推断参数和
返回值类型</li>
</ul>
<p>当然，闭包也可以添加注解增加明确性</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span>  <span class="title">add_one_v1</span>   &#123;<span class="title">x</span>: <span class="title">u32</span>&#125; -&gt; <span class="title">u32</span> &#123; <span class="title">x</span> + 1 &#125;;</span></span><br><span class="line"><span class="function"><span class="title">let</span> <span class="title">add_one_v2</span> = |<span class="title">x</span>: <span class="title">u32</span>| -&gt; <span class="title">u32</span> &#123; <span class="title">x</span> + 1 &#125;;</span></span><br><span class="line"><span class="function"><span class="title">let</span> <span class="title">add_one_v3</span> = |<span class="title">x</span>|             &#123; <span class="title">x</span> + 1 &#125;;</span></span><br><span class="line"><span class="function"><span class="title">let</span> <span class="title">add_one_v4</span> = |<span class="title">x</span>|               <span class="title">x</span> + 1;</span></span><br><span class="line"><span class="function">	//闭包体只有一行可以省略`&#123;&#125;`</span></span><br></pre></td></tr></table></figure>
<p>Rust会根据闭包出调用为每个参数和返回值推断类型，并将其锁定，
如果尝试对同一闭包使用不同类型的参数调用会报错</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> example_closure = |x| x;</span><br><span class="line"><span class="keyword">let</span> s = example_closure(<span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">	<span class="comment">//此时已经锁定闭包参数、返回值类型</span></span><br><span class="line"><span class="keyword">let</span> n = example_closure(<span class="number">5</span>);</span><br><span class="line">	<span class="comment">//尝试使用`i32`类型调用闭包会报错</span></span><br></pre></td></tr></table></figure>
<h3 id="Fntrait-bound"><a href="#Fntrait-bound" class="headerlink" title="Fntrait bound"></a><code>Fn</code>trait bound</h3><p>每个闭包实例有自己独有的匿名类型，即使两个闭包有相同的签名，
其类型依然不同。为了定义使用闭包的结构体、枚举、函数参数，
（这些定义中都需要指定元素类型），需要使用泛型和trait 
bound</p>
<ul>
<li><code>FnOnce</code>：获取从周围环境捕获的变量的所有权，因此只能调用
一次，即<code>Once</code>的含义</li>
<li><code>Fn</code>：获取从周围环境捕获的变量的不可变引用</li>
<li><code>FnMut</code>：获取从周围环境捕获的变量的可变引用</li>
</ul>
<p>所有的闭包都实现了以上3个trait中的一个，Rust根据闭包如何
使用环境中的变量推断其如何捕获环境，及实现对应的trait</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cacher</span></span>&lt;T&gt;</span><br><span class="line">	<span class="keyword">where</span> T: <span class="built_in">Fn</span>(<span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span>&#123;</span><br><span class="line">		<span class="comment">//`T`的类型中包括`Fn`、参数、返回值三个限定</span></span><br><span class="line">	calculation: T,</span><br><span class="line">	value: <span class="built_in">Option</span>&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Function-Pointer-fn"><a href="#Function-Pointer-fn" class="headerlink" title="Function Pointer fn"></a>Function Pointer <code>fn</code></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add_one</span></span>(x: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>&#123;</span><br><span class="line">	x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">do_twice</span></span>(f: <span class="function"><span class="keyword">fn</span></span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>, arg: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>&#123;</span><br><span class="line">	<span class="comment">//`f`是`fn`函数指针类型</span></span><br><span class="line">	f(arg) + f(arg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> answer = do_twice(add_one, <span class="number">5</span>);</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;the anwser is: &#123;&#125;&quot;</span>, anwser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数指针类型实现了以上<strong>全部</strong><code>Fn</code>、<code>FnMut</code>、<code>FnOnce</code>三个
trait，所以总是可以在调用期望闭包作为参数的函数时传递函数
指针，因此倾向于使用泛型和闭包trait bound的函数，这样可以
同时使用闭包、函数指针作为参数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list_of_numbers = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> list_of_Strings: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = list_of_numbers</span><br><span class="line">	.iter()</span><br><span class="line">	.map(|i| i.to_string())</span><br><span class="line">		<span class="comment">//闭包作为参数传递</span></span><br><span class="line">	.collect();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list_of_strings: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = list_of_numbers</span><br><span class="line">	.iter()</span><br><span class="line">	.map(<span class="built_in">ToString</span>::to_string)</span><br><span class="line">		<span class="comment">//函数作为参数传递</span></span><br><span class="line">		<span class="comment">//使用了完全限定语法，因为存在多个`to_string`函数</span></span><br><span class="line">		<span class="comment">//标准库为所有实现了`Display`的类型实现了此trait</span></span><br><span class="line">	.collect();</span><br></pre></td></tr></table></figure>
<p>与不存在闭包的外部代码（如C语言，只有函数没有闭包）交互时，
只能使用函数作为参数，不能使用闭包。</p>
<h3 id="move关键字"><a href="#move关键字" class="headerlink" title="move关键字"></a><code>move</code>关键字</h3><p><code>move</code>关键字强制闭包获其捕获的环境变量的所有权，在将闭包
传递给新线程以便将数据移动到新线程时非常实用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> x = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">	<span class="keyword">let</span> equal_to_x = <span class="keyword">move</span> |z| z == x;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;can&#x27;t use x here: &#123;:?&#125;&quot;</span>, x);</span><br><span class="line">		<span class="comment">//此时`x`的所有权已经转移进闭包，不能在闭包外使用</span></span><br><span class="line">	<span class="keyword">let</span> y = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">	<span class="built_in">assert!</span>(equal_to_x(y));</span><br></pre></td></tr></table></figure>
<h3 id="返回闭包"><a href="#返回闭包" class="headerlink" title="返回闭包"></a>返回闭包</h3><p>闭包表现为trait，没有确定的类型、大小，无法直接返回，也不
允许使用函数指针<code>fn</code>作为返回值类型，需要使用trait对象返回
闭包</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">return_closure</span></span>() -&gt; <span class="built_in">Box</span>&lt;<span class="built_in">Fn</span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>&gt;&#123;</span><br><span class="line">	<span class="comment">//trait对象作为返回值</span></span><br><span class="line">	<span class="built_in">Box</span>::new(|x| x + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迭代器Iterator"><a href="#迭代器Iterator" class="headerlink" title="迭代器Iterator"></a>迭代器Iterator</h2><p>迭代器负责遍历序列中的每一项和决定序列何时结束的逻辑。Rust
中迭代器时惰性的，直到调用方法”消费“迭代器之前都不会有效果</p>
<h3 id="Iteratortrait"><a href="#Iteratortrait" class="headerlink" title="Iteratortrait"></a><code>Iterator</code>trait</h3><p>迭代器都实现了标准库中<code>Iterator</code>trait</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Item</span></span>;</span><br><span class="line">		<span class="comment">//定义`Iterator`的关联类型</span></span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item);</span><br><span class="line">		<span class="comment">//参数是`&amp;mut self`，要求迭代器是`mut`类型</span></span><br><span class="line">		<span class="comment">//`next`方法改变了迭代器中用来记录序列位置的状态</span></span><br><span class="line">	<span class="comment">//methods with default implementation elided</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="next方法"><a href="#next方法" class="headerlink" title="next方法"></a><code>next</code>方法</h3><p><code>next</code>是<code>Iterator</code>唯一要求被实现的方法，其返回迭代器中封装
在<code>Some</code>中的一项（<strong>消费</strong>迭代器中的一项），迭代器结束时，
返回<code>None</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">iterator_demostration</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> v_iter = v1.iter();</span><br><span class="line">		<span class="comment">//注意`v_iter`声明为`mut`</span></span><br><span class="line">		<span class="comment">//使用`for`循环时无需使`v1_iter`可变，`for`会获取其</span></span><br><span class="line">		<span class="comment">//所有权并在后台使其可变</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">assert_eq!</span>(v1_iter.next(), <span class="literal">Some</span>(&amp;<span class="number">1</span>));</span><br><span class="line">	<span class="built_in">assert_eq!</span>(v1_iter.next(), <span class="literal">Some</span>(&amp;<span class="number">2</span>));</span><br><span class="line">	<span class="built_in">assert_eq!</span>(v1_iter.next(), <span class="literal">Some</span>(&amp;<span class="number">3</span>));</span><br><span class="line">		<span class="comment">//真的很难理解，rust中&amp;integer是怎么比较的</span></span><br><span class="line">	<span class="built_in">assert_eq!</span>(v1_iter.nett(), <span class="literal">None</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费适配器Comsuming-Adaptors"><a href="#消费适配器Comsuming-Adaptors" class="headerlink" title="消费适配器Comsuming Adaptors"></a>消费适配器Comsuming Adaptors</h3><p><code>Iterator</code>trait中定义，调用<code>next</code>方法，消耗迭代器</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">iterator_sum</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">	<span class="keyword">let</span> v1_iter = v1.iter();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> total:<span class="built_in">i32</span> = v1_iter.sum();</span><br><span class="line">		<span class="comment">//`sum`获取迭代器所有权，`v1_iter`不能继续使用</span></span><br><span class="line">	<span class="built_in">assert_eq!</span>(total, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<h3 id="迭代器适配器Iterator-Adaptors"><a href="#迭代器适配器Iterator-Adaptors" class="headerlink" title="迭代器适配器Iterator Adaptors"></a>迭代器适配器Iterator Adaptors</h3><p><code>Iterator</code>trait中定义，将当前迭代器变为其他迭代器，同样是
惰性的，必须调用消费适配器以便获取迭代适配器的结果</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v1:<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">v1.iter().map(|x| x + <span class="number">1</span>);</span><br><span class="line">	<span class="comment">//这里因为没有调用消费适配器，其实没有做事</span></span><br><span class="line"><span class="keyword">let</span> v2:<span class="built_in">Vec</span>&lt;_&gt; =  v1.iter().map(|x| x + <span class="number">1</span>).collect();</span><br><span class="line"><span class="built_in">assert_eq!</span>(v2, <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(PartialEq, Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Shoe</span></span>&#123;</span><br><span class="line">	size: <span class="built_in">u32</span>,</span><br><span class="line">	style: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">shoes_in_my_size</span></span>(shoes: <span class="built_in">Vec</span>&lt;Shoe&gt;, show_size: <span class="built_in">u32</span>) -&gt; <span class="built_in">Vec</span>&lt;Shoe&gt;&#123;</span><br><span class="line">	shoes.into_iter()</span><br><span class="line">			<span class="comment">//获取vector所有权的迭代器</span></span><br><span class="line">		.filter(|s| s.size == show_size)</span><br><span class="line">			<span class="comment">//这里使用闭包获取外部环境变量</span></span><br><span class="line">		.collect()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">filter_by_size</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> shoes = <span class="built_in">vec!</span>[</span><br><span class="line">		Shoe&#123;size: <span class="number">10</span>, style: <span class="built_in">String</span>::from(<span class="string">&quot;sneaker&quot;</span>)&#125;,</span><br><span class="line">		Shoe&#123;size: <span class="number">13</span>, style: <span class="built_in">String</span>::from(<span class="string">&quot;sandal&quot;</span>)&#125;,</span><br><span class="line">		Shoe&#123;size: <span class="number">10</span>, style: <span class="built_in">String</span>::from(<span class="string">&quot;boot&quot;</span>)&#125;,</span><br><span class="line">	];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> in_my_size = shoes_in_my_size(shoes, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">assert_eq!</span>(</span><br><span class="line">		in_my_size,</span><br><span class="line">		<span class="built_in">vec!</span>[</span><br><span class="line">			Shoe&#123;size: <span class="number">10</span>, style: <span class="built_in">String</span>::from(<span class="string">&quot;sneaker&quot;</span>)&#125;,</span><br><span class="line">			Shoe&#123;size: <span class="number">10</span>, style: <span class="built_in">String</span>::from(<span class="string">&quot;boot&quot;</span>)&#125;,</span><br><span class="line">		]</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现Iterator"><a href="#实现Iterator" class="headerlink" title="实现Iterator"></a>实现<code>Iterator</code></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Counter</span></span>&#123;</span><br><span class="line">	count: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Counter&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; Counter&#123;</span><br><span class="line">		Counter&#123;count: <span class="number">0</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Iterator</span> <span class="keyword">for</span> Counter&#123;</span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Item</span></span> = <span class="built_in">u32</span>;</span><br><span class="line">		<span class="comment">//迭代器将返回`u32`值集合</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt;&#123;</span><br><span class="line">		<span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">self</span>.count &lt; <span class="number">6</span>&#123;</span><br><span class="line">			<span class="literal">Some</span>(<span class="keyword">self</span>.count)</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="literal">None</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">using_other_iterator_trait_methods</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> sum: <span class="built_in">u32</span> = Counter::new().zip(Counter::new().skip(<span class="number">1</span>))</span><br><span class="line">								.map(|(a, b)| a * b)</span><br><span class="line">								.filter(|x| x % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">								.sum();</span><br><span class="line">	<span class="built_in">assert_eq!</span>(<span class="number">18</span>, sum);</span><br></pre></td></tr></table></figure>
<h2 id="并发（并行）"><a href="#并发（并行）" class="headerlink" title="并发（并行）"></a>并发（并行）</h2><p>多线程可以改善性能，但是也会增加复杂性</p>
<ul>
<li>竞争状态Race Conditions：多个线程以不一致的顺序访问资源</li>
<li>死锁Dead Lock：线程互相等待资源释放，阻止继续运行</li>
<li>只会在特定情况出现、无法稳定重现的bug</li>
</ul>
<p>线程模型</p>
<ul>
<li><code>1:1</code>模型：一个OS线程对应一个语言线程，语言调用操作系统
API创建线程，性能较好</li>
<li><code>M:N</code>模型：语言有自己的线程实现，其提供的线程称为
<strong>绿色</strong>(green)线程，M个绿色线程对应N个OS线程，更好的
运行控制、更底的上下文切换成本</li>
</ul>
<p>Rust为了更小的运行时（这里表示二进制文件中语言自身提供的
代码）考虑，标准库中只提供了<code>1:1</code>线程模式实现。可以通过一些
crate扩展<code>M:N</code>线程模式。</p>
<h3 id="spawn创建新线程"><a href="#spawn创建新线程" class="headerlink" title="spawn创建新线程"></a><code>spawn</code>创建新线程</h3><p><code>std::thread::spawn</code>接受一个闭包作为参数，返回<code>JoinHandle</code>
类型的句柄。作为<code>spawn</code>参数的闭包和一般的闭包有些不同，
线程直接独立执行，所以此时闭包捕获外部环境变量不能按照默认
的获取不可变引用，因为此时捕获的变量值可能已经被丢弃，必须
使用<code>move</code>关键字获取所有权，而一般的闭包是顺序执行的，没有
特殊需要可以直接获取不可变引用，而能够保证值不被丢弃。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time:Duration;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">		<span class="comment">//`thread::spawn`接受一个闭包作为参数，返回</span></span><br><span class="line">		<span class="comment">//`JoinHandle`类型的值（不是引用）</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span>&#123;</span><br><span class="line">			<span class="built_in">println!</span>(<span class="string">&quot;number &#123;&#125; from spwaned thread!&quot;</span>, i);</span><br><span class="line">			thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span>&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;number&#123;&#125; from main thread!&quot;</span>, i);</span><br><span class="line">		thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	handle.join().wrap();</span><br><span class="line">		<span class="comment">//`JoinHandle.join()`将阻塞直到其对应的线程结束</span></span><br><span class="line">		<span class="comment">//如果调用`join`，spawn线程可能无法执行完毕</span></span><br><span class="line">		<span class="comment">//因为主线程执行完，整个进行结束</span></span><br><span class="line">		<span class="comment">//注意`join`调用的位置决定阻塞的位置</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span> , <span class="number">3</span>];</span><br><span class="line">	<span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">		<span class="comment">//这里`move`关键字将捕获的外部环境中变量`v`所有权</span></span><br><span class="line">		<span class="comment">//移入spawn线程，否则无法正常编译</span></span><br><span class="line">		prinln!(<span class="string">&quot;here&#x27;s a vector: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">	&#125;);</span><br><span class="line">	handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>Rust中实现消息传递并发的主要工具是通道（channel）</p>
<h4 id="mpsc-channel"><a href="#mpsc-channel" class="headerlink" title="mpsc::channel"></a><code>mpsc::channel</code></h4><p>mpsc：multiple producer single consumer，多个生产者，单个
消费者，即Rust标准库实现通道的方式允许多个产生值的发送端，但
只能有一个消费这些值的接收端。发送端或接收端任一被丢弃时，
意味着通道被关闭</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::sync:mpsc;</span><br><span class="line"><span class="keyword">use</span> std::time:Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line">		<span class="comment">//`tx`表示发送端，`rx`表示接收端</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> tx1 = mpsc::Sender::clone(&amp;tx);</span><br><span class="line">		<span class="comment">//clone发送端创建多个生产者</span></span><br><span class="line"></span><br><span class="line">	thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">		<span class="keyword">let</span> vals = <span class="built_in">vec!</span>[</span><br><span class="line">			<span class="built_in">String</span>::from(<span class="string">&quot;hi&quot;</span>),</span><br><span class="line">			<span class="built_in">String</span>::from(<span class="string">&quot;from&quot;</span>),</span><br><span class="line">			<span class="built_in">String</span>::from(<span class="string">&quot;the&quot;</span>),</span><br><span class="line">			<span class="built_in">String</span>::from(<span class="string">&quot;thread&quot;</span>),</span><br><span class="line">		];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> val <span class="keyword">in</span> vals &#123;</span><br><span class="line">			tx1.send(val).unwrap();</span><br><span class="line">				<span class="comment">//`send`会获取参数所有权归接收者所有，避免</span></span><br><span class="line">				<span class="comment">//值被其他线程丢弃、修改导致意外结果</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">//`send`返回`Result&lt;T, E&gt;`，如果接收端被丢弃</span></span><br><span class="line">				<span class="comment">//将没有发送值的目标，将返回`Err&lt;E&gt;`</span></span><br><span class="line">			thread::sleep(Duration::from_secs(<span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	thread::spawn(<span class="keyword">move</span> || &#123;d</span><br><span class="line">		<span class="keyword">let</span> vals = <span class="built_in">vec!</span>[</span><br><span class="line">			<span class="built_in">String</span>::from(<span class="string">&quot;move&quot;</span>),</span><br><span class="line">			<span class="built_in">String</span>::from(<span class="string">&quot;messages&quot;</span>),</span><br><span class="line">			<span class="built_in">String</span>::from(<span class="string">&quot;for&quot;</span>),</span><br><span class="line">			<span class="built_in">String</span>::from(<span class="string">&quot;you&quot;</span>),</span><br><span class="line">		];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> val <span class="keyword">in</span> vals&#123;</span><br><span class="line">			tx.send(val).unwrap();</span><br><span class="line">			thread::sleep(Duration::from_secs(<span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> received = rx.recv().unwrap();</span><br><span class="line">		<span class="comment">//`recv`将阻塞直到接收到一个值，返回`Result&lt;T, E&gt;`</span></span><br><span class="line">		<span class="comment">//通道发送端关闭时`recv`将返回`Err&lt;E&gt;`表明不会有新值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> received = rx.try_recv().unwrap();</span><br><span class="line">		<span class="comment">//`try_recv`不阻塞，立刻返回`Result&lt;T, E&gt;`，`Err&lt;E&gt;`</span></span><br><span class="line">		<span class="comment">//表示当前没有消息</span></span><br><span class="line">		<span class="comment">//可以再循环中多次调用`try_recv`，有消息进行处理，</span></span><br><span class="line">		<span class="comment">//否则进行其他工作直到下次调用`try_recv`</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> received <span class="keyword">in</span> rx&#123;</span><br><span class="line">		<span class="comment">//将接收端`rx`当作迭代器使用，返回接收到值</span></span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, received);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="共享状态"><a href="#共享状态" class="headerlink" title="共享状态"></a>共享状态</h3><p>（任何语言）通道都类似于单所有权，一旦值通过通道传送，将无法
再次使用，而共享内存类似于多所有权</p>
<h4 id="Mutex-lt-T-gt"><a href="#Mutex-lt-T-gt" class="headerlink" title="Mutex&lt;T&gt;"></a><code>Mutex&lt;T&gt;</code></h4><p>互斥器mutex：mutual exclusion，任意时刻只允许一个线程访问
数据</p>
<ul>
<li>线程在访问数据之前需要获取互斥器的锁lock，lock是作为
互斥器一部分的数据结构，记录数据所有者的排他访问权</li>
<li>处理完互斥器保护的数据之后，需要解锁，这样才能允许其他
线程获取数据</li>
</ul>
<p><code>Mutex&lt;T&gt;</code>类似于线程安全版本的<code>RefCell&lt;T&gt;</code>（<code>cell</code>族），
提供了内部可变性，<code>Mutex&lt;T&gt;</code>有可能造成死锁，如一个操作需要
两个锁，两个线程各持一个互相等待。</p>
<p><code>Arc&lt;T&gt;</code>原子引用计数atomically reference counted，则是
线程安全版本的<code>Rc&lt;T&gt;</code>，而线程安全带有性能惩罚，如非必要，
使用单线程版本<code>Rc&lt;T&gt;</code>性能更好。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Mutex, Arc&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));</span><br><span class="line">		<span class="comment">//因为需要在多个线程内引用，所以需要使用多所有权</span></span><br><span class="line">		<span class="comment">//数据结构，而`Rc`不是线程安全的，需要使用线程安全</span></span><br><span class="line">		<span class="comment">//`Arc`</span></span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut</span> handles = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span>&#123;</span><br><span class="line">		<span class="keyword">let</span> counter = Arc::clone(&amp;counter);</span><br><span class="line">		<span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">			<span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</span><br><span class="line">			<span class="comment">//`lock`返回一个`MutexGuard`类型的智能指针，</span></span><br><span class="line">			<span class="comment">//实现了`Deref`指向其内部数据，`Drop`当</span></span><br><span class="line">			<span class="comment">//`MutexGuard`离开作用域时自动释放锁</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//只有`lock`才能获取值，类型系统保证访问数据之前</span></span><br><span class="line">			<span class="comment">//获取锁；而锁的释放自动发生，保证锁一定会释放</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//这里发生了一次强制解引用多态，将`counter`</span></span><br><span class="line">			<span class="comment">//解引用为`Mutex&lt;T&gt;`类型</span></span><br><span class="line">			*num += <span class="number">1</span>;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		handles.push(handle);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> handle <span class="keyword">in</span> handles&#123;</span><br><span class="line">		handle.join().unwrap();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, counter.lock.unwrap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Synctrait、Sendtrait"><a href="#Synctrait、Sendtrait" class="headerlink" title="Synctrait、Sendtrait"></a><code>Sync</code>trait、<code>Send</code>trait</h4><p>Rust的并发模型大部分属于标准库的实现，但是
<code>std::marker::Send</code>和<code>std::marker::Sync</code>时内嵌于语言的</p>
<ul>
<li><code>Send</code>：表明类型所有权可以在线程间传递，几乎所有类型都是
<code>Send</code>的，<code>Rc&lt;T&gt;</code>是其中的一个例外，因为<code>Rc&lt;T&gt;</code>clone之后
在两个线程间可能同时更新引用计数，trait bound保证无法将
不安全的<code>Rc&lt;T&gt;</code>在线程间传递。任何全部由<code>Send</code>组成的类型
会自动标记为<code>Send</code></li>
<li><code>Sync</code>：表明类型可以安全的在多线程中拥有其值的引用，对于
任何类型，如果<code>&amp;T</code>是<code>Send</code>的，那么<code>T</code>就是<code>Sync</code>的。
<code>Cell&lt;T&gt;</code>系列不是<code>Sync</code>的，<code>Mutex&lt;T&gt;</code>是。基本类型是<code>Sync</code>
的，全部由<code>Sync</code>组成的类型也是<code>Sync</code>的</li>
</ul>
<p><code>Send</code>和<code>Sync</code>是标记trait，不需要实现任何方法，全部是<code>Send</code>
或<code>Sync</code>组成的类型就是<code>Send</code>或<code>Sync</code>，一般不需要手动实现
它们，而且手动实现这些标记trait涉及编写不安全代码</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:37.000Z" title="3/21/2019, 5:27:37 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-02-17T03:57:08.000Z" title="2/17/2019, 11:57:08 AM">2019-02-17</time></span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a></span><span class="level-item">28 minutes read (About 4195 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Rust/std_var_types.html">Rust 标准库数据类型</a></h1><div class="content"><h2 id="通用集合类型"><a href="#通用集合类型" class="headerlink" title="通用集合类型"></a>通用集合类型</h2><h3 id="Vec-lt-T-gt"><a href="#Vec-lt-T-gt" class="headerlink" title="Vec&lt;T&gt;"></a><code>Vec&lt;T&gt;</code></h3><p>vector允许在单独数据结构中存储多于一个的值，它们在内存中相邻
排列，vector被丢弃时，其中的数据也会被丢弃</p>
<h4 id="存储不同类型"><a href="#存储不同类型" class="headerlink" title="存储不同类型"></a>存储不同类型</h4><p>vector只能存储相同类型的值，因为vector必须在编译前知道所有
存储元素所需内存、允许的元素类型，否则对vector进行操作可能
会出错。但是可以使用枚举类型存储”不同类型”（Message为例）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vec!</span>[Message::Write(<span class="built_in">String</span>::from(<span class="string">&quot;ab&quot;</span>), Message::Move&#123;x:<span class="number">5</span>, y:<span class="number">6</span>&#125;]</span><br></pre></td></tr></table></figure>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v:<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">Vec</span>::with_capacity(<span class="number">3</span>);</span><br><span class="line">	<span class="comment">//为vector预先分配空间，比`new`稍有效率</span></span><br><span class="line">	<span class="comment">//但是这个为啥不用指定类型啊，这样怎么分配空间</span></span><br><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">v.push(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">let</span> third:&amp;<span class="built_in">i32</span> = &amp;v[<span class="number">2</span>]</span><br><span class="line">	<span class="comment">//尝试获取一个引用值，如果越界则报错</span></span><br><span class="line"><span class="keyword">let</span> third:<span class="built_in">Option</span>&lt;&amp;<span class="built_in">i32</span>&gt; = v.get(<span class="number">2</span>)</span><br><span class="line">	<span class="comment">//尝试获取Option&lt;&amp;i32&gt;，越界则返回None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v&#123;</span><br><span class="line">	*i += <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iter = v.iter();</span><br><span class="line">	<span class="comment">//不可变引用迭代器</span></span><br><span class="line"><span class="keyword">let</span> iter_mut = v.iter_mut();</span><br><span class="line">	<span class="comment">//可变引用迭代器</span></span><br><span class="line"><span class="keyword">let</span> iter_owner = v.into_iter();</span><br><span class="line">	<span class="comment">//所有权引用迭代器</span></span><br></pre></td></tr></table></figure>
<p>使用enum+match就能保证处理所有类型，不会出错</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>通常意义上的字符串往往是以下两种的”综合“</p>
<ul>
<li><p>rust核心语言中的字符串slice<code>&amp;str</code>：存储在别处的utf-8
编码字节序列的引用</p>
<blockquote>
<p>   字符串slice是&amp;str类型，这个好像体现了rust引用更像
   指针，字符串字面值应该是一系列字节序列（流）存储，
   所以”返回值“应该是”首地址“，因此是引用类型</p>
</blockquote>
</li>
<li><p>rust标准库中<code>String</code>类型，是<code>Vec&lt;u8&gt;</code>的封装</p>
<ul>
<li>可增长</li>
<li>可变</li>
<li>有所有权</li>
<li>utf-8编码</li>
</ul>
</li>
</ul>
<h4 id="索引字符串"><a href="#索引字符串" class="headerlink" title="索引字符串"></a>索引字符串</h4><p>因此<code>String</code>类型不能索引获取字符，索引操作预期是常数时间，
而utf-8字列序列并不能保证在常数时间内获取“字符”，rust需要
从头检查。另外，字符串中可能有不可见字符（如发音字符），
即<strong>字形簇</strong>和<strong>字符串</strong>不等价，此时索引的意义也不明确。</p>
<p>更加有价值的是使用<code>[]</code>和range创建一个字符串slice需要注意的是
如果字符串slice不是有效处utf-8编码序列，程序会在运行时
<code>panic!</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> len = <span class="built_in">String</span>::from(<span class="string">&quot;Здравствуйте&quot;</span>).len()</span><br><span class="line">	<span class="comment">//`len`返回的是utf-8编码序列的长度20，不是“字符”数目12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hello = <span class="string">&quot;Здравствуйте&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s = &amp;hello[<span class="number">0</span>..<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<h4 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h4><ul>
<li>返回字符Unicode值<code>char</code>类型<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.chars() &#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
将会打印出6个字符，两个不可见的发音字符<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">न</span><br><span class="line">म</span><br><span class="line">स</span><br><span class="line">	्</span><br><span class="line">त</span><br><span class="line">	े</span><br></pre></td></tr></table></figure></li>
<li>返回字节byte值<code>u8</code>类型<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.bytes() &#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="String常用方法"><a href="#String常用方法" class="headerlink" title="String常用方法"></a><code>String</code>常用方法</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;initial contet&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = <span class="string">&quot;initial content&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s = data.to_string();</span><br><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;initial content&quot;</span>.to_string();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">s.push_str(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">s.push_str(&amp;s2);</span><br><span class="line"><span class="built_in">println!</span>(s2);</span><br><span class="line">	<span class="comment">//此时，`s2`仍然可以打印出来，因为`push_str`的参数是它的</span></span><br><span class="line">	<span class="comment">//一个引用，应该是方法中对`&amp;&amp;str`类型做了处理？</span></span><br><span class="line">s.push(<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello, &quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s3 = s1 + &amp;s2;</span><br><span class="line">	<span class="comment">//此时`s1`所有权被转移给`s3`不能再使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s3 = string::from(<span class="string">&quot;toc&quot;</span>);</span><br><span class="line"><span class="comment">//let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, s1, s2, s3);</span><br><span class="line">	<span class="comment">//`format!`宏是更好地连接字符串的方法，且不会获取任何</span></span><br><span class="line">	<span class="comment">//参数的所有权</span></span><br></pre></td></tr></table></figure>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap键、值必须是同质的，相对来说使用频率较低，没有引入
<code>prelude</code>，使用之前需要用<code>use</code>关键字引入</p>
<p><code>HashMap</code>默认使用一种密码学安全的哈希函数，它可以抵抗拒绝
服务（Denial of Service, DoS）攻击。然而这并不是可用的最快的
算法，不过为了更高的安全性值得付出一些性能的代价。可指定不同
<em>hasher</em>来切换为其它函数。<em>hasher</em>是一个实现了<code>BuildHasher</code>
trait的类型</p>
<h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">&quot;Yellow&quot;</span>), <span class="number">30</span>);</span><br><span class="line">	<span class="comment">//对于没有实现`copy`trait的`string`类型，所有权将转移给</span></span><br><span class="line">	<span class="comment">//HashMap</span></span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>, <span class="number">20</span>);</span><br><span class="line">	<span class="comment">//之前存储的值被覆盖</span></span><br><span class="line"></span><br><span class="line">scores.entry(<span class="built_in">String</span>::from(<span class="string">&quot;Yellow&quot;</span>)).or_insert(<span class="number">90</span>);</span><br><span class="line">scores.entry(<span class="built_in">String</span>::from(<span class="string">&quot;Red&quot;</span>)).or_insert(<span class="number">90</span>);</span><br><span class="line">	<span class="comment">//`entry`以想要检查的键作为参数，返回`Entry`类型的枚举</span></span><br><span class="line">	<span class="comment">//代表可能存在的值，`or_insert`方法在键对应的值存在时</span></span><br><span class="line">	<span class="comment">//返回值`Entry`（实际上时值的可变引用），否则将参数作为</span></span><br><span class="line">	<span class="comment">//新值插入，并返回修改后的`Entry`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;hello world wonderful word&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> text.split_whitespace()&#123;</span><br><span class="line">	<span class="keyword">let</span> count = map.entry(word).or_insert(<span class="number">0</span>);</span><br><span class="line">	*count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">//这段将在`map`中存储`text`中个单词出现次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> teams = <span class="built_in">vec!</span>[<span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>), <span class="built_in">String</span>::from(<span class="string">&quot;Yello&quot;</span>)];</span><br><span class="line"><span class="keyword">let</span> initial_scores = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">30</span>];</span><br><span class="line"><span class="keyword">let</span> scores: HashMap&lt;_,_&gt; = teams.iter.zip(initial_scores.iter()).collect();</span><br><span class="line">	<span class="comment">//`collect`可能返回很多不同的数据结构，需要显式指定`scores`</span></span><br><span class="line">	<span class="comment">//的类型`HashMap&lt;_,_&gt;`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> team_name = <span class="built_in">String</span>::from(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> team_score = scores.get(&amp;team_name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (key, val) <span class="keyword">in</span> &amp;scores&#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>, key, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><ul>
<li>指针pointer：包含内存地址的变量，这个地址引用（指向）
其他数据</li>
<li>智能指针smart pointer：一类数据结构，表现类似于指针，
拥有额外的元数据和功能</li>
</ul>
<p>Rust中最常见的指针是<strong>引用reference</strong>，除了引用数据没有其他
特殊功能，也没有任何额外开销。</p>
<p>智能指针通常由结构体实现，区别于常规结构体的特在于实现了
<code>Deref</code>和<code>Drop</code>trait</p>
<blockquote>
<p>   事实上，<code>String</code>和<code>Vec&lt;T&gt;</code>也是智能指针</p>
</blockquote>
<h3 id="Dereftrait、DerefMuttrait"><a href="#Dereftrait、DerefMuttrait" class="headerlink" title="Dereftrait、DerefMuttrait"></a><code>Deref</code>trait、<code>DerefMut</code>trait</h3><ul>
<li><code>Deref</code>trait：重载解<strong>不可变引用</strong>运算符<code>*</code></li>
<li><code>DerefMut</code>trait：重载解<strong>可变引用</strong>引用运算符<code>*</code></li>
</ul>
<p>允许智能指针结构体实例表现得像引用，可以让代码兼容智能指针
和引用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">let</span> y = &amp;x;</span><br><span class="line">	<span class="keyword">let</span> z = <span class="built_in">Box</span>::new(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">	<span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">	<span class="built_in">assert_eq!</span>(<span class="number">5</span>, *z);</span><br></pre></td></tr></table></figure>
<h4 id="自定义类型实现Dereftrait"><a href="#自定义类型实现Dereftrait" class="headerlink" title="自定义类型实现Dereftrait"></a>自定义类型实现<code>Deref</code>trait</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyBox</span></span>&lt;T&gt;(T);</span><br><span class="line">	<span class="comment">//`Box&lt;T&gt;`从本质上被定义为包含一个元素的元组结构体</span></span><br><span class="line">	<span class="comment">//类似定义自定义类型`MyBox`</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt;&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x: T) -&gt; MyBox&lt;T&gt;&#123;</span><br><span class="line">		MyBox(X)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">use::std::Deref;</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> MyBox&lt;T&gt;&#123;</span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Target</span></span> = T;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T&#123;</span><br><span class="line">		&amp;sell.<span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">		<span class="comment">//`deref`返回引用，因为大部分使用解引用时不希望获取</span></span><br><span class="line">		<span class="comment">//`MyBox`内部值的所有权</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为`MyBox&lt;T&gt;`实现`Deref`trait</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">let</span> y = MyBox::new(x);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;y = &#123;&#125;&quot;</span>, *y);</span><br><span class="line">		<span class="comment">//对于`*y`Rust实际在底层`*(y.deref())`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DerefMut</code>trait类似</p>
<h4 id="隐式解引用强制多态Deref-Coercions"><a href="#隐式解引用强制多态Deref-Coercions" class="headerlink" title="隐式解引用强制多态Deref Coercions"></a>隐式解引用强制多态Deref Coercions</h4><p>将实现了<code>Deref</code>trait或<code>DerefMut</code>trait类型的引用转换为其他
类型的引用，通过<strong>多次</strong>的<strong>隐式</strong>转换使得实参和型参类型
一致，（这些解析发生在编译时，没有运行时损失)避免多次使用
<code>&amp;</code>和<code>*</code> 引用和解引用，也使得代码更容易兼容智能指针和引用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>(name: &amp;<span class="built_in">str</span>)&#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;hello, &#123;&#125;&quot;</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> m = MyBox::new(<span class="built_in">String</span>::from(<span class="string">&quot;Rust&quot;</span>));</span><br><span class="line">	hello(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实参类型T和型参类型U满足（间接）</p>
<ul>
<li><code>T: Deref&lt;Target = U&gt;</code>：<code>&amp;T</code>转换为<code>&amp;U</code></li>
<li><code>T: Deref&lt;Target = U&gt;</code>：<code>&amp;mut T</code>转换为<code>&amp;U</code></li>
<li><code>T: DerefMut&lt;Target = U&gt;</code>：<code>&amp;mut T</code>转换为<code>&amp;mut U</code></li>
</ul>
<p>相当于在引用外面添加任意层<code>&amp;(*_)</code>、<code>&amp;mut(*_)</code>，直到实参类型
和型参类型一致</p>
<h3 id="Droptrait"><a href="#Droptrait" class="headerlink" title="Droptrait"></a><code>Drop</code>trait</h3><p><code>Drop</code>trait要求实现<code>drop</code>方法（析构函数destructor），获取
<code>&amp;mut self</code>可变引用，智能指针离开作用域时运行<code>drop</code>方法中的
代码，用于释放类似于文件或网络连接的资源，编译器会自动插入
这些代码。</p>
<ul>
<li><code>Drop</code>trait会自动清理代码</li>
<li>所有权系统确<code>drop</code>只会在值不再使用时被调用一次</li>
</ul>
<blockquote>
<h1 id="todo：获取-amp-mut-self，那么之前不能获取可变引用了？"><a href="#todo：获取-amp-mut-self，那么之前不能获取可变引用了？" class="headerlink" title="todo：获取&amp;mut self，那么之前不能获取可变引用了？"></a>todo：获取&amp;mut self，那么之前不能获取可变引用了？</h1></blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustomSmartPointer</span></span>&#123;</span><br><span class="line">	data: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> CustomSmartPointer&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>)&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;Dropping CustomSmartPointer with data `&#123;&#125;`!&quot;</span>, <span class="keyword">self</span>.data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> c = CustomSmartPointer&#123; data: <span class="built_in">String</span>::from(<span class="string">&quot;pointer1&quot;</span>)&#125;;</span><br><span class="line">	<span class="keyword">let</span> d = CustomSmartPointer&#123; data: <span class="built_in">String</span>::from(<span class="string">&quot;pointer2&quot;</span>)&#125;;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;CustomSmartPointer created!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出顺序如下，变量以被创建时相反的顺序丢弃</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CustomSmartPointer created!</span><br><span class="line">Dropping CustomSmartPointer with data `pointer1`!</span><br><span class="line">Dropping CustomSmartPointer with data `pointer2`!</span><br></pre></td></tr></table></figure>
<p>Rust不允许显示调用<code>drop</code>函数，因为Rust仍然会在值离开作用域时
调用<code>drop</code>函数导致<strong>double free</strong>的错误。如果需要提早清理，
可以使用<code>std::mem::drop</code>函数（已经位于prelude中）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">man</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> c = CustomSmartPointer&#123; data: <span class="built_in">String</span>::from(<span class="string">&quot;some data&quot;</span>)&#125;;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;CumstomSmartPointer Created&quot;</span>);</span><br><span class="line">	<span class="built_in">drop</span>(c);</span><br><span class="line">		<span class="comment">//调用`std::mem::drop`函数，不是`c.drop()`方法</span></span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;CustomSmartPointer dropped before the end of main&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Box-lt-T-gt"><a href="#Box-lt-T-gt" class="headerlink" title="Box&lt;T&gt;"></a><code>Box&lt;T&gt;</code></h3><p>在堆上存储数据，而栈上存放指向堆数据的指针，常用于</p>
<ul>
<li>类型编译时大小未知，而想要在确切大小的上下文中使用</li>
<li>大量数据希望在拷贝时不转移所有权</li>
<li>只关心数据是否实现某个trait而不是其具体的类型
（trait对像）</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="built_in">Box</span>::new(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;b = &#123;&#125;&quot;</span>, b);</span><br><span class="line">	<span class="comment">//可以像数据存储在栈上一样访问数据</span></span><br><span class="line">	<span class="comment">//box离开作用域时，栈上和指向的堆上的数据都被释放</span></span><br></pre></td></tr></table></figure>
<h4 id="创建递归类型"><a href="#创建递归类型" class="headerlink" title="创建递归类型"></a>创建递归类型</h4><p>Rust需要在编译时知道类型占用的空间，而递归类型（recursive
type）中值的一部分可以时相同类型的另一个值，所以Rust无法知道
递归类型占用的空间。而box大小已知，可以在递归类型中插入box
创建递归类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span>&#123;</span><br><span class="line">	Cons(<span class="built_in">i32</span>, <span class="built_in">Box</span>&lt;list&gt;),</span><br><span class="line">	Nil,</span><br><span class="line">		<span class="comment">//代表递归终止条件的规范名称，表示列表的终止</span></span><br><span class="line">		<span class="comment">//不同于`null`或`nil`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> list = Cons(<span class="number">1</span>,</span><br><span class="line">		<span class="built_in">Box</span>::new(Cons(<span class="number">2</span>,</span><br><span class="line">			<span class="built_in">Box</span>::new(Cons(<span class="number">3</span>,</span><br><span class="line">				<span class="built_in">Box</span>::new(Nil))))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Rc-lt-T-gt"><a href="#Rc-lt-T-gt" class="headerlink" title="Rc&lt;T&gt;"></a><code>Rc&lt;T&gt;</code></h3><p>Rc：引用计数reference counting，记录一个值引用的数量判断
这个值是否仍然被使用，如果值只有0个引用，表示没有任何有效
引用，可以被清理。</p>
<p><code>Rc&lt;T&gt;</code>允许多个不可变引用，让值有多个<strong>所有者</strong>共享数据，
引用计数确保任何所有者存在时值有效。用于在堆上分配内存供
程序多个部分读取，且在无法在编译时确定哪部分最后结束使用
（否则令其为所以者即可）</p>
<blockquote>
<p>   <code>Rc&lt;T&gt;</code>只适合单线程场景</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span>&#123;</span><br><span class="line">	Cons(<span class="built_in">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">	Nil,</span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">//使用`Rc&lt;T&gt;`代替`Box&lt;T&gt;`，可以构造共享List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, Rc::new(Cons(<span class="number">10</span>, Rc::new(Nil)))));</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;count after creating a = &#123;&#125;&quot;</span>, Rc::strong_count(&amp;a));</span><br><span class="line">		<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> b = Cons::(<span class="number">3</span>, Rc::clone(&amp;a));</span><br><span class="line">		<span class="comment">//`Rc::clone`并不像大多数`clone`方法一样对所有数据</span></span><br><span class="line">		<span class="comment">//进行深拷贝，只会增加引用计数，允许`a`和`b`**共享**</span></span><br><span class="line">		<span class="comment">//`Rc`中数据的所有权</span></span><br><span class="line">		<span class="comment">//这里可以调用`a.clone()`代替`Rc::clone(&amp;a)`，但是</span></span><br><span class="line">		<span class="comment">//习惯上使用`Rc::cloen(&amp;a)`</span></span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;count after creating b = &#123;&#125;&quot;</span>, Rc::strong_count(&amp;a));</span><br><span class="line">		<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">let</span> c = Cons::(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;count after creating c = &#123;&#125;&quot;</span>, Rc::strong_count(&amp;a));</span><br><span class="line">			<span class="comment">//3</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;count after c goes out of scope = &#123;&#125;&quot;</span>, Rc::strong_count(&amp;a));</span><br><span class="line">		<span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RefCell-lt-T-gt"><a href="#RefCell-lt-T-gt" class="headerlink" title="RefCell&lt;T&gt;"></a><code>RefCell&lt;T&gt;</code></h3><p><code>RefCell&lt;T&gt;</code>是一个遵守<em>内部可变性</em>模式的类型，允许通过
<strong>不可变引用</strong>更改<code>T</code>值。实际上仍然是通过可变引用更改值，
只是获得的<code>T</code>的可变引用在<code>RefCell&lt;T&gt;</code>内部。</p>
<blockquote>
<p>   <code>RefCell&lt;T&gt;</code>同样只能应用于单线程场景</p>
</blockquote>
<p>可以理解为，将Rust<strong>静态引用</strong>改成<strong>时分复用</strong>引用，Rust在
运行时进时引用检查，只要保证在运行时任意时刻满足引用规则
即可。</p>
<h4 id="内部可变性interior-mutability"><a href="#内部可变性interior-mutability" class="headerlink" title="内部可变性interior mutability"></a>内部可变性interior mutability</h4><p>Rust中的一个设计模式，允许在有不可变引用时改变数据，这违反
了引用规则，因此在该模式中使用<code>unsafe</code>代码模糊Rust通常的
可变性和引用规则。但是引用规则依然适用，只是在运行时检查，
会带来一定运行时损失。</p>
<p>在确保代码运行时遵守借用规则，即使编译器不能保证，可以选择
使用运用内部可变性模式的类型，涉及的<code>unsafe</code>代码被封装进
安全的API中，外部类型依然不可变</p>
<h4 id="Ref、RefMut"><a href="#Ref、RefMut" class="headerlink" title="Ref、RefMut"></a><code>Ref</code>、<code>RefMut</code></h4><ul>
<li><code>Ref = RefCell&lt;T&gt;.borrow()</code>：获取<code>T</code>的不可变引用</li>
<li><code>RefMut = RefCell&lt;T&gt;.borrow_mut()</code>：获取<code>T</code>的一个可变引用</li>
</ul>
<p><code>Ref</code>和<code>RefMut</code>均是实现<code>Deref</code>trait的智能指针，<code>RefCell&lt;T&gt;</code>
记录当前活动的<code>Ref</code>和<code>RefMut</code>指针，调用<code>borrow</code>时，不可变
引用计数加1，<code>Ref</code>离开作用域时不可变引用计数减1</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Messenger</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>(&amp;<span class="keyword">self</span>, msg: &amp;<span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">LimitTracker</span></span>&lt;<span class="symbol">&#x27;a</span>, T:<span class="symbol">&#x27;a</span> + Messenger&gt;&#123;</span><br><span class="line">	Messenger:&amp;<span class="symbol">&#x27;a</span> T,</span><br><span class="line">	value: <span class="built_in">usize</span>,</span><br><span class="line">	max : <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">//这个结构体有`‘a`和`T`两个泛型参数，且`T`还以生命周期</span></span><br><span class="line">	<span class="comment">//注解作为trait bound</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; LimitTracker&lt;a&#x27;, T&gt;</span><br><span class="line">	<span class="keyword">where</span> T: Messenger&#123;</span><br><span class="line">	<span class="comment">//这里的`T`就没有加上`‘a`作为trait bound</span></span><br><span class="line">	<span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(messenger: &amp;T, max: <span class="built_in">usize</span>) -&gt; LimitTracker&lt;T&gt;&#123;</span><br><span class="line">		LimitTracker&#123;</span><br><span class="line">			messenger,</span><br><span class="line">			value: <span class="number">0</span>,</span><br><span class="line">			max,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_value</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value:<span class="built_in">usize</span>)&#123;</span><br><span class="line">		<span class="keyword">self</span>.value = value;</span><br><span class="line">		<span class="keyword">let</span> percentage_of_max = <span class="keyword">self</span>.max <span class="keyword">as</span> <span class="built_in">f64</span> / <span class="keyword">self</span>.max <span class="keyword">as</span> <span class="built_in">f64</span>;</span><br><span class="line">		<span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.75</span>&#123;</span><br><span class="line">			<span class="keyword">self</span>.messenger.send(<span class="string">&quot;Warning: over 75% of quota has been used!&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests&#123;</span><br><span class="line">	<span class="keyword">use</span> supper::*;</span><br><span class="line">	<span class="keyword">use</span> std::cell:RefCell;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">MockMessenger</span></span>&#123;</span><br><span class="line">		sent_messages: RefCell&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;&gt;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">impl</span> MockMessenger&#123;</span><br><span class="line">		<span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; MockMessenger&#123;</span><br><span class="line">			MockMessenger&#123; sent_messages: RefCell&lt;<span class="built_in">vec!</span>[]&gt; &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">impl</span> Messenger <span class="keyword">for</span> MockMessenger&#123;</span><br><span class="line">		<span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="built_in">str</span>)&#123;</span><br><span class="line">			<span class="keyword">self</span>.sent_messages.borrow_mut().push(<span class="built_in">String</span>::from(message));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">#[test]</span></span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">it_send_an_over_75_percent_warning_message</span></span>()&#123;</span><br><span class="line">		<span class="keyword">let</span> mock_messenger = MockMessenger::new();</span><br><span class="line">		<span class="keyword">let</span> <span class="keyword">mut</span> limit_tracker = LimitTracker::new(&amp;mock_messenger, <span class="number">100</span>);</span><br><span class="line">		limit_tracker.set_value(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">assert_eq!</span>(mock_messenger.sent_messages.borrow().len(), <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Rc-lt-RefCell-lt-T-gt-gt"><a href="#Rc-lt-RefCell-lt-T-gt-gt" class="headerlink" title="Rc&lt;RefCell&lt;T&gt;&gt;"></a><code>Rc&lt;RefCell&lt;T&gt;&gt;</code></h4><p><code>T</code>值可以修改，且可以被多个所有者拥有</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span>&#123;</span><br><span class="line">	Cons(Rc&lt;RefCell&lt;<span class="built_in">i32</span>&gt;&gt;, Rc&lt;List&gt;),</span><br><span class="line">	Nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> value = Rc::new(RefCell::new(<span class="number">5</span>));</span><br><span class="line">	<span class="keyword">let</span> a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));</span><br><span class="line">	<span class="keyword">let</span> b = Cons(Rc::new(RefCell::new(<span class="number">6</span>)), Rc::clone(&amp;a));</span><br><span class="line">	<span class="keyword">let</span> c = Cons(Rc::new(RefCell::new(<span class="number">10</span>)), Rc::clone(&amp;a));</span><br><span class="line">	</span><br><span class="line">	*value.borrow_value += <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;a after = &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;b after = &#123;:?&#125;&quot;</span>, b);</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;c after = &#123;:?&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RefCell-lt-Rc-lt-T-gt-gt"><a href="#RefCell-lt-Rc-lt-T-gt-gt" class="headerlink" title="RefCell&lt;Rc&lt;T&gt;&gt;"></a><code>RefCell&lt;Rc&lt;T&gt;&gt;</code></h4><p><code>T</code>值不能改变，但是<code>Rc&lt;T&gt;</code>整体可以改变，此时可能出现引用循环
，导致内存泄露。引用循环是程序逻辑上的bug，Rust无法捕获。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span>&#123;</span><br><span class="line">	Cons(<span class="built_in">i32</span>, RefCell&lt;Rc&lt;list&gt;&gt;),</span><br><span class="line">	Nil,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> List&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">tail</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;&amp;RefCell&lt;R&lt;List&gt;&gt;&gt;&#123;</span><br><span class="line">		<span class="keyword">match</span> *<span class="keyword">self</span>&#123;</span><br><span class="line">			Cons(_, <span class="keyword">ref</span> item) =&gt; <span class="literal">Some</span>(item),</span><br><span class="line">			Nil =&gt; <span class="literal">None</span>,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, RefCell::new(Rc::New(Nil))));</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;a initial rc count =&#123;&#125;&quot;</span>, Rc::strong_count(&amp;a));</span><br><span class="line">		<span class="comment">//1</span></span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;a next item = &#123;:?&#125;&quot;</span>, a.tail());</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">let</span> b = Rc::new(Cons(<span class="number">10</span>, RefCell::new(Rc::clone(&amp;a))));</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;a rc count after b creating = &#123;&#125;&quot;</span>, Rc::strong_count(&amp;a));</span><br><span class="line">		<span class="comment">//2</span></span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;b initial rc count = &#123;&#125;&quot;</span>, Rc::strong_count(&amp;b));</span><br><span class="line">		<span class="comment">//1</span></span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;b next item = &#123;:?&#125;&quot;</span>&lt;, b.tail());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(link) = a.tail()&#123;</span><br><span class="line">		*link.borrow_mut() = Rc::clone(&amp;b);</span><br><span class="line">			<span class="comment">//此时`a`、`b`循环引用，离开作用域时，两个值的</span></span><br><span class="line">			<span class="comment">//引用计数因为`a`、`b`被丢弃而减1，但是它们互相</span></span><br><span class="line">			<span class="comment">//引用，引用计数保持在1，在堆上不会被丢弃</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;b rc count after changing a = &#123;&#125;&quot;</span>, Rc::strong_count(&amp;b));</span><br><span class="line">		<span class="comment">//2</span></span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;a rc count after changing a = &#123;&#125;&quot;</span>, Rc::strong_count(&amp;a));</span><br><span class="line">		<span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Weak-lt-T-gt"><a href="#Weak-lt-T-gt" class="headerlink" title="Weak&lt;T&gt;"></a><code>Weak&lt;T&gt;</code></h4><p>强引用<code>Rc&lt;T&gt;</code>代表共享<code>Rc</code>实例的引用，代表所有权关系，
而弱引用<code>Weak&lt;T&gt;</code>不代表所有权关系，不同于<code>Rc&lt;T&gt;</code>使用
<code>strong_count</code>计数，<code>Weak&lt;T&gt;</code>使用<code>weak_count</code>计数，即使
<code>weak_count</code>无需为0，<code>Rc</code>实例也会被清理（只要<code>strong_count</code>
为0）</p>
<ul>
<li><code>Weak&lt;T&gt;</code>指向的值可能已丢弃，不能像<code>Rc&lt;T&gt;</code>一样直接解引用
，需要调用<code>upgrade</code>方法返回<code>Option&lt;Rc&lt;T&gt;&gt;</code></li>
<li><code>Weak&lt;T&gt;</code>避免<code>Rc&lt;T&gt;</code>可能导致的引用循环</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::&#123;Rc, Weak&#125;;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">	value: <span class="built_in">i32</span>,</span><br><span class="line">	parent: RefCell&lt;Weak&lt;Node&gt;&gt;,</span><br><span class="line">	Children: RefCell&lt;<span class="built_in">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> leaf = Rc::new(Node&#123;</span><br><span class="line">		value: <span class="number">3</span>,</span><br><span class="line">		parent: RefCell::new(Weak::new()),</span><br><span class="line">		children: RefCell::new(<span class="built_in">vec!</span>[]),</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println!</span>(</span><br><span class="line">		<span class="string">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">		Rc::strong_count(&amp;leaf),</span><br><span class="line">		Rc::weak_count(&amp;leaf),</span><br><span class="line">	);</span><br><span class="line">		<span class="comment">//strong = 1, weak = 0</span></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">let</span> branch = Rc::new(Node&#123;</span><br><span class="line">			value: <span class="number">5</span>,</span><br><span class="line">			parent: RefCell::new(Weak::new()),</span><br><span class="line">			children: RefCell::new(<span class="built_in">vec!</span>[Rc::clone(&amp;leaf)),</span><br><span class="line">		&#125;);</span><br><span class="line">		*leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);</span><br><span class="line">			<span class="comment">//`downgrade`返回`Weak&lt;T&gt;`</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">println!</span>(</span><br><span class="line">			<span class="string">&quot;branch strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">			Rc::strong_count(&amp;branch),</span><br><span class="line">			Rc::weak_count(&amp;branch),</span><br><span class="line">		);</span><br><span class="line">			<span class="comment">//strong = 1, weak = 1</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">println!</span>(</span><br><span class="line">			<span class="string">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">			Rc::strong_count(&amp;leaf),</span><br><span class="line">			Rc::weak_count(&amp;leaf),</span><br><span class="line">		);</span><br><span class="line">			<span class="comment">//strong = 2, weak = 0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;leaf parent = &#123;:?&#125;&quot;</span>, leaf.parent.borrow().upgrade());</span><br><span class="line">		<span class="comment">//`upgrade`返回`Option&lt;Rc&lt;T&gt;&gt;`，此例中因为`branch`</span></span><br><span class="line">		<span class="comment">//离开作用域已经丢弃，这里返回`None`</span></span><br><span class="line">	<span class="built_in">println!</span>(</span><br><span class="line">		<span class="string">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">		Rc::strong_count(&amp;leaf),</span><br><span class="line">		Rc::weak_count(&amp;leaf),</span><br><span class="line">	);</span><br><span class="line">		<span class="comment">//strong = 1, weak = 0</span></span><br><span class="line">		<span class="comment">//如此不会造成引用循环导致内存泄露</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><div class="table-container">
<table>
<thead>
<tr>
<th>智能指针</th>
<th>数据拥有者</th>
<th>引用检查</th>
<th>多线程</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Box&lt;T&gt;</code></td>
<td>单一所有者</td>
<td>编译时执行可变（不可变）引用检查</td>
<td>是</td>
</tr>
<tr>
<td><code>Rc&lt;T&gt;</code></td>
<td>多个所有者</td>
<td>编译时执行不可变引用检查</td>
<td>否</td>
</tr>
<tr>
<td><code>RefCell&lt;T&gt;</code></td>
<td>单一所有者</td>
<td>运行时执行不可变（可变）引用检查</td>
<td>否</td>
</tr>
<tr>
<td><code>Weak&lt;T&gt;</code></td>
<td>不拥有数据</td>
<td>编译时执行可变（不可变）检查</td>
<td>否</td>
</tr>
</tbody>
</table>
</div>
<h2 id="常用枚举类型"><a href="#常用枚举类型" class="headerlink" title="常用枚举类型"></a>常用枚举类型</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Option</span>&lt;T&gt;&#123;</span><br><span class="line">	<span class="literal">Some</span>&lt;T&gt;,</span><br><span class="line">	<span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">some = <span class="literal">Some</span>(<span class="number">9</span>);</span><br><span class="line">some.take();</span><br><span class="line">	<span class="comment">//`take`获取`some`的值所有权作为返回值，并设置`some`为</span></span><br><span class="line">	<span class="comment">//`None`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Result</span>&lt;T, U&gt;&#123;</span><br><span class="line">		<span class="literal">Ok</span>&lt;T&gt;,</span><br><span class="line">		<span class="literal">Err</span>&lt;U&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:37.000Z" title="3/21/2019, 5:27:37 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-02-17T03:57:08.000Z" title="2/17/2019, 11:57:08 AM">2019-02-17</time></span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a></span><span class="level-item">35 minutes read (About 5224 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Rust/struct_enum.html">Rust 自定义数据类型</a></h1><div class="content"><h2 id="结构体struct"><a href="#结构体struct" class="headerlink" title="结构体struct"></a>结构体struct</h2><p>rust不允许只将特定字段标记为可变（很正常，因为结构体应当
作为一个整体考虑）</p>
<ul>
<li>定义结构体时字段不能添加<code>mut</code></li>
<li>声明结构体时，语法上也难以做到，字段不是单独声明</li>
</ul>
<blockquote>
<p>   结构体中若有字段是引用类型，需要添加生命周期</p>
</blockquote>
<h3 id="普通结构体"><a href="#普通结构体" class="headerlink" title="普通结构体"></a>普通结构体</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stct</span></span>&#123;</span><br><span class="line">	field1: <span class="built_in">i32</span>,</span><br><span class="line">	field2: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> field1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> stct=&#123;</span><br><span class="line">	field1,</span><br><span class="line">	field2: <span class="built_in">String</span>::from(<span class="string">&quot;fy&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//变量字段同名时字段初始化简略写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> struct1 = stct&#123;</span><br><span class="line">	field1: <span class="number">1</span>,</span><br><span class="line">	..struct2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结构体更新语法</span></span><br></pre></td></tr></table></figure>
<h3 id="元组结构体"><a href="#元组结构体" class="headerlink" title="元组结构体"></a>元组结构体</h3><p>结构体名称提供的含义，但只有字段类型没有字段名，用于命名
元组、指定类型，区别于其他相同（结构）的元组</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tuple_stct</span></span>=(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>)</span><br></pre></td></tr></table></figure>
<h3 id="类单元结构体unit-like-struct"><a href="#类单元结构体unit-like-struct" class="headerlink" title="类单元结构体unit-like struct"></a>类单元结构体unit-like struct</h3><p>不定义任何字段，类似于<code>()</code>（<code>()</code>一般用于泛型中占位，表示
当前类型为空，比如<code>T</code>表示返回值泛型参数，无返回值就可以使用
<code>()</code>代替，因为Rust中类似于<code>typedef</code>用于自定义类型），常用于
在某个类型上实现trait，但不需要在 类型内存储数据时发挥作用</p>
<h2 id="枚举enum"><a href="#枚举enum" class="headerlink" title="枚举enum"></a>枚举enum</h2><p>rust枚举更像C语言中<code>enum</code>+<code>struct</code></p>
<ul>
<li><code>enum</code>：定义了新的枚举类型，取值范围有限</li>
<li><code>struct</code>：枚举成员可以关联数据类型，且可以定义方法</li>
</ul>
<h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpArr</span></span>&#123;</span><br><span class="line">	V4,</span><br><span class="line">	V6,</span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">//基础版本</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpArr</span></span>&#123;</span><br><span class="line">	V4(<span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>&#125;,</span><br><span class="line">	V6(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">//附加数据版本</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">	Quit,</span><br><span class="line">	Move&#123;x: <span class="built_in">i32</span>, y:<span class="built_in">i32</span>&#125;,</span><br><span class="line">	Write(<span class="built_in">String</span>),</span><br><span class="line">	ChangeColor(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">//含有匿名结构体版本</span></span><br></pre></td></tr></table></figure>
<h3 id="标准库中的枚举"><a href="#标准库中的枚举" class="headerlink" title="标准库中的枚举"></a>标准库中的枚举</h3><h4 id="处理null值"><a href="#处理null值" class="headerlink" title="处理null值"></a>处理<code>null</code>值</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt;&#123;</span><br><span class="line">	<span class="literal">Some</span>&lt;T&gt;,</span><br><span class="line">	<span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Option</code>被包含在prelude中，包括其成员，rust标准库中唯一
支持创建任何类型枚举值的枚举类型。rust不允许像有效的<code>T</code>类型
数据一样处理<code>Option&lt;T&gt;</code>类型数据，要求在使用之前处理为<code>None</code>
的情况，此即能够保证在可能为空的值会被处理</p>
<h4 id="处理潜在panic"><a href="#处理潜在panic" class="headerlink" title="处理潜在panic"></a>处理潜在<code>panic</code></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt;&#123;</span><br><span class="line">	<span class="literal">Ok</span>&lt;T&gt;,</span><br><span class="line">	<span class="literal">Err</span>&lt;E&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法、关联函数"><a href="#方法、关联函数" class="headerlink" title="方法、关联函数"></a>方法、关联函数</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Message&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; Message&#123;</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="comment">//关联函数associated functions，没有`self`作为参数</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">fn1</span></span>(&amp;<span class="keyword">self</span>) -&gt; ret_type&#123;</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="comment">//在结构体（枚举、trait对像）的上下文中定义</span></span><br><span class="line">		<span class="comment">//第一个参数总是`self`，代表调用方法的结构体实例</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">fn2</span></span>(<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; ret_type&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法-Methods"><a href="#方法-Methods" class="headerlink" title="方法 Methods"></a>方法 Methods</h3><ul>
<li><p>定义方法的好处主要在于组织性，将某类型实例能做的事均放入
<code>impl</code>块</p>
</li>
<li><p>方法签名中<code>self</code>会由rust根据<code>impl</code>关键字后的“替换”为
相应类型（运行过程中是当前实例）</p>
</li>
<li><p>方法可以获取<code>self</code>（当前实例）所有权，常用于将<code>self</code>转换
为其他实例，防止调用者转换之后仍使用原始实例</p>
</li>
<li><p>方法是rust中少数几个可以“自动引用和解引用”的地方，因为
方法中<code>self</code>类型是明确的（调用者类型也明确），rust可以
根据方法签名自动为对象添加<code>&amp;</code>、<code>&amp;mut</code>或<code>*</code>以适应方法签名，
所以rust调用方法只有<code>.</code>，没有<code>-&gt;</code></p>
</li>
</ul>
<h3 id="关联函数-Associated-Functions"><a href="#关联函数-Associated-Functions" class="headerlink" title="关联函数 Associated Functions"></a>关联函数 Associated Functions</h3><p>与结构体相关联，不作用于一个结构体实例，常被用于返回一个
结构体新实例的构造函数</p>
<h2 id="Trait"><a href="#Trait" class="headerlink" title="Trait"></a>Trait</h2><p>将方法（关联函数）签名（可以有默认实现）组合起来、定义实现
某些目的所必需的行为的集合</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summarizable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 无默认实现</span></span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">author_summary</span></span>() -&gt; <span class="built_in">String</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 有默认实现</span></span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">summary</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>&#123;</span><br><span class="line">		<span class="built_in">String</span>::from(<span class="string">&quot;Read more...&#123;&#125;&quot;</span>, <span class="keyword">self</span>.author_summary())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义trait</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summarizable <span class="keyword">for</span> Message&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">author_summary</span></span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">summary</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为类型实现trait，之后就可以和普通非trait方法一样调用</span></span><br></pre></td></tr></table></figure>
<h3 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h3><ul>
<li><p>trait中有默认实现的方法可以不重载，实现trait就可直接
调用，没有默认实现的方法则需要全部实现</p>
</li>
<li><p>默认实现重载之后不可能被调用</p>
</li>
<li><p>默认实现可以调用<strong>同trait</strong>中的其他方法，包括没有默认
实现的方法，如此trait可以实现很多功能而只需要实现少部分</p>
<ul>
<li><p>同trait：trait之间本就应该保持独立，这个是trait的
意义</p>
</li>
<li><p>因为实现trait一定要实现所有没有默认实现的方法，所以
默认实现总是“可以调用”</p>
</li>
</ul>
</li>
</ul>
<h3 id="孤儿规则-Orphan-Rule"><a href="#孤儿规则-Orphan-Rule" class="headerlink" title="孤儿规则 Orphan Rule"></a>孤儿规则 Orphan Rule</h3><p>orphan rule：父类型不存在</p>
<p>仅<strong>trait</strong>或<strong>类型</strong>位于（之一）本地crate才能实现trait，
如果没有此限制，可能出现两个crate同时对相同类型实现同一trait
，出现冲突</p>
<h3 id="Box-lt-trait-gt-Trait对像"><a href="#Box-lt-trait-gt-Trait对像" class="headerlink" title="Box&lt;trait&gt; Trait对像"></a><code>Box&lt;trait&gt;</code> Trait对像</h3><p>trait对像指向一个实现了指定trait的类型实例，Rust类型系统在
编译时会确保，任何在此上下文中使用的值会实现其trait对像的
trait，如此无需在编译时知晓所有可能类型。</p>
<h4 id="Trait对象、泛型Trait-Bound对比"><a href="#Trait对象、泛型Trait-Bound对比" class="headerlink" title="Trait对象、泛型Trait Bound对比"></a>Trait对象、泛型Trait Bound对比</h4><ul>
<li><p>trait对像在运行时替代多种具体类型</p>
<ul>
<li>编译时都是同质的<code>Box&lt;trait&gt;</code>类型</li>
<li>只关心值反映的信息而不是其具体类型，类似于动态语言中
<strong>鸭子类型</strong></li>
<li>编译器无法知晓所有可能用于trait对象的类型，因此也
不知道应该调用哪个类型的哪个方法，因此Rust必须使用
<strong>动态</strong>分发</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Draw</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">draw</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Screen</span></span>&#123;</span><br><span class="line">	<span class="keyword">pub</span> components: <span class="built_in">Vec</span>&lt;<span class="built_in">Box</span>&lt;Draw&gt;&gt;,</span><br><span class="line">		<span class="comment">//`Box&lt;Draw&gt;`就是trait对像，可以代替任何实现了</span></span><br><span class="line">		<span class="comment">//`Draw`trait的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Screen&#123;</span><br><span class="line">	<span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span> component <span class="keyword">in</span> <span class="keyword">self</span>.components.iter()&#123;</span><br><span class="line">			component.draw();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Button</span></span>&#123;</span><br><span class="line">	<span class="keyword">pub</span> width: <span class="built_in">u32</span>,</span><br><span class="line">	<span class="keyword">pub</span> height: <span class="built_in">u32</span>,</span><br><span class="line">	<span class="keyword">pub</span> label: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Draw <span class="keyword">for</span> Button&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">Draw</span>&#123;</span></span><br><span class="line"><span class="function">	&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部crate使用时</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> rust::gui;</span><br><span class="line"><span class="keyword">use</span> rust_gui::&#123;Screen, Button, Draw&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SelectBox</span></span>&#123;</span><br><span class="line">	width: <span class="built_in">u32</span>,</span><br><span class="line">	height: <span class="built_in">u32</span>,</span><br><span class="line">	options: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">//此类型对于`Screen`是未知的，但是`components`中仍然能够</span></span><br><span class="line">	<span class="comment">//包含此类型</span></span><br><span class="line"><span class="keyword">impl</span> Draw <span class="keyword">for</span> SelectBox&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">draw</span></span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> screen = Screen&#123;</span><br><span class="line">		components: <span class="built_in">vec!</span>[</span><br><span class="line">			<span class="built_in">Box</span>::new(SelectBox&#123;</span><br><span class="line">				width: <span class="number">75</span>,</span><br><span class="line">				height: <span class="number">10</span>,</span><br><span class="line">				option: <span class="built_in">vec!</span>[</span><br><span class="line">					<span class="built_in">String</span>::from(<span class="string">&quot;yes&quot;</span>),</span><br><span class="line">					<span class="built_in">String</span>::from(<span class="string">&quot;maybe&quot;</span>),</span><br><span class="line">				],</span><br><span class="line">			&#125;),</span><br><span class="line">			<span class="built_in">Box</span>::new(Button&#123;</span><br><span class="line">				width: <span class="number">50</span>,</span><br><span class="line">				height: <span class="number">10</span>,</span><br><span class="line">				label: <span class="built_in">String</span>::from(<span class="string">&quot;OK&quot;</span>),</span><br><span class="line">			&#125;),</span><br><span class="line">		],</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	screen.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>trait bound泛型类型参数结构体在编译时单态化</p>
<ul>
<li>一次只能替代一个具体类型，多个类型之间不同质</li>
<li>单态化产生的代码进行<strong>静态分发</strong></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Screen</span></span>&lt;T: Draw&gt;&#123;</span><br><span class="line">	<span class="keyword">pub</span> components: <span class="built_in">Vec</span>&lt;T&gt;,</span><br><span class="line">		<span class="comment">//trait bound泛型参数`T`只能替代一种类型</span></span><br><span class="line">		<span class="comment">//不同的实现`Draw`trait类型不能放在同一个vector中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Screen&lt;T&gt;</span><br><span class="line">	<span class="keyword">where</span> T: Draw&#123;</span><br><span class="line">	<span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span> component <span class="keyword">in</span> <span class="keyword">self</span>.components.iter()&#123;</span><br><span class="line">			component.draw();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<ul>
<li><p>鸭子类型：如果它走起来像一只鸭子，叫起来像一只鸭子，那么
  它就是一直鸭子</p>
</li>
<li><p>静态分发：编译器知晓调用何种方法</p>
</li>
<li>动态分发：编译器在编译时不知晓调用何种方法，生成在运行时
  确定调用某种方法的代码。动态分发阻止编译器有选择的内联
  方法代码，这会禁用部分优化，但获得了额外的灵活性</li>
</ul>
</blockquote>
<h4 id="对象安全"><a href="#对象安全" class="headerlink" title="对象安全"></a>对象安全</h4><p>trait对象要求对象安全，只有<strong>对象安全</strong>的trait才能组成trait
对象，这有一些复杂的规则，但是实践中只涉及</p>
<ul>
<li>返回值类型不为<code>Self</code>：如果trait中的方法返回<code>Self</code>类型，
而使用trait对象后就不再知晓具体的类型，那方法就不可能
使用已经忘却的原始具体类型（<code>Clone</code>trait不是对象安全）</li>
<li>方法没有任何泛型类型参数：具体类型实现trait时会放入具体
类型单态化，但是使用trait对象时无法得知具体类型</li>
</ul>
<h3 id="状态模式（面向对象设计）"><a href="#状态模式（面向对象设计）" class="headerlink" title="状态模式（面向对象设计）"></a>状态模式（面向对象设计）</h3><ul>
<li>值某些内部状态，其行为随着内部状态而改变</li>
<li>内部状态由一系列集成了共享功能的对象表现，每个状态对象
负责自身行为和需要转变为另一个状态时的规则</li>
<li>值对不同状态的行为、何时状态转移不知情，需求改变时无需
改变值持有的状态、值实现代码，只需更新某个状态对象代码
或者是增加更多状态对象</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Post</span></span>&#123;</span><br><span class="line">	state: <span class="built_in">Option</span>&lt;<span class="built_in">Box</span>&lt;State&gt;&gt;,</span><br><span class="line">	content: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Post&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_text</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, text: &amp;<span class="built_in">str</span>)&#123;</span><br><span class="line">		<span class="keyword">self</span>.content.push_str(&amp;<span class="built_in">str</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">request_review</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(s) = <span class="keyword">self</span>.state.take()&#123;</span><br><span class="line">			<span class="comment">//`Option&lt;T&gt;.take()`返回值，并设置为`None`</span></span><br><span class="line">			<span class="keyword">self</span>.state = <span class="literal">Some</span>(s.request_review())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">approve</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(s) = <span class="keyword">self</span>.state.take()&#123;</span><br><span class="line">			<span class="keyword">self</span>.state = <span class="literal">Some</span>(s.approve())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">content</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="built_in">str</span>&#123;</span><br><span class="line">		<span class="keyword">self</span>.state.as_ref().unwrap().content(&amp;<span class="keyword">self</span>)</span><br><span class="line">			<span class="comment">//`Option&lt;T&gt;.as_ref()`返回`Option&lt;&amp;T&gt;`，因为参数</span></span><br><span class="line">			<span class="comment">//是`&amp;self`，只能获取不可变引用</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">State</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">request_review</span></span>(<span class="keyword">self</span>: <span class="built_in">Box</span>&lt;<span class="keyword">Self</span>&gt;) -&gt; <span class="built_in">Box</span>&lt;State&gt;;</span><br><span class="line">		<span class="comment">//`self: Box&lt;Self&gt;`意味着这个方法调用只对`Self`</span></span><br><span class="line">		<span class="comment">//类型的`Box`指针有效，这里`Self`表示值类型，因为</span></span><br><span class="line">		<span class="comment">//值的类型到struct实现trait的时候才能确定，编译时</span></span><br><span class="line">		<span class="comment">//应该会替换成具体类型</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//这个方法会获取对象的所有权（消费）</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//返回值`Box&lt;State&gt;`是trait对象</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">approve</span></span>(<span class="keyword">self</span>: <span class="built_in">Box</span>&lt;<span class="keyword">Self</span>&gt;) -&gt; <span class="built_in">Box</span>&lt;State&gt;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">content</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="keyword">self</span>, post:&amp;<span class="symbol">&#x27;a</span> Post) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>&#123;</span><br><span class="line">		<span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Draft</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> State <span class="keyword">for</span> Draft&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">request_review</span></span>(<span class="keyword">self</span>: <span class="built_in">Box</span>&lt;<span class="keyword">Self</span>&gt;) -&gt; <span class="built_in">Box</span>&lt;State&gt;&#123;</span><br><span class="line">		<span class="built_in">Box</span>::new(PendingReview&#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">approve</span></span>(<span class="keyword">self</span>: <span class="built_in">Box</span>&lt;<span class="keyword">Self</span>&gt;) -&gt; <span class="built_in">Box</span>&lt;State&gt;&#123;</span><br><span class="line">		<span class="keyword">self</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PendingReview</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> State <span class="keyword">for</span> PendingReview&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">request_review</span></span>(<span class="keyword">self</span>: <span class="built_in">Box</span>&lt;<span class="keyword">Self</span>&gt;) -&gt; <span class="built_in">Box</span>&lt;State&gt;&#123;</span><br><span class="line">		<span class="keyword">self</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">approve</span></span>(<span class="keyword">self</span>: <span class="built_in">Box</span>&lt;<span class="keyword">Self</span>&gt;) -&gt; <span class="built_in">Box</span>&lt;State&gt;&#123;</span><br><span class="line">		<span class="built_in">Box</span>::new(Published&#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Published</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> State <span class="keyword">for</span> Published&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">request_review</span></span>(<span class="keyword">self</span>: <span class="built_in">Box</span>&lt;<span class="keyword">Self</span>&gt;) -&gt; <span class="built_in">Box</span>&lt;State&gt;&#123;</span><br><span class="line">		<span class="keyword">self</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">approve</span></span>(<span class="keyword">self</span>: <span class="built_in">Box</span>&lt;<span class="keyword">Self</span>&gt;) -&gt; <span class="built_in">Box</span>&lt;State&gt;&#123;</span><br><span class="line">		<span class="keyword">self</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">content</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="keyword">self</span> , post:&amp;<span class="symbol">&#x27;a</span> Post) -&gt; &amp;<span class="symbol">&#x27;a</span> <span class="built_in">str</span>&#123;</span><br><span class="line">		&amp;post.content</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高级trait"><a href="#高级trait" class="headerlink" title="高级trait"></a>高级trait</h2><h3 id="Associated-Type"><a href="#Associated-Type" class="headerlink" title="Associated Type"></a>Associated Type</h3><p>关联类型：将类型占位符和trait相关联的方式</p>
<ul>
<li>可在trait方法中使用这些占位符类型</li>
<li>实现trait时需要指定为具体类型</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Item</span></span>;</span><br><span class="line">		<span class="comment">//关联类型`Item`，实现时需要指定具体类型</span></span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt;;</span><br><span class="line">		<span class="comment">//trait方法（签名）中使用关联类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关联类型可以看作时trait中“泛型”（弱化版）。只能实现一次
trait，因此关联类型也只能指定一次，保证了一定的抽象</p>
<h3 id="默认泛型类型参数"><a href="#默认泛型类型参数" class="headerlink" title="默认泛型类型参数"></a>默认泛型类型参数</h3><p>使用泛型类型参数时，可为泛型指定默认类型
<code>&lt;PlaceholderType = ConcreteType&gt;</code></p>
<ul>
<li>扩展类型而不破坏现有代码（普通trait改为泛型trait不需要
改变之前实现trait的代码）</li>
<li>在特殊情况下自定义trait及其中的方法</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Add;</span><br><span class="line"><span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">	x: <span class="built_in">i32</span>,</span><br><span class="line">	y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Add <span class="keyword">for</span> Point&#123;</span><br><span class="line">	<span class="comment">//`Add`是`+`运算符对应的trait</span></span><br><span class="line">	<span class="comment">//`Add`有默认类型参数，此时未指定泛型参数的具体类型，</span></span><br><span class="line">	<span class="comment">//`RHS`将是默认类型</span></span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = Point;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(<span class="keyword">self</span>, other: Point) -&gt; Point&#123;</span><br><span class="line">		Point&#123;</span><br><span class="line">			x: <span class="keyword">self</span>.x + other.x,</span><br><span class="line">			y: <span class="keyword">self</span>.x + other.y,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Add</span></span>&lt;RHS=<span class="keyword">Self</span>&gt;&#123;</span><br><span class="line">	<span class="comment">//`Add`trait定义，包含有泛型参数，但是在实现该trait之前</span></span><br><span class="line">	<span class="comment">//应该必须要为泛型指定具体类型</span></span><br><span class="line">	<span class="comment">//`RHS=Self`就是*默认类型参数*语法，泛型参数`RHS`默认为</span></span><br><span class="line">	<span class="comment">//`Self`类型（`+`左值类型）</span></span><br><span class="line">	<span class="comment">//RHS：right hand side</span></span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(<span class="keyword">self</span>, rhs: RHS) -&gt; <span class="keyword">Self</span>:Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>Rust不允许<strong>创建</strong>自定义运算符、重载<strong>任意</strong>运算符，不过
<code>std::ops</code>中的运算符、相应的trait可以通过实现相关trait重载</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Add;</span><br><span class="line"><span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Millimeters</span></span>(<span class="built_in">u32</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Meters</span></span>(<span class="built_in">u32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Add&lt;Meters&gt; <span class="keyword">for</span> Millimeters&#123;</span><br><span class="line">	<span class="comment">//`Add`trait中`RHS`不是默认类型`Self`，`Add&lt;Meters&gt;`</span></span><br><span class="line">	<span class="comment">//设置`RHS`为`Meters`</span></span><br><span class="line">	<span class="comment">//此运算符重载允许`Millmeters`类型和`Meters`类型能够</span></span><br><span class="line">	<span class="comment">//直接相加</span></span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = Millimeters;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(<span class="keyword">self</span>, other: Meters) -&gt; Millimeters&#123;</span><br><span class="line">		Millimters(<span class="keyword">self</span>.<span class="number">0</span> + (other.<span class="number">0</span> * <span class="number">1000</span>))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消歧义"><a href="#消歧义" class="headerlink" title="消歧义"></a>消歧义</h3><p>Rust无法避免两个trait具有相同名称的方法，也无法阻止某类型
同时实现两个这样的trait（或者是类型已经实现同名方法），此时
需要明确指定使用哪个方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Pilot</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">fly</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Wizard</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">fly</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Human</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Pilot <span class="keyword">for</span> Human&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">fly</span></span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;this is your captain speaking&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Wizard <span class="keyword">for</span> Human&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">fly</span></span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;up!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Human&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">fly</span></span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;waving arms furiously!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> person = Human;</span><br><span class="line">	Pilot::fly(&amp;person);</span><br><span class="line">		<span class="comment">//`Pilot`trait中方法的消歧义写法</span></span><br><span class="line">	Wizard::fly(&amp;person);</span><br><span class="line">	person.fly();</span><br><span class="line">		<span class="comment">//默认调用直接实现在**类型**上的方法</span></span><br><span class="line">	Person::fly(&amp;person);</span><br><span class="line">		<span class="comment">//`Person`类型中方法消歧义写法，一般不使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Fully-Qualified-Syntax"><a href="#Fully-Qualified-Syntax" class="headerlink" title="Fully Qualified Syntax"></a>Fully Qualified Syntax</h3><p>方法获取<code>self</code>参数</p>
<ul>
<li>不同类型、同方法名，Rust根据<code>self</code>类型可以判断调用何函数</li>
<li>同类型、同方法名，消歧义语法可以指定调用何函数</li>
</ul>
<p>而对于关联函数，没有<code>self</code>参数，某类型有同名的两个关联函数
时，无法使用消歧义语法指定调用何函数，需要使用完全限定语法
<code>&lt;Type as Trait&gt;::function(receiver_if_method), next_args, ...)</code></p>
<p>当然，完全限定语法可以用于所有trait方法、关联函数场合，其中
<code>recevier_if_method</code>即表示方法中<code>self</code>参数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">trati Animal&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">baby_name</span></span>() -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dog</span></span>;</span><br><span class="line"><span class="keyword">impl</span> Dog&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">baby_name</span></span>() -&gt; <span class="built_in">String</span>&#123;</span><br><span class="line">		<span class="built_in">String</span>::from(<span class="string">&quot;Spot&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Animal <span class="keyword">for</span> Dog&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">baby_name</span></span>() -&gt; <span class="built_in">String</span>&#123;</span><br><span class="line">		<span class="built_in">String</span>::from(<span class="string">&quot;puppy&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;A baby dog is called a &#123;&#125;&quot;</span>, Dog::baby_name());</span><br><span class="line">		<span class="comment">//调用`Dog`的关联函数</span></span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;A baby dog-animal is called a &#123;&#125;&quot;</span>, &lt;Dog <span class="keyword">as</span> Animal&gt;::baby_name());</span><br><span class="line">		<span class="comment">//完全限定语法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Super-Trait"><a href="#Super-Trait" class="headerlink" title="Super Trait"></a>Super Trait</h3><p>有时某个trait可能需要使用另一个trait的功能，要求某类型实现
该trait之前实现被依赖的trait，此所需的trait就是超（父）trait</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">OutlinePrint</span></span>: fmt::Display&#123;</span><br><span class="line">	<span class="comment">//`OutlinePrint`trait依赖于`fmt::Display`trait</span></span><br><span class="line">	<span class="comment">//在实现`OutlinePrint`之前，需要实现`fmt::Display`</span></span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">outline_print</span></span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">		<span class="keyword">let</span> output = <span class="keyword">self</span>.to_string();</span><br><span class="line">		<span class="keyword">let</span> len = output.len();</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;*&quot;</span>.repeat(len + <span class="number">4</span>));</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;* &#123;&#125; *&quot;</span>, output);</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;*&quot;</span>.repeat(len+<span class="number">4</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">	x: <span class="built_in">i32</span>,</span><br><span class="line">	y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> fmt::Display <span class="keyword">for</span> Point&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">fmt</span></span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) -&gt; fmt::<span class="built_in">Result</span>&#123;</span><br><span class="line">		<span class="built_in">write!</span>(f, <span class="string">&quot;(&#123;&#125;, &#123;&#125;)&quot;</span>, <span class="keyword">self</span>,x, <span class="keyword">self</span>.y)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> OutlinePrint <span class="keyword">for</span> Point&#123;&#125;</span><br><span class="line">	<span class="comment">//`OutlinePrint`中所有方法均有默认实现</span></span><br></pre></td></tr></table></figure>
<h2 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h2><h3 id="Newtype-Pattern"><a href="#Newtype-Pattern" class="headerlink" title="Newtype Pattern"></a>Newtype Pattern</h3><p>孤儿规则限制了只有trait、类型其中只有位于当前crate时，才能对
类型实现trait，使用newtype模式可以“绕过”该限制，即创建新的
元组结构体类型，其中只包含该类型一个成员，此时封装类型对于
crate是本地的。newtype概念源自于Haskell，此模式没有运行时
性能损失，封装类型在编译器时已经省略了</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Wrapper</span></span>(<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;);</span><br><span class="line"><span class="keyword">impl</span> fmt::Display <span class="keyword">for</span> Wrapper&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">fmt</span></span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt:Formatter) -&gt; fmt:<span class="built_in">Result</span>&#123;</span><br><span class="line">		<span class="built_in">write!</span>(f, <span class="string">&quot;[&#123;&#125;]&quot;</span>, <span class="keyword">self</span>.<span class="number">0</span>.join(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> w = Wrapper(<span class="built_in">vec!</span>[<span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>), <span class="built_in">String</span>::from(<span class="string">&quot;world&quot;</span>)]);</span><br><span class="line">	prinlnt!(<span class="string">&quot;w = &#123;&#125;&quot;</span>, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是Newtype模式中<code>Wrapper</code>是一个新类型，其上没有定义方法，
需要手动实现<code>self.0</code>的所有方法。或者，为<code>Wrapper</code>实现
<code>Deref</code>trait，并返回<code>self.0</code>，但是此方式下<code>Wrapper</code>会具有
所有<code>self.0</code>的所有方法，如果需要限制封装类型行为，只能自行
实现所需的方法。</p>
<h3 id="Type创建类型别名"><a href="#Type创建类型别名" class="headerlink" title="Type创建类型别名"></a><code>Type</code>创建类型别名</h3><p><code>type</code>关键字可以给予现有类型别名</p>
<ul>
<li><p><code>type</code>不是创建新、单独类型，而是创建别名，而newtype模式
则是真正创建了新类型，也因此无法像newtype模式一样进行
类型检查</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Kilometers</span></span> = <span class="built_in">i32</span>;</span><br><span class="line">	<span class="comment">//`type`不是创建新、单独的类型，而是赋予别名，两个类型</span></span><br><span class="line">	<span class="comment">//将得到相同的对待</span></span><br><span class="line"><span class="keyword">let</span> x: <span class="built_in">i32</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> y: Kilometers = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x + y = &#123;&#125;&quot;</span>, x + y);</span><br><span class="line">	<span class="comment">//`Kilometers`类型和`i32`类型完全相同，直接进行运算</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类型别名主要用途是避免重复</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Thunk</span></span> = <span class="built_in">Box</span>::&lt;<span class="built_in">Fn</span>() + <span class="built_in">Send</span> + `<span class="keyword">static</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> f: Thunk = <span class="built_in">Box</span>::new(|| <span class="built_in">println!</span>(<span class="string">&quot;hi&quot;</span>));</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">takes_long_type</span></span>(f: Thunk)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">returns_long_type</span></span>() -&gt; Thunk&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Never-Type"><a href="#Never-Type" class="headerlink" title="Never Type"></a>Never Type</h3><p>Rust中有一个特殊的类型<code>!</code>，被称为empty type（never type)</p>
<ul>
<li><code>!</code>的正式说法：never type可以强转为其他任何类型</li>
<li>无法被创建</li>
<li>用于发散函数（diverging functions，从不返回的函数）的
返回值<h1 id="todo-这个和无返回值函数有何区别"><a href="#todo-这个和无返回值函数有何区别" class="headerlink" title="todo 这个和无返回值函数有何区别"></a>todo 这个和无返回值函数有何区别</h1></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> guess: <span class="built_in">u32</span> = metch guess.trim().parse()&#123;</span><br><span class="line">	<span class="literal">Ok</span>(num) =&gt; num,</span><br><span class="line">	<span class="literal">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">		<span class="comment">//`continue`的值即为`!`，`match`分支的返回值必须相同</span></span><br><span class="line">		<span class="comment">//而`!`没有值，因此确定`match`的返回值类型为`u32`</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Option</span>&lt;T&gt;&#123;</span><br><span class="line">	<span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">unwrap</span></span>(<span class="keyword">self</span>) -&gt; T&#123;</span><br><span class="line">		<span class="comment">// `Option::unwrap`定义</span></span><br><span class="line">		<span class="keyword">match</span> <span class="keyword">self</span>&#123;</span><br><span class="line">			<span class="literal">Some</span>(val) =&gt; val, </span><br><span class="line">			<span class="literal">None</span> =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;called `Option::unwrap()` on a `None` value&quot;</span>),</span><br><span class="line">				<span class="comment">// `panic!`是`!`类型，不返回值而是终止程序</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;forever&quot;</span>);</span><br><span class="line"><span class="keyword">loop</span>&#123;</span><br><span class="line">	<span class="comment">// 循环永不结束，表达式值是`!`</span></span><br><span class="line">	<span class="comment">// 如果加上`break`就不再如此</span></span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;for ever&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Dynamically-Sized-Types"><a href="#Dynamically-Sized-Types" class="headerlink" title="Dynamically Sized Types"></a>Dynamically Sized Types</h3><p>动态大小类型：“DST”或者“uniszed type”，这些类型允许处理
在运行时才知道大小的类型。Rust需要知道特定类型值需要分配的
内存空间，同类型的值<strong>必须</strong>使用相同数量的内存，因此必须
<strong>将动态大小类型的值至于某种指针之后</strong>（此即动态大小类型的
黄金规则），并且使用某些额外的元信息存储动态信息的大小。</p>
<p><code>str</code>就是动态大小类型，<code>&amp;str</code>则是两个值：<code>str</code>的地址和长度，
这样<code>&amp;str</code>就有了一个在编译时可以知道的大小，并且<code>str</code>可以和
所有类型的指针结合<code>Box&lt;str&gt;</code>或<code>Rc&lt;str&gt;</code>。同样的，trait也是
动态大小类型，为了使用trait对象，必须将将其放入指针之后。</p>
<h4 id="Sized-trait"><a href="#Sized-trait" class="headerlink" title="Sized trait"></a><code>Sized</code> trait</h4><p>Rust自动为编译器在编译时就知道大小的类型实现<code>Sized</code> trait，
且Rust隐式的为每个泛型增加了<code>Sized</code> bound</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">generic</span></span>&lt;T&gt;(t: T)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">generic</span></span>&lt;T: <span class="built_in">Sized</span>&gt;(t: T)&#123;</span><br><span class="line">	<span class="comment">//实际上按照此函数头处理</span></span><br><span class="line">	<span class="comment">//即默认情况下，泛型参数不能是DST</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">generic</span></span>&lt;T: ?<span class="built_in">Sized</span>&gt;(t: &amp;T)&#123;</span><br><span class="line">	<span class="comment">//`?Sized`是特殊的语法，只能用于`Sized` trait不能用于</span></span><br><span class="line">	<span class="comment">//其他trait，表示泛型`T`可能不是`Sized`的，此时参数类型</span></span><br><span class="line">	<span class="comment">//不能是`T`，必须是指针类型的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型（generic）"><a href="#泛型（generic）" class="headerlink" title="泛型（generic）"></a>泛型（generic）</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest</span></span>&lt;T&gt;(list: &amp;[T]) -&gt; T &#123;&#125;</span><br><span class="line"><span class="comment">//函数签名中泛型</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt;&#123;</span><br><span class="line">	x: T,</span><br><span class="line">	y: T,</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T, U&gt;&#123;</span><br><span class="line">	x: T,</span><br><span class="line">	y: U,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结构体定义中泛型</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt;&#123;</span><br><span class="line">	<span class="literal">Some</span>(T),</span><br><span class="line">	<span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt;&#123;</span><br><span class="line">	<span class="literal">Ok</span>(T),</span><br><span class="line">	<span class="literal">Err</span>(E),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//枚举定义中泛型</span></span><br></pre></td></tr></table></figure>
<h3 id="方法实现中泛型"><a href="#方法实现中泛型" class="headerlink" title="方法实现中泛型"></a>方法实现中泛型</h3><ul>
<li><p><code>impl</code>后声明泛型<code>impl&lt;T&gt;</code>表示<code>Point&lt;T&gt;</code>中的<code>T</code>是泛型而
不是具体类型，是对所有的泛型结构体实现</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt;&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">x</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>impl</code>后不声明泛型，则表示<code>Point&lt;T&gt;</code>中<code>T</code>为具体类型，
此时仅对<code>Point&lt;T&gt;</code><strong>类型</strong>实现方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Point&lt;<span class="built_in">f32</span>&gt;&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">x</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">f32</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//仅`Point&lt;f32&gt;`实现此方法，其他`T`类型没有</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>结构体定义中的泛型和方法签名中泛型不一定一致</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T, U&gt; Point&lt;T, U&gt;&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">mixup</span></span>&lt;V,W&gt;(<span class="keyword">self</span>, other:Point&lt;V,W&gt;) -&gt; Point&lt;T,W&gt;&#123;</span><br><span class="line">		Point&#123;</span><br><span class="line">			x: <span class="keyword">self</span>.x,</span><br><span class="line">			y: other.y,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="trait实现中的泛型"><a href="#trait实现中的泛型" class="headerlink" title="trait实现中的泛型"></a>trait实现中的泛型</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T:Display&gt; <span class="built_in">ToString</span> <span class="keyword">for</span> T&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个时标准库中的一个例子，使用了trait bounds</span></span><br><span class="line"><span class="comment">// 不使用trait bounds，那感觉有些恐怖。。。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>   trait定义中的没有泛型，但是其中可以包含泛型方法，同普通
    函数</p>
</blockquote>
<h3 id="泛型代码的性能"><a href="#泛型代码的性能" class="headerlink" title="泛型代码的性能"></a>泛型代码的性能</h3><p>rust在编译时将代码单态化（monomorphization）保证效率，所以
rust使用泛型代码相比具体类型没有任何性能损失</p>
<blockquote>
<p>   单态化：将泛型代码转变为实际放入的具体类型</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> integer = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> float = <span class="literal">Some</span>(<span class="number">5.0</span>);</span><br><span class="line"><span class="comment">//单态化</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option_i32</span></span>&#123;</span><br><span class="line">	<span class="literal">Some</span>(<span class="built_in">i32</span>),</span><br><span class="line">	<span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option_f64</span></span>&#123;</span><br><span class="line">	<span class="literal">Some</span>(<span class="built_in">f64</span>),</span><br><span class="line">	<span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> integer = Option_i32::<span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> float = Option_f64::<span class="literal">Some</span>(<span class="number">5.0</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Trait-Bounds"><a href="#Trait-Bounds" class="headerlink" title="Trait Bounds"></a>Trait Bounds</h3><p>指定泛型的trait bounds：限制泛型不再适合任何类型，编译器
确保其被限制为实现特定trait的类型</p>
<ul>
<li><p>指定函数泛型trait bounds限制参数类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summarizable&gt;(item:T)&#123;&#125;</span><br><span class="line"><span class="comment">// 一个trait bound</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">some_fn</span></span>&lt;T: Display+<span class="built_in">Clone</span>, U: <span class="built_in">Debug</span>+<span class="built_in">Clone</span>&gt;(t:T, u:U) -&gt; <span class="number">32</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 多个trait bounds</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">some_fn</span></span>&lt;T, U&gt;(t:T, u:U) -&gt; <span class="number">32</span></span><br><span class="line">	<span class="keyword">where</span> T:Display + <span class="built_in">Clone</span>,</span><br><span class="line">			U: <span class="built_in">Debug</span> + <span class="built_in">Clone</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// where从句写法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指定方法泛型trait bounds有条件的为某些类型实现</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: Display+<span class="built_in">PartialOrd</span>&gt; Point&lt;T&gt;&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">cmp_display</span></span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="trait和泛型的比较"><a href="#trait和泛型的比较" class="headerlink" title="trait和泛型的比较"></a>trait和泛型的比较</h3><p>trait和泛型都是<strong>抽象</strong>方法</p>
<ul>
<li><p>trait从方法角度抽象</p>
<ul>
<li>定义一组公共“行为”</li>
<li>“标记（trait bounds）”特定<strong>类型（泛型）</strong></li>
</ul>
</li>
<li><p>泛型从类型的角度抽象</p>
<ul>
<li>为<strong>一组（trait bounds）</strong>类型定义“项”<code>struct</code>、<code>enum</code></li>
<li>为<strong>一组（trait bounds）</strong>类型实现函数、trait</li>
</ul>
</li>
<li><p>trait的定义中不应该出现泛型</p>
<ul>
<li>trait本意应该是定义一组“行为”，需要特定类型实现其方法
（当然有的方法有默认实现），其对应的“对象”不是类型而
是方法，与泛型用途无关</li>
<li>trait中定义泛型无意义，trait只是一个“包裹”，真正实现
的是其中的方法，如有必要，定义含有泛型参数的方法即可</li>
<li>若trait中可以使用泛型，则<strong>有可能</strong>对不同的泛型具体
类型实现“相同”（函数签名没有泛型参数）函数
（在trait中有关联类型提供略弱与泛型的功能）</li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:15.000Z" title="3/21/2019, 5:27:15 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-02-17T03:57:08.000Z" title="2/17/2019, 11:57:08 AM">2019-02-17</time></span><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a></span><span class="level-item">a minute read (About 119 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Rust/command_line.html">Rust 程序设计笔记</a></h1><div class="content"><h2 id="参数、环境变量"><a href="#参数、环境变量" class="headerlink" title="参数、环境变量"></a>参数、环境变量</h2><ul>
<li><p><code>std::env::args()</code>：返回所有参数的一个迭代器，第一参数
是可执行文件，包含任何无效<code>unicode</code>字符将<code>panic!</code>，</p>
<p>   args: Vec<String> = std::env::args().collect()</p>
</li>
<li><p><code>std::env::var(&quot;env_var&quot;)</code>：获取设置的环境变量值，返回
一个Result</p>
<ul>
<li>环境变量设置时返回包含其的Ok成员</li>
<li>未设置时返回Err成员</li>
</ul>
<p>设置“环境变量”并执行程序：<code>$&gt;ENV_NAME=val cargo run</code></p>
</li>
</ul>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">36</span></span></a><ul><li><a class="level is-mobile" href="/categories/Algorithm/Data-Structure/"><span class="level-start"><span class="level-item">Data Structure</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Heuristic/"><span class="level-start"><span class="level-item">Heuristic</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Issue/"><span class="level-start"><span class="level-item">Issue</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Problem/"><span class="level-start"><span class="level-item">Problem</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Specification/"><span class="level-start"><span class="level-item">Specification</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/C-C/"><span class="level-start"><span class="level-item">C/C++</span></span><span class="level-end"><span class="level-item tag">34</span></span></a><ul><li><a class="level is-mobile" href="/categories/C-C/Cppref/"><span class="level-start"><span class="level-item">Cppref</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/Cstd/"><span class="level-start"><span class="level-item">Cstd</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/MPI/"><span class="level-start"><span class="level-item">MPI</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/STL/"><span class="level-start"><span class="level-item">STL</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/CS/"><span class="level-start"><span class="level-item">CS</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/CS/Character/"><span class="level-start"><span class="level-item">Character</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Parallel/"><span class="level-start"><span class="level-item">Parallel</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Program-Design/"><span class="level-start"><span class="level-item">Program Design</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Storage/"><span class="level-start"><span class="level-item">Storage</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Daily-Life/"><span class="level-start"><span class="level-item">Daily Life</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/Daily-Life/Maxism/"><span class="level-start"><span class="level-item">Maxism</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Database/"><span class="level-start"><span class="level-item">Database</span></span><span class="level-end"><span class="level-item tag">27</span></span></a><ul><li><a class="level is-mobile" href="/categories/Database/Hadoop/"><span class="level-start"><span class="level-item">Hadoop</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Database/SQL-DB/"><span class="level-start"><span class="level-item">SQL DB</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Database/Spark/"><span class="level-start"><span class="level-item">Spark</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/Scala/"><span class="level-start"><span class="level-item">Scala</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">42</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Bash-Programming/"><span class="level-start"><span class="level-item">Bash Programming</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Configuration/"><span class="level-start"><span class="level-item">Configuration</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/File-System/"><span class="level-start"><span class="level-item">File System</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/IPC/"><span class="level-start"><span class="level-item">IPC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Process-Schedual/"><span class="level-start"><span class="level-item">Process Schedual</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Shell/"><span class="level-start"><span class="level-item">Shell</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Tool/"><span class="level-start"><span class="level-item">Tool</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Tool/Vi/"><span class="level-start"><span class="level-item">Vi</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Model/"><span class="level-start"><span class="level-item">ML Model</span></span><span class="level-end"><span class="level-item tag">21</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Model/Linear-Model/"><span class="level-start"><span class="level-item">Linear Model</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Model-Component/"><span class="level-start"><span class="level-item">Model Component</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Nolinear-Model/"><span class="level-start"><span class="level-item">Nolinear Model</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Unsupervised-Model/"><span class="level-start"><span class="level-item">Unsupervised Model</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/"><span class="level-start"><span class="level-item">ML Specification</span></span><span class="level-end"><span class="level-item tag">17</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/Click-Through-Rate/"><span class="level-start"><span class="level-item">Click Through Rate</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/Click-Through-Rate/Recommandation-System/"><span class="level-start"><span class="level-item">Recommandation System</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/Computer-Vision/"><span class="level-start"><span class="level-item">Computer Vision</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Specification/FinTech/"><span class="level-start"><span class="level-item">FinTech</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/FinTech/Risk-Control/"><span class="level-start"><span class="level-item">Risk Control</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/Graph-Analysis/"><span class="level-start"><span class="level-item">Graph Analysis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Specification/NLP/"><span class="level-start"><span class="level-item">NLP</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Technique/"><span class="level-start"><span class="level-item">ML Technique</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Technique/Feature-Engineering/"><span class="level-start"><span class="level-item">Feature Engineering</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Technique/Neural-Network/"><span class="level-start"><span class="level-item">Neural Network</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Theory/"><span class="level-start"><span class="level-item">ML Theory</span></span><span class="level-end"><span class="level-item tag">11</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Theory/Loss/"><span class="level-start"><span class="level-item">Loss</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Theory/Model-Enhencement/"><span class="level-start"><span class="level-item">Model Enhencement</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Theory/Optimization/"><span class="level-start"><span class="level-item">Optimization</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Algebra/"><span class="level-start"><span class="level-item">Math Algebra</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Algebra/Linear-Algebra/"><span class="level-start"><span class="level-item">Linear Algebra</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Algebra/Universal-Algebra/"><span class="level-start"><span class="level-item">Universal Algebra</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Analysis/"><span class="level-start"><span class="level-item">Math Analysis</span></span><span class="level-end"><span class="level-item tag">23</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Analysis/Fourier-Analysis/"><span class="level-start"><span class="level-item">Fourier Analysis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Functional-Analysis/"><span class="level-start"><span class="level-item">Functional Analysis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Optimization/"><span class="level-start"><span class="level-item">Optimization</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Real-Analysis/"><span class="level-start"><span class="level-item">Real Analysis</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Mixin/"><span class="level-start"><span class="level-item">Math Mixin</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Mixin/Statistics/"><span class="level-start"><span class="level-item">Statistics</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Mixin/Time-Series/"><span class="level-start"><span class="level-item">Time Series</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Probability/"><span class="level-start"><span class="level-item">Probability</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">89</span></span></a><ul><li><a class="level is-mobile" href="/categories/Python/Cookbook/"><span class="level-start"><span class="level-item">Cookbook</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Jupyter/"><span class="level-start"><span class="level-item">Jupyter</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Keras/"><span class="level-start"><span class="level-item">Keras</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Matplotlib/"><span class="level-start"><span class="level-item">Matplotlib</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Numpy/"><span class="level-start"><span class="level-item">Numpy</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Pandas/"><span class="level-start"><span class="level-item">Pandas</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Py3Ref/"><span class="level-start"><span class="level-item">Py3Ref</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Py3std/"><span class="level-start"><span class="level-item">Py3std</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Pywin32/"><span class="level-start"><span class="level-item">Pywin32</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Readme/"><span class="level-start"><span class="level-item">Readme</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/TensorFlow/"><span class="level-start"><span class="level-item">TensorFlow</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Twists/"><span class="level-start"><span class="level-item">Twists</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/RLang/"><span class="level-start"><span class="level-item">RLang</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Rust/"><span class="level-start"><span class="level-item">Rust</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Set/"><span class="level-start"><span class="level-item">Set</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/"><span class="level-start"><span class="level-item">Tool</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/Tool/Editor/"><span class="level-start"><span class="level-item">Editor</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Markup-Language/"><span class="level-start"><span class="level-item">Markup Language</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Web-Browser/"><span class="level-start"><span class="level-item">Web Browser</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Windows/"><span class="level-start"><span class="level-item">Windows</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/Web/CSS/"><span class="level-start"><span class="level-item">CSS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/NPM/"><span class="level-start"><span class="level-item">NPM</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/Proxy/"><span class="level-start"><span class="level-item">Proxy</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/Thrift/"><span class="level-start"><span class="level-item">Thrift</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://octodex.github.com/images/hula_loop_octodex03.gif" alt="UBeaRLy"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">UBeaRLy</p><p class="is-size-6 is-block">Protector of Proxy</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">392</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">93</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">522</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/xyy15926" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/xyy15926"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-04T15:07:54.896Z">2021-08-04</time></p><p class="title"><a href="/uncategorized/README.html"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-03T07:46:51.000Z">2021-08-03</time></p><p class="title"><a href="/Web/NPM/hexo_config.html">Hexo 建站</a></p><p class="categories"><a href="/categories/Web/">Web</a> / <a href="/categories/Web/NPM/">NPM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-03T02:32:45.000Z">2021-08-03</time></p><p class="title"><a href="/Web/NPM/config.html">NPM 总述</a></p><p class="categories"><a href="/categories/Web/">Web</a> / <a href="/categories/Web/NPM/">NPM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-02T08:11:11.000Z">2021-08-02</time></p><p class="title"><a href="/Python/Py3std/internet_data.html">互联网数据</a></p><p class="categories"><a href="/categories/Python/">Python</a> / <a href="/categories/Python/Py3std/">Py3std</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-29T13:55:00.000Z">2021-07-29</time></p><p class="title"><a href="/Linux/Shell/sh_apps.html">Shell 应用程序</a></p><p class="categories"><a href="/categories/Linux/">Linux</a> / <a href="/categories/Linux/Shell/">Shell</a></p></div></article></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">Advertisement</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5385776267343559" data-ad-slot="6995841235" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="https://api.follow.it/subscription-form/WWxwMVBsOUtoNTdMSlJ4Z1lWVnRISERsd2t6ek9MeVpEUWs0YldlZGxUdXlKdDNmMEZVV1hWaFZFYWFSNmFKL25penZodWx3UzRiaVkxcnREWCtOYUJhZWhNbWpzaUdyc1hPangycUh5RTVjRXFnZnFGdVdSTzZvVzJBcTJHKzl8aXpDK1ROWWl4N080YkFEK3QvbEVWNEJuQjFqdWdxODZQcGNoM1NqbERXST0=/8" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="UBeaRLy" height="28"></a><p class="is-size-7"><span>&copy; 2021 UBeaRLy</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/xyy15926/proxy"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>