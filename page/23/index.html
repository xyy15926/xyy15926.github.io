<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>UBeaRLy</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="UBeaRLy&#039;s Proxy"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="UBeaRLy&#039;s Proxy"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="UBeaRLy"><meta property="og:url" content="https://xyy15926.github.io/"><meta property="og:site_name" content="UBeaRLy"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://xyy15926.github.io/img/og_image.png"><meta property="article:author" content="UBeaRLy"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xyy15926.github.io"},"headline":"UBeaRLy","image":["https://xyy15926.github.io/img/og_image.png"],"author":{"@type":"Person","name":"UBeaRLy"},"publisher":{"@type":"Organization","name":"UBeaRLy","logo":{"@type":"ImageObject","url":"https://xyy15926.github.io/img/logo.svg"}},"description":""}</script><link rel="alternate" href="/atom.xml" title="UBeaRLy" type="application/atom+xml"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/darcula.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><script data-ad-client="pub-5385776267343559" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><meta name="follow_it-verification-code" content="SVBypAPPHxjjr7Y4hHfn"><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="UBeaRLy" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Visit on GitHub" href="https://github.com/xyy15926/proxy"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-06-04T15:11:44.000Z" title="6/4/2019, 11:11:44 PM">2019-06-04</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-06-04T15:11:44.000Z" title="6/4/2019, 11:11:44 PM">2019-06-04</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Specification/">Specification</a></span><span class="level-item">5 minutes read (About 768 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Specification/searching_high_dimensional.html">高维数据检索方法</a></h1><div class="content"><h2 id="相似性检索"><a href="#相似性检索" class="headerlink" title="相似性检索"></a>相似性检索</h2><p>相似性检索：从指定目标集合中检索出与给定样本相似的目标</p>
<blockquote>
<ul>
<li><em>range searches</em>：范围检索，给定查询点、检索距离阈值</li>
<li><em>K-neighbor searches</em>：K近邻检索，给定查询点、检索结果
  数量</li>
</ul>
</blockquote>
<ul>
<li><p>待检索目标、样本：以指定<em>feature space</em>中的高维数据点
表示</p>
</li>
<li><p>相似性检索则在相应<em>metric space</em>中搜索样本点最近邻作为
检索结果</p>
</li>
<li><p>关键：对待检索的目标建立有效的<strong>相似性索引</strong></p>
<ul>
<li>对待检索目标进行预划分，在对给定样本进行检索时，只需
对比相似索引中给出的可能相似的目标</li>
<li>减少相似性检索的对比次数、I/O，让相似性检索在大规模
数据集中应用成为可能</li>
</ul>
</li>
</ul>
<h2 id="Tree-Based-Index"><a href="#Tree-Based-Index" class="headerlink" title="Tree-Based Index"></a><em>Tree-Based Index</em></h2><p>基于树结构的索引</p>
<ul>
<li><p>向量维度大于20之后，仍然需要扫描整个向量集合的大部分，
与线性扫描没有太大差别</p>
</li>
<li><p>包括</p>
<ul>
<li><em>kd-tree</em></li>
<li><em>R-tree</em></li>
<li>R*-tree</li>
<li>X-tree</li>
<li>SS-tree</li>
<li>SR-tree</li>
<li>VP-tree</li>
<li>metric-trees</li>
</ul>
</li>
</ul>
<h2 id="Hasing-Based-Index"><a href="#Hasing-Based-Index" class="headerlink" title="Hasing-Based Index"></a><em>Hasing-Based Index</em></h2><p>基于哈希的索引技术：利用<em>LSH</em>函数简化搜索</p>
<ul>
<li><p><em>locality sensitive hashing</em>：<em>LSH</em>，局部敏感哈希，特征
向量越接近，哈希后值越可能相同</p>
<ul>
<li>局部敏感哈希值能够代表代替原始数据比较相似性</li>
<li>支持对原始特征向量进行<strong>非精确匹配</strong></li>
</ul>
</li>
<li><p>hash技术能从两个方面简化高维数据搜索</p>
<ul>
<li><p>提取特征、减小特征维度</p>
<ul>
<li>在损失信息较小的情况下对数据进行降维</li>
<li>hash函数（特征提取方法）选择依赖于对问题认识</li>
<li>一般都归于特征提取范畴</li>
</ul>
</li>
<li><p>划分特征空间（哈希桶）、缩小搜索空间</p>
<ul>
<li>将高维特征映射到1维先进行近似搜索得到候选集，
然后在候选集中进行精确搜索</li>
<li>hash函数的选择取决于原始特征表示、度量空间</li>
<li>一般LSH都是指此类哈希技术</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="提取特征"><a href="#提取特征" class="headerlink" title="提取特征"></a>提取特征</h4><ul>
<li><em>average hashing</em>：<em>aHash</em>，平均哈希</li>
<li><em>perceptual hashing</em>：<em>pHash</em>，感知哈希</li>
<li><em>differantiate hashing</em>：<em>dHash</em>，差异哈希</li>
</ul>
<h4 id="划分空间"><a href="#划分空间" class="headerlink" title="划分空间"></a>划分空间</h4><ul>
<li><em>MinHashing</em>：最小值哈希，基于Jaccard系数</li>
<li>基于汉明距离的LSH</li>
<li>基于曼哈顿距离的LSH</li>
<li><em>Exact Euclidean LSH</em>：<em>E2LSH</em>，基于欧式距离</li>
</ul>
<h2 id="Visual-Words-Based-Inverted-Index"><a href="#Visual-Words-Based-Inverted-Index" class="headerlink" title="Visual Words Based Inverted Index"></a><em>Visual Words Based Inverted Index</em></h2><p>向量化方法：将向量映射为标量，为（图像）特征建立
<em>visual vocabulary</em></p>
<ul>
<li>基于K-means聚类（层级K-means、近似K-means）</li>
<li>在图像检索实际问题中取得了一定成功</li>
<li>K-means聚类算法的复杂度与图像特征数量、聚类数量有关<ul>
<li>图像规模打达到百万级时，索引、匹配时间复杂度依然较高</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><em>visual vocabulary</em>：视觉词库，代表聚类类别整体</li>
<li><em>visual word</em>：视觉单词，每个代表一个聚类类别</li>
</ul>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-06-04T15:11:44.000Z" title="6/4/2019, 11:11:44 PM">2019-06-04</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-06-04T15:11:44.000Z" title="6/4/2019, 11:11:44 PM">2019-06-04</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Data-Structure/">Data Structure</a></span><span class="level-item">31 minutes read (About 4716 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Data-Structure/tree_search.html">查找/搜索树</a></h1><div class="content"><h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><blockquote>
<ul>
<li>二叉查找树：最基础的查找树，但是不平衡时效率很差</li>
<li>自平衡查找树：使用旋转技术得到平衡二叉树</li>
<li>多路查找树：使用多叉树达到平衡</li>
</ul>
</blockquote>
<ul>
<li><strong>树高度一般即决定其查找、插入、删除效率</strong></li>
<li>以代码复杂性、插入节点时间代价，换取查询时$logN$性能</li>
</ul>
<h3 id="Self-Balancing-Binary-Tree"><a href="#Self-Balancing-Binary-Tree" class="headerlink" title="Self-Balancing Binary Tree"></a><em>Self-Balancing Binary Tree</em></h3><p>自平衡查找树：如果节点插入、删除产生了一棵违背平衡要求的树，
就从称为<strong>旋转</strong>的一系列特定变换中选择一种，重新构造树使得
树满足平衡要求</p>
<ul>
<li>不同的对<strong>平衡</strong>的定义产生了不同的实现</li>
<li>这种方案属于<strong>变治法</strong>中<strong>实例化简</strong></li>
</ul>
<h4 id="Balance-Factor"><a href="#Balance-Factor" class="headerlink" title="Balance Factor"></a><em>Balance Factor</em></h4><p>平衡因子：节点左、右子树高度差（一般右树-左数）</p>
<ul>
<li><p>AVL树中平衡情况下节点平衡因子只能为-1、+1、0</p>
</li>
<li><p>更新节点后可能存在不平衡节点，其平衡因子可能变为-2、+2</p>
</li>
<li><p>平衡因子也可以被定义为左右子树叶子数</p>
</li>
</ul>
<h4 id="Rotation"><a href="#Rotation" class="headerlink" title="Rotation"></a><em>Rotation</em></h4><p>旋转需要使得二叉树平衡时，保证二叉树依然<strong>有序</strong></p>
<ul>
<li><p>左旋：节点平衡因子<strong>符号为正</strong>，即右子树高于左子树</p>
<ul>
<li>节点T<strong>下沉</strong>为其<strong>右</strong>儿子R的<strong>左</strong>儿子</li>
<li>如果右儿子R本身有<strong>左子树RL</strong>，则左子树RL成为节点T
新右子树</li>
</ul>
</li>
<li><p>右旋：节点平衡因子<strong>符号为负</strong>，即左子树高于右子树，</p>
<ul>
<li>节点T<strong>下沉</strong>为其<strong>左</strong>儿子L的<strong>右</strong>儿子</li>
<li>如果左儿子L本身有<strong>右子树LR</strong>，则右子树LR成为节点T
新左子树</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>旋转只涉参与选择的至多3个节点指针变化，其余节点状态保持</li>
<li>“旋转”行为确实类似：节点绕其子节点旋转，子节点旋转后上浮
  成为父节点</li>
<li>参与旋转的两个节点也称为轴</li>
</ul>
</blockquote>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>AVL树</li>
<li>红黑树</li>
<li>分裂树</li>
</ul>
<h3 id="Multiway-Search-Tree"><a href="#Multiway-Search-Tree" class="headerlink" title="Multiway Search Tree"></a>Multiway Search Tree</h3><p>多路查找树：允许查找树中单个节点中不止包含一个元素</p>
<ul>
<li>二叉查找树的推广，用于磁盘超大数据集的高效存取</li>
<li>此方案属于<strong>变治法</strong>中<strong>改变表现</strong></li>
</ul>
<h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><ul>
<li>2-3树</li>
<li>2-4树</li>
<li>B树</li>
<li>B+树</li>
</ul>
<h2 id="Binary-Search-Tree"><a href="#Binary-Search-Tree" class="headerlink" title="Binary Search Tree"></a>Binary Search Tree</h2><p>二叉查找树：分配给每个父母顶点的数字都比其左子树中数字大，
比右子树数字小</p>
<ul>
<li>二叉树有序，保证二叉树能够快速找到<strong>中间元素</strong>，从而支持
<strong>二分查找</strong></li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><p>对于n个顶点的二叉树，满足
$ \lfloor {log_{2}^{n}} \rfloor \leq h \leq n-1 $</p>
</li>
<li><p>二叉查找树的查找算法效率取决于二叉树的<strong>高度</strong></p>
<ul>
<li><p>平均情况下，查找、插入、删除时间$\in Theta(logn)$</p>
</li>
<li><p>最差情况下（严重不平衡的树，接近链表结构），树高度
h接近节点数n，查找、插入、删除时间$\in Theta(n)$</p>
</li>
</ul>
</li>
<li><p>包含n个键的二叉查找树总数量
$c(n) = \frac 1 {n+1} C_{2n}^n, c(0)=1$</p>
</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li>查找</li>
</ul>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>在给定二叉查找树中查找给定键值K</p>
<ul>
<li><p>如果树为空，查找失败</p>
</li>
<li><p>若树不为空，将查找键K和树根节点K(r)比较</p>
<ul>
<li>相等则查找停止</li>
<li>$K &lt; K(r)$：在左子树中继续查找</li>
<li>$K &gt; K(r)$：在右子树中继续查找</li>
</ul>
</li>
</ul>
<h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><ul>
<li>算法时间效率<ul>
<li>最差情况下，二叉树完全偏斜，需要进行n次比较</li>
<li>随机情况下，查找n个随机键构造的二叉树比较次数$2logn$</li>
</ul>
</li>
</ul>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>除非是空树，否则总是把新键K插入叶子节点中</p>
<ul>
<li>通过查找K确定合适插入位置（叶子节点）</li>
<li>若K大于叶子节点键值，则作为右子女，否则作为左子女</li>
</ul>
<h3 id="最优二叉查找树"><a href="#最优二叉查找树" class="headerlink" title="最优二叉查找树"></a>最优二叉查找树</h3><p>对集合中元素确定的查找概率，成功查找的平均比较次数最小的
二叉查找树（可以扩展到包含不成功查找）</p>
<blockquote>
<ul>
<li>$a_i, i=1,2,\cdots,n$：从小到大互不相等的键</li>
<li>$p_i, i=1,2,\cdots,n$：键查找概率</li>
<li>$T_i^j$：由键$a_i, \cdots, a_j$构成的二叉树</li>
<li>$C(i, j)$：成功查找的最小平均查找次数</li>
</ul>
</blockquote>
<h4 id="动态规划构造"><a href="#动态规划构造" class="headerlink" title="动态规划构造"></a>动态规划构造</h4><ul>
<li><p>根据最优化法则，最优二叉查找树左右子树均是最优排列的</p>
</li>
<li><p>二叉树$T<em>i^j$有序，设树根为$a_1$，$a_2,..,a</em>{k-1}$构成
的左子树、$a_{k+1},..,a_j$构成右子树均是最优排列的</p>
</li>
</ul>
<p>递推式如下</p>
<ul>
<li><p>$1 \leqslant i \leqslant j \leqslant n$</p>
<script type="math/tex; mode=display">\begin{align}
C(i, j) & = \min_{i \leqslant k \leqslant j} \{p_k + 
       \sum_{s=i}^{k-1} p_s * (a_s在T_i^{k-1}中层数 + 1) +
       \sum_{s=k+1}^j p_s * (a_s在T_{k+1}^j中层数 + 1) \}\\
   & = \min_{i \leqslant k \leqslant j} \{
       \sum_{s=i}^{k-1} p_s * a_s在T_i^{k-1}中层数 +
       \sum_{s=k+1}^j p_s * a_s在T_{k+1}^j中层数 +
       \sum_{s=i}^j p_s \} \\
   & = \min_{i \leqslant k \leqslant j}
       \{C(i, k-1) + C(k+1, j)\} + \sum_{s=i}^j p_s
\end{align}</script></li>
<li><p>$1 \leqslant i \leqslant n+1, C(i, i-1)=0$：空树</p>
</li>
<li><p>$1 \leqslant i \leqslant n, C(i, i)=p_i$：单节点</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">OptimalBST(P[<span class="number">1.</span>.n])</span><br><span class="line">	<span class="comment">// 动态规划法构建最优二叉查找树</span></span><br><span class="line">	<span class="comment">// 输入：P[1..n]n个键查找概率</span></span><br><span class="line">	<span class="comment">// 输出：在最优BST中查找成功的平均比较次数，最优BST子树根表</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">		C[i, i<span class="number">-1</span>] = <span class="number">0</span></span><br><span class="line">		C[i, i] = P[i]</span><br><span class="line">		R[i, i] = i</span><br><span class="line">	C[n+<span class="number">1</span>, n] = <span class="number">0</span></span><br><span class="line">		<span class="comment">// 初始化平均查找次数表、子树根表</span></span><br><span class="line">	<span class="keyword">for</span> d = <span class="number">1</span> to n<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">		<span class="comment">// d为二叉树节点数</span></span><br><span class="line">		<span class="keyword">for</span> i = <span class="number">1</span> to n-d <span class="keyword">do</span></span><br><span class="line">			<span class="comment">// n-d是为了控制j的取值</span></span><br><span class="line">			j = i + d</span><br><span class="line">			minval = \infty</span><br><span class="line">			<span class="keyword">for</span> k = i to j <span class="keyword">do</span></span><br><span class="line">				<span class="comment">// 遍历设置二叉树根节点</span></span><br><span class="line">				<span class="keyword">if</span> C[i, k<span class="number">-1</span>] + C[k+<span class="number">1</span>, j] &lt; minval</span><br><span class="line">					minval = C[i, k<span class="number">-1</span>] + C[k+<span class="number">1</span>, j]</span><br><span class="line">					kmin = k</span><br><span class="line">			R[i, j] = kmin</span><br><span class="line">			sum = P[i]</span><br><span class="line">			<span class="keyword">for</span> s=i+<span class="number">1</span> to j <span class="keyword">do</span></span><br><span class="line">				sum += P[s]</span><br><span class="line">			C[i, j] = minval + sum</span><br><span class="line">	<span class="keyword">return</span> C[<span class="number">1</span>, n], R</span><br></pre></td></tr></table></figure>
<h4 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li>算法效率<ul>
<li>算法时间效率为立方级</li>
<li>算法空间效率为平方级</li>
</ul>
</li>
</ul>
<h2 id="AVL-Tree"><a href="#AVL-Tree" class="headerlink" title="AVL Tree"></a>AVL Tree</h2><p>AVL树：要求其节点在左右子树高度差不能超过1的平衡二叉树</p>
<ul>
<li><p>基本思想：总能通过一次简单的节点重排使树达到平衡</p>
<ul>
<li>如果树插入操作使得一棵AVL树失去平衡，利用旋转对树作
变换</li>
<li>若有多个这样的节点，找出最靠近新插入的叶子节点不平衡
结点，然后旋转以该节点为根的子树</li>
</ul>
</li>
<li><p>AVL树高度h即为其查找、插入效率</p>
<ul>
<li><p>包含n个节点AVL树高度h满足
$\lfloor log_2 n \rfloor \leq h &lt; 1.4405log_2(n+2) - 1.3277$</p>
</li>
<li><p>最差情况下，操作效率$\in \Theta(logn)$</p>
</li>
<li><p>平均而言，在n不是太小时，高度h平均为
$1.01log_2 n + 0.1$（几乎同折半查找有序数组）</p>
</li>
</ul>
</li>
<li><p>AVL树缺点（平衡代价），阻碍AVL树成为实现字典的标准结构</p>
<ul>
<li>需要频繁旋转</li>
<li>维护树的节点平衡</li>
<li>总体比较复杂</li>
</ul>
</li>
</ul>
<h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>按照<strong>节点平衡符号</strong>进行旋转：<code>+</code>左旋、<code>-</code>右旋</p>
<ul>
<li><p>单旋：<strong>不平衡节点</strong>、<strong>不平衡子节点</strong>不平衡因子符号相同</p>
<ul>
<li>全为<code>+</code>：<strong>不平衡节点</strong>左旋</li>
<li>全为<code>-</code>：<strong>不平衡节点</strong>右旋</li>
</ul>
</li>
<li><p>双旋：<strong>不平衡节点</strong>、<strong>不平衡子节点</strong>不平衡因子符号不同</p>
<ul>
<li>先旋转<strong>不平衡子节点</strong></li>
<li>再旋转<strong>不平衡节点</strong></li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>优先考虑最底层、不平衡节点</li>
</ul>
</blockquote>
<h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><p>AVL树插入关键：查找不平衡节点</p>
<ul>
<li>节点中应有存储其平衡因子的实例变量</li>
<li>插入过程中<strong>经过每个节点</strong>返回当前节点子树深度是否变化</li>
<li>比较节点平衡因子、子节点深度变化返回值判断是否平衡</li>
</ul>
<blockquote>
<ul>
<li>插入过程中查询的每个节点都有可能不平衡</li>
<li>自下而上返回深度变化情况，优先旋转最底层不平衡节点</li>
</ul>
</blockquote>
<h4 id="4种插入情况"><a href="#4种插入情况" class="headerlink" title="4种插入情况"></a>4种插入情况</h4><p>根据插入情况的不同，对最靠近新插入叶子节点的不平衡点T</p>
<h5 id="LL"><a href="#LL" class="headerlink" title="LL"></a>LL</h5><p>插入T<strong>左儿子L的左子树LL</strong>：平衡因子全<code>-</code></p>
<ul>
<li>即T到最底层叶节点（只可能有一个）的路径为LL（中间省略）</li>
<li><em>R-rotation</em>：右单转，对T做一次右旋即可平衡</li>
</ul>
<p><img src="/imgs/avl_ll_rotation.png" alt="avl_ll_rotation"></p>
<h5 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h5><p>插入T<strong>右儿子R的右子树R</strong>：平衡因子全<code>+</code></p>
<ul>
<li>即T到最底层叶节点（只可能有一个）的路径为RR（中间省略）</li>
<li><em>L-rotation</em>：左单转，对T做一次左旋即可平衡</li>
</ul>
<p><img src="/imgs/avl_rr_rotation.png" alt="avl_ll_rotation"></p>
<h5 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h5><p>插入T<strong>左儿子L的右子树R</strong>：平衡因子<code>-+</code></p>
<ul>
<li>即T到最底层叶节点（只可能有一个）的路径为LR（中间省略）</li>
<li><em>LR-rotation</em>：左右双转<ul>
<li>先对左儿子L做一次左旋，变成LL模式</li>
<li>在LL模式下，再对T做一次右旋</li>
</ul>
</li>
</ul>
<p><img src="/imgs/avl_lr_rotation.png" alt="avl_lr_rotation"></p>
<h5 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h5><p>插入T<strong>右儿子R的左子树L</strong>：平衡因子<code>+-</code></p>
<ul>
<li>即T到最底层叶节点（只可能有一个）的路径为RL（中间省略）</li>
<li><em>RL-rotation</em>：右左双转<ul>
<li>先对右儿子R做一次右旋，变成RR模式</li>
<li>在RR模式下，再对T做一次左旋</li>
</ul>
</li>
</ul>
<p><img src="/imgs/avl_rl_rotation.png" alt="avl_rl_rotation"></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><blockquote>
<ul>
<li>在AVL树中删除键相对而言比较困难，但也是对数级的</li>
</ul>
</blockquote>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><h2 id="Red-Black-Tree"><a href="#Red-Black-Tree" class="headerlink" title="Red-Black Tree"></a>Red-Black Tree</h2><p>红黑树：能够容忍同一节点的一棵子树高度是另一棵的2倍</p>
<h2 id="Splay-Tree"><a href="#Splay-Tree" class="headerlink" title="Splay Tree"></a>Splay Tree</h2><p>分裂树：</p>
<h2 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2><p>2-3树：可以包含两种类型的节点2节点、3节点，树的所有叶子节点
必须位于同一层</p>
<p><img src="/imgs/2_3_tree.png" alt="2_3_tree"></p>
<ul>
<li><p>2-3树的高度即决定其查找、插入、删除效率</p>
<ul>
<li>节点数为n的2-3数高度h满足
$log_3(n+1)-1 \leq h \leq log_2(n+1) - 1$</li>
<li>最差、平均情况下，操作效率$\in \Theta(logn)$</li>
</ul>
</li>
<li><p>2-3树总是高度平衡</p>
<ul>
<li>所有叶子节点位于同一层，即树根到其路径长度相同</li>
<li>2-3树平衡代价<ul>
<li>树中节点可以有1或2个键，需要处理2种节点类型</li>
<li>拆分3节点的情况有很多种</li>
</ul>
</li>
</ul>
</li>
<li><p>节点类型</p>
<ul>
<li><p>2节点：只包含1个键K、2个子女</p>
<ul>
<li>左子女：作为所有键都小于K的子树的根</li>
<li>右子女：作为所有键都大于K的子树的根</li>
</ul>
</li>
<li><p>3节点：两个有序键$K_1 &lt; K_2$、3个子女</p>
<ul>
<li>最左边子女：作为键值小于$K_1$的子树的根</li>
<li>中间子女：作为键值位于$[K_1, K_2]$之间子树的根</li>
<li>最右边子女：作为键值大于$K_2$的子树的根</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>类似的还有2-4树</li>
</ul>
</blockquote>
<h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><ul>
<li><p>如果根是2节点，当作二叉树查找</p>
<ul>
<li>若K等于根键值，停止</li>
<li>若K小、大于根键值，在左、右子树中查找</li>
</ul>
</li>
<li><p>若根是3节点</p>
<ul>
<li>和两个键值比较，有相等，停止</li>
<li>否则能确定应该在3棵子树中哪棵继续查找</li>
</ul>
</li>
</ul>
<h3 id="插入节点-1"><a href="#插入节点-1" class="headerlink" title="插入节点"></a>插入节点</h3><p>除非是空树，否则总是把新键K插入叶子节点中</p>
<ul>
<li><p>查找K确定合适的插入位置（叶子节点）</p>
</li>
<li><p>若叶子节点2节点，根据大小关系将K作为第一个键或第二个键
插入
<img src="/imgs/2_3_2node_insert.png" alt="2_3_2node_insert"></p>
</li>
<li><p>若叶子节点3节点，把叶子分裂为两个节点：3个键中最小的放入
第一个叶子中，最大的放入第二个叶子中，中间的键提升到原
叶子节点父母中</p>
<p><img src="/imgs/2_3_2node_insert.png" alt="2_3_3node_insert"></p>
<ul>
<li>若叶子就是根，则需要创建新根容纳中间键</li>
<li>中间键的提升可能会导致父母节点分裂，并引起祖先链条上
多个节点的分裂</li>
</ul>
</li>
</ul>
<h3 id="删除节点-1"><a href="#删除节点-1" class="headerlink" title="删除节点"></a>删除节点</h3><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>B树：允许节点可以有$1~m-1$个键（$2~m$个子女）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BTREE_M</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> degree;				<span class="comment">// 节点实际包含键数</span></span><br><span class="line">	KeyType key_slots[BTREE_M<span class="number">-1</span>];		<span class="comment">// 节点存储键数组</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> <span class="title">ptr_slots</span>[<span class="title">BTREE_M</span>];</span>	<span class="comment">// 指向子女节点指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> * <span class="title">ptr_parent</span>;</span>			<span class="comment">// 父节点指针</span></span><br><span class="line">&#125;BTNode, *BTNodePtr;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>$m$：B树阶数，节点允许最大子女数<blockquote>
<ul>
<li>节点最多允许有$m-1$个条目</li>
<li>$m=2$即为二叉树、$m=3$即为2-3树</li>
</ul>
</blockquote>
</li>
<li>键：用于构建树的关键字，和具体条目类似于键值对</li>
</ul>
</blockquote>
<ul>
<li><p>根节点具有$2~m$个子女，除非为叶子节点</p>
</li>
<li><p>非根、非叶节点具有$[\lceil m/2 \rceil, m]$个子女</p>
<ul>
<li><p>即具有$[\lceil m/2 \rceil - 1, m]$个<strong>有序</strong>键</p>
</li>
<li><p>其中子树$T_0$所有键小于$K_1$，子树$T_1$中所有键大于
等于$K_1$小于 $K_2$，以此类推</p>
</li>
</ul>
</li>
<li><p>B树是完美平衡的：所有叶子节点在同一层上</p>
</li>
</ul>
<h3 id="查找-2"><a href="#查找-2" class="headerlink" title="查找"></a>查找</h3><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><blockquote>
<ul>
<li>输入：B树、目标查找键</li>
<li>输出：查找键所属B树节点（若存在）</li>
</ul>
</blockquote>
<ul>
<li><p>从根节点开始，比较查找键k和节点中键序列大小</p>
<ul>
<li>节点中键有序，若B树阶数足够大，可考虑<strong>折半查找</strong></li>
</ul>
</li>
<li><p>若在节点键序列中找到匹配键，则查找成功、返回</p>
</li>
<li><p>否则根据比较结果选择合适分支，顺着指针链前进，在相应子女
节点中进行查找</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BTreeSearch(T, k):</span><br><span class="line">	<span class="comment">// 在B树中搜索键</span></span><br><span class="line">	<span class="comment">// 输入：B树根节点T、目标查找键k</span></span><br><span class="line">	<span class="comment">// 输出：目标键所在节点、目标键在节点中序号</span></span><br><span class="line">	i = <span class="number">0</span></span><br><span class="line">	cur = T</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历寻找目标键对应键、分支</span></span><br><span class="line">	<span class="keyword">while</span> i &lt; cur.degree <span class="keyword">and</span> k &gt; cur.key_slots[i]:</span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> i &lt; cur.degree <span class="keyword">and</span> k == cur.key_slots[i]:</span><br><span class="line">		<span class="keyword">return</span> cur, i</span><br><span class="line">	elif cur.is_leaf():			<span class="comment">// 未找到目标键</span></span><br><span class="line">		<span class="keyword">return</span> cur, <span class="number">-1</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> BTreeSearch(cur.ptr_slots[i], k)</span><br></pre></td></tr></table></figure>
<h3 id="分裂"><a href="#分裂" class="headerlink" title="分裂"></a>分裂</h3><h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><blockquote>
<ul>
<li>输入：待分裂节点父节点、待分裂节点序号</li>
</ul>
</blockquote>
<ul>
<li><p>计算待分裂节点分裂中心</p>
<ul>
<li>将分裂中心右侧数据移动至新节点</li>
</ul>
</li>
<li><p>将节点分裂中心、新节点提升至父节点</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">BTreeNodeSplit(T, ptr_idx):</span><br><span class="line">	<span class="comment">// 分裂B树中节点</span></span><br><span class="line">	<span class="comment">// 输入：待分裂节点父节点`T`、待分裂节点序号`ptr_idx`</span></span><br><span class="line"></span><br><span class="line">	nnode = BTreeNode()</span><br><span class="line">	fnode = T.ptr_slots[ptr_idx]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分裂中心</span></span><br><span class="line">	mid = fnode.degree <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 复制右半部分键至新节点</span></span><br><span class="line">	nnode.key_slots[:fnode.degree - mid] = fnode.key_slots[mid:fnode.degree]</span><br><span class="line">	fnode.key_slots[mid:fnode.degree] = <span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若原节点非叶子节点，复制右半部分指针至新节点</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> fnode.is_leaf():</span><br><span class="line">		nnode.ptr_slots[:fnode.degree + <span class="number">1</span> - mid] = fnode.ptr_slots[mid: fnode.degree + <span class="number">1</span>]</span><br><span class="line">		fnode.ptr_slots[mid: fnode.degree+<span class="number">1</span>] = <span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修改两节点度</span></span><br><span class="line">	nnode.degree = fnode.degree - mid</span><br><span class="line">	fnode.degree = mid</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将分裂中心提升至父节点</span></span><br><span class="line">	<span class="comment">// 修改父节点指向子女节点指针</span></span><br><span class="line">	T.key_slots.insert(fnode.key_slots[mid], ptr_idx)</span><br><span class="line">	T.ptr_slots.insert(nnode, ptr_idx+<span class="number">1</span>)	<span class="comment">// 原节点指针不变</span></span><br></pre></td></tr></table></figure>
<h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><blockquote>
<ul>
<li>输入：B树根T、待插入键K</li>
<li>假设B树中不存在键K，否则查找、更新对应值即可</li>
</ul>
</blockquote>
<ul>
<li>根据需要插入键K，查找需要插入的<strong>叶子节点</strong>L</li>
<li>若叶子节点L键数小于m-1，直接插入结束</li>
<li>否则以叶子节点键值中位数mid为中心分裂<ul>
<li>将mid插入叶子节点L父节点P中</li>
<li>将mid左子支指向分裂后左子树、右子支指向分裂后右子树</li>
</ul>
</li>
<li>对父节点尝试操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BTreeInsert(T, k)</span><br><span class="line">	<span class="comment">// 向B树中插入不存在键K</span></span><br><span class="line">	<span class="comment">// 输入：B树根T、待插入键k</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找到键`k`应该插入的叶子节点`L`</span></span><br><span class="line">	L, _ = BTreeSearch(T, k)</span><br><span class="line">	L.key_slots.insert_in_order(k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若节点已满、须分裂</span></span><br><span class="line">	<span class="keyword">while</span> L.is_full():</span><br><span class="line">		BTreeNodeSplit(L.parent_ptr, L.get_index())</span><br><span class="line">		L = L.parent_ptr</span><br></pre></td></tr></table></figure>
<ul>
<li>此实现是考虑<strong>节点都有空位容纳新键</strong>，节点插入新键后再
判断是否需要分裂</li>
</ul>
<h3 id="删除-todo"><a href="#删除-todo" class="headerlink" title="删除#todo"></a>删除#todo</h3><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><ul>
<li>类似一般查找树，把数据记录插入初始为空的树中构造B树</li>
</ul>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B+树：B树的一种变形树</p>
<ul>
<li>其中非叶节点只有<strong>索引</strong>作用，跟记录相关信息均存放在
叶结点中</li>
<li>B+树中所有叶结点构成<strong>有序链表</strong>，可以按照键次序遍历</li>
</ul>
<h3 id="查找-3"><a href="#查找-3" class="headerlink" title="查找"></a>查找</h3><h4 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>从根开始，比较查找键K和节点中键大小，选择合适指针，顺着
指针链前进</p>
</li>
<li><p>指针链指向可能包含查找键的叶子节点，在其中查找K</p>
<ul>
<li>父母节点、叶子节点都是有序的，如果B树次数足够
大，可以考虑使用<strong>折半查找</strong></li>
</ul>
</li>
</ul>
<h4 id="算法效率"><a href="#算法效率" class="headerlink" title="算法效率"></a>算法效率</h4><p>以B树作索引存储大型数据文件为例</p>
<ul>
<li><p>查找指定查找键访问B树节点数量为B树高度$h+1$
（即磁盘访问次数）</p>
</li>
<li><p>次数为m、高度为h的B树能够包含最少节点数为
$n \geqslant 4 \lceiling m/2 \rceiling ^ {h-1} -1$，
即$h \leqslant \lfloor log_{[m/2]} \frac {n+1} 4 \rfloor + 1$</p>
</li>
<li><p>所以在B树中查找，访问磁盘次数$\in O(logn)$</p>
<ul>
<li>实际应用中，磁盘访问次数很少超过3，因为B树的根、甚至
是第一层节点会存储在内存中减少磁盘访问次数</li>
</ul>
</li>
</ul>
<h3 id="插入-2"><a href="#插入-2" class="headerlink" title="插入"></a>插入</h3><h4 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>查找新记录键K对应的叶子节点</p>
</li>
<li><p>若叶子节点中还有空间存放此记录，在保持键有序的情况下插入</p>
</li>
<li><p>若节点中没有空间</p>
<ul>
<li>将节点分裂，后半部分记录放在新节点中</li>
<li>新节点中最小键$K^{‘}$、指向其的指针插入原叶子节点
父母节点中（原叶子节点键、指针之后）</li>
<li>插入过程可以一直回溯到树根，甚至直到树根分裂</li>
</ul>
</li>
</ul>
<p>其他考虑</p>
<ul>
<li>查找新记录对应叶子节点时就分裂满节点，可以避免递归分裂</li>
<li>将满叶子节点中部分键移动给兄弟节点，同时替换父母节点中的
键值（保证B树特点），增加少许复杂度以节约空间</li>
</ul>
<h4 id="算法特点-1"><a href="#算法特点-1" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li>算法效率<ul>
<li>算法时间效率$\in O(logn)$</li>
</ul>
</li>
</ul>
<h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><ul>
<li>B+树是存储结构化记录数据集合最重要的索引结构<ul>
<li>所有数据记录（键）按照升序存储在叶子节点中，其父母
节点作为索引</li>
<li>B+树中节点常常对应磁盘中页</li>
<li>考虑到访问磁盘页面是比较内存中键值比较时间多好几个
数量级，磁盘访问次数是衡量B树效率的主要指标</li>
</ul>
</li>
</ul>
<p>标</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-06-03T17:18:34.000Z" title="6/4/2019, 1:18:34 AM">2019-06-04</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-04T03:26:19.000Z" title="8/4/2021, 11:26:19 AM">2021-08-04</time></span><span class="level-item"><a class="link-muted" href="/categories/Math-Analysis/">Math Analysis</a><span> / </span><a class="link-muted" href="/categories/Math-Analysis/Optimization/">Optimization</a></span><span class="level-item">16 minutes read (About 2327 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Math-Analysis/Optimization/gredient_based.html">Gradient Descent Method</a></h1><div class="content"><h2 id="思想：最速下降-amp-牛顿"><a href="#思想：最速下降-amp-牛顿" class="headerlink" title="思想：最速下降&amp;牛顿"></a>思想：最速下降&amp;牛顿</h2><p>对目标函数$f(x)$在$x^{(1)}$进行展开</p>
<script type="math/tex; mode=display">
f(x) = f(x^{(1)}) + \nabla f(x^{(1)})(x - x^{(1)})+
    \frac 1 2 \nabla^2 f(x^{(1)})(x - x^{(1)})^2 +
    o((x - x^{(1)})^2)</script><blockquote>
<ul>
<li>最速下降法：只保留一阶项，即使用线性函数近似原目标函数</li>
<li>Newton法：保留一阶、二阶项，即使用二次函数近似</li>
</ul>
</blockquote>
<ul>
<li><p>利用近似函数求解元素问题极小值</p>
<ul>
<li>最速下降法：<strong>线性函数无极值，需要确定步长、迭代</strong></li>
<li>Newton法：<strong>二次函数有极值，直接求导算出极值、迭代</strong></li>
</ul>
</li>
<li><p>最速下降法</p>
<ul>
<li>只考虑一阶导：甚至说根本没有考虑拟合原目标函数</li>
</ul>
</li>
<li><p>Newton法</p>
<ul>
<li>考虑二阶导：每步迭代还考虑了二阶导，即当前更新完毕
后，下一步能够更好的更新（二阶导的意义）</li>
<li>甚至从后面部分可以看出，Newton法甚至考虑是全局特征，
不只是局部性质（前提目标函数性质足够好）</li>
<li>二次函数拟合更接近函数极值处的特征</li>
</ul>
</li>
</ul>
<h2 id="最速下降算法"><a href="#最速下降算法" class="headerlink" title="最速下降算法"></a>最速下降算法</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><ul>
<li><p>设$x=x(t)$为最优点$x$从初始点、沿负梯度方向经过的曲线，
则有</p>
<script type="math/tex; mode=display">\left \{ \begin{array}{l}
& \frac {dx(t)} {dt} = -\nabla f(x(t)) \\
& x(t_1) = x^{(1)}
\end{array} \right.</script><blockquote>
<ul>
<li>$t_1, x^{(1)}$：初始时刻、初始位置</li>
</ul>
</blockquote>
</li>
<li><p>可以证明，$x(t)$解存在，且$t \rightarrow \infty$时，有
$x(t) \rightarrow x^{ * }$，即得到无约束问题最优解</p>
</li>
<li><p>但微分方程组求解可能很麻烦，可能根本无法求解</p>
<ul>
<li>考虑将以上曲线离散化，每次前进到“不应该”前进为止</li>
<li>然后更换方向，逐步迭代得到最优解</li>
</ul>
</li>
</ul>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><blockquote>
<ul>
<li>搜索方向最速下降方向：负梯度方向</li>
<li>终止准则：$\nabla f(x^{(k)})=0$</li>
</ul>
</blockquote>
<ol>
<li><p>取初始点$x^{(1)}$，置k=1</p>
</li>
<li><p>若$\nabla f(x^{(k)})=0$，则停止计算，得到最优解，
否则置</p>
<script type="math/tex; mode=display">d^{(k)} = -\nabla f(x^{(k)})</script><p>以负梯度作为前进方向</p>
</li>
<li><p>一维搜索，求解一维问题</p>
<script type="math/tex; mode=display">
\arg\min_{\alpha} \phi(\alpha) =
  f(x^{(k)} + \alpha d^{(k)})</script><p>得$\alpha_k$前进步长，置</p>
<script type="math/tex; mode=display">
x^{(k+1)} = x^{(k)} + \alpha_k d^{(k)}</script></li>
<li><p>置k=k+1，转2</p>
</li>
</ol>
<blockquote>
<ul>
<li>最速下降算法不具有二次终止性</li>
</ul>
</blockquote>
<h2 id="叠加惯性"><a href="#叠加惯性" class="headerlink" title="叠加惯性"></a>叠加惯性</h2><p>模拟物体运动时惯性：指数平滑更新步长</p>
<p><img src="/imgs/momentum.png" alt="momentum"></p>
<h3 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a><em>Momentum</em></h3><p>冲量方法：在<strong>原始更新步</strong>上叠加上次更新步，类似指数平滑</p>
<script type="math/tex; mode=display">
v^{(t)} = \gamma v^{(t-1)} + (1 - \gamma) \eta
    \bigtriangledown_\theta L(\theta^{(t-1)}) \\
\theta^{(t)} = \theta^{(t-1)} - v^{(t)}</script><blockquote>
<ul>
<li>$v^{(t)}$：第$t$步时第k个参数更新步</li>
<li>$L(\theta)$：往往是batch损失函数</li>
</ul>
</blockquote>
<ul>
<li>更新参数时，一定程度<strong>保持</strong>上次更新方向</li>
<li>可以在一定程度上保持稳定性，学习速度更快</li>
<li>能够越过部分局部最优解</li>
</ul>
<h3 id="Nesterov-Momentum"><a href="#Nesterov-Momentum" class="headerlink" title="Nesterov Momentum"></a><em>Nesterov Momentum</em></h3><p><em>NGA</em>：在使用冲量修正最终方向基础上，使用冲量对当前
<strong>参数位置</strong>进行修正，即使用“未来”位置计算梯度</p>
<ul>
<li>先使用冲量更新一步</li>
<li>再在更新后位置计算新梯度进行第二步更新</li>
</ul>
<script type="math/tex; mode=display">
v^{(t)} = \gamma v^{(t-1)} + \eta \bigtriangledown_\theta
    L(\theta^{(t-1)} - \gamma v^{(t-1)}) \\

\theta^{(t)} = \theta^{(t-1)} - v^{(t)}</script><h2 id="动态学习率"><a href="#动态学习率" class="headerlink" title="动态学习率"></a>动态学习率</h2><ul>
<li>学习率太小收敛速率缓慢、过大则会造成较大波动</li>
<li>在训练过程中动态调整学习率大小较好</li>
</ul>
<blockquote>
<ul>
<li>模拟退火思想：达到一定迭代次数、损失函数小于阈值时，减小
  学习速率</li>
</ul>
</blockquote>
<p><img src="/imgs/param_estimation_comparion_1.png" alt="param_estimation_comparion_1">
<img src="/imgs/param_estimation_comparion_2.png" alt="param_estimation_comparion_2"></p>
<h3 id="Vanilla-Gradient-Descent"><a href="#Vanilla-Gradient-Descent" class="headerlink" title="Vanilla Gradient Descent"></a><em>Vanilla Gradient Descent</em></h3><p>每次迭代减小学习率$\eta$</p>
<script type="math/tex; mode=display">
\eta^{(t)} = \frac \eta {\sqrt {t+1}} \\

\theta^{(t)} = \theta^{(t-1)} - \eta^{(t)}
    \bigtriangledown_\theta L(\theta^{(t-1)})</script><ul>
<li>学习率逐渐减小，避免学习后期参数在最优解附近反复震荡</li>
</ul>
<h3 id="Adagrad"><a href="#Adagrad" class="headerlink" title="Adagrad"></a><em>Adagrad</em></h3><p><em>adaptive gradient</em>：训练中<strong>不同参数</strong>学习率随着迭代次数、
梯度动态变化，使得参数收敛更加平稳</p>
<script type="math/tex; mode=display">
v^{(t)}_k = \bigtriangledown_{\theta_k} L(\theta^{(t-1)}) \\

\theta^{(t)}_k = \theta^{(t-1)}_k - \frac \eta
    {\sqrt {\sum_{i=0}^{t-1} (v^{(i)}_k)^2 + \epsilon}}
    v^{(t)}_k</script><blockquote>
<ul>
<li>$\epsilon$：fuss factor，避免分母为0</li>
<li>$\theta^{(t)}_k$：第t轮迭代完成后待估参数第k个分量
  （之前未涉及参数间不同，统一为向量）</li>
</ul>
</blockquote>
<ul>
<li><p>特点</p>
<ul>
<li>较大梯度参数真正学习率会被拉小；较小梯度真正学习率
参数被拉小幅度较小</li>
<li>可以和异步更新参数结合使用，给不常更新参数更大学习率</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>在训练后期，分母中梯度平方累加很大，学习步长趋于0，
收敛速度慢（可能触发阈值，提前结束训练）</li>
</ul>
</li>
</ul>
<h3 id="RMSprop"><a href="#RMSprop" class="headerlink" title="RMSprop"></a><em>RMSprop</em></h3><p><em>root mean square prop</em>：指数平滑更新学习率分母</p>
<script type="math/tex; mode=display">
v^{(t)}_k = \bigtriangledown_{\theta_k} L(\theta^{(t-1)}) \\

\theta^{(t)}_k = \theta^{(t-1)}_k - \frac \eta
    {\sqrt { \gamma \sum_{i=1}^{t-1}(v^{(i)}_k)^2 +
        (1 - \gamma)((v^{(t)})^2 + \epsilon}
    } v^{(t)}</script><ul>
<li>赋予当前梯度更大权重，减小学习率分母，避免学习速率下降
太快</li>
</ul>
<h3 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a><em>Adam</em></h3><p><em>adptive moment estimation</em>：指数平滑更新步、学习率分母</p>
<script type="math/tex; mode=display">
\begin{align*}
v^{(t)}_k & = \gamma_1 v^{(t-1)}_k + (1 - \gamma_1)
    \bigtriangledown_{\theta_k} L(\theta^{(t-1)}) \\
s^{(t)}_k & = \gamma_2 s^{(t-1)}_k + (1 - \gamma_2)
    \bigtriangledown_{\theta_k} L(\theta^{(t-1)})^2 \\

\hat{v^{(t)}_k} & = \frac {v^{(t)}_k} {1 - \gamma_1^t} \\
\hat{s^{(t)}_k} & = \frac {s^{(t)}_k} {1 - \gamma_2^t} \\

\theta^{(t)}_k & = \theta^{(t-1)}_k - \frac \eta
    {\sqrt{\hat{s^{(t)}_k} + \epsilon}} \hat{v^{(t)}_k}
\end{align*}</script><blockquote>
<ul>
<li>$\gamma_1$：通常为0.9</li>
<li>$\gamma_2$：通常为0.99</li>
<li>$\hat{v^{(t)}_k} = \frac {v^{(t)}_k} {1 - \gamma_1^t}$
  ：权值修正，使得过去个时间步，小批量随机梯度权值之和为1</li>
</ul>
</blockquote>
<ul>
<li><p>利用梯度的一阶矩$v^{(t)}$、二阶矩$s^{(t)}$动态调整每个
参数学习率</p>
</li>
<li><p>类似于<em>mommentum</em>、<em>RMSprop</em>结合</p>
</li>
<li><p>经过偏执矫正后，每次迭代学习率都有确定范围，参数比较平稳</p>
</li>
</ul>
<h3 id="Adadelta"><a href="#Adadelta" class="headerlink" title="Adadelta"></a><em>Adadelta</em></h3><p>指数平滑更新学习率（分子）、学习率分母</p>
<script type="math/tex; mode=display">
\begin{align*}
s^{(t)}_k & = \gamma_1 s^{(t-1)}_k + (1 - \gamma_1)
    \bigtriangledown_{\theta_k} L(\theta^{(t-1)})^2 \\

\hat{v^{(t)}_k} & = \sqrt {\frac {\Delta \theta^{(t-1)}_k + \epsilon}
    {s^{(t)}_k + \epsilon}}
    \bigtriangledown_{\theta_k} L(\theta^{(t-1)})^2 \\

\Delta \theta^{(t)}_k & = \gamma_1 \Delta \theta^{(t-1)}_k +
    (1 - \gamma_1) \hat{v^{(t)}_k}^2 \\

\theta^{(t)}_k & = \theta^{(t)}_k - \hat{v^{(t)}_k}
\end{align*}</script><blockquote>
<ul>
<li>$s, \Delta \theta$共用超参$\gamma_1$</li>
</ul>
</blockquote>
<ul>
<li>在<em>RMSprop</em>基础上，使用$\sqrt {\Delta \theta}$作为学习率</li>
<li>$\hat v$：中超参$\gamma_1$在分子、分母“抵消”，模型对
超参不敏感</li>
</ul>
<h2 id="样本量"><a href="#样本量" class="headerlink" title="样本量"></a>样本量</h2><h3 id="Singular-Loss-Stocastic-Gradient-Descent"><a href="#Singular-Loss-Stocastic-Gradient-Descent" class="headerlink" title="Singular Loss/Stocastic Gradient Descent"></a>Singular Loss/Stocastic Gradient Descent</h3><p><em>SGD</em>：用模型在某个样本点上的损失极小化目标函数、计算梯度、
更新参数</p>
<ul>
<li><p>单点损失度量模型“一次”预测的好坏</p>
<ul>
<li>代表模型在单点上的优劣，无法代表模型在总体上性质</li>
<li>具有很强随机性</li>
</ul>
</li>
<li><p>单点损失不常用，SGD范围也不局限于单点损失</p>
</li>
</ul>
<blockquote>
<ul>
<li>损失函数具体参见<em>ml_xxxxx</em></li>
</ul>
</blockquote>
<h3 id="全局估计"><a href="#全局估计" class="headerlink" title="全局估计"></a>全局估计</h3><p>全局损失：用模型在全体样本点上损失极小化目标函数、计算梯度、
更新参数</p>
<script type="math/tex; mode=display">
\theta^{(t)} = \theta^{(t-1)} - \eta \bigtriangledown_\theta
    L_{total}(\theta_{(t-1)})</script><blockquote>
<ul>
<li>$\theta^{(t)}$：第t步迭代完成后待估参数</li>
<li>$\eta$：学习率</li>
<li>$L<em>{total}(\theta) = \sum</em>{i=1}^N L(\theta, x_i, y_i)$：
  训练样本整体损失</li>
<li>$N$：训练样本数量</li>
</ul>
</blockquote>
<ul>
<li><p>若损失函数有解析解、样本量不大，可<strong>一步更新（计算）</strong>
完成（传统参数估计场合）</p>
<ul>
<li>矩估计</li>
<li>最小二乘估计</li>
<li>极大似然估计</li>
</ul>
</li>
<li><p>否则需要迭代更新参数</p>
<ul>
<li>样本量较大场合</li>
<li>并行计算</li>
</ul>
</li>
</ul>
<h3 id="Mini-Batch-Loss"><a href="#Mini-Batch-Loss" class="headerlink" title="Mini-Batch Loss"></a>Mini-Batch Loss</h3><p><em>mini-batch loss</em>：用模型在某个batch上的损失极小化目标函数、
计算梯度、更新参数</p>
<script type="math/tex; mode=display">
\theta^{(t)} = \theta^{(t-1)} - \eta \bigtriangledown_\theta
    L_{batch}(\theta^{(t-1)})</script><blockquote>
<ul>
<li>$L<em>{batch}(\theta)=\sum</em>{i \in B} L(\theta, x_i, y_i)$：
  当前batch整体损失</li>
<li>$B$：当前更新步中，样本组成的集合batch</li>
</ul>
</blockquote>
<ul>
<li><p>batch-loss是模型在batch上的特征，对整体的代表性取决于
batch大小</p>
<ul>
<li>batch越大对整体代表性越好，越稳定；越小对整体代表
越差、不稳定、波动较大、难收敛</li>
<li>batch大小为1时，就是SGD</li>
<li>batch大小为整个训练集时，就是经验（结构）风险</li>
</ul>
</li>
<li><p>batch-loss是学习算法中最常用的loss，SGD优化常指此</p>
<ul>
<li>实际中往往是使用batch-loss替代整体损失，表示经验风险
极小化</li>
<li>batch-loss同样可以带正则化项，表示结构风险极小化</li>
<li>损失极值：SVM（几何间隔最小）</li>
</ul>
</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>适合样本量较大、无法使用样本整体估计使用</li>
<li>一定程度能避免局部最优（随机batch可能越过局部极值）</li>
<li>开始阶段收敛速度快</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><p>限于每次只使用单batch中样本更新参数，batch-size较小时，
结果可能不稳定，往往很难得到最优解</p>
</li>
<li><p>无法保证良好的收敛性，学习率小收敛速度慢，学习率过大
则损失函数可能在极小点反复震荡</p>
</li>
<li><p>对所有参数更新应用相同学习率，没有对低频特征有优化
（更的学习率）</p>
</li>
<li><p>依然容易陷入局部最优点</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-06-03T17:18:34.000Z" title="6/4/2019, 1:18:34 AM">2019-06-04</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-06-03T17:18:34.000Z" title="6/4/2019, 1:18:34 AM">2019-06-04</time></span><span class="level-item"><a class="link-muted" href="/categories/Math-Analysis/">Math Analysis</a><span> / </span><a class="link-muted" href="/categories/Math-Analysis/Optimization/">Optimization</a></span><span class="level-item">5 minutes read (About 752 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Math-Analysis/Optimization/newtons.html">Newton&#039;s Method</a></h1><div class="content"><h2 id="Newton法"><a href="#Newton法" class="headerlink" title="Newton法"></a>Newton法</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><ul>
<li><p>若$x^{ * }$是无约束问题局部解，则有</p>
<script type="math/tex; mode=display">\nabla f(x^{ * }) = 0</script><p>可求解此问题，得到无约束问题最优解</p>
</li>
<li><p>原始问题是非线性，考虑求解其线性逼近，在初始点$x^{(1)}$
处泰勒展开</p>
<script type="math/tex; mode=display">
\nabla f(x) \approx \nabla f(x^{(1)})
   + \nabla^2 f(x^{(1)})(x - x^{(1)})</script><p>解得</p>
<script type="math/tex; mode=display">
x^{(2)} = x^{(1)} - (\nabla^2 f(x^{(1)}))^{-1}
   \nabla f(x^{(1)})</script><p>作为$x^{ * }$的第二次近似</p>
</li>
<li><p>不断迭代，得到如下序列</p>
<script type="math/tex; mode=display">
x^{(k+1)} = x^{(k)} + d^{(k)}</script><blockquote>
<ul>
<li>$d^{(k)}$：Newton方向，即以下方程解<script type="math/tex; mode=display">
 \nabla^2 f(x^{(k)}) d = -\nabla
     f(x^{(k)})</script></li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul>
<li><p>初始点 $x^{(1)}$、精度要求 $\epsilon$，置 $k=1$</p>
</li>
<li><p>考虑 $|\nabla f(x^{(k)})| \leq \epsilon$</p>
<ul>
<li>若满足，则停止计算，得到最优解 $x^{(k)}$</li>
<li><p>否则求解如下方程，得到 $d^{(k)}$</p>
<script type="math/tex; mode=display">
\nabla^2 f(x^{(k)}) d = -\nabla f(x^{(k)})</script></li>
</ul>
</li>
<li><p>如下设置，并转2</p>
<script type="math/tex; mode=display">x^{(k+1)} = x^{(k)} + d^{(k)}, k = k+1</script></li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><p>优点</p>
<ul>
<li>产生点列 ${x^{k}}$ 若收敛，则具有二阶收敛速率</li>
<li>具有二次终止性，事实上对正定二次函数，一步即可收敛</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>可能会在某步迭代时目标函数值上升</li>
<li>当初始点 $x^{(1)}$ 距离最优解 $x^{ * }$ 时，产生的点列
可能不收敛，或者收敛到鞍点</li>
<li>需要计算 <em>Hesse</em> 矩阵<ul>
<li>计算量大</li>
<li><em>Hesse</em> 矩阵可能不可逆，算法终止</li>
<li><em>Hesse</em> 矩阵不正定，<em>Newton</em> 方向可能不是下降方向</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="阻尼-修正-Newton-法"><a href="#阻尼-修正-Newton-法" class="headerlink" title="阻尼/修正 Newton 法"></a>阻尼/修正 <em>Newton</em> 法</h2><ul>
<li>克服 <em>Newton</em> 法目标函数值上升的缺点</li>
<li>一定程度上克服点列可能不收敛缺点</li>
</ul>
<h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><ul>
<li><p>初始点 $x^{(1)}$、精度要求 $\epsilon$，置 $k=1$</p>
</li>
<li><p>考虑 $|\nabla f(x^{(k)})| \leq \epsilon$</p>
<ul>
<li>若满足，停止计算，得到最优解 $x^{(k)}$</li>
<li>否则求解如下方程得到 $d^{(k)}$<script type="math/tex; mode=display">
\nabla^2 f(x^{(k)}) d = -\nabla f(x^{(k)})</script></li>
</ul>
</li>
<li><p>一维搜索，求解一维问题</p>
<script type="math/tex; mode=display">
\arg\min_{\alpha} \phi(\alpha) = f(x^{(k)} + \alpha d^{(k)})</script><p>得到 $\alpha_k$，如下设置并转2</p>
<script type="math/tex; mode=display">
x^{(k+1)} = x^{(k)} + \alpha_k d^{(k)}, k = k+1</script></li>
</ul>
<h2 id="其他改进"><a href="#其他改进" class="headerlink" title="其他改进"></a>其他改进</h2><ul>
<li><em>Newton</em> 法、修正 <em>Newton</em> 法的改进方向<ul>
<li>结合最速下降方向修正迭代方向</li>
<li><em>Hesse</em> 矩阵不正定情形下的替代</li>
</ul>
</li>
</ul>
<h3 id="结合最速下降方向"><a href="#结合最速下降方向" class="headerlink" title="结合最速下降方向"></a>结合最速下降方向</h3><blockquote>
<ul>
<li>将 <em>Newton</em> 方向和最速下降方向结合</li>
</ul>
</blockquote>
<ul>
<li><p>设 $\theta_k$ 是 $<d^{(k)}, -\nabla f(x^{(k)})>$ 之间夹角，显然希望 $\theta &lt; \frac \pi 2$</p>
</li>
<li><p>则置限制条件 $\eta$，取迭代方向</p>
<script type="math/tex; mode=display">
d^{(k)} = \left \{ \begin{array}{l}
   d^{(k)}, & cos\theta_k \geq \eta \\
   -\nabla f(x^{(k)}), & 其他
\end{array} \right.</script></li>
</ul>
<h3 id="Negative-Curvature"><a href="#Negative-Curvature" class="headerlink" title="Negative Curvature"></a><em>Negative Curvature</em></h3><blockquote>
<ul>
<li>当 <em>Hesse</em> 矩阵非正定时，选择负曲率下降方向 $d^{(k)}$（一定存在）</li>
</ul>
</blockquote>
<ul>
<li><p><em>Hesse</em> 矩阵非正定时，一定存在负特征值、相应特征向量 $u$</p>
<ul>
<li><p>取负曲率下降方向作为迭代方向</p>
<script type="math/tex; mode=display">
d^{(k)} = -sign(u^T \nabla f(x^{(k)})) u</script></li>
<li><p>$x^{(k)}$ 处负曲率方向 $d^{(k)}$ 满足</p>
<script type="math/tex; mode=display">
{d^{(k)}}^T \nabla^2 f(x^{(k)}) d^{(k)} < 0</script></li>
</ul>
</li>
</ul>
<h3 id="修正-Hesse-矩阵"><a href="#修正-Hesse-矩阵" class="headerlink" title="修正 Hesse 矩阵"></a>修正 <em>Hesse</em> 矩阵</h3><ul>
<li><p>取迭代方向 $d^{(k)}$ 为以下方程的解</p>
<script type="math/tex; mode=display">
(\nabla^2 f(x^{(k)}) + v_k I) d = -\nabla f(x^{k})</script></li>
</ul>
<blockquote>
<ul>
<li>$v_k$：大于 $\nabla^2 f(x^{(k)})$ 最大负特征值绝对值</li>
</ul>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-06-03T16:55:56.000Z" title="6/4/2019, 12:55:56 AM">2019-06-04</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-06-03T16:55:56.000Z" title="6/4/2019, 12:55:56 AM">2019-06-04</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Py3Ref/">Py3Ref</a></span><span class="level-item">an hour read (About 10552 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Py3Ref/cls_special_methods.html">Special Methods</a></h1><div class="content"><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>特殊方法：python类中具有特殊名称的方法，实现<strong>由特殊语法</strong>
所引发的特定操作</p>
<ul>
<li><p>python实现<strong>操作符重载</strong>的方式</p>
<ul>
<li>允许每个类自行定义基于操作符的特定行为</li>
<li>特定操作包括python内置的<strong>钩子函数</strong></li>
</ul>
</li>
<li><p>钩子函数不能简单的看作<strong>直接调用</strong>特殊方法</p>
<ul>
<li>尝试调用备用实现：<code>iter</code>、<code>reversed</code></li>
<li>修改方法返回值：<code>dir</code></li>
</ul>
</li>
<li><p>大部分情况下，若没有定义适当方法，尝试<strong>执行操作</strong>将
<code>raise AttributeError</code>、<code>raise TypeError</code></p>
<ul>
<li><p>但<code>__hash__</code>、<code>__iter__</code>、<code>__reversed__</code>、
<code>__contains__</code>等方法即使未定义，其<strong>对应钩子函数</strong>
实现会尝试调用可能的其他方法完成操作
（直接<code>obj.__xxx__</code>调用方法仍然报错）</p>
</li>
<li><p>将特殊方法设为<code>None</code>表示对应操作不可用，此时即使以上
<code>hash</code>、<code>iter</code>、<code>reversed</code>、<code>in</code>等操作也不会尝试调用
备用方法</p>
</li>
</ul>
</li>
</ul>
<h2 id="实例创建、销毁"><a href="#实例创建、销毁" class="headerlink" title="实例创建、销毁"></a>实例创建、销毁</h2><p>调用类时，元属性方法执行顺序</p>
<ul>
<li><code>__prepare__()</code>：创建命名空间</li>
<li>依次执行类定义语句</li>
<li><code>__new__()</code>：创建类实例</li>
<li><code>__init__()</code>：初始化类<ul>
<li><code>__new__</code><strong>返回的新实例</strong>的<code>__init__</code>方法将被调用</li>
<li>用户定义<code>__new__</code>返回对象不一定期望类实例，调用的
<code>__init__</code>随之不一定是期望方法</li>
</ul>
</li>
<li>返回<code>__new__</code>返回类实例</li>
</ul>
<h3 id="prepare"><a href="#prepare" class="headerlink" title="__prepare__"></a><code>__prepare__</code></h3><ul>
<li>在所有类定义开始执行前被调用，用于创建类命名空间</li>
<li>一般这个方法只是简单的返回一个字典或其他映射对象</li>
</ul>
<h3 id="new"><a href="#new" class="headerlink" title="__new__"></a><code>__new__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">classmethod</span> <span class="built_in">object</span>.__new__(cls[, *args, **kwargs]):</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：创建、返回<code>cls</code>类新实例</p>
<ul>
<li><code>super().__new__(cls[,...])</code>调用超类方法创建类实例，
然后根据需要修改新创建实例再返回</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><code>cls</code>：待实例化类</li>
<li>其余参数：类构造器表达式参数</li>
</ul>
</li>
<li><p>返回值：<code>cls</code>类新实例</p>
<ul>
<li><code>__new__</code>返回值就是类构造器的返回值，有绝对控制权</li>
</ul>
</li>
</ul>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul>
<li><p><code>__new__</code>：<em>builtin_function_or_method</em></p>
</li>
<li><p><code>__new__</code>是静态方法：以需实例化类作为第一个参数</p>
<ul>
<li><code>__new__</code>方法绑定当前<strong>类对象</strong></li>
<li>特例，不需要显式声明为静态方法</li>
</ul>
</li>
<li><p>原生有两个<code>__new__</code>函数，二者C实现不同</p>
<ul>
<li><code>type.__new__</code>：元类继承，用于创建类对象</li>
<li><code>object.__new__</code>：其他类继承，用于创建实例</li>
</ul>
</li>
</ul>
<h3 id="init"><a href="#init" class="headerlink" title="__init__"></a><code>__init__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__init__</span>(<span class="params">self[, *args, *kwargs]</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：初始化类实例</p>
<ul>
<li>类构造器中<code>__new__</code>返回类实例调用此方法初始化</li>
<li>若基类有用户定义<code>__init__</code>方法，则其派生类<code>__init__</code>
应该<strong>显式调用</strong>基类<code>__init__</code>保证基类部分正确初始化</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><code>self</code>：当前类实例</li>
<li>其余参数：类构造器表达式参数</li>
</ul>
</li>
<li><p>返回值：<code>None</code>，否则<code>raise TypeError</code></p>
</li>
</ul>
<h3 id="del"><a href="#del" class="headerlink" title="__del__"></a><code>__del__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__del__</span>(<span class="params">self</span>)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用途：实例销毁时（引用计数变为0）被调用<ul>
<li>若基类有<code>__del__</code>方法，则其派生类<code>__del__</code>方法中
需要<strong>显式调用</strong>基类<code>__del__</code>保证基类部分正确清除</li>
<li>对象重生：在其中创建该实例的新引用推迟其销毁<ul>
<li>不推荐</li>
<li>重生对象被销毁时<code>__del__</code>是否会被再次调用取决于
具体实现</li>
<li>当前CPython实现中只会调用一次</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><ul>
<li>解释器退出时不会确保为仍然存在的对象调用<code>__del__</code>方法</li>
<li>“钩子函数”：<code>del</code><ul>
<li><code>del x</code>不直接调用<code>x.__del__()</code></li>
<li><code>del x</code>仅将<code>x</code>的引用计数减一</li>
</ul>
</li>
</ul>
<h2 id="输出属性"><a href="#输出属性" class="headerlink" title="输出属性"></a>输出属性</h2><h3 id="repr"><a href="#repr" class="headerlink" title="__repr__"></a><code>__repr__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：输出对象的“官方”字符串表示</p>
<ul>
<li>如果可能，应类似有效的python表达式，可以用于重建具有
相同取值的对象（适当环境下）</li>
<li>若不可能，返回形如<code>&lt;...some useful description...&gt;</code>
的字符串</li>
<li>常用于调试，确保内容丰富、信息无歧义很重要</li>
</ul>
</li>
<li><p>返回值：字符对象</p>
<ul>
<li>内置钩子函数：<code>repr</code></li>
<li><strong>交互环境</strong>下直接“执行”变量的结果</li>
</ul>
</li>
</ul>
<h3 id="str"><a href="#str" class="headerlink" title="__str__"></a><code>__str__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：生成对象“非正式”、格式良好的字符串表示</p>
<ul>
<li>返回较方便、准确的描述信息</li>
</ul>
</li>
<li><p>返回值：字符串对象</p>
<ul>
<li>内置钩子函数：<code>str</code></li>
</ul>
</li>
</ul>
<h4 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h4><ul>
<li><p><code>object.__str__</code>方法默认实现调用<code>object.__repr__</code></p>
<ul>
<li>所以若未定义<code>__str__</code>，需要实例“非正式”字符串表示时
也会使用<code>__repr__</code></li>
</ul>
</li>
<li><p><code>format</code>、<code>print</code>函数会隐式调用对象<code>__str__</code>方法</p>
<ul>
<li>此时若<code>__str__</code>返回非字符串会<code>raise TypeError</code></li>
</ul>
</li>
</ul>
<h3 id="bytes"><a href="#bytes" class="headerlink" title="__bytes__"></a><code>__bytes__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__bytes__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：生成对象的字节串表示</p>
</li>
<li><p>返回值：<code>bytes</code>对象</p>
<ul>
<li>内置钩子函数：<code>bytes</code></li>
</ul>
</li>
</ul>
<h3 id="format"><a href="#format" class="headerlink" title="__format__"></a><code>__format__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__format__</span>(<span class="params">self, format_spec</span>)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：生成对象的“格式化”字符串表示</p>
<ul>
<li>内部常调用<code>format</code>、<code>str.format</code>实现格式化</li>
<li><code>object.__format__(x, &#39;&#39;)</code>等同于<code>str(x)</code></li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><code>fomrat_spec</code>：包含所需格式选项描述的字符串<ul>
<li>参数解读由实现<code>__format__</code>的类型决定</li>
<li>大多数类将格式化委托给内置类型、或使用相似格式化
语法</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：字符串对象</p>
<ul>
<li>内置钩子函数：<code>format</code></li>
</ul>
</li>
</ul>
<h3 id="hash"><a href="#hash" class="headerlink" title="__hash__"></a><code>__hash__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__hash__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：计算对象hash值返回</p>
<ul>
<li>相等的对象（即使类型不同）<strong>理应</strong>具有相同hash值</li>
<li>建议把参与比较的对象的全部组件的hash值打包为元组，
对元组做hash运算<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__hash__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">hash</span>((self.name, self.nick, self.color))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>返回值：整数</p>
<ul>
<li>内置钩子函数：<code>hash()</code></li>
</ul>
</li>
</ul>
<h4 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h4><ul>
<li><p><code>hash()</code>会从对象自定义的<code>__hash__()</code>方法返回值中截断为
<code>Py_ssize_t</code>大小</p>
<ul>
<li>64bits编译平台通常为8bytes、32bits为4bytes</li>
<li>若对象<code>__hash__()</code>需要在不同位大小的平台上互操作，
需要检查支持的平台位宽</li>
</ul>
<blockquote>
<ul>
<li>查看<code>sys.hash_info.width</code></li>
</ul>
</blockquote>
</li>
<li><p><code>set</code>、<code>frozenset</code>、<code>dict</code>这3个hash集类型中成员的操作
会调用相应<code>__hash__()</code></p>
</li>
<li><p>类的<code>__hash__</code>方法设置为<code>None</code>时</p>
<ul>
<li>尝试获取实例hash值时将<code>raise TypeError</code></li>
<li><code>isinstance(obj, collecitons.abc.Hashable)</code>返回
<code>False</code></li>
<li>单纯在<code>__hash__</code>中显式<code>raise TypeError</code>会被错误
认为是可hash</li>
</ul>
</li>
</ul>
<h4 id="关联-eq"><a href="#关联-eq" class="headerlink" title="关联__eq__"></a>关联<code>__eq__</code></h4><p>hash绝大部分应用场景是比较是否相等，所以<code>__hash__</code>、<code>__eq__</code>
密切相关</p>
<ul>
<li><p>类未定义<code>__eq__</code></p>
<ul>
<li>也不应该定义<code>__hash__</code>，单独hash结果无法保证比较结果</li>
</ul>
</li>
<li><p>类实现<code>__eq__</code></p>
<ul>
<li>未定义<code>__hash__</code>：其实例将不可被用作hash集类型的项</li>
<li>类中定义了可变对象：不应该实现<code>__hash__</code>，因为hash集
实现要求键hash值不可变</li>
</ul>
</li>
<li><p>类重载<code>__eq__</code>方法</p>
<ul>
<li>默认其<code>__hash__</code>被隐式设为<code>None</code></li>
<li>否则须设置<code>__has__ = &lt;ParentClass&gt;.__hash__</code>显式保留
来自父类<code>__hash__</code>实现</li>
</ul>
</li>
</ul>
<h4 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h4><ul>
<li><p><code>float</code>、<code>integer</code>、<code>decimal.Decimal</code>等数字类型hash运算
是基于为任意有理数定义的统一数学函数</p>
<blockquote>
<ul>
<li>详细参考<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#hashing-of-numeric-types">https://docs.python.org/zh-cn/3/library/stdtypes.html#hashing-of-numeric-types</a></li>
</ul>
</blockquote>
</li>
<li><p><code>str</code>、<code>bytes</code>、<code>datetime</code>对象<code>__hash__</code>值会使用不可预知
值<strong>随机加盐</strong></p>
<ul>
<li>盐在单独python进程中保持不变，但在重复执行的python
进程之间是不可预测的</li>
<li>目的是为了防止某种形式的DDos服务攻击</li>
</ul>
</li>
<li><p>改变hash值会影响集合迭代次序</p>
<ul>
<li>python也不保证次序不会改变</li>
</ul>
</li>
</ul>
<h3 id="bool"><a href="#bool" class="headerlink" title="__bool__"></a><code>__bool__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__bool__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：返回<code>True</code>、<code>False</code>实现真值检测</p>
<ul>
<li>未定义：调用<code>__len__</code>返回非0值时对象逻辑为真</li>
<li><code>__len__</code>、<code>__bool__</code>均未定义：所有实例逻辑为真</li>
</ul>
</li>
<li><p>返回值：<code>False</code>、<code>True</code></p>
<ul>
<li>内置构造函数：<code>bool()</code></li>
</ul>
</li>
</ul>
<h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">		self.x = x</span><br><span class="line">		self.y = y</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="comment"># 返回实例代码表示形式</span></span><br><span class="line">		<span class="comment"># 通常用于重新构造实例</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Pair(&#123;0.x!r&#125;, &#123;0.y!r&#125;)&quot;</span>.<span class="built_in">format</span>(self)</span><br><span class="line">			<span class="comment"># 格式化代码`!r`指明输出使用`__repr__`而不是默认</span></span><br><span class="line">				<span class="comment"># 的`__str___`</span></span><br><span class="line">			<span class="comment"># 格式化代码`0.x`表示第一个参数`x`属性</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;(&#123;0.x!s&#125;, &#123;0.y!s&#125;)&quot;</span>.<span class="built_in">format</span>(self)</span><br><span class="line">			<span class="comment"># 格式化代码`!s`指明使用默认`__str__`</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__format__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">if</span> self.x == <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">return</span> self.y</span><br><span class="line">		<span class="keyword">elif</span> self.y == <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">return</span> self.x</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&#123;0.x!r&#125;, &#123;0.y!r&#125;&quot;</span>.<span class="built_in">format</span>(self)</span><br></pre></td></tr></table></figure>
<h2 id="Rich-Comparison-Methods"><a href="#Rich-Comparison-Methods" class="headerlink" title="Rich Comparison Methods"></a><em>Rich Comparison Methods</em></h2><p>富比较方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__lt__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__le__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__eq__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__ne__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__gt__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__ge__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：比较运算符重载</p>
<ul>
<li><code>x &lt; y</code>：调用<code>x.__lt__(y)</code></li>
<li><code>x &lt;= y</code>：调用<code>x.__le__(y)</code></li>
<li><code>x == y</code>：调用<code>x.__eq__(y)</code></li>
<li><code>x != y</code>：调用<code>x.__ne__(y)</code></li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>成功比较返回<code>False</code>、<code>True</code></li>
<li>若指定方法没有相应实现，富比较方法会返回单例对象
<code>NotImplemented</code></li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>比较运算默认实现参见<em>cs_python/py3ref/expressions</em></li>
</ul>
</blockquote>
<h3 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h3><ul>
<li><p>默认情况下，<code>__ne__</code>会委托给<code>__eq__</code>，并将结果取反，除非
结果为<code>NotImplemented</code></p>
</li>
<li><p>比较运算符之间没有其他隐含关系</p>
<ul>
<li><code>x &lt; y or x == y</code>为真不意味着<code>x &lt;= y</code></li>
<li>要根据单个运算自动生成排序操作可以利用
<code>functools.total_ordering()</code>装饰器简化实现</li>
</ul>
</li>
<li><p>以上方法没有对调参数版本（左边参数不支持该操作，右边参数
支持该操作）</p>
<ul>
<li>若两个操作数类型不同、且右操作数是左操作数直接或间接
子类，优先选择右操作数的<strong>反射方法</strong>，否则左操作数
方法（不考虑虚拟子类）</li>
<li>反射方法<ul>
<li><code>__lt__</code>、<code>__gt__</code>互为反射</li>
<li><code>__le__</code>、<code>__ge__</code>互为反射</li>
<li><code>__eq__</code>、<code>__ne__</code>各为自身反射</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="内部信息"><a href="#内部信息" class="headerlink" title="内部信息"></a>内部信息</h2><h3 id="dict"><a href="#dict" class="headerlink" title="__dict__"></a><code>__dict__</code></h3><ul>
<li><p>钩子函数：<code>vars</code>、<code>dir</code>（部分）</p>
<ul>
<li><code>vars</code>是真正对应的钩子函数，返回键值对</li>
<li><code>dir</code>执行过程中会访问<code>__dict__</code>、<code>__class__</code>，而且
只返回keys</li>
</ul>
</li>
<li><p><strong>对象</strong>底层字典，存储对象属性、方法</p>
<ul>
<li>注意区分开：实例属性、类属性、基类属性，<code>__dict__</code>
只包括<strong>当前实例</strong>属性、方法</li>
<li>返回结果是<code>dir</code>结果的子集</li>
</ul>
</li>
<li><p>调用实例<code>obj</code>的属性时，按照以下顺序查找</p>
<ul>
<li><code>obj.__dict__</code>：当前实例的<code>__dict__</code>中</li>
<li><code>type(obj).__dict__</code>：实例所属类的<code>__dict__</code>中</li>
<li><code>type(obj).mro().__dict__</code>：基类的<code>__dict__</code>中</li>
</ul>
</li>
<li><p>在大部分情况下<code>__dict__</code>会自动更新，如<code>setattr</code>函数时，
或说实例的属性、方法更新就是<code>__dict__</code>的变动</p>
<ul>
<li><p>一般情况下不要直接访问<code>__dict__</code>，除非真的清楚所有
细节，如果类使用了<code>cls.__slots__</code>、<code>@property</code>、
描述器类等高级技术时代码可能会被破坏</p>
</li>
<li><p>尽量使用<code>setattr</code>函数，让python控制其更新</p>
</li>
</ul>
</li>
</ul>
<h3 id="class"><a href="#class" class="headerlink" title="__class__"></a><code>__class__</code></h3><ul>
<li><p>用途：返回实例所属类</p>
</li>
<li><p>返回值：实例（狭义）返回类、类返回元类</p>
<ul>
<li>钩子函数：<code>type</code></li>
</ul>
</li>
</ul>
<h3 id="objclass"><a href="#objclass" class="headerlink" title="__objclass__"></a><code>__objclass__</code></h3><ul>
<li>用途：被<code>inspect</code>模块解读为<strong>指定实例所在的类</strong><ul>
<li>合适的设置可以有助于动态类属性的运行时检查</li>
<li>对于可调用对象：指明第一个位置参数应为特定类型的
实例、子类<ul>
<li>描述器类：<code>instance</code>参数<h1 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h1></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="slots"><a href="#slots" class="headerlink" title="__slots__"></a><code>__slots__</code></h3><ul>
<li><p>用途：显式声明数据成员、特征属性，限制实例添加属性</p>
<ul>
<li><p>可赋值为：字符串、可迭代对象、实例使用的变量名构成的
字符串序列</p>
<ul>
<li>可迭代对象中元素可以是任何类型</li>
<li>还可以映射类型，未来可能会分别赋给每个键特殊含义
的值</li>
</ul>
</li>
<li><p><code>__slots__</code>会为已声明变量保留空间</p>
<ul>
<li>直接访问将<code>raise AttributeError</code></li>
<li><code>dir</code>可以找到<code>__slots__</code>中声明的变量</li>
</ul>
</li>
</ul>
</li>
<li><p>阻止默认为每个实例创建<code>__dict__</code>、<code>__weakref__</code>的
行为，除非在<code>__slots__</code>中显式声明、或在父类中可用</p>
<ul>
<li><p>无<code>__dict__</code>属性实例无法给未在<code>__slots__</code>中列出
的新变量赋值</p>
<ul>
<li>但是python很多特性依赖于普通的依赖字典实现，定义
<code>__slots__</code>的类不再支持普通类某些特性</li>
<li>大多数情况下，应该只在经常使用到作为数据结构的
类上定义<code>__slots__</code></li>
<li>不应该把<code>__slots__</code>作为防止用户给实例增加新属性
的封装工具</li>
</ul>
</li>
<li><p>无<code>__weakref__</code>属性实例不支持对实例的弱引用</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>是阻止给实例创建<code>__dict__</code>，类本身仍然有<code>__dict__</code>属性
  （<code>dir</code>返回值中无<code>__dict__</code>，<code>__dir__</code>返回值中有）</li>
</ul>
</blockquote>
<h4 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h4><ul>
<li><p><code>__slots__</code>声明的行为不只限于定义其的类</p>
<ul>
<li><p>父类中声明<code>__slots__</code>可以在子类中使用，但子类将获得
<code>__dict__</code>、<code>__weakref__</code>，除非其也定义了<code>__slots__</code></p>
</li>
<li><p>子类<code>__slots__</code>中定义的slot将覆盖父类中同名slot</p>
<ul>
<li>需要直接从基类直接获取描述器才能访问</li>
<li>这会导致程序未定义，以后增加检查避免</li>
</ul>
</li>
<li><p>多重继承中只允许一个父类具有非空<code>__slots__</code>，否则
<code>raise TypeError</code></p>
</li>
</ul>
</li>
<li><p><code>__slots__</code>是在类层次上的实现：为每个变量创建描述器</p>
<ul>
<li>类属性不能被用于给在<code>__slots__</code>中定义变量设置默认值</li>
<li>否则类属性会覆盖描述器赋值，变成只读属性</li>
</ul>
</li>
<li><p>非空的<code>__slots__</code>不适用于派生自“可变长度”内置类型，如
<code>int</code>、<code>bytes</code>、<code>tuple</code></p>
</li>
<li><p>定义类属性<code>__slots__</code>后，python会为实例属性使用紧凑内部
表示</p>
<ul>
<li>实例属性使用固定大小、很小的数组构建，而不是为每个
实例定义字典</li>
<li>在<code>__slots__</code>列出的属性名在内部映射到数组指定下标上</li>
<li>类似于R中<code>factor</code>类型、C中<code>enum</code>类型</li>
<li>相比<code>__dict__</code>可以显著节省空间、提升属性查找速度</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>:</span></span><br><span class="line">	__slots__ = [<span class="string">&quot;year&quot;</span>, <span class="string">&quot;month&quot;</span>, <span class="string">&quot;day&quot;</span>]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, year, month, day</span>):</span></span><br><span class="line">		self.year = year</span><br><span class="line">		self.month = month</span><br><span class="line">		self.day = day</span><br></pre></td></tr></table></figure>
<ul>
<li><p>继承自未定义<code>__slots__</code>类时，实例中<code>__dict__</code>、
<code>__weakref__</code>属性将总是可访问的</p>
</li>
<li><p><code>__class__</code>赋值仅在两个类具有相同<code>__slots__</code>值时才有用</p>
</li>
</ul>
<h2 id="自定义属性访问"><a href="#自定义属性访问" class="headerlink" title="自定义属性访问"></a>自定义属性访问</h2><h3 id="getattr"><a href="#getattr" class="headerlink" title="__getattr__"></a><code>__getattr__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__getattr__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：<code>.</code>默认属性访问引发<code>AttributeError</code>而失败时调用</p>
<ul>
<li>如果属性通过正常机制找到，<code>__getattr__</code>不会被调用<ul>
<li>在<code>__getattr__</code>、<code>__setattr__</code>之间故意设置的
不对称性</li>
<li>出于效率考虑</li>
</ul>
</li>
<li>对实例变量而言，无需在实例属性字典中插入值，就可以
模拟对其的完全控制</li>
</ul>
</li>
<li><p>返回值：计算后的属性值、或<code>raise AttributeError</code></p>
</li>
</ul>
<h4 id="说明-6"><a href="#说明-6" class="headerlink" title="说明"></a>说明</h4><ul>
<li><p>可能引发<code>AttributeError</code></p>
<ul>
<li>调用<code>__getattribute__</code>时因为<code>name</code>不是实例属性、
或是类关系树中属性</li>
<li>对调用<code>__get__</code>获取<code>name</code>描述器</li>
</ul>
</li>
<li><p>调用<code>__getattr__</code>是<code>.</code>运算符中逻辑</p>
<ul>
<li><code>__getattribute__</code>显式调用<code>raise AtttributeError</code>
不会调用<code>__getattr__</code></li>
</ul>
</li>
<li><p><code>__getattr__</code>甚至不是<code>object</code>具有的
<code>&lt;wrapper_descriptor&gt;</code></p>
</li>
<li><p>相较于<code>__getattribute__</code>其实更常用，因为修改<strong>所有</strong>对
对对象的访问逻辑没啥价值</p>
</li>
</ul>
<h3 id="getattribute"><a href="#getattribute" class="headerlink" title="__getattribute__"></a><code>__getattribute__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">	<span class="string">&quot;Emulate type_getattro() in Objects/typeobject.c&quot;</span></span><br><span class="line">	v = <span class="built_in">object</span>.__getattribute__(self, key)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">hasattr</span>(v, <span class="string">&quot;__get__&quot;</span>):</span><br><span class="line">		<span class="keyword">return</span> v.__get__(<span class="literal">None</span>, self)</span><br><span class="line">	<span class="keyword">return</span> v</span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：访问对象属性时无条件被调用</p>
<ul>
<li><strong>判断访问属性类型、做对应操作</strong><ul>
<li>描述器：调用描述器方法</li>
<li>实例方法：为类中函数绑定实例</li>
<li>类方法：为类中函数绑定类</li>
<li>静态方法：不绑定</li>
<li>普通属性</li>
</ul>
</li>
<li>作为<strong>通过特定语法、内置函数隐式调用的结果</strong>情况下，
查找特殊方法时仍可能被跳过</li>
</ul>
</li>
<li><p>返回值：找到的属性值、或<code>raise AttributeError</code></p>
</li>
</ul>
<blockquote>
<ul>
<li><code>__getattribute__</code>仅对继承自<code>object</code>的新式类实例可用</li>
</ul>
</blockquote>
<h4 id="说明-7"><a href="#说明-7" class="headerlink" title="说明"></a>说明</h4><ul>
<li><p>内置类型均有各自<code>__getattribute__</code>函数实例</p>
<ul>
<li>其均为<code>wrapper_descriptor</code>类型（C实现的函数）</li>
<li>各函数实例标识符不同，若其均“继承自<code>object</code>”，其
应为同一个函数实例</li>
<li>自定义类真继承自<code>object</code>类，其<code>__getattribute__</code>同
<code>object.__getattribute__</code></li>
</ul>
</li>
<li><p>自定义实现</p>
<ul>
<li>为<strong>避免方法中无限递归</strong>，实现总应该调用具有相同名称
基类方法访问所需要的属性</li>
</ul>
</li>
</ul>
<h4 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h4><ul>
<li><p><code>.</code>运算符：首先调用<code>__getattribute__</code>，若无访问结果，
调用<code>__getattr__</code></p>
<blockquote>
<ul>
<li><code>.</code>运算符说明参见<em>cs_python/py3ref/cls_basics</em></li>
</ul>
</blockquote>
</li>
<li><p><code>getattr</code>：基本同<code>.</code>运算符，除可捕获异常，设置默认返回值</p>
</li>
<li><p><code>hasattr</code>：内部调用<code>getattr</code>，根据<code>raise Exception</code>判断
属性是否存在</p>
<ul>
<li>可以通过<code>@property.getter</code>中<code>raise AttributeError</code>
使得属性看起来不存在</li>
<li>内部有更多<code>boilerplate</code>相较于<code>getattr</code>更慢</li>
<li>则按照字面意思使用不需要考虑过多</li>
</ul>
</li>
</ul>
<h3 id="setattr"><a href="#setattr" class="headerlink" title="__setattr__"></a><code>__setattr__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__setattr__</span>(<span class="params">self, name, value</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：<strong>属性被尝试赋值时被调用</strong></p>
<ul>
<li>默认实现：将值保存到实例字典</li>
<li>若<code>__setattr__</code>要赋值给实例属性，应该调用同名基类
方法</li>
</ul>
</li>
<li><p>返回指：<code>None</code></p>
<ul>
<li>钩子函数：<code>setattr</code></li>
</ul>
</li>
</ul>
<h3 id="delattr"><a href="#delattr" class="headerlink" title="__delattr__"></a><code>__delattr__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__delattr__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：<strong>删除实例属性时被调用</strong></p>
<ul>
<li>默认实现：从实例字典中删除对应项</li>
<li>应该在<code>del obj.name</code>对该对象有意义时才实现</li>
</ul>
</li>
<li><p>返回值：<code>None</code></p>
<ul>
<li>内置钩子函数：<code>delattr</code>、<code>del</code></li>
</ul>
</li>
</ul>
<h3 id="dir"><a href="#dir" class="headerlink" title="__dir__"></a><code>__dir__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__dir__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：返回实例中“可访问”名称的字符串列表</p>
<ul>
<li>默认实现：返回实例、类、祖先类所有属性</li>
<li>交互式解释器就是在<code>__dir__</code>/<code>dir</code>返回列表中进行查询
进行补全</li>
</ul>
</li>
<li><p>返回值：序列</p>
<ul>
<li>内置钩子函数：<code>dir</code><ul>
<li><code>dir()</code>获取<code>__dir__</code>返回序列，转换为列表、排序</li>
<li><code>dir()</code>会剔除<code>__dir__</code>返回值中部分值</li>
<li>若<code>__dir__</code>返回值不可迭代，报错</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="自定义模块属性访问"><a href="#自定义模块属性访问" class="headerlink" title="自定义模块属性访问"></a>自定义模块属性访问</h3><ul>
<li><p><code>__getattr__</code>、<code>__dir__</code>可以用于自定义对模块属性的访问</p>
<ul>
<li>模块层次<code>__getattr__</code>类似普通类<ul>
<li>接受属性名作为参数</li>
<li>返回计算后结果、或<code>raise AttributeError</code></li>
<li>若正常查找<code>__getattribute__</code>无法在模块中找到某个
属性，调用<code>__getattr__</code></li>
</ul>
</li>
<li>模块层次<code>__dir__</code>类似普通类<ul>
<li>不接受参数</li>
<li>返回模块中可访问名称的字符串列表</li>
</ul>
</li>
</ul>
</li>
<li><p>可以将模块的<code>__class__</code>属性设置为<code>types.ModuleType</code>子类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> types <span class="keyword">import</span> ModuleType</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VersboseModule</span>(<span class="params">ModuleType</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">f&quot;verbose <span class="subst">&#123;self.__name__&#125;</span>&quot;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span>(<span class="params">self, attr, value</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">f&quot;settting <span class="subst">&#123;attr&#125;</span>&quot;</span>)</span><br><span class="line">		<span class="built_in">super</span>().__setattr__(attr, value)</span><br><span class="line"></span><br><span class="line">sys.modules[__name__].__class__ = VerboseModule</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<ul>
<li>设置模块<code>__getattr__</code>、<code>__class__</code>只影响使用<strong>属性访问</strong>
  语法进行查找，直接访问模块全局变量（通过模块内代码、对
  模块全局字典引用）不受影响</li>
</ul>
</blockquote>
<h2 id="描述器类"><a href="#描述器类" class="headerlink" title="描述器类"></a>描述器类</h2><p>描述器：<strong>具有“绑定行为”</strong>的对象属性</p>
<ul>
<li><p>类中定义其中任意一个方法，则其实例被称为描述器</p>
<ul>
<li><code>__set__</code></li>
<li><code>__get__</code></li>
<li><code>__delete__</code></li>
</ul>
</li>
<li><p>所有对描述器属性的访问会被<code>__get__</code>、<code>__set__</code>、
<code>__delete__</code>方法捕获/重载</p>
<ul>
<li>如果只是想简单的自定义某个类的属性处理逻辑，使用
<code>@porperty</code>装饰器简化实现</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><code>@property</code>参见<em>cs_python/py3ref/cls_basics</em></li>
</ul>
</blockquote>
<h3 id="描述器协议"><a href="#描述器协议" class="headerlink" title="描述器协议"></a>描述器协议</h3><ul>
<li>以下方法仅包含其的类的实例出现在类属性中才有效<ul>
<li>即以下方法必须在（祖先）类<code>__dict__</code>中出现，而不是
实例<code>__dict__</code>中</li>
<li>即描述器只能定义为类属性，不能定义为实例属性</li>
</ul>
</li>
</ul>
<h4 id="get"><a href="#get" class="headerlink" title="__get__"></a><code>__get__</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__get__</span>(<span class="params">self, instance, owner=<span class="literal">None</span></span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：访问描述器属性时调用，重载实例属性访问</p>
<ul>
<li>若描述器未定义<code>__get__</code>，则访问属性会返回描述器对象
自身，除非实例字典<code>__dict__</code>中有同名属性</li>
<li>若仅仅只是从底层实例字典中获取属性值，<code>__get__</code>方法
不用实现</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><code>instance</code>：用于方法属性的实例</li>
<li><code>owner</code>：实例所属类，若通过类获取属性则为<code>None</code></li>
</ul>
</li>
<li><p>返回值：计算后属性值、或<code>raise AttributeError</code></p>
</li>
<li><p>示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, cls</span>):</span></span><br><span class="line">	<span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">		<span class="comment"># 装饰器类一般作为类属性，需要考虑通过类直接访问</span></span><br><span class="line">			<span class="comment"># 描述器类属性，此时`instance is None`</span></span><br><span class="line">		<span class="comment"># 常用操作是返回当前实例</span></span><br><span class="line">		<span class="keyword">return</span> self</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> instance.__dict__[self.name]</span><br><span class="line"></span><br><span class="line">	<span class="comment"># self：描述器类当前实例</span></span><br><span class="line">	<span class="comment"># instance：定义描述器作为类属性的类的实例</span></span><br><span class="line">	<span class="comment"># cls：定义描述器作为类属性的类</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="set"><a href="#set" class="headerlink" title="__set__"></a><code>__set__</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__set__</span>(<span class="params">self, instance, name, value</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：设置实例<code>instance</code>的“描述器属性”值为<code>value</code>，重载
实例属性赋值</p>
<ul>
<li>常用实现：操作实例<code>instance.__dict__</code>存储值，使得
看起来是设置普通实例属性</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, name, value</span>):</span></span><br><span class="line">	<span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> instance(value, <span class="built_in">int</span>):</span><br><span class="line">			<span class="keyword">raise</span> TypeError(<span class="string">&quot;expect an int&quot;</span>)</span><br><span class="line">		instance.__dict__[self.name] = value</span><br><span class="line">		<span class="comment"># 操作实例底层`__dict__`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># `value`：赋给描述器类属性的值</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="delete"><a href="#delete" class="headerlink" title="__delete__"></a><code>__delete__</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__delete__</span>(<span class="params">self, instance</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用于：“删除”实例<code>instance</code>的“描述器属性”，重载实例属性
删除</p>
<ul>
<li>具体实现应取决于<code>__set__</code>实现</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self, instance</span>):</span></span><br><span class="line">	<span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">del</span> instance.__dict__[self.name]</span><br><span class="line">		<span class="comment"># 操作实例底层`__dict__`</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="set-name"><a href="#set-name" class="headerlink" title="__set_name__"></a><code>__set_name__</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__set_name__</span>(<span class="params">self, owner, name</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用途：类<code>owner</code>被创建时调用，描述器被赋给<code>name</code></li>
</ul>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul>
<li><p>描述器的实现依赖于<code>object.__getattribute__()</code>方法</p>
<ul>
<li>可以通过重写类的<code>__getattribute__</code>方法改变、关闭
描述器行为</li>
</ul>
</li>
<li><p>描述器调用：描述器<code>x</code>定义在类<code>A</code>中、<code>a = A()</code></p>
<ul>
<li>直接调用：<code>x.__get__(a)</code></li>
<li>实例绑定：<code>a.x</code><ul>
<li>转换为：<code>type(a).__dict__[&#39;x&#39;].__get__(a)</code></li>
</ul>
</li>
<li>类绑定：<code>A.x</code><ul>
<li>转换为：<code>A.__dict__[&#39;x&#39;].__get__(None,A)</code></li>
</ul>
</li>
<li>超绑定：<code>super(a, A).x</code><ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="实例绑定—资料描述器"><a href="#实例绑定—资料描述器" class="headerlink" title="实例绑定—资料描述器"></a>实例绑定—资料描述器</h4><blockquote>
<ul>
<li>资料描述器：定义了<code>__set__</code>、<code>__delete__</code>方法</li>
<li>非资料描述器：只定义了<code>__get__</code>方法</li>
</ul>
</blockquote>
<ul>
<li><p>访问对象属性时，描述器调用的<strong>优先级</strong>取决于描述器定义的方法</p>
<ul>
<li>优先级：资料描述器 &gt; 实例字典属性 &gt; 非资料描述器</li>
<li>实例属性会重载非资料描述器</li>
<li>实例属性和资料描述器同名时，优先访问描述器，否则优先
访问属性</li>
</ul>
</li>
<li><p>只读资料描述器：<code>__set__</code>中<code>raise AttributeError</code>得到</p>
</li>
</ul>
<h4 id="描述器调用"><a href="#描述器调用" class="headerlink" title="描述器调用"></a>描述器调用</h4><h1 id="todo-1"><a href="#todo-1" class="headerlink" title="todo"></a>todo</h1><h4 id="Python设计"><a href="#Python设计" class="headerlink" title="Python设计"></a>Python设计</h4><ul>
<li><p><code>function</code>类中定义有<code>__get__</code>方法，则其实例（即函数）
都为非资料描述器</p>
<ul>
<li>所以实例可以覆盖、重载方法</li>
<li><code>__getattribute__</code>会根据不同方法类型选择绑定对象<ul>
<li><code>staticmethod</code>：静态方法</li>
<li><code>classmethod</code>：类方法</li>
<li>实例方法</li>
</ul>
</li>
</ul>
</li>
<li><p><code>super</code>类中定义有<code>__get__</code>方法，则其实例也为描述器</p>
</li>
<li><p><code>@property</code>方法被实现为资料描述器</p>
</li>
</ul>
<h3 id="特殊描述器类"><a href="#特殊描述器类" class="headerlink" title="特殊描述器类"></a>特殊描述器类</h3><h1 id="todo-2"><a href="#todo-2" class="headerlink" title="todo"></a>todo</h1><ul>
<li><p><code>wrapper_descripter</code>：<code>&lt;slot wrapper&gt;</code>，封装C实现的函数</p>
<ul>
<li>等价于CPython3中函数</li>
<li>调用<code>__get__</code>绑定后得到<code>&lt;method-wrapper&gt;</code></li>
<li><code>object</code>的方法全是<code>&lt;slot wrapper&gt;</code></li>
</ul>
</li>
<li><p><code>method-wrapper</code>：<code>&lt;method-wrapper&gt;</code>，封装C实现的绑定方法</p>
<ul>
<li>等价于CPython3中绑定方法</li>
</ul>
</li>
</ul>
<h4 id="function描述器类"><a href="#function描述器类" class="headerlink" title="function描述器类"></a><code>function</code>描述器类</h4><p><code>function</code>描述器类：实例化即得到函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">function</span>:</span></span><br><span class="line">	function(code, <span class="built_in">globals</span>[, name[, argdefs[, closure]]])</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, /, *args, **kwargs</span>):</span></span><br><span class="line">		<span class="comment"># 作为一个函数调用自身</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, owner, /</span>):</span></span><br><span class="line">		<span class="comment"># 返回`owner`类型实例`instance`的属性</span></span><br><span class="line">		<span class="comment"># 即返回绑定方法</span></span><br></pre></td></tr></table></figure>
<h4 id="method描述器类"><a href="#method描述器类" class="headerlink" title="method描述器类"></a><code>method</code>描述器类</h4><p><code>method</code>描述器类：实例化即得到<em>(bound )method</em>，绑定方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">method</span>:</span></span><br><span class="line">	method(function, instance)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, /, *args, **kwargs</span>):</span></span><br><span class="line">		<span class="comment"># 作为函数调用自身</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, owner, /</span>):</span></span><br><span class="line">		<span class="comment"># 返回自身</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><em>(bound )method</em>：绑定方法，（首个参数）绑定为具体实例
  的函数，即实例属性</li>
</ul>
</blockquote>
<h4 id="XXmethod描述类"><a href="#XXmethod描述类" class="headerlink" title="XXmethod描述类"></a><code>XXmethod</code>描述类</h4><blockquote>
<ul>
<li>代码是C实现，这里是python模拟，和<code>help</code>结果不同</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classmethod</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, method</span>):</span></span><br><span class="line">		self.method = method</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, obj, cls</span>):</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">lambda</span> *args, **kw: self.method(cls,*args,**kw)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">staticmethod</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, <span class="built_in">callable</span></span>):</span></span><br><span class="line">		self.f = <span class="built_in">callable</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, obj, cls=<span class="literal">None</span></span>):</span></span><br><span class="line">		<span class="keyword">return</span> self.f</span><br><span class="line"><span class="meta">	@property</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__func__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> self.f</span><br></pre></td></tr></table></figure>
<ul>
<li><p>类中静态方法、类方法就是以上类型的描述器</p>
<ul>
<li>静态方法：不自动传入第一个参数</li>
<li>类方法：默认传递类作为第一个参数</li>
<li>描述器用途就是避免默认传入实例为第一个参数的行为</li>
</ul>
</li>
<li><p>静态方法、类方法均是非资料描述器，所以和实例属性重名时
会被覆盖</p>
</li>
<li><p>所以类静态方法、类方法不能直接通过<code>__dict__</code>获取、调用，
需要调用<code>__get__</code>方法返回绑定方法才能调用</p>
<ul>
<li>直接访问属性则由<code>__getattribute__</code>方法代劳</li>
</ul>
</li>
</ul>
<h3 id="例-1"><a href="#例-1" class="headerlink" title="例"></a>例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span>:</span></span><br><span class="line">	<span class="comment"># 描述器类</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">		self.name = name</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, cls</span>):</span></span><br><span class="line">		<span class="comment"># 描述器的每个方法会接受一个操作实例`instance`</span></span><br><span class="line">		<span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">			<span class="comment"># 描述器只能定义为类属性，在这里处理直接使用类</span></span><br><span class="line">				<span class="comment"># 访问描述器类的逻辑</span></span><br><span class="line">			<span class="keyword">return</span> self</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">return</span> instance.__dict__(self.name)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> instance(value, <span class="built_in">int</span>):</span><br><span class="line">			rasie TypeError(<span class="string">&quot;expect an int&quot;</span>)</span><br><span class="line">		instance.__dict__[self.name] = value</span><br><span class="line">			<span class="comment"># 描述器方法会操作实例底层`__dict__`属性</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self, instance</span>):</span></span><br><span class="line">		<span class="keyword">del</span> instance.__dict__[self.name]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">	x = Integer(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">	y = Integer(<span class="string">&quot;y&quot;</span>)</span><br><span class="line">		<span class="comment"># 需要将描述器的实例作为类属性放在类的定义中使用</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">		self.x = x</span><br><span class="line">		self.y = y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">	p = Point(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">	<span class="built_in">print</span>(p.x)</span><br><span class="line">		<span class="comment"># 调用`Point.x.__get__(p, Point)`</span></span><br><span class="line">	<span class="built_in">print</span>(Point.x)</span><br><span class="line">		<span class="comment"># 调用`Point.x.__get__(None, Point)`</span></span><br><span class="line">	p.y = <span class="number">5</span></span><br><span class="line">		<span class="comment"># 调用`Point.y.__set__(p, 5)`</span></span><br></pre></td></tr></table></figure>
<h2 id="自定义类创建"><a href="#自定义类创建" class="headerlink" title="自定义类创建"></a>自定义类创建</h2><h3 id="init-subclass"><a href="#init-subclass" class="headerlink" title="__init_subclass__"></a><code>__init_subclass__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">classmethod</span> <span class="built_in">object</span>.__init_subclass__(cls):</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用途：派生类继承父类时，基类的<code>__init_subclas__</code>被调用<ul>
<li>可以用于编写能够改变子类行为的类</li>
<li>类似类装饰器，但是类装饰其影响其应用的类，而
<code>__init_subclass__</code>影响基类所有派生子类</li>
<li>默认实现：无行为、只有一个参数<code>cls</code></li>
<li>方法默认、隐式为类方法，不需要<code>classmethod</code>封装</li>
</ul>
</li>
</ul>
<ul>
<li><p>参数</p>
<ul>
<li><code>cls</code>：指向新的子类</li>
<li>默认实现无参数，可以覆盖为自定义参数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init_subclass__</span>(<span class="params">self, default_name, **kwargs</span>):</span></span><br><span class="line">		<span class="built_in">super</span>().__init_subclass__(**kwrags)</span><br><span class="line">		cls.default_name = default_name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AstraliaPhilosopher</span>(<span class="params">Philosopher, default_name=<span class="string">&quot;Bruce&quot;</span></span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定义派生类时需要注意传递参数</li>
<li>元类参数<code>metaclass</code>会被其他类型机制消耗，不会被传递
给<code>__init_subclass__</code></li>
</ul>
</li>
</ul>
<h3 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h3><ul>
<li><p>默认情况下，类使用<code>type</code>构建</p>
<ul>
<li>类体在新的命名空间中执行，类名被局部绑定到
元类创建结果<code>type(name, bases, namespace)</code></li>
</ul>
</li>
<li><p>可在类定义部分传递<code>metaclass</code>关键字参数，自定义类创建
过程</p>
<ul>
<li>类继承同样继承父类元类参数</li>
<li>其他类定义过程中的其他关键字参数会在以下元类操作中
进行传递<ul>
<li>解析MRO条目</li>
<li>确定适当元类</li>
<li>准备类命名空间<code>__prepare__</code></li>
<li>执行类主体</li>
<li>创建类对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="解释MRO条目"><a href="#解释MRO条目" class="headerlink" title="解释MRO条目"></a>解释MRO条目</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def type.__mro_entries__():</span><br><span class="line">	pass</span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：若类定义中基类不是<code>type</code>的实例，则使用此方法对
基类进行搜索</p>
<ul>
<li>找到结果时，以原始基类元组作为参数进行调用</li>
</ul>
</li>
<li><p>返回值：类的元组替代基类被使用</p>
<ul>
<li>元组可以为空，此时原始基类将被忽略</li>
</ul>
</li>
</ul>
<h4 id="元类确定"><a href="#元类确定" class="headerlink" title="元类确定"></a>元类确定</h4><ul>
<li>若没有显式给出基类、或元类，使用<code>type()</code></li>
<li>若显式给出的元类不是<code>type()</code>的实例，直接用其作为元类</li>
<li>若显式给出<code>type()</code>实例作为元类、或定义有基类，则选取
“最派生”元类<ul>
<li>最派生元类从显式指定的元类、基类中元类中选取</li>
<li>最派生元类应为所有候选元类的子类型</li>
<li>若没有满足条件的候选元类则<code>raise TypeError</code></li>
</ul>
</li>
</ul>
<h4 id="准备类命名空间"><a href="#准备类命名空间" class="headerlink" title="准备类命名空间"></a>准备类命名空间</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">type</span>.<span class="title">__prepare__</span>(<span class="params">name, bases, **kwds</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：确定合适的元类之后，准备类命名空间</p>
<ul>
<li>若元类没有<code>__prepare__</code>属性，类命名空间将被初始化为
空<code>ordered mapping</code></li>
</ul>
</li>
<li><p>参数：来自于类定义中的关键字参数</p>
</li>
</ul>
<h4 id="执行类定义主体"><a href="#执行类定义主体" class="headerlink" title="执行类定义主体"></a>执行类定义主体</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span>(body, <span class="built_in">globals</span>(), namespace)</span><br><span class="line">	<span class="comment"># 执行类主体类似于</span></span><br></pre></td></tr></table></figure>
<ul>
<li>普通调用和<code>exec()</code>区别<ul>
<li>类定义在函数内部时<ul>
<li>词法作用域允许类主体、方法引用来自当前、外部
作用域名称</li>
<li>但内部方法仍然无法看到在类作用域层次上名称</li>
<li>类变量必须通过实例的第一个形参、类方法方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="创建类对象"><a href="#创建类对象" class="headerlink" title="创建类对象"></a>创建类对象</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">metaclass(name, base, namespace, **kwds):</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：执行类主体填充类命名空间后，将通过调用
<code>metaclass(name, base, namespace, **kwds)</code>创建类对象</p>
</li>
<li><p>参数：来自类定义中的关键字参数</p>
</li>
</ul>
<h5 id="说明-8"><a href="#说明-8" class="headerlink" title="说明"></a>说明</h5><ul>
<li><p>若类主体中有方法中引用<code>__class__</code>、<code>super</code>，则<code>__class__</code>
将被编译器创建为隐式闭包引用</p>
<ul>
<li>这使得无参数调用<code>super</code>可以能基于词法作用域正确
定位类</li>
<li>而被用于进行当前调用的类、实例则是基于传递给方法
的第一个参数来标识</li>
</ul>
</li>
</ul>
<h2 id="自定义实例、子类检查"><a href="#自定义实例、子类检查" class="headerlink" title="自定义实例、子类检查"></a>自定义实例、子类检查</h2><ul>
<li><p>以下方法应该的定义在元类中，不能在类中定义为类方法</p>
<ul>
<li>类似于实例从类中查找方法</li>
</ul>
</li>
<li><p>元类<code>abc.ABCMeta</code>实现了以下方法以便允许将抽象基类<code>ABC</code>
作为“虚拟基类”添加到任何类、类型（包括内置类型）中</p>
</li>
</ul>
<h3 id="instancecheck"><a href="#instancecheck" class="headerlink" title="__instancecheck__"></a><code>__instancecheck__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">class</span>.<span class="title">__instancecheck__</span>(<span class="params">self, instance</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：若<code>instance</code>被视为<code>class</code>直接、间接实例则返回真值</p>
<ul>
<li>重载<code>instance</code>内置函数行为</li>
</ul>
</li>
<li><p>返回：布尔值</p>
<ul>
<li>内置钩子函数：<code>isintance(instance, class)</code></li>
</ul>
</li>
</ul>
<h3 id="subclasscheck"><a href="#subclasscheck" class="headerlink" title="__subclasscheck__"></a><code>__subclasscheck__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>.__subclasscheck__(self, subclass):</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：若<code>subclass</code>被视为<code>class</code>的直接、间解子类则返回
真值</p>
<ul>
<li>重载<code>issubclass</code>内置函数行为</li>
</ul>
</li>
<li><p>返回：布尔值</p>
<ul>
<li>内置钩子函数：<code>issubclass(subclass, class)</code></li>
</ul>
</li>
</ul>
<h2 id="模拟范型类型"><a href="#模拟范型类型" class="headerlink" title="模拟范型类型"></a>模拟范型类型</h2><h3 id="class-getitem"><a href="#class-getitem" class="headerlink" title="__class_getitem__"></a><code>__class_getitem__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">classmethod</span> <span class="built_in">object</span>.__class_getitem__(cls, key):</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：按照<code>key</code>指定类型返回表示泛型类的专门化对象</p>
<ul>
<li>实现<em>PEP 484</em>规定的泛型类语法</li>
<li>查找基于对象自身</li>
<li>主要被保留用于静态类型提示，不鼓励其他尝试使用</li>
<li>方法默认、隐式为类方法，不需要<code>classmethod</code>封装</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><code>cls</code>：当前类</li>
<li><code>key</code>：类型</li>
</ul>
</li>
</ul>
<h2 id="模拟可调用对象"><a href="#模拟可调用对象" class="headerlink" title="模拟可调用对象"></a>模拟可调用对象</h2><h3 id="call"><a href="#call" class="headerlink" title="__call__"></a><code>__call__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__call__</span>(<span class="params">self[,args...]</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用途：实例作为函数被调用时被调用<ul>
<li>若定义此方法<code>x(arg1, arg2, ...)</code>等价于
<code>x.__call__(arg1, args2, ...)</code></li>
</ul>
</li>
</ul>
<h2 id="模拟容器类型"><a href="#模拟容器类型" class="headerlink" title="模拟容器类型"></a>模拟容器类型</h2><ul>
<li><code>collections.abc.MutableMapping</code>为抽象基类<ul>
<li>其实现基本方法集<code>__getitem__</code>、<code>__setitem__</code>、
<code>__delitem__</code>、<code>keys()</code></li>
<li>可以方法继承、扩展、实现自定义映射类</li>
</ul>
</li>
</ul>
<h3 id="len"><a href="#len" class="headerlink" title="__len__"></a><code>__len__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：计算、返回实例长度</p>
<ul>
<li>若对象未定义<code>__bool__</code>，以<code>__len__</code>是否返回非0作为
布尔运算结果</li>
</ul>
</li>
<li><p>返回值：非负整形</p>
<ul>
<li>钩子函数：<code>len()</code></li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>CPython：要求长度最大为<code>sys.maxsize</code>，否则某些特征可能
  会<code>raise OverflowError</code></li>
</ul>
</blockquote>
<h3 id="length-hint"><a href="#length-hint" class="headerlink" title="__length_hint__"></a><code>__length_hint__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__length_hist__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：返回对象长度<strong>估计值</strong></p>
<ul>
<li>存粹为优化性能，不要求正确无误</li>
</ul>
</li>
<li><p>返回值：非负整形</p>
<ul>
<li>钩子函数：<code>operator.length_hint()</code></li>
</ul>
</li>
</ul>
<h3 id="getitem"><a href="#getitem" class="headerlink" title="__getitem__"></a><code>__getitem__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__getitem__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：实现根据索引取值</p>
</li>
<li><p>参数</p>
<ul>
<li><p>序列<code>key</code>：整数、切片对象</p>
<ul>
<li><code>key</code>类型不正确将<code>raise TypeError</code></li>
<li><code>key</code>在实例有效范围外将<code>raise IndexError</code></li>
</ul>
</li>
<li><p>映射<code>key</code>：可hash对象</p>
<ul>
<li><code>key</code>不存在将<code>raise KeyError</code></li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：<code>self[key]</code></p>
</li>
</ul>
<h3 id="setitem"><a href="#setitem" class="headerlink" title="__setitem__"></a><code>__setitem__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__setitem__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：实现根据索引赋值</p>
</li>
<li><p>参数：同<code>__geitem__</code></p>
</li>
</ul>
<h3 id="delitem"><a href="#delitem" class="headerlink" title="__delitem__"></a><code>__delitem__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__delitem</span>(<span class="params">self, key</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：实现删除索引对应项</p>
</li>
<li><p>参数：同<code>__getitem__</code></p>
</li>
</ul>
<h3 id="missing"><a href="#missing" class="headerlink" title="__missing__"></a><code>__missing__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__missing__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用途：<code>__getitem__</code>无法找到映射中键时调用</li>
</ul>
<h3 id="reversed"><a href="#reversed" class="headerlink" title="__reversed__"></a><code>__reversed__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：为容器类创建逆向迭代器</p>
</li>
<li><p>返回值：逆向迭代对象</p>
<ul>
<li>内置钩子函数：<code>reversed()</code></li>
</ul>
</li>
</ul>
<h4 id="说明-9"><a href="#说明-9" class="headerlink" title="说明"></a>说明</h4><ul>
<li><p>若未提供<code>__reversed__</code>方法，<code>reversed</code>函数将回退到使用
<strong>序列协议</strong>：<code>__len__</code>、<code>__getitem__</code></p>
</li>
<li><p>支持序列协议的对象应该仅在能够提供比<code>reversed</code>更高效实现
时才提供<code>__reversed__</code>方法</p>
</li>
</ul>
<h3 id="contains"><a href="#contains" class="headerlink" title="__contains__"></a><code>__contains__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__contains__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：实现成员检测</p>
<ul>
<li>若<code>item</code>是<code>self</code>成员则返回<code>True</code>、否则返回<code>False</code></li>
<li>对映射应检查键</li>
</ul>
</li>
<li><p>返回值：布尔值</p>
<ul>
<li>钩子运算：<code>in</code></li>
</ul>
</li>
</ul>
<h4 id="说明-10"><a href="#说明-10" class="headerlink" title="说明"></a>说明</h4><ul>
<li><p>若未提供<code>__contains__</code>方法，成员检测将依次尝试</p>
<ul>
<li>通过<code>__iter__</code>进行迭代</li>
<li>使用<code>__getitem__</code>旧式序列迭代协议</li>
</ul>
</li>
<li><p>容器对象可以提供更有效率的实现</p>
</li>
</ul>
<h2 id="模拟数字"><a href="#模拟数字" class="headerlink" title="模拟数字"></a>模拟数字</h2><h3 id="数字运算"><a href="#数字运算" class="headerlink" title="数字运算"></a>数字运算</h3><p>定义以下方法即可模拟数字类型</p>
<ul>
<li>特定类型数值类型不支持的运算应保持未定义状态</li>
<li>若不支持与提供的参数进行运算，应返回<code>NotImplemented</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `+`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__sub__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `-`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__mul__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `*`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__matmul__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `@`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__truediv__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `/`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__floordiv__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `//`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__mod__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `%`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__divmod__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `divmod()`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__pow__</span>(<span class="params">self, other[, modulo=<span class="number">1</span>]</span>):</span></span><br><span class="line">	<span class="comment"># `pow()`/`**`</span></span><br><span class="line">	<span class="comment"># 若要支持三元版本内置`pow()`函数，应该接受可选的第三个</span></span><br><span class="line">		<span class="comment"># 参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__lshift__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `&lt;&lt;`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__rshift__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `&gt;&gt;`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__and__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `&amp;`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__or__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `|`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__xor__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `~`</span></span><br></pre></td></tr></table></figure>
<h3 id="反射二进制算术运算"><a href="#反射二进制算术运算" class="headerlink" title="反射二进制算术运算"></a>反射二进制算术运算</h3><p>以下成员函数仅在<strong>左操作数不支持相应运算</strong>、
<strong>且两操作数类型不同时</strong>被调用</p>
<ul>
<li><p>实例作为作为相应运算的右操作数</p>
</li>
<li><p>若右操作数类型为左操作数类型子类，且字类提供如下反射方法</p>
<ul>
<li>右操作数反射方法优先于左操作数非反射方法被调用</li>
<li>允许子类覆盖祖先类运算符</li>
</ul>
</li>
<li><p>三元版<code>pow()</code>不会尝试调用<code>__rpow__</code>（转换规则太复杂）</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__radd__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `+`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__rsub__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `-`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__rmul__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `*`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__rmatmul__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `@`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__rtruediv__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `/`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__rfloordiv__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `//`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__rmod__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `%`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__rdivmod__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `divmod()`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__rpow__</span>(<span class="params">self, other[, modulo=<span class="number">1</span>]</span>):</span></span><br><span class="line">	<span class="comment"># `pow()`/`**`</span></span><br><span class="line">	<span class="comment"># 若要支持三元版本内置`pow()`函数，应该接受可选的第三个</span></span><br><span class="line">		<span class="comment"># 参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__rlshift__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `&lt;&lt;`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__rrshift__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `&gt;&gt;`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__rand__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `&amp;`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__ror__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `|`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__rxor__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `~`</span></span><br></pre></td></tr></table></figure>
<h3 id="扩展算术赋值"><a href="#扩展算术赋值" class="headerlink" title="扩展算术赋值"></a>扩展算术赋值</h3><p>实现以下方法实现扩展算数赋值</p>
<ul>
<li><p>以下方法应该尝试对自身进行操作</p>
<ul>
<li>修改<code>self</code>、返回结果（不一定为<code>self</code>）</li>
</ul>
</li>
<li><p>若方法未定义，相应扩展算数赋值将回退到普通方法中</p>
</li>
<li><p>某些情况下，扩展赋值可导致未预期错误</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__iadd__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `+=`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__isub__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `-=`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__imul__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `*=`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__imatmul__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `@=`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__itruediv__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `/=`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__ifloordiv__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `//=`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__imod__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `%=`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__ipow__</span>(<span class="params">self, other[, modulo=<span class="number">1</span>]</span>):</span></span><br><span class="line">	<span class="comment"># `**=`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__ilshift__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `&lt;&lt;=`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__irshift__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `&gt;&gt;=`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__iand__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `&amp;=`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__ior__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `|=`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__ixor__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `~=`</span></span><br></pre></td></tr></table></figure>
<h3 id="一元算术运算"><a href="#一元算术运算" class="headerlink" title="一元算术运算"></a>一元算术运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__neg__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="comment"># `-`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__pos__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="comment"># `+`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__abs__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="comment"># `abs()`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__invert__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="comment"># `~`</span></span><br></pre></td></tr></table></figure>
<h3 id="类型转换运算"><a href="#类型转换运算" class="headerlink" title="类型转换运算"></a>类型转换运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__complex__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="comment"># `complex()`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__int__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="comment"># `int()`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__float__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="comment"># `float()`</span></span><br></pre></td></tr></table></figure>
<h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__index__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>存在此方法表明对象属于整数类型</p>
<ul>
<li>必须返回整数</li>
<li>为保证以一致性，同时也应该定义<code>__int__()</code>，两者返回
相同值</li>
</ul>
</li>
<li><p>调用此方法以实现<code>operator.index()</code>、或需要无损的转换为
整数对象</p>
<ul>
<li>作为索引、切片参数</li>
<li>作为<code>bin()</code>、<code>hex()</code>、<code>oct()</code>函数参数</li>
</ul>
</li>
</ul>
<h3 id="精度运算"><a href="#精度运算" class="headerlink" title="精度运算"></a>精度运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__round__</span>(<span class="params">self[, ndigits]</span>):</span></span><br><span class="line">	<span class="comment"># `round()`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__trunc__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="comment"># `math.trunc()`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__floor__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="comment"># `math.floor()`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__ceil__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="comment"># `math.ceil()`</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>返回值：除<code>__round__</code>中给出<code>ndigits</code>参数外，都应该为
原对象截断为<code>Integral</code>（通常为<code>int</code>）</p>
</li>
<li><p>若未定义<code>__int__</code>，则<code>int</code>回退到<code>__trunc__</code></p>
</li>
</ul>
<h2 id="元属性查找"><a href="#元属性查找" class="headerlink" title="元属性查找"></a>元属性查找</h2><ul>
<li><p>元属性查找通常会绕过<code>__getattribute__</code>方法，甚至包括元类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">*args</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;Metaclass getattribute invoked&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">type</span>.__getattribute__(*args)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params"><span class="built_in">object</span>, metaclass=Meta</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">*args</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;Class getattribute invoked&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">object</span>.__geattribute__(*args)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	c = C()</span><br><span class="line">	c.__len__()</span><br><span class="line">		<span class="comment"># 通过实例显式调用</span></span><br><span class="line">		<span class="comment"># 输出`Class getattribute invoked\n10&quot;</span></span><br><span class="line">	<span class="built_in">type</span>(c).__len__(c)</span><br><span class="line">		<span class="comment"># 通过类型显式调用</span></span><br><span class="line">		<span class="comment"># 输出`Metaclass getattribute invoked\n10&quot;</span></span><br><span class="line">	<span class="built_in">len</span>(c)</span><br><span class="line">		<span class="comment"># 隐式查找</span></span><br><span class="line">		<span class="comment"># 输出`10`</span></span><br></pre></td></tr></table></figure>
<ul>
<li>为解释器内部速度优化提供了显著空间</li>
<li>但是牺牲了处理特殊元属性时的灵活性<ul>
<li>特殊元属性必须设置在类对象本身上以便始终一致地
由解释器发起调用</li>
</ul>
</li>
</ul>
</li>
<li><p>隐式调用元属性仅保证<strong>元属性定义在对象类型中</strong>能正确发挥
作用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	c = C()</span><br><span class="line">	c.__len__() = <span class="keyword">lambda</span>: <span class="number">5</span></span><br><span class="line">	<span class="built_in">len</span>(c)</span><br><span class="line">		<span class="comment"># `rasie TypeError`</span></span><br></pre></td></tr></table></figure>
<ul>
<li>元属性定义在实例字典中会引发异常</li>
<li>若元属性的隐式查找过程使用了传统查找过程，会在对类型
对象本身发起调用时失败</li>
<li><p>可以通过在查找元属性时绕过实例避免</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">1</span>).__hash__(<span class="number">1</span>) == <span class="built_in">hash</span>(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="built_in">int</span>).__hash__(<span class="built_in">int</span>) == <span class="built_in">hash</span>(<span class="built_in">int</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="上下文管理器协议"><a href="#上下文管理器协议" class="headerlink" title="上下文管理器协议"></a>上下文管理器协议</h2><p>上下文管理器：定义了在执行<code>with</code>语句时要建立的运行时上下文
的对象</p>
<ul>
<li><p>上下文管理器为执行代码块，处理进入、退出运行时所需上下文</p>
<ul>
<li>通常使用<code>with</code>语句调用</li>
<li>也可以直接调用协议中方法方法</li>
</ul>
</li>
<li><p>典型用法</p>
<ul>
<li>保存、恢复各种全局状态</li>
<li>锁、解锁资源：避免死锁</li>
<li>关闭打开的文件：自动控制资源释放</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>可利用<code>contextlib</code>模块方便实现上下文管理器协议</li>
</ul>
</blockquote>
<h3 id="enter"><a href="#enter" class="headerlink" title="__enter__"></a><code>__enter__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">contextmanager</span>.<span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：创建、进入与当前对象相关的运行时上下文</p>
<ul>
<li>在执行<code>with</code>语句块前设置运行时上下文</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li><code>with</code>子句绑定方法返回值到<code>as</code>子句中指定的目标，如果
方法返回值</li>
</ul>
</li>
</ul>
<h3 id="exit"><a href="#exit" class="headerlink" title="__exit__"></a><code>__exit__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">contextmanger</span>.<span class="title">__exit__</span>(<span class="params">self, exc_type, exc_value, traceback</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：销毁、退出关联到此对象的运行时上下文</p>
<ul>
<li><code>with</code>语句块结束后，<code>__exit__</code>方法触发进行清理工作</li>
<li>不论<code>with</code>代码块中发生什么，即使是出现异常，
<code>__exit__</code>控制流也会执行完</li>
</ul>
</li>
<li><p>参数：描述了导致上下文退出的异常，正常退出则各参数为
<code>None</code></p>
<ul>
<li><code>exc_type</code></li>
<li><code>exc_value</code></li>
<li><code>traceback</code></li>
</ul>
</li>
<li><p>返回值：布尔值</p>
<ul>
<li>若上下文因异常退出<ul>
<li>希望方法屏蔽此异常（避免传播），应该返回真值，
异常被清空</li>
<li>否则异常在退出此方法时将按照正常流程处理</li>
</ul>
</li>
<li>方法中不应该重新引发被传入的异常，这是调用者的责任</li>
</ul>
</li>
</ul>
<h3 id="例-2"><a href="#例-2" class="headerlink" title="例"></a>例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket, AF_INET, SOCK_STREAM</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyConnection</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, address, family=AF_INET, <span class="built_in">type</span>=SOCK_STREAM</span>):</span></span><br><span class="line">		self.address = address</span><br><span class="line">		self.family = family</span><br><span class="line">		self.<span class="built_in">type</span> = <span class="built_in">type</span></span><br><span class="line">		self.connections = []</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">		sock = socket(self.family, self.<span class="built_in">type</span>)</span><br><span class="line">		sock.connect(self.address)</span><br><span class="line">		self.connections.append(sock)</span><br><span class="line">		<span class="keyword">return</span> self.sock</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exc_ty, exc_val, tb</span>):</span></span><br><span class="line">		self.connections.pop().close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">	conn = LazyConnection(<span class="string">&quot;www.python.org&quot;</span>, <span class="number">80</span>))</span><br><span class="line">	<span class="keyword">with</span> conn <span class="keyword">as</span> s1:</span><br><span class="line">		<span class="comment"># `conn.__enter___()` executes: connection opened</span></span><br><span class="line">		s.send(<span class="string">b&quot;GET /index.html HTTP/1.0\r\n&quot;</span>)</span><br><span class="line">		s.send(<span class="string">b&quot;Host: www.python.org\r\n&quot;</span>)</span><br><span class="line">		s.send(<span class="string">b&quot;\r\n&quot;</span>)</span><br><span class="line">		resp = <span class="string">b&quot;&quot;</span>.join(<span class="built_in">iter</span>(partial(s.recv, <span class="number">8192</span>), <span class="string">b&quot;&quot;</span>))</span><br><span class="line">		<span class="comment"># `conn.__exit__()` executes: connection closed</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">with</span> conn <span class="keyword">as</span> s2:</span><br><span class="line">			<span class="comment"># 此版本`LasyConnection`可以看作是连接工厂</span></span><br><span class="line">			<span class="comment"># 使用列表构造栈管理连接，允许嵌套使用</span></span><br><span class="line">			<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h2 id="迭代器协议"><a href="#迭代器协议" class="headerlink" title="迭代器协议"></a>迭代器协议</h2><ul>
<li>可迭代对象：实现<code>__iter__</code>方法的对象</li>
<li>迭代器对象：同时实现<code>__next__</code>方法的可迭代对象</li>
</ul>
<blockquote>
<ul>
<li>使用<code>collections.abc</code>模块判断对象类型</li>
</ul>
</blockquote>
<h3 id="iter"><a href="#iter" class="headerlink" title="__iter__"></a><code>__iter__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：创建迭代器对象，<strong>不负责产生、返回迭代器元素</strong></p>
<ul>
<li>容器对象要提供迭代须实现此方法<ul>
<li>容器支持不同迭代类型，可以提供额外方法专门请求
不同迭代类型迭代器</li>
</ul>
</li>
<li>迭代对象本身需要实现此方法，返回对象自身<ul>
<li>允许容器、迭代器均可配合<code>for...in...</code>语句使用</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：迭代器对象</p>
<ul>
<li>映射类型应该逐个迭代容器中键</li>
<li>内置钩子函数：<code>iter()</code></li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>此方法对应Python/C API中python对象类型结构体中
  <code>tp_iter</code>槽位</li>
</ul>
</blockquote>
<h3 id="next"><a href="#next" class="headerlink" title="__next__"></a><code>__next__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__next__</span>():</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：从迭代器中返回下一项</p>
<ul>
<li>若没有项可以返回，则<code>raise StopIteration</code></li>
<li>一旦引发<code>raise StopIteration</code>，对后续调用必须一直
引发同样的异常，否则此行为特性无法正常使用</li>
</ul>
</li>
<li><p>返回值：迭代器对象中下个元素</p>
<ul>
<li>映射类型返回容器中键</li>
<li>内置钩子函数：<code>next()</code></li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>此方法对应Python/C API中python对象类型结构体中
  <code>tp_iternext</code>槽位</li>
</ul>
</blockquote>
<h2 id="协程-异步"><a href="#协程-异步" class="headerlink" title="协程/异步"></a>协程/异步</h2><h3 id="await"><a href="#await" class="headerlink" title="__await__"></a><code>__await__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__await__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：用于实现<strong>可等待对象</strong></p>
</li>
<li><p>返回值：迭代器</p>
<ul>
<li>钩子运算：<code>await</code></li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><code>asyncio.Future</code>实现此方法以与<code>await</code>表达式兼容</li>
</ul>
</blockquote>
<h4 id="Awaitable-Objects"><a href="#Awaitable-Objects" class="headerlink" title="Awaitable Objects"></a><em>Awaitable Objects</em></h4><p>可等待对象：异步调用句柄，<strong>等待结果应为迭代器</strong></p>
<ul>
<li><p>主要是实现<code>__await__</code>方法对象</p>
<ul>
<li>从<code>async def</code>函数返回的协程对象</li>
</ul>
</li>
<li><p><code>type.coroutine()</code>、<code>asyncio.coroutine()</code>装饰的生成器
返回的生成器迭代器对象也属于可等待对象，但其未实现
<code>__await__</code></p>
</li>
</ul>
<blockquote>
<ul>
<li>协程对象参见<em>cs_python/py3ref/dm_gfuncs</em></li>
<li>py3.7前多次<code>await</code>可等待对象返回<code>None</code>，之后报错</li>
</ul>
</blockquote>
<h3 id="异步迭代器协议"><a href="#异步迭代器协议" class="headerlink" title="异步迭代器协议"></a>异步迭代器协议</h3><ul>
<li>异步迭代器常用于<code>async for</code>语句中</li>
</ul>
<blockquote>
<ul>
<li>其他参见迭代器协议</li>
</ul>
</blockquote>
<h4 id="aiter"><a href="#aiter" class="headerlink" title="__aiter__"></a><code>__aiter__</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__aiter__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用途：返回异步迭代器对象，<strong>不负责产生、返回迭代器元素</strong><ul>
<li>返回其他任何对象都将<code>raise TypeError</code></li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>其他参见<code>__iter__</code>方法</li>
</ul>
</blockquote>
<h4 id="anext"><a href="#anext" class="headerlink" title="__anext__"></a><code>__anext__</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__anext__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>返回：从异步迭代器返回下个结果值</p>
<ul>
<li>迭代结束时应该<code>raise StopAsyncIteration</code></li>
</ul>
</li>
<li><p>用途</p>
<ul>
<li>在其中调用异步代码</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>其他参见<code>__next__</code>方法</li>
</ul>
</blockquote>
<h4 id="例-3"><a href="#例-3" class="headerlink" title="例"></a>例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reader</span>:</span></span><br><span class="line">	<span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">readline</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__aiter__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> self</span><br><span class="line">	<span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">__anext__</span>(<span class="params">self</span>):</span></span><br><span class="line">		val = <span class="keyword">await</span> self.readline()</span><br><span class="line">		<span class="keyword">if</span> val == <span class="string">&quot;b&quot;</span>:</span><br><span class="line">			<span class="keyword">raise</span> StopAsyncIteration</span><br><span class="line">		<span class="keyword">return</span> val</span><br></pre></td></tr></table></figure>
<h3 id="异步上下文管理器协议"><a href="#异步上下文管理器协议" class="headerlink" title="异步上下文管理器协议"></a>异步上下文管理器协议</h3><ul>
<li>异步上下文管理器常用于<code>async with</code><strong>异步</strong>语句中</li>
</ul>
<blockquote>
<ul>
<li>其他参见上下文管理器协议</li>
</ul>
</blockquote>
<h4 id="aenter"><a href="#aenter" class="headerlink" title="__aenter__"></a><code>__aenter__</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__aenter__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：异步创建、进入关联当前对象的上下文执行环境</p>
<ul>
<li>由<code>async def</code>定义为协程函数，即在创建上下文执行环境
时可以被挂起</li>
</ul>
</li>
<li><p>返回：可等待对象</p>
</li>
</ul>
<blockquote>
<ul>
<li>其他参见<code>__enter__</code></li>
</ul>
</blockquote>
<h4 id="aexit"><a href="#aexit" class="headerlink" title="__aexit__"></a><code>__aexit__</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__aexit__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：异步销毁、退出关联当前对象的上下文执行环境</p>
<ul>
<li>由<code>async def</code>定义为协程函数，即在销毁上下文执行环境
时可以被挂起</li>
</ul>
</li>
<li><p>返回：可等待对象</p>
</li>
</ul>
<blockquote>
<ul>
<li>其他参见<code>__exit__</code>函数</li>
</ul>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-06-03T09:02:43.000Z" title="6/3/2019, 5:02:43 PM">2019-06-03</time></span><span class="level-item">Updated&nbsp;<time dateTime="2020-09-19T03:49:30.000Z" title="9/19/2020, 11:49:30 AM">2020-09-19</time></span><span class="level-item"><a class="link-muted" href="/categories/CS/">CS</a><span> / </span><a class="link-muted" href="/categories/CS/Parallel/">Parallel</a></span><span class="level-item">an hour read (About 7174 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/CS/Parallel/implementation.html">Parallel</a></h1><div class="content"><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><blockquote>
<ul>
<li><em>Parallel</em>：并行，<strong>同时做</strong>多件事情，关于执行、实现</li>
<li><em>Concurrent</em>：并发，<strong>能够处理</strong>多件事情，关于结构、逻辑</li>
</ul>
</blockquote>
<ul>
<li><p>并发问题可以使用并行方式解决，也可以串行解决</p>
<ul>
<li>100并发任务同时运行在4核CPU上，最多可能有4个并发任务
并行处理，其余只能是串行处理</li>
</ul>
</li>
<li><p>并行角度：硬件技术的<strong>物理限制瓶颈</strong></p>
<ul>
<li>单计算核心能力不足，所以需要多核并行运算</li>
<li>进程、线程可认为是实现并行的基本逻辑实体</li>
</ul>
</li>
<li><p>并发角度：程序执行的<strong>逻辑重用需求</strong></p>
<ul>
<li>程序要求重用一组逻辑，所以需要将一组指令集打包，重复
调用该组指令集</li>
<li>子程序、协程可认为是方便重用的基本逻辑实体，因此更
应是语言内建机制<ul>
<li>子程序：无状态保存，同样重入得到同样结果</li>
<li>协程：有保存状态，重入会改变协程状态，结果可能
不同</li>
</ul>
</li>
</ul>
</li>
<li><p>线程作为任务执行的实体，可以认为是子程序、协程的具体执行</p>
<ul>
<li>内核线程作为可以独立执行的实体，逻辑上更会被设计为
完成独立任务，即没有保存状态需求，因此多是子程序的
具体执行</li>
<li>用户线程则用程序负责调度，二者执行实例均可</li>
<li>某种意义上线程、子程序是对应的执行实体、逻辑实体</li>
</ul>
</li>
</ul>
<h2 id="子程序、协程"><a href="#子程序、协程" class="headerlink" title="子程序、协程"></a>子程序、协程</h2><ul>
<li>子程序可以看作时协程的特例<ul>
<li>只有一个状态，每次进入时局部状态重置</li>
<li>唯一入口点</li>
</ul>
</li>
<li>协程可视为子程序的组成<ul>
<li>维护自身状态，所以<strong>逻辑上不独立</strong> ，应该是作为被
调用对象</li>
<li>对于每次返回部分结果值的协程（也称生成器迭代器），
可以直接视为类似链表之类的数据结构
（在某些语言中可以所有数据都是类，从这个角度这也都是
统一的）</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>子程序</th>
<th>协程</th>
</tr>
</thead>
<tbody>
<tr>
<td>生命周期</td>
<td>后进先出</td>
<td>完全取决于需要</td>
</tr>
<tr>
<td>入口点</td>
<td>起始处</td>
<td>起始处、<code>yield</code>返回出口点</td>
</tr>
<tr>
<td>返回值</td>
<td>调用结束后返回全部</td>
<td>可每次<code>yield</code>返回部分值</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<ul>
<li>现代指令集通常提供对调用栈的指令支持，便于实现可递归
  调用的子程序，在提供续体的语言环境（如<em>Scheme</em>），恰好
  可用此抽象状态表示实现协程</li>
</ul>
</blockquote>
<h3 id="Subroutine-Procedure-Function-Routine-Method"><a href="#Subroutine-Procedure-Function-Routine-Method" class="headerlink" title="Subroutine/Procedure/Function/Routine/Method"></a><em>Subroutine</em>/<em>Procedure</em>/<em>Function</em>/<em>Routine</em>/<em>Method</em></h3><p>子程序：打包为整体、用于执行特定任务的指令集序列</p>
<ul>
<li><p>子程序是依赖可重入能力的弱化版本</p>
<ul>
<li>一旦唤醒，于起始点开始执行</li>
<li>一旦退出，子程序结束</li>
<li>子程序实例只返回一次，两次激活间不保存状态</li>
</ul>
</li>
<li><p>子程序中局部变量在每次<strong>调用/重入</strong>函数时都是相同的</p>
<ul>
<li><strong>相同输入得到相同输出</strong></li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><em>procedure</em>：过程，有时特指无返回值、仅有副作用</li>
</ul>
</blockquote>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>线程安全：子程序在多线程环境调用时，能够正确处理多个线程之间
的共享变量，使程序功能能正确完成</p>
<ul>
<li><p>线程安全函数应该为每个调用其的线程分配专门空间，存储需要
单独保存的状态</p>
</li>
<li><p><em>Atomicity</em>：原子性，操作不会被线程调度机制打断，一旦
开始就会运行到结束，中间不会有任何线程切换</p>
<ul>
<li>可以通过<em>lock</em>、<em>synchronized</em>确保原子性</li>
</ul>
</li>
<li><em>Visibility</em>：可见性，某线程修改变量值后，其他线程能够
立刻感知<ul>
<li>一般可以通过<code>volatile</code>保证可见性，强制要求被修改值
从寄存器同步至主存</li>
<li><em>lock</em>、<em>synchronized</em>也可以通过限制其他线程访问变量
的方式保证可见性</li>
</ul>
</li>
<li><em>Ordering</em>：有序性/一致性，程序按照代码顺序执行<ul>
<li>可以通过<code>volatile</code>保证一定的有序性</li>
<li>也可通过<em>lock</em>、<em>synchronized</em>提供单线程执行环境保证
有序性</li>
</ul>
</li>
</ul>
<h4 id="Instruction-Reorder"><a href="#Instruction-Reorder" class="headerlink" title="Instruction Reorder"></a>Instruction Reorder</h4><p>指令重排：编译器对无相互依赖的指令重新排序执行</p>
<ul>
<li><p><code>as-if-serial</code>语义：指令可以为优化而重排序，但是必须保证
最终执行结果不变</p>
<ul>
<li>规则：重排序过程不破坏数据依赖关系</li>
<li>只能保证单线程执行结果有效，但不保证多线程并发执行
的正确性</li>
</ul>
<p><img src="/imgs/instruction_reorder_asif.png" alt="instruction_reorder_asif"></p>
</li>
<li><p><code>happens-before</code>原则：保证前后两个操作间不会被重排序，</p>
<ul>
<li>程序次序规则：线程中每个操作<em>happens-before</em>该线程中
任意后续操作</li>
<li>锁定规则：锁的解锁<em>happens-before</em>加锁</li>
<li>volatile变量规则：volatile变量写操作<em>happens-before</em>
其读操作</li>
<li>传递规则：若A <em>happens-before</em> B、B <em>happens-before</em>
C，则A <em>happens-before</em> C</li>
<li>线程启动规则：线程对象启动<em>happens-before</em>线程中每个
动作</li>
<li>线程中断规则：线程中断方法的调用<em>happens-before</em>被
中断线程代码检测到的中断事件的发生</li>
<li>线程终结规则：线程中所有操作<em>happens-before</em>线程的
终止检测</li>
<li>对象终结规则：对象的初始化<em>happens-before</em>其<em>final</em>
方法的开始</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><em>happens-before</em>原则被JVM用于规定（跨线程）操作之间偏序
  关系，若操作之间的关系可以由此原则退出，则两个操作有序</li>
</ul>
</blockquote>
<h4 id="Reentrant"><a href="#Reentrant" class="headerlink" title="Reentrant"></a><em>Reentrant</em></h4><blockquote>
<ul>
<li>A computer program or routine is described as reentrant
  if it can be safely executed concorrently; that is, the
  routine can be re-entered while it is already running</li>
</ul>
</blockquote>
<p>可重入函数：对于相同（合法）的函数参数，多次重复调用（包括
执行过程中被中断再重入）结果总是可预期的</p>
<ul>
<li><p>可重入需要满足条件</p>
<ul>
<li>不在函数内部使用静态或全局数据，所有数据都由函数
调用者提供<ul>
<li>全局变量区</li>
<li>中断向量表</li>
</ul>
</li>
<li>使用本地数据，或制作全局数据的本地拷贝保护全局数据</li>
<li>不返回静态或全局数据</li>
<li>不调用不可重入函数</li>
</ul>
</li>
<li><p>不可重入后果主要体现在信号处理函数这样需要重入情况中，
若在信号处理函数中使用了不可重入函数，则可能导致程序错误</p>
</li>
<li><p>可重入函数总是线程安全的，反之不一定成立</p>
<ul>
<li>线程安全可以通过“并发不冲突”实现</li>
<li>可重入则要求“并行不冲突”</li>
</ul>
</li>
</ul>
<h3 id="Coroutine"><a href="#Coroutine" class="headerlink" title="Coroutine"></a><em>Coroutine</em></h3><p>协程：为<strong>非抢占式</strong>多任务产生子程序的程序组件，允许执行过程
中挂起、恢复</p>
<ul>
<li><p>挂起、恢复：协程可以通过<code>yield</code>（让步）调用其他协程暂时
退出，之后可在退出位置恢复执行</p>
<ul>
<li>从协程角度看，这是调用其他协程而不是退出</li>
<li>但实际是<strong>各协程之间是对称的</strong>，而不像子程序调用
中主调-被调关系</li>
<li>这即暗含<ul>
<li>协程可包含多个入口点</li>
<li>允许在不同入口点暂停、开始执行程序</li>
</ul>
</li>
</ul>
</li>
<li><p>局部状态维护：协程实例保持上次退出时状态</p>
<ul>
<li>则协程被唤醒时状态可能不同</li>
<li>可能同时有多个给定协程实例</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>协程将原在子程序外、输入状态管理工作交由自身逻辑维护</li>
<li>原生不支持协程的语言也可以使用循环等构建</li>
<li>经典状态机、对象已经具有协程特性</li>
</ul>
</blockquote>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul>
<li><p>协程可以简化异步代码的实现，使得需要使用异步+回调的代码
可以使用看似同步方式写出</p>
<ul>
<li>协程本身只涉及<strong>状态保存、过程重入</strong>，和并发/异步无关系</li>
<li>但协程本身蕴含的状态保存使得状态切换几乎无成本，适合
高并发任务</li>
</ul>
</li>
<li><p>协程在线程中调度完全由用户控制，可以视为用户态轻量级线程</p>
<ul>
<li>避免陷入<strong>无效内核级别上下文切换</strong>造成的性能损失</li>
<li>较线程在IO密集任务上性能上更好</li>
</ul>
</li>
</ul>
<h2 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h2><blockquote>
<ul>
<li>这里仅讨论理论上的异同，不考虑各平台具体实现</li>
</ul>
</blockquote>
<ul>
<li>进程：具有独立功能的程序关于某数据集合的一次运行活动</li>
<li>线程/子程序：进程内某特定任务的执行活动</li>
<li>协程：推广协作式多任务的子程序</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Process</th>
<th>Thread</th>
<th>Coroutine</th>
</tr>
</thead>
<tbody>
<tr>
<td>调度、创建、切换、维护</td>
<td>内核（系统）</td>
<td>内核、自身</td>
<td>自身</td>
</tr>
<tr>
<td>切换开销、速度</td>
<td>大、慢</td>
<td>小、快</td>
<td>无</td>
</tr>
<tr>
<td>易用性</td>
<td>需要考虑进程退出、僵尸进程</td>
<td>只需要管理进程即可</td>
<td>无需管理</td>
</tr>
<tr>
<td>资源共享</td>
<td>独立</td>
<td>同进程内线程共享资源</td>
<td>除局部变量外均共享</td>
</tr>
<tr>
<td>通信</td>
<td>IPC较复杂：环境变量、文件、系统端口</td>
<td>较简单：共享内存</td>
<td>结果调用</td>
</tr>
<tr>
<td>移植性</td>
<td>差</td>
<td>好</td>
<td>好</td>
</tr>
<tr>
<td>健壮性</td>
<td>好，进程死亡不影响其他进程</td>
<td>差，线程死亡会导致进程（及线程）死亡</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>进程、线程、协程可以看作是控制权逐渐从系统已经移交到自身
的过程</li>
</ul>
<blockquote>
<ul>
<li>这里的协程强调其在实现方面的资源、调度特点，其与子程序间
  功能差异参加<em>cs_program/parallel/implementation</em></li>
<li>通信：参见<em>cs_program/parallel/#todo</em></li>
<li>移植性：基于进程分支多进程和windows模型有很大冲突，往往
  不能在windows平台上使用</li>
</ul>
</blockquote>
<h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a><em>Process</em></h3><p>进程：具有独立功能的程序关于某数据集合的一次运行活动</p>
<ul>
<li><p>进程是处于运行期的程序和相关资源的总称</p>
<ul>
<li>程序：代码、指令</li>
<li>运行：对CPU的占用，逐渐发展为线程，标识进程中指令的执行</li>
<li>资源：执行上下文，由进程内线程共享</li>
</ul>
</li>
<li><p>从系统调度方面看</p>
<ul>
<li>进程是系统进行<strong>资源分配、调度的独立单位</strong></li>
<li>在系统中有进程控制块（进程描述符）描述进程相关信息，
系统通过此控制块控制系统相关行为</li>
</ul>
</li>
<li><p>从资源分配方面看</p>
<ul>
<li>有独立的存储空间（虚拟寻址空间）<ul>
<li>独享的用户空间</li>
<li>进程专用的“共享内核空间”</li>
</ul>
</li>
<li>可执行的程序代码</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>线程可能对系统是可感知的，则进程不定是资源分配的基本
  单位</li>
<li>Linux线程实现即类似进程，但不包含独立存储空间</li>
</ul>
</blockquote>
<h4 id="调度角度"><a href="#调度角度" class="headerlink" title="调度角度"></a>调度角度</h4><ul>
<li><p>内核跟踪进程运行所需的状态信息（上下文）</p>
<ul>
<li>主存、虚拟内存内容</li>
<li>寄存器文件值</li>
<li>栈</li>
<li>文件句柄</li>
</ul>
</li>
<li><p>调度：分配CPU执行进程</p>
<ul>
<li>内核决定CPU控制权在进程间的转移</li>
</ul>
</li>
<li><p>上下文切换：进程状态的记录、恢复、切换</p>
<ul>
<li>保存当前进程上下文、恢复新进程上下文</li>
<li>通过处理器在进程间切换，实现单个CPU“看似”并发执行
多个进程</li>
<li>上下文进程间切换开销比较大，但相对比较稳定安全</li>
</ul>
</li>
</ul>
<h4 id="资源角度"><a href="#资源角度" class="headerlink" title="资源角度"></a>资源角度</h4><blockquote>
<ul>
<li>独立内存空间/虚拟地址空间：每个进程<strong>“独占的”</strong>使用
  内存、看到一致的存储器</li>
</ul>
</blockquote>
<p><img src="/imgs/process_virtual_address_space_structure.png" alt="process_virtual_address_space_structure"></p>
<ul>
<li><p>用户空间</p>
<ul>
<li>程序代码、数据：对所有进程，代码从同一固定位置开始，
直接按照可执行目标文件的内容初始化</li>
<li>（运行时）堆：可在运行时动态扩展、收缩</li>
<li>共享库：共享库代码和数据，如：C标准库、数学库</li>
<li>栈：用于实现函数调用，运行时动态扩展、收缩，位于虚拟
地址空间顶部</li>
</ul>
</li>
<li><p>内核空间</p>
<ul>
<li>内核虚拟存储器：内核总是驻留在内存中，为其保留地址
空间顶部</li>
<li>不允许程序读写区域内容或直接调用内核代码定义的函数</li>
</ul>
</li>
</ul>
<h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a><em>Thread</em></h3><p>线程：进程执行实体，进程中包含指令的执行活动</p>
<h4 id="调度角度-1"><a href="#调度角度-1" class="headerlink" title="调度角度"></a>调度角度</h4><blockquote>
<ul>
<li>线程是CPU调度、分派的基本单位，有时被称为轻量级进程
  （在Linux系统中也是按照轻量级进程实现）</li>
</ul>
</blockquote>
<ul>
<li><p>线程引入逻辑</p>
<ul>
<li>进程内部可能存在多个不同task，task需要共享进程数据</li>
<li>同时task操作的数据具有独立性，多个task不需要按照时序
执行</li>
<li>task间需根据不同策略进行调度，因此产生了线程概念，
并被引入作为内核调度基本单位</li>
</ul>
</li>
<li><p>线程：比进程更小的、能独立运行的基本单位</p>
<ul>
<li>线程能/是“独立运行”，但不一定能被内核感知到，也一定由
内核调度</li>
<li>只能说线程是针对某个task的执行活动</li>
</ul>
</li>
</ul>
<h4 id="资源角度-1"><a href="#资源角度-1" class="headerlink" title="资源角度"></a>资源角度</h4><p><img src="/imgs/thread_virtual_address_space_structure.png" alt="thread_virtual_address_space_structure"></p>
<ul>
<li><p>线程运行在进程的上下文中，共享同样代码和全局数据</p>
<ul>
<li>进程代码段、公有数据</li>
<li>进程打开的文件描述符、信号的处理器</li>
<li>进程当前目录</li>
<li>进程用户ID、进程组ID</li>
</ul>
</li>
<li><p>线程还独享某些个性以实现并发性</p>
<ul>
<li>线程ID：进程中唯一标识</li>
<li>寄存器组值：线程间并发运行，线程有不同运行线索，
切换时需要保存当前线程的寄存器集合状态</li>
<li>线程堆栈：独立函数堆栈保证线程内函数调用可以正常
执行，不受其他线程影响</li>
<li>错误返回码：线程的系统调用错误可能未及时处理，独立
错误返回码避免其被其他线程修改</li>
<li>线程的信号屏蔽码：线程感兴趣的信号不同，因此信号
屏蔽码应由自己管理</li>
<li>线程优先级：线程需要像进程被调度，需要有相应的优先级</li>
</ul>
</li>
</ul>
<h2 id="线程实现理论"><a href="#线程实现理论" class="headerlink" title="线程实现理论"></a>线程实现理论</h2><h3 id="User-Level-Thread"><a href="#User-Level-Thread" class="headerlink" title="User-Level Thread"></a><em>User-Level Thread</em></h3><p>用户级线程：由用户程序自身负责支持、调度</p>
<ul>
<li><p>特点</p>
<ul>
<li>相当于实现自己的线程调度内核，实现线程数据结构、
创建、销毁、调度维护</li>
<li>线程运行在内核（可感知的）进程内</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>即使系统不支持线程，也可通过库函数支持在系统中实现
真实的多线程</li>
<li>线程只在用户态，减少内核态到用户态切换开销</li>
</ul>
</li>
<li><p>缺点：线程对系统透明，对系统每个进程只有一个线程，
系统直接调用进程</p>
<ul>
<li>当线程进行系统调用而阻塞时，系统会阻塞整个进程</li>
<li>用户空间没有时钟中断机制，若线程长时间不释放CPU，
会导致阻塞其他线程</li>
</ul>
</li>
</ul>
<h3 id="Kernel-Level-Thread"><a href="#Kernel-Level-Thread" class="headerlink" title="Kernel-Level Thread"></a><em>Kernel-Level Thread</em></h3><p>内核级线程：系统内核支持的线程，通过内核完成线程切换</p>
<ul>
<li><p>优点/特点：系统负责线程的创建、销毁、调度、维护</p>
<ul>
<li>内核通过操纵调度器对线程进行调度，并负责将线程
的任务映射到各个处理器上</li>
<li>程序可以直接使用系统调用已实现线程，无需实现线程
调度、对CPU资源抢占使用</li>
</ul>
</li>
<li><p>缺点：内核线程需要内核支持</p>
<ul>
<li>创建、销毁、调度、维护往往都需要系统调用，代价较高</li>
<li>需要消耗内核资源，不能大量创建</li>
</ul>
</li>
</ul>
<h3 id="线程调度模型"><a href="#线程调度模型" class="headerlink" title="线程调度模型"></a>线程调度模型</h3><blockquote>
<ul>
<li><code>X对Y</code>是指<code>X</code> task对应<code>Y</code>内核调度单位</li>
</ul>
</blockquote>
<h4 id="N对1模型"><a href="#N对1模型" class="headerlink" title="N对1模型"></a>N对1模型</h4><p><img src="/imgs/thread_model_n_versus_1.png" alt="thread_model_n_versus_1"></p>
<p>N对1模型：线程库有实现用户级线程，内核未实现内核级线程</p>
<ul>
<li>系统只负责调用进程</li>
<li>线程对系统透明，由进程自身负责调用</li>
</ul>
<blockquote>
<ul>
<li>此模型中内核没有实现内核级线程，所以内核调度单位就是进程
S<h4 id="1对1模型"><a href="#1对1模型" class="headerlink" title="1对1模型"></a>1对1模型</h4></li>
</ul>
</blockquote>
<p><img src="/imgs/thread_model_1_versus_1.png" alt="thread_model_1_versus_1"></p>
<p>1对1模型：线程库未实现用户级线程，内核实现有内核线程</p>
<ul>
<li><p>程序（逻辑）层面</p>
<ul>
<li>创建执行独立task的线程</li>
<li>程序创建的线程直接由内核负责调度</li>
</ul>
</li>
<li><p>内核（实现）层面</p>
<ul>
<li>每次创建线程都是调用系统调用创建内核级线程</li>
<li>可视为每个“用户创建的线程”同内核级线程绑定，二者一一
对应</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>此模型中内核调度单位就是内核级线程</li>
<li>此模型中不存在上述定义的用户级线程，图中<em>Thread</em>实际上
  应该就是<em>Kernel Thread</em>，仅拆分出来表示是程序创建的线程</li>
</ul>
</blockquote>
<h4 id="M对N模型"><a href="#M对N模型" class="headerlink" title="M对N模型"></a>M对N模型</h4><p><img src="/imgs/thread_model_m_versus_n.png" alt="thread_model_m_versus_n"></p>
<p>M对N模型：线程库实现有用户级线程，系统也实现有内核级线程</p>
<ul>
<li><p>程序（逻辑）层面</p>
<ul>
<li>创建执行独立task的<strong>用户级线程</strong></li>
<li>创建可独立被内核调度的<strong>内核级线程</strong></li>
<li>将若干和用户线程同内核线程相关联，即task组总体由内核
负责调度，task组内task由程序自身负责调度</li>
</ul>
</li>
<li><p>内核（实现）层面</p>
<ul>
<li>调用系统调用创建内核级线程</li>
<li>内核线程执行指令中包含用户线程创建、调度指令</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>用户级线程创建、切换、析构等均在用户空间中，依然
廉价，支持大规模用户线程并发</li>
<li>内核级线程作为用户线程在内核中调度、执行的桥梁，
降低整个进程被完全阻塞的风险</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>此模型中内核调度单位为内核级线程、task单位为用户线程，
  二者比例不定</li>
<li>有的说法里面会使用<em>Light Weighted Process</em>表示内核级线程</li>
</ul>
</blockquote>
<h2 id="通用调度算法"><a href="#通用调度算法" class="headerlink" title="通用调度算法"></a>通用调度算法</h2><ul>
<li><p>耗时相差不大的task队列总是比较好处理，难以调度的task是</p>
<ul>
<li>耗时相差大</li>
<li>IO任务、计算任务混合</li>
</ul>
</li>
<li><p>内核调度除考虑任务（线程）外，还会考虑进程因素</p>
<ul>
<li><em>Gang Scheduling</em>：尽量将同进程中线程同时调度，而非
随机从多个进程中挑选CPU数量线程调度</li>
<li><em>Space Sharing</em>：将CPU划分，各进程仅允许占用部分CPU
执行并发</li>
</ul>
</li>
<li><p>从任务角度，调度需要考虑</p>
<ul>
<li>Responsiveness</li>
<li>Schedule Overload</li>
<li>Starvation-Freedom：饥饿避免</li>
<li>Fairness</li>
</ul>
</li>
</ul>
<h3 id="First-In-First-Out"><a href="#First-In-First-Out" class="headerlink" title="First-In-First-Out"></a>First-In-First-Out</h3><p>先进先出：按task在队列中的顺序依次调用，执行完task再执行下个
task，仅在task结束后才会切换task</p>
<ul>
<li><p>优点</p>
<ul>
<li>最少task切换开销</li>
<li>最大吞吐量（总处理效率）</li>
<li>朴实公平</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>平均相应时间高</li>
</ul>
</li>
</ul>
<h3 id="Shortest-task-First-Shortest-Remained-Time-task"><a href="#Shortest-task-First-Shortest-Remained-Time-task" class="headerlink" title="Shortest task First/Shortest Remained Time task"></a>Shortest task First/Shortest Remained Time task</h3><p>最短耗时task优先：有限调度耗时短task</p>
<ul>
<li><p>优点</p>
<ul>
<li>平均相应时间短：长耗时task不断推移，必然统计出较短
平均响应时间</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>不公平，长耗时task难被调度，容易饥饿</li>
<li>频繁task切换，调度额外开销大</li>
</ul>
</li>
</ul>
<h3 id="Round-Robin"><a href="#Round-Robin" class="headerlink" title="Round Robin"></a>Round Robin</h3><p>时间片轮转：给队列中每个task时间片，时间片结束之后task移至
队列末尾，切换到执行下个task</p>
<ul>
<li><p>优点</p>
<ul>
<li>每个task可以得到公平调度</li>
<li>耗时短task即使在耗时长task之后也可以较快得到执行</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>task切换引起的调度开销大，需要多次切换task上下文</li>
<li>时间片不好设置<ul>
<li>时间片足够小则退化为SFJ</li>
<li>时间片足够大则退化为FIFO</li>
</ul>
</li>
<li>需要知道task（剩余）执行时间</li>
</ul>
</li>
</ul>
<h3 id="Weighted-Max-Min-Fairness"><a href="#Weighted-Max-Min-Fairness" class="headerlink" title="(Weighted) Max-Min Fairness"></a>(Weighted) Max-Min Fairness</h3><p>（带权重的）最大最小公平：资源按照需求递增的顺序分配，不存在
需求得到资源超过自身需求，未得到满足得到需求等价分享资源</p>
<ul>
<li>具体方案<ul>
<li>每轮开始将资源按照权重分配</li>
<li>若需求大于被分配资源则推迟执行，进入下轮</li>
<li>若需求小于被分配资源则执行，并将多余资源继续按照权重
分配给无法执行资源</li>
</ul>
</li>
</ul>
<h3 id="Multi-level-Feedback-Queue"><a href="#Multi-level-Feedback-Queue" class="headerlink" title="Multi-level Feedback Queue"></a>Multi-level Feedback Queue</h3><p>多级反馈队列：监控task处理耗时，若task未用尽分配资源则提高
优先级，否则降低其优先级</p>
<ul>
<li><p>具体方案</p>
<ul>
<li>task、分片时长具有相对应的不同优先级<ul>
<li>分片时长越长优先级越低</li>
<li>高级优先级task可以抢占低优先级task</li>
<li>新task位于高优先级task</li>
</ul>
</li>
<li>同一优先级task使用<em>Round Robin</em>
（事实上仅有最低优先级task使用<em>Round Robin</em>算法，
其他优先级都是FIFO）<ul>
<li>时间片用完后task结束则正常退出系统，否则优先级
下滑一等级</li>
<li>若是主动让出CPU（IO等），则停留在当前优先级或
提升</li>
</ul>
</li>
</ul>
</li>
<li><p>多核场景</p>
<ul>
<li>应该为每个CPU分配单独MFQ，同时采用
<em>Affinity Scheduling</em>保证task尽量同一CPU核上执行，
避免CPU cache频繁失效</li>
<li>若共用MFQ，则容易出现<ul>
<li>随CPU增长，对MFQ锁争抢严重</li>
<li>task每次执行位于的CPU不同，CPU Cache需要在不同
CPU间转移</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a>同步问题</h2><h3 id="生产者-消费者问题-缓存绑定问题"><a href="#生产者-消费者问题-缓存绑定问题" class="headerlink" title="生产者-消费者问题/缓存绑定问题"></a>生产者-消费者问题/缓存绑定问题</h3><blockquote>
<ul>
<li>生产者生成数据放入缓存，消费者从缓存获取、移除、消费数据
  ，问题核心在于保证不让生产者在缓存已满时放入数据、不让
  消费者在缓存为空时读取数据</li>
</ul>
</blockquote>
<ul>
<li>若缓存满：生产者者停止工作</li>
<li>若缓存空：消费者停止消费</li>
<li>消费者从缓存中取走数据，通知生产者工作</li>
<li>生产者向缓存中放入数据，通知消费者消费</li>
</ul>
<blockquote>
<ul>
<li>不完善的解决方案会造成死锁：生产者、消费者均等待对方唤醒</li>
</ul>
</blockquote>
<h4 id="信号量解决方案"><a href="#信号量解决方案" class="headerlink" title="信号量解决方案"></a>信号量解决方案</h4><blockquote>
<ul>
<li><code>mutex</code>信号量：互斥信号量，确保只有一个生产者、消费者
  操作缓存区，单一消费者、生产者可省略此信号量</li>
<li><code>fill_count</code>信号量：已使用缓存区数量</li>
<li><code>empty_count</code>信号量：空闲缓存区数量</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span></span><br><span class="line">semaphore fill_count = <span class="number">0</span></span><br><span class="line">semaphore empty_count = BUFFER_SIZE</span><br><span class="line"></span><br><span class="line">producer():</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span>:</span><br><span class="line">		item = produce_item()</span><br><span class="line">		down(empty_count)</span><br><span class="line">		down(mutex)</span><br><span class="line">		put_item_into_buffer(item)</span><br><span class="line">		up(mutex)</span><br><span class="line">		up(fillcount)</span><br><span class="line"></span><br><span class="line">consumer():</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span>:</span><br><span class="line">		down(fill_count)</span><br><span class="line">		down(mutex)</span><br><span class="line">		item = remove_item_from_buffer()</span><br><span class="line">		up(mutex)</span><br><span class="line">		up(empty_count)</span><br><span class="line">		consume_item(item)</span><br></pre></td></tr></table></figure>
<h4 id="状态监控解决方案"><a href="#状态监控解决方案" class="headerlink" title="状态监控解决方案"></a>状态监控解决方案</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">item_count = <span class="number">0</span></span><br><span class="line">condition full</span><br><span class="line">condition empty</span><br><span class="line"></span><br><span class="line">add(item):</span><br><span class="line">	<span class="keyword">while</span> item_count == BUFFER_SIZE:</span><br><span class="line">		wait(full)</span><br><span class="line"></span><br><span class="line">	item_count = item_count + <span class="number">1</span></span><br><span class="line">	put_item_into_buffer(item)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> item_count == <span class="number">1</span>:</span><br><span class="line">		notify(empty)</span><br><span class="line"></span><br><span class="line">remove():</span><br><span class="line">	<span class="keyword">while</span> item_count == <span class="number">0</span>:</span><br><span class="line">		wait(empty)</span><br><span class="line"></span><br><span class="line">	item_count = item_count - <span class="number">1</span></span><br><span class="line">	item = remove_item_from_buffer()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> item_count == BUFFER_SIZE - <span class="number">1</span>:</span><br><span class="line">		notify(full)</span><br><span class="line"></span><br><span class="line">produer():</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span>:</span><br><span class="line">		item = produce_item()</span><br><span class="line">		add(item)</span><br><span class="line"></span><br><span class="line">consumer():</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span>:</span><br><span class="line">		item = remove()</span><br><span class="line">		consume_item(item)</span><br></pre></td></tr></table></figure>
<ul>
<li>互斥信号没有保护关键区，监控方法更好</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li><p>协调生产者、消费者的关闭</p>
<ul>
<li>可在在队列中放置特殊的值，消费者读到时终止执行，结束
消费者线程</li>
<li>有多个消费者时，消费者读取特殊值之后可将特殊值放回
队列中继续传递，直至关闭所有消费者</li>
</ul>
</li>
</ul>
<h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><blockquote>
<ul>
<li>哲学家围坐在圆桌旁，只能吃饭<strong>或者</strong>思考，每两个哲学家
  之间只有一根筷子，只有同时拿到左右两根筷子才能正常吃饭</li>
</ul>
</blockquote>
<ul>
<li>实际计算机问题中，筷子视为共享资源</li>
</ul>
<h4 id="服务生"><a href="#服务生" class="headerlink" title="服务生"></a>服务生</h4><blockquote>
<ul>
<li>引入服务生判断资源是否能被获取</li>
</ul>
</blockquote>
<ul>
<li><p>引入服务生，哲学家必须经过其允许才能拿起筷子</p>
</li>
<li><p>服务生知道有哪些筷子正在被使用，能够判断是否会死锁</p>
</li>
</ul>
<h4 id="资源分级"><a href="#资源分级" class="headerlink" title="资源分级"></a>资源分级</h4><blockquote>
<ul>
<li>为资源（筷子）分配偏序关系<blockquote>
<ul>
<li>约定所有资源都按此偏序获取、相反顺序释放</li>
<li>且保证不会有无关资源同时被同一工作获取</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<ul>
<li><p>哲学家只能拿左右侧筷子：不会有无关资源被同一工作获取</p>
</li>
<li><p>将筷子按顺序编号：资源分配偏序关系</p>
<ul>
<li>哲学家只能先拿左右筷子中编号较小者</li>
<li>哲学家需要先放下筷子中编号较大者</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>最实用的解法：为锁指定常量分级，强制获取顺序的顺序</li>
<li>策略不总是实用的，尤其是所需资源列表事先不知道，可能需要
  先释放已获取资源、获取低编号资源、重新获取资源，效率不高</li>
</ul>
</blockquote>
<h4 id="Chandy-Misra解法"><a href="#Chandy-Misra解法" class="headerlink" title="Chandy/Misra解法"></a>Chandy/Misra解法</h4><blockquote>
<ul>
<li>标记资源，保留未使用资源、交出已使用资源，初始所以资源
  已使用</li>
</ul>
</blockquote>
<ul>
<li><p>每根筷子分为干净、脏，最初所有筷子都脏</p>
</li>
<li><p>对每对竞争同一筷子的哲学家，新拿筷子给编号较低者</p>
</li>
<li><p>当哲学家需要某筷子时</p>
<ul>
<li>向其竞争对手发送请求</li>
<li>拥有筷子的哲学家收到请求<ul>
<li>若筷子干净则保留</li>
<li>否则擦干净交出</li>
</ul>
</li>
</ul>
</li>
<li><p>哲学家吃完东西后，筷子变脏</p>
<ul>
<li>若有哲学家之前请求过该筷子，擦干净交出</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>有很大并行性，适合任意大问题</li>
</ul>
</blockquote>
<h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h3><blockquote>
<ul>
<li>多线程同时访问共享内存地址，线程写入时其他线程不能读取、
  写入，多个线程可以同时读取</li>
</ul>
</blockquote>
<ul>
<li>一般使用<em>readers-writer lock</em>解决问题</li>
</ul>
<h4 id="读者优先"><a href="#读者优先" class="headerlink" title="读者优先"></a>读者优先</h4><ul>
<li>若共享内存被读取，其他读者可以立即、同时读取</li>
<li>若一直有读者开始读取，则写者会一直被插队、无法修改</li>
</ul>
<h4 id="写者优先"><a href="#写者优先" class="headerlink" title="写者优先"></a>写者优先</h4><ul>
<li>如果写者在排队，应该尽快写入共享内存</li>
<li>若一直有写者准备写入，则读者会一直被插队、无法读取</li>
</ul>
<h4 id="限定时间"><a href="#限定时间" class="headerlink" title="限定时间"></a>限定时间</h4><ul>
<li>共享内存区的锁定权要在限定时间内结束</li>
<li>能避免读者、写者一直排队</li>
</ul>
<h3 id="熟睡的理发师问题"><a href="#熟睡的理发师问题" class="headerlink" title="熟睡的理发师问题"></a>熟睡的理发师问题</h3><blockquote>
<ul>
<li>理发店只有一名理发师、一张理发时坐的椅子、若干普通椅子
  供顾客等待<blockquote>
<ul>
<li>没有顾客时理发师在理发椅子上睡觉，顾客到达后离开、
 或者叫醒理发师</li>
<li>有顾客时，理发师为别人立法，顾客达到后若有空闲普通
 椅子则坐下休息、否则离开</li>
<li>理完发后，任选顾客开始理发</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<ul>
<li>理发师等待顾客、顾客等待理发师，造成死锁</li>
<li>有顾客不按顺序等待，让某些顾客永远不能理发</li>
</ul>
<h4 id="3信标解决"><a href="#3信标解决" class="headerlink" title="3信标解决"></a>3信标解决</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">semaphore customer = <span class="number">0</span></span><br><span class="line">semaphore barber = <span class="number">0</span></span><br><span class="line">semaphore mutex = <span class="number">1</span></span><br><span class="line">empty_chairs = BUFFER_SIZE</span><br><span class="line"></span><br><span class="line">barber():</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span>:</span><br><span class="line">		<span class="keyword">if</span> empty_chairs == BUFFER_SIZE:</span><br><span class="line">			sleep()</span><br><span class="line"></span><br><span class="line">		down(mutex)</span><br><span class="line">		item = get_customer_from_chairs()</span><br><span class="line">		empty_chairs += <span class="number">1</span></span><br><span class="line">		up(mutex)</span><br><span class="line"></span><br><span class="line">		down(barber)</span><br><span class="line">		cut_hair(item)</span><br><span class="line">		up(barber)</span><br><span class="line"></span><br><span class="line">customer():</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">true</span>:</span><br><span class="line">		down(mutex)</span><br><span class="line">		<span class="keyword">if</span> empty_chairs &gt; <span class="number">0</span>:</span><br><span class="line">			empty_chairs -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			wait() <span class="keyword">or</span> leave()</span><br><span class="line"></span><br><span class="line">		up(mutex)</span><br></pre></td></tr></table></figure>
<h3 id="三个烟鬼问题"><a href="#三个烟鬼问题" class="headerlink" title="三个烟鬼问题"></a>三个烟鬼问题</h3><blockquote>
<ul>
<li>香烟需要：烟草、卷烟纸、火柴，三个烟鬼分别有无限各一种，
  不吸烟协调人会随机安排两个烟鬼各拿出一份材料放在桌上，
  另外一个烟鬼拿到材料卷烟、抽<blockquote>
<ul>
<li>桌上空了后，协调人就随机要求烟鬼拿出材料</li>
<li>烟鬼只会在抽完手中烟后才会卷另一只</li>
<li>若烟草、卷烟纸在桌上，有火柴的烟鬼在吸烟，直到该烟鬼
 吸完烟拿走桌上材料才会继续</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<ul>
<li>问题模拟程序中4种角色，展示信标方法作用有限</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-05-29T16:38:54.000Z" title="5/30/2019, 12:38:54 AM">2019-05-30</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-05-29T16:38:54.000Z" title="5/30/2019, 12:38:54 AM">2019-05-30</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Data-Structure/">Data Structure</a></span><span class="level-item">8 minutes read (About 1166 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Data-Structure/tree_heap.html">Heap</a></h1><div class="content"><h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a><em>Heap</em></h2><p>堆/大根堆：每个节点包含一个键、且大于等于其子女键、基本完备
的二叉树</p>
<ul>
<li>认为非叶子节点自动满足大于其子女键值</li>
<li>根到某个叶子节点路径上，键值序列递减（允许键值相等则是
非递增）</li>
<li>键值之间没有从左到右的次序，即树的同一层节点间没有任何
关系，或者说<strong>左右子树</strong>之间没有任何关系</li>
</ul>
<h3 id="堆特性"><a href="#堆特性" class="headerlink" title="堆特性"></a>堆特性</h3><ul>
<li>完全二叉树特性参见<em>完全二叉树</em></li>
<li>堆的根总是包含了堆的最大元素</li>
<li>堆的节点及该节点子孙也是一个堆</li>
</ul>
<blockquote>
<ul>
<li>堆这种数据结构经常被用于实现优先队列</li>
</ul>
</blockquote>
<h3 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h3><p><em>min-heap</em>：（最大）堆的镜像</p>
<ul>
<li>堆的主要特性最小堆也满足，但<ul>
<li>最小堆根节点包含最小元素</li>
</ul>
</li>
<li>可通过给元素取反构造（最大）堆得到最小堆</li>
</ul>
<h2 id="堆算法"><a href="#堆算法" class="headerlink" title="堆算法"></a>堆算法</h2><h3 id="Bottom-Up-Heap-Construction"><a href="#Bottom-Up-Heap-Construction" class="headerlink" title="Bottom-Up Heap Construction"></a><em>Bottom-Up Heap Construction</em></h3><p>自底向上堆构造：先利用所有元素构造二叉树，从倒数第二层开始
修改使得整棵树满足堆要求</p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ul>
<li>将给定线性表对应为（初始化）一棵完全二叉树</li>
<li>对二叉树进行堆化，从最后父母节点开始、到根为止，算法检查
节点键是否满足大于等于其子女键<ul>
<li>若不满足，交换节点键K和其子女最大键值</li>
<li>在新位置上检查是否满足大于子女键值，直到满足为止</li>
</ul>
</li>
<li>对以当前节点为根的子树满足堆化条件后，算法对节点直接前趋
进行检查，直到树根满足堆化</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">HeapAdjust(H[<span class="number">0.</span>.n<span class="number">-1</span>], cur):</span><br><span class="line">	<span class="comment">// 左右子树已经为堆，仅根节点元素不一定满足</span></span><br><span class="line">	<span class="comment">// 输入：待调整堆H、根节点cur，cur左右子树已经为堆</span></span><br><span class="line">	<span class="comment">// 输入：调整后堆</span></span><br><span class="line">	<span class="keyword">while</span> <span class="number">2</span>*cur+<span class="number">2</span> &lt; n:</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取左右子女中最大者</span></span><br><span class="line">		<span class="keyword">if</span> <span class="number">2</span>*cur+<span class="number">2</span> &lt; n:</span><br><span class="line">			_tmp = argmax(H[<span class="number">2</span>*cur+<span class="number">1</span>], H[<span class="number">2</span>*cur+<span class="number">2</span>])</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			_tmp = <span class="number">2</span>*cur+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 交换自身和最大子女</span></span><br><span class="line">		<span class="keyword">if</span> H[_tmp] &gt; H[cur]:</span><br><span class="line">			swap(H[cur], H[_tmp])</span><br><span class="line">			cur = _tmp</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="comment">// 从底向上建堆，左、右子树均为堆</span></span><br><span class="line">			<span class="comment">// 则此时已经满足堆性质</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> H</span><br><span class="line"></span><br><span class="line">HeapBottomUp(H[<span class="number">0.</span>.n<span class="number">-1</span>]):</span><br><span class="line">	<span class="comment">// 用自底向上算法，从给定数组元素中构造一个堆</span></span><br><span class="line">	<span class="comment">// 输入：可排序数组H[0..n-1]</span></span><br><span class="line">	<span class="comment">// 输出：堆H[0..n-1]</span></span><br><span class="line">	<span class="keyword">for</span> i=<span class="built_in">floor</span>((n<span class="number">-1</span>)/<span class="number">2</span>) to <span class="number">0</span>:</span><br><span class="line">		HeapAdjust(H, i)</span><br><span class="line">	<span class="keyword">return</span> H</span><br></pre></td></tr></table></figure>
<h4 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li>算法效率<ul>
<li>时间效率：最差情况，每个位于树第i层节点会移到叶子层
h中，每次移动比较两次，则总键值比较次数
$C_{worst}=2(n-log_2(n+1))$
（将各层叶子节点可能交换次数加总即差比数列求和）</li>
</ul>
</li>
</ul>
<h3 id="Top-Down-Heap-Construction"><a href="#Top-Down-Heap-Construction" class="headerlink" title="Top-Down Heap Construction"></a><em>Top-Down Heap Construction</em></h3><p>自顶向下堆构造算法：先利用部分元素构建堆顶，把新键连续插入
已经构造好的堆末尾，修改使之满足堆要求</p>
<h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><ul>
<li>把包含键K的新节点附加在当前堆最后一个叶子节点</li>
<li>将K与其父母进行比较<ul>
<li>若后者大于K，算法停止</li>
<li>否则交换这两个键，并比较K和其新父母，直到K不大于其
父母或是达到了树根</li>
</ul>
</li>
</ul>
<h4 id="算法特点-1"><a href="#算法特点-1" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li>算法效率<ul>
<li>操作所需键值比较次数小于堆高度$h \approx log_2 n$，
则总比较次数$\in \Theta(nlogn)$</li>
</ul>
</li>
</ul>
<h3 id="删除堆根节点"><a href="#删除堆根节点" class="headerlink" title="删除堆根节点"></a>删除堆根节点</h3><h4 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h4><ul>
<li>根键和堆中最后一个键K交换</li>
<li>堆规模减1（删除原根键）</li>
<li>按照自底向上堆构造算法，把K沿着树向下筛选使得新树满足
堆化</li>
</ul>
<h4 id="算法特点-2"><a href="#算法特点-2" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li>算法效率<ul>
<li>效率取决于树堆化所需比较次数，不可能超过树高度两倍，
即$\in O(logn)$</li>
</ul>
</li>
</ul>
<h3 id="堆排序算法"><a href="#堆排序算法" class="headerlink" title="堆排序算法"></a>堆排序算法</h3><h4 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h4><ul>
<li>为给定数组构造堆</li>
<li>删除最大键，即对堆应用n-1此根删除操作</li>
</ul>
<h4 id="算法特点-3"><a href="#算法特点-3" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>算法效率</p>
<ul>
<li><p>根删除阶段算法所需比较次数</p>
<script type="math/tex; mode=display">\begin{align}
C(n) & \leq 2\sum_{i=1}^{n-1} \lfloor log_2i \rfloor \\
  & \leq 2 \sum_{i=1}^{n-1} log_2(n-1) \\
  & = 2(n-1)log_2(n-1)
\end{align}</script></li>
<li><p>两阶段总效率$\in O(nlogn)$</p>
</li>
<li>详细分析证明，无论最差情况、平均情况下，时间效率
$\in \Theta(nlogn)$</li>
</ul>
</li>
<li><p>堆排序时间效率和归并排序、快排时间效率属于同一类，但是
堆排序是在位的（不需要额外存储空间）</p>
</li>
<li><p>随机实验表明：堆排序比快排慢、和归并排序相比有竞争力</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-05-29T16:38:54.000Z" title="5/30/2019, 12:38:54 AM">2019-05-30</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-05-29T16:38:54.000Z" title="5/30/2019, 12:38:54 AM">2019-05-30</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">39 minutes read (About 5826 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/basic_strategies.html">算法设计策略</a></h1><div class="content"><h2 id="蛮力法"><a href="#蛮力法" class="headerlink" title="蛮力法"></a>蛮力法</h2><p>Brute Force：简单直接解决问题的方法，常常直接基于问题的描述
和所涉及的概念定义</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>蛮力法可以解决各种问题，实际上可能是唯一几乎可以解决所有
问题的方法</li>
<li>对某些重要问题，蛮力法可以产生合理算法，具备实用价值，
且不必限制实例规模</li>
<li>如果解决问题实例不多，蛮力法速度可接受，设计高效算法可能
不值得</li>
<li>蛮力法可以用于研究、教学目的，如：衡量同样问题其他更高效
算法</li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>因为基本所有问题都可以使用蛮力得到<strong>理论可行</strong>的解决方法，
所以这里只包含实际可行、有价值算法</p>
<ul>
<li>排序<ul>
<li>选择排序</li>
<li>冒泡排序</li>
</ul>
</li>
<li>查找<ul>
<li>顺序查找</li>
<li>蛮力字符串匹配</li>
</ul>
</li>
<li>几何<ul>
<li>最近对问题</li>
<li>凸包问题</li>
</ul>
</li>
<li>组合<ul>
<li>背包问题</li>
<li>旅行商问题</li>
<li>分配问题</li>
</ul>
</li>
<li>图处理<ul>
<li>深度优先搜索</li>
<li>广度优先搜索</li>
</ul>
</li>
</ul>
<h2 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a><em>Recursion</em></h2><blockquote>
<ul>
<li><em>reduction</em>：简化论，仅仅通过理解构成对象某一部分就可以
  理解整个对象</li>
<li><em>holism</em>：整体论，总体总比构成它的部分更为重要</li>
</ul>
</blockquote>
<p>递归：将大问题通过简化成相同形式的小问题来解决问题</p>
<ul>
<li>递归的思考需要从整体角度考虑</li>
<li>需要习惯于采用递归的稳步跳跃理念</li>
<li>关键在于如何正确的将原始问题分解为有效的子问题<ul>
<li>更加简单，且和原问题求解形式相同</li>
<li>最终能达到简单情况，并正确解决</li>
<li>能重新组合子问题的解得到原始问题的解</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><em>recursive leap of faith</em>：递归的稳步跳跃理念，任何更
  简单的递归调用将正确工作</li>
</ul>
</blockquote>
<h3 id="Recursive-Paradigm"><a href="#Recursive-Paradigm" class="headerlink" title="Recursive Paradigm"></a><em>Recursive Paradigm</em></h3><p>递归范型：递归函数体形式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(test <span class="keyword">for</span> simple <span class="keyword">case</span>)&#123;</span><br><span class="line">	<span class="comment">// 非递归解决简单问题</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 将问题简化为某种形式的子问题（一个或多个）</span></span><br><span class="line">	<span class="comment">// 递归调用函数解决每个子问题</span></span><br><span class="line">	<span class="comment">// 将子问题的解组合得到原问题的解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="返回值问题"><a href="#返回值问题" class="headerlink" title="返回值问题"></a>返回值问题</h3><ul>
<li><p>无返回值：没有返回值回退过程、处理函数</p>
<ul>
<li><strong>全局变量、引用参数记录结果</strong></li>
<li><strong>参数传递结果，最末栈直接使用</strong></li>
</ul>
</li>
<li><p>有返回值：有返回值回退过程</p>
<ul>
<li>可以完全类似无返回值函数调用，此时返回值无实际价值</li>
<li>也可以最终结果在初始主调函数中得到</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>不方便使用全局变量记录结果时，可以给<strong>真实递归调用函数</strong>
  添加记录结果的引用参数，外层包装其、提供实参</li>
<li>是否有返回值不是递归调用的关键，关键是<strong>是否继续调用</strong></li>
</ul>
</blockquote>
<h2 id="减治法"><a href="#减治法" class="headerlink" title="减治法"></a>减治法</h2><p><em>Decrease and Conquer</em>：利用问题给定实的解和同样问题较小
实例解之间某种关系，可以自底向上、自底向上的运用该关系</p>
<ul>
<li>自顶向下会自然导致递归算法，但是还是非递归实现较好</li>
<li>自底向上往往是迭代实现的，从求解问题较小实例开始</li>
</ul>
<p>减治法有3种主要变化形式</p>
<h3 id="Decrease-by-Constant"><a href="#Decrease-by-Constant" class="headerlink" title="Decrease-by-Constant"></a><em>Decrease-by-Constant</em></h3><p>减常量：每次算法迭代总是从实例中减去相同常量</p>
<ul>
<li><em>新问题规模 = 原问题规模 - constant</em></li>
<li>一般来说这个常量为1</li>
</ul>
<h3 id="Decrease-by-A-Contant-Factor"><a href="#Decrease-by-A-Contant-Factor" class="headerlink" title="Decrease-by-A-Contant-Factor"></a><em>Decrease-by-A-Contant-Factor</em></h3><p>减去常量因子：在算法迭代过程中总是减去相同的常数因子</p>
<ul>
<li><em>新问题规模 = 原问题规模 / constant-factor</em></li>
<li>常数因子一般为2</li>
</ul>
<h3 id="Variable-Size-Decrease"><a href="#Variable-Size-Decrease" class="headerlink" title="Variable-Size-Decrease"></a><em>Variable-Size-Decrease</em></h3><p>减可变规模：算法每次迭代时，规模减小模式不同</p>
<h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><ul>
<li><p>减常量法</p>
<ul>
<li>数值计算<ul>
<li>自顶向下递归计算指数</li>
<li>利用指数定义自底向上计算指数</li>
</ul>
</li>
<li>排序<ul>
<li>插入排序</li>
<li>希尔排序</li>
</ul>
</li>
<li>图问题<ul>
<li>拓扑排序</li>
</ul>
</li>
<li>组合<ul>
<li>生成排列</li>
<li>生成子集</li>
</ul>
</li>
</ul>
</li>
<li><p>减常因子法</p>
<ul>
<li>数值计算<ul>
<li>递归的计算$a^{n/2}$计算指数</li>
<li>俄式乘法</li>
<li>约瑟夫斯问题</li>
</ul>
</li>
<li>查找<ul>
<li>数值问题</li>
</ul>
</li>
</ul>
</li>
<li><p>减可变规模</p>
<ul>
<li>数值计算<ul>
<li>计算最大公约数的欧几里得算法<script type="math/tex; mode=display">gcd(m, n) = gcd(n, m mod n)</script></li>
</ul>
</li>
<li>排序<ul>
<li>顺序统计量</li>
</ul>
</li>
<li>查找<ul>
<li>差值查找</li>
<li>二叉查找树</li>
</ul>
</li>
<li>组合<ul>
<li>拈游戏</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><p><em>Divide-and-Conquer</em></p>
<ul>
<li>将问题划分为同一类型的若干子问题，子问题规模最好相同</li>
<li>对子问题求解<ul>
<li>一般使用递归方法</li>
<li>规模足够小时，有时也会利用其他算法</li>
</ul>
</li>
<li>有必要则合并子问题的解得到原始问题答案</li>
</ul>
<h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><ul>
<li>查找<ul>
<li>求解二叉树高度</li>
<li>遍历二叉树</li>
</ul>
</li>
<li>数值计算<ul>
<li>大整数乘法</li>
<li>Strassen矩阵乘法</li>
</ul>
</li>
<li>几何<ul>
<li>最近对问题</li>
<li>凸包问题</li>
</ul>
</li>
</ul>
<h2 id="变治法"><a href="#变治法" class="headerlink" title="变治法"></a>变治法</h2><blockquote>
<ul>
<li>输入增强</li>
<li>时空权衡</li>
</ul>
</blockquote>
<p>变治法分成两个阶段工作</p>
<ul>
<li>“变”：出于某种原因，把问题实例变得容易求解</li>
<li>“治”：对实例问题进行求解</li>
</ul>
<p>根据对问题的变换方式，可以分为3类</p>
<h3 id="Instance-Simplification"><a href="#Instance-Simplification" class="headerlink" title="Instance Simplification"></a><em>Instance Simplification</em></h3><p>实例化简：变换为同样问题的更简单、更方便的实例</p>
<ul>
<li>预排序：</li>
</ul>
<h3 id="Representation-Change"><a href="#Representation-Change" class="headerlink" title="Representation Change"></a><em>Representation Change</em></h3><p>改变表现：变换为同样实例不同表现</p>
<h3 id="problem-reduction"><a href="#problem-reduction" class="headerlink" title="problem reduction"></a><em>problem reduction</em></h3><p>问题化简：变换为算法已知的另一个问题的实例</p>
<h3 id="典例"><a href="#典例" class="headerlink" title="典例"></a>典例</h3><ul>
<li><p>排序</p>
<ul>
<li>预排序（线性表）<ul>
<li>比较计数排序</li>
<li>分布计数排序</li>
</ul>
</li>
</ul>
</li>
<li><p>查找</p>
<ul>
<li>预排序<ul>
<li>检验线性表唯一性</li>
<li>寻找线性表众数</li>
<li>查找线性表中元素</li>
</ul>
</li>
<li>字符串模式增强<ul>
<li><em>Horspool</em>算法</li>
<li><em>Boyer-Moore</em>算法</li>
<li><em>KMP</em>算法</li>
<li>最长公共子串</li>
</ul>
</li>
</ul>
</li>
<li><p>数值</p>
<ul>
<li>高斯消元法<ul>
<li>前向消去法</li>
<li>部分选主元法</li>
<li>反向替换法</li>
</ul>
</li>
<li>数值计算<ul>
<li>霍纳法则</li>
<li>二进制（计算）幂</li>
<li>欧几里得算法</li>
</ul>
</li>
<li>极大、极小值转换</li>
<li>极值转换为求导数为0点</li>
<li>线性规划：在极点求解</li>
<li>整数规划</li>
</ul>
</li>
<li><p>图</p>
<ul>
<li>把问题转换为状态图求解</li>
</ul>
</li>
<li><p>Hash（散列）</p>
</li>
</ul>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p><em>Dynamic Programming</em>：记录、再利用子问题结果</p>
<ul>
<li><p>记录子问题解，试图避免不必要、重复子问题求解</p>
<ul>
<li>否则就是普通递归，不能避免重复求解</li>
<li>或者说动态规划就是<strong>普通递归+子问题解记录</strong></li>
</ul>
</li>
<li><p>适合解决的问题特点</p>
<ul>
<li><p><strong>离散</strong>最优化问题：如递推关系中包含<em>max</em>、<em>min</em>、
<em>sum</em>等，递推式中</p>
<ul>
<li><strong>因变量</strong>待求解最优化问题</li>
<li><strong>自变量</strong>则为问题中涉及的离散变量</li>
</ul>
</li>
<li><p><strong>交叠</strong>子问题构成复杂问题，需遍历比较</p>
</li>
<li><p>问题具有<strong>最优子结构</strong>，由<em>最优解定理</em>，最优解由
子问题最优解构成</p>
</li>
</ul>
</li>
</ul>
<h3 id="求解空间"><a href="#求解空间" class="headerlink" title="求解空间"></a>求解空间</h3><p>求解空间：问题涉及的两个、多个取离散值变量，根据递推关系考虑
<strong>离散变量待求解问题可能组合</strong></p>
<ul>
<li><p>离散变量包括</p>
<ul>
<li>明显离散列表</li>
<li><strong>因变量限制条件</strong></li>
</ul>
</li>
<li><p>可利用变量间限制条件组合因变量</p>
<ul>
<li>默认各变量组合是笛卡尔积</li>
<li>由于限制条件可以减少变量组合取值数量</li>
</ul>
</li>
<li><p>某变量可能为其他变量提供搜索空间</p>
<ul>
<li>即其<strong>每个取值均需</strong>和其他变量组合、搜索</li>
<li>此时可以不将其计入求解变量、动态规划表，而是遍历其
（如：找零问题中零钱）</li>
</ul>
</li>
</ul>
<h3 id="递推式、递推关系"><a href="#递推式、递推关系" class="headerlink" title="递推式、递推关系"></a>递推式、递推关系</h3><p>递推式、递推关系：将原问题分解为较小、交叠子问题的方法</p>
<ul>
<li><p>动态规划递推中包含重要思想<strong>有序组合</strong></p>
<ul>
<li><p>有序<strong>剔除遍历</strong>相关变量，一般单向剔除，有些变量需要
考虑双向，视为两个有约束条件的独立变量
（如：最优二叉树）</p>
</li>
<li><p>因为只需要求解全集最优解，所以只需要考虑
<strong>部分有序子集</strong>，直观类比<strong>矩阵可逆</strong>只需要判断
<strong>顺序主子式</strong></p>
</li>
</ul>
</li>
<li><p>原问题解可能无法直接得到递推关系</p>
<ul>
<li><p>原始问题非求数值解</p>
<ul>
<li>应该寻找数值中间解构建递推关系，</li>
<li>再利用动态规划表得到最终解（最长子序列）</li>
</ul>
</li>
<li><p>原始问题是求<strong>宽松范围解即解不要求包含断点</strong>的解</p>
<ul>
<li>以<strong>各个元素分别作为端点</strong>的解构建递推关系</li>
<li>以最优者即为宽松范围解（最长子序列）</li>
</ul>
</li>
</ul>
</li>
<li><p>递推式中应优先考虑限制条件：减少搜索空间</p>
<ul>
<li>单个自变量限制条件</li>
<li><strong>两端都需要变化的变量视为两个独立、相互约束变量</strong></li>
</ul>
</li>
</ul>
<h3 id="动态规划表"><a href="#动态规划表" class="headerlink" title="动态规划表"></a>动态规划表</h3><p>动态规划表：存储已求解交叠子问题解，相同问题查表避免重复求解</p>
<ul>
<li><p>动态规划表结构</p>
<ul>
<li>n维结构化数据表（常用）<ul>
<li>n为自变量数量（组合变量视为单个变量）</li>
<li>每维对应某离散变量</li>
</ul>
</li>
<li><strong>字典</strong>：适合自顶向下动态规划</li>
</ul>
</li>
<li><p>求解问题时</p>
<ul>
<li>将问题分解为交叠子问题</li>
<li>先查动态规划表，尝试从表中得到问题解，否则求解问题，
记录于动态规划表</li>
<li>并用于求解更大规模问题，直至原问题求解完成</li>
</ul>
</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="自底向上（经典）"><a href="#自底向上（经典）" class="headerlink" title="自底向上（经典）"></a>自底向上（经典）</h4><p>自底向上：求解给定问题所有较小子问题，最终得到的原始问题解</p>
<ul>
<li><p>计算用<strong>所有</strong>小问题解、填充动态规划表格</p>
<ul>
<li>常逐行、逐列填充动态表（求解子问题）</li>
<li>一般<strong>先填充初始化变量对应维度（即位于内部循环）</strong><ul>
<li>先初始化行，在初始化列过程中可以在循环中填充行</li>
<li>先初始化列，在初始化行过程中可以在循环中填充列</li>
</ul>
</li>
<li><strong>循环</strong>保证所需子问题已经求解完毕</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>自底向上没有对问题整体的全局把握，必须求解全部子问题</li>
<li>无需递归栈空间</li>
</ul>
</li>
</ul>
<h4 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h4><p>自顶向下：整体把握原始问题，只计算对求解原问题的有必要子问题</p>
<ul>
<li><p>用自顶向下方式求解给定问题</p>
<ul>
<li>先将问题分解子问题</li>
<li>求解必要的子问题<ul>
<li>先检查相应动态规划表中该问题是否已求解，</li>
<li>否则求解子问题，记录解于动态规划表</li>
</ul>
</li>
<li>所有子问题求解完毕，回溯得到原问题解</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>整体把握问题整体，避免求解不必要子问题</li>
<li>需要通过回溯（递归栈）得到问题最优解的构成</li>
</ul>
</li>
</ul>
<h3 id="Principle-of-Optimality"><a href="#Principle-of-Optimality" class="headerlink" title="Principle of Optimality"></a><em>Principle of Optimality</em></h3><p>最优化法则：最优化问题的任一实例的最优解，都是由其子问题实例
的最优解构成</p>
<ul>
<li><p>最优化法则在大多数情况下成立，但也存在少数例外：寻找图
中最长简单路径</p>
</li>
<li><p>在动态规划算法中，可以方便检查最优化法则是否适用</p>
</li>
</ul>
<blockquote>
<ul>
<li>动态规划的大多数应用都是求解最优化问题</li>
</ul>
</blockquote>
<h3 id="典例-1"><a href="#典例-1" class="headerlink" title="典例"></a>典例</h3><ul>
<li>组合问题<ul>
<li>币值最大化问题</li>
<li>找零问题</li>
<li>硬币问题</li>
<li>背包问题</li>
<li>最优二叉查找树</li>
<li>最长公共子序列</li>
</ul>
</li>
<li>查找问题<ul>
<li>字符串<ul>
<li>最长上升子序列</li>
<li>最长公共字串</li>
<li>编辑距离</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="贪婪技术"><a href="#贪婪技术" class="headerlink" title="贪婪技术"></a>贪婪技术</h2><p>贪婪法：通过一系列步骤构造问题的解，每步对目前构造的部分解
作扩展，直到得到问题的完整解</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li><p>只能应用于最优问题，但可以作为一种通用设计技术</p>
</li>
<li><p>贪婪法每步条件</p>
<ul>
<li><em>feasible</em>：必须可行，满足问题约束</li>
<li><em>locally optimal</em>：是当前所有步骤中所有可行选择的
最佳局部选择</li>
<li><em>irrevocable</em>：选择一旦做出不能更改</li>
</ul>
</li>
<li><p>希望通过通过一系列局部最优选择产生全局最优解</p>
<ul>
<li>有些问题能够通过贪婪算法获得最优解</li>
<li>对于无法通过贪婪算法获得最优解的问题，如果满足于、
关心近似解，那么贪婪算法依然有价值</li>
</ul>
</li>
</ul>
<h3 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h3><p>证明贪婪算法能够获得全局最优解方法</p>
<ul>
<li><p>数学归纳法</p>
</li>
<li><p>证明在接近目标过程中，贪婪算法每步至少不比其他任何算法差</p>
</li>
<li><p>基于算法的输出、而不是算法操作证明贪婪算法能够获得最优解</p>
</li>
</ul>
<h3 id="拟阵"><a href="#拟阵" class="headerlink" title="拟阵"></a>拟阵</h3><h3 id="典例-2"><a href="#典例-2" class="headerlink" title="典例"></a>典例</h3><ul>
<li><p>图</p>
<ul>
<li>Prim算法</li>
<li>Kruskal算法</li>
<li>Dijkstra算法</li>
</ul>
</li>
<li><p>组合</p>
<ul>
<li>哈夫曼树（编码）</li>
</ul>
</li>
</ul>
<h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><p><em>Backtracing</em>：每次只构造解的一个满足约束<strong>分量</strong>，然后评估
此<strong>部分构造解</strong></p>
<ul>
<li><p>尝试对部分构造解进行<strong>进一步</strong>构造（构造下个分量），若
存在不违反问题约束的下个分量，则接受<strong>首个</strong>合法选择</p>
</li>
<li><p>若无法得到下个分量合法选择，则不必考虑之后分量，此时进行
回溯，将部分构造解最后一个分量替换为下个选择</p>
</li>
</ul>
<blockquote>
<ul>
<li>回溯法核心就是对状态空间树进行剪枝，忽略无法产生解的分支</li>
</ul>
</blockquote>
<h3 id="适合问题"><a href="#适合问题" class="headerlink" title="适合问题"></a>适合问题</h3><ul>
<li><p>适合处理含有约束条件、困难的组合问题</p>
<ul>
<li>往往只需要求出<em>feasible solution</em></li>
<li>问题往往有精确解，但是没有高效算法求解</li>
</ul>
</li>
<li><p>回溯法目标是最终输出：n元组$(x_1, x_2, \cdots, x_n)$</p>
<ul>
<li>其中元素$x_i$为有限线性集$S_i$的一个元素</li>
<li>元组可能需要满足额外约束</li>
</ul>
</li>
</ul>
<h3 id="状态空间树"><a href="#状态空间树" class="headerlink" title="状态空间树"></a>状态空间树</h3><ul>
<li><p>回溯法会显式、隐式的生成一棵空间状态树</p>
<ul>
<li><p>树根表示查找解之前的初始状态</p>
</li>
<li><p>树的第$i$层节点表示对第$i$个分量的选择</p>
<ul>
<li>应该、可以认为是经过$i$次<strong>可能</strong>选择后的由$i$个
元素组成的解分量整体$(x_1, x_2, \cdots, x_i)$</li>
</ul>
</li>
<li><p>叶子节点</p>
<ul>
<li>在<strong>完整树</strong>中为<strong>无希望解分量、完整解</strong>之一</li>
<li>构造中的树为<strong>无希望分量、未处理解分量</strong>之一</li>
</ul>
</li>
</ul>
</li>
<li><p>大部分情况下，回溯算法的状态空间树按照深度优先方式构造</p>
<ul>
<li><p>如果当前节点（解分量）有希望，向解分量添加
<strong>下个分量下个选择</strong>得到新的节点，处理新节点</p>
</li>
<li><p>如果当前节点无希望，回溯到节点父母重新处理</p>
</li>
</ul>
</li>
</ul>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Backtrack(X[<span class="number">1.</span>.i])</span><br><span class="line">	<span class="comment">// 回溯算法通用模板</span></span><br><span class="line">	<span class="comment">// 输入：X[1..i]一个解的前i个有希望的分量</span></span><br><span class="line">	<span class="comment">// 输出；代表问题解的所有元组</span></span><br><span class="line">	<span class="keyword">if</span> X[<span class="number">1.</span>.i] 是一个解</span><br><span class="line">		write X[<span class="number">1.</span>.i]</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">for</span> 满足约束的x \in S_&#123;i+<span class="number">1</span>&#125; <span class="keyword">do</span></span><br><span class="line">			<span class="comment">// 不符合约束的不处理，即回溯</span></span><br><span class="line">			<span class="comment">// 符合约束则继续深度优先搜索</span></span><br><span class="line">			X[i+<span class="number">1</span>] = x</span><br><span class="line">			Backtrack(X[<span class="number">1.</span>.i+<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h4 id="Promising"><a href="#Promising" class="headerlink" title="Promising"></a>Promising</h4><blockquote>
<ul>
<li><em>Promising</em>：有希望，当前解分量（节点）仍然有可能导致
  完整解，满足<blockquote>
<ul>
<li>当前解分量符合约束：新添加分量个体约束、解分量整体
 约束</li>
<li>当前解分量节点仍有未处理的子女节点</li>
</ul>
</blockquote>
</li>
<li><em>Nonpromising</em>：没希望，当前解分量不满足有希望两个条件
  ，无法导致完整解</li>
</ul>
</blockquote>
<p>注意：有希望不能采用递归定义：是否有希望是当前状态的结果，
当时并不知道、不需要知道子女状态（是否有希望）</p>
<h4 id="约束判断位置"><a href="#约束判断位置" class="headerlink" title="约束判断位置"></a>约束判断位置</h4><p>处理节点时，对子女的约束条件有两种说法</p>
<ul>
<li><p><em>添加下个分量满足约束的选择</em>：这里是将约束<strong>说法上</strong>提前
考虑</p>
<ul>
<li>此说法可能适合约束只需要考虑最后分量的情况</li>
<li>此种情况下的<em>有希望</em>只需要满足：解分量节点有未处理、
合法子女</li>
<li>是这里回溯法部分的说法</li>
</ul>
</li>
<li><p><em>添加下个分量下个选择</em>：这里是将约束<strong>说法上</strong>延后考虑</p>
<ul>
<li>此说法可能适合约束需要考虑解分量整体的情况</li>
<li>此种情况下的<em>有希望</em>就是前面条件</li>
<li>是这里状态空间树的说法</li>
</ul>
</li>
<li><p>但其实两者是一样的，只是说法不同</p>
<ul>
<li><p>前一个说法绘制状态空间树也同样需要
<em>*绘制不满足约束的节点</em></p>
</li>
<li><p>后一个说法也不定会直接把元素添加解分量中</p>
</li>
</ul>
</li>
</ul>
<h3 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h3><ul>
<li><p>回溯法时间效率不稳定，无法保证优良性能</p>
<ul>
<li><p>回溯法对状态空间树剪枝，是对穷举法的改进，避免考虑
某些无效解</p>
</li>
<li><p>回溯法在最坏情况下必须生成指数、甚至更快增长的状态
空间中所有解</p>
</li>
<li><p>但回溯法至少可以期望在期望时间能，对规模不是很小的
问题在可接受时间内求解</p>
</li>
<li><p>即使回溯法没能消去状态空间中任何元素，其依然提供了
一种特定的解题方法，方法本身就有价值</p>
</li>
</ul>
</li>
<li><p>回溯法状态空间树规模基本不能通过分析法求解</p>
<ul>
<li><p>可以通过生成一条根到叶子的随机路径，按照生成路径中
不同选择的数量${c_i, i=1,2,\cdots,n}$信息估计规模</p>
</li>
<li><p>树节点数量为:$1 + \sum<em>{i=1}^n \prod</em>{j=1}^i c_j$</p>
</li>
<li><p>可以多做几次估计取平均值</p>
</li>
</ul>
</li>
<li><p>有些技巧可以用于缩小状态空间规模</p>
<ul>
<li><p>组合问题往往有对称性，如：n皇后问题中第个皇后只需要
考虑前一半位置</p>
</li>
<li><p>把值预先分配给解的分量</p>
</li>
<li><p>预排序</p>
</li>
</ul>
</li>
</ul>
<h2 id="分支界限法"><a href="#分支界限法" class="headerlink" title="分支界限法"></a>分支界限法</h2><p>分支界限法：类似于回溯法，但是用于求<em>optimal solution</em></p>
<ul>
<li><p>在回溯法的基础上，比较<strong>叶子节点边界值</strong>、目前最优解</p>
<ul>
<li><p>叶子边界值：节点对应部分解向量衍生的解集合在目标函数
值上的最优边界</p>
</li>
<li><p>对最小化问题，边界值为下界；对最大化问题，边界值为
上界</p>
</li>
</ul>
</li>
<li><p>类似于在回溯法的约束条件中增加：节点最优边界必须超越当前
最优值</p>
<ul>
<li>随着深度增加，节点最优边界逐渐紧密，节点更容易被终止</li>
</ul>
</li>
<li><p>分支界限法适合问题、算法特点类似回溯法</p>
</li>
</ul>
<h3 id="状态空间树-1"><a href="#状态空间树-1" class="headerlink" title="状态空间树"></a>状态空间树</h3><p>分支界限空间树和节点生成顺序有关</p>
<ul>
<li><p><em>best-first branch-and-bound</em>：最佳优先分支边界策略，
在当前树未终止<strong>叶子</strong>中，选择拥有最佳边界的节点作为最有
希望节点，优先处理</p>
<ul>
<li>最优边界比较范围是<strong>全局比较</strong>，不仅仅局限于</li>
<li>这种策略可能会得到较好的结果，消除更多分支，甚至有时
只需计算一个完整解元组就能消除其他所有分支</li>
<li>当然，最优解最终可能属于其他分支，这种策略也不一定
能够加速算法</li>
</ul>
</li>
<li><p>顺序策略：类似于回溯法，优先处理最近、有希望节点</p>
</li>
</ul>
<h3 id="边界函数"><a href="#边界函数" class="headerlink" title="边界函数"></a>边界函数</h3><p>发现好的边界函数比较困难</p>
<ul>
<li>希望函数容易计算，否则得不偿失</li>
<li>函数不能过于简单，否则无法得到紧密边界，尽可能削剪状态
空间树分支</li>
<li>需要对具体问题各个实例进行大量实验，才能在两个矛盾的要求
之间达到平衡</li>
</ul>
<h2 id="迭代策略"><a href="#迭代策略" class="headerlink" title="迭代策略"></a>迭代策略</h2><p>迭代策略：从某些可行解出发，通过重复应用一些简单步骤不断改进</p>
<ul>
<li>这些步骤会通过一些小的、局部的改变生成新可行解</li>
<li>并使得目标函数更加优化</li>
<li>当目标函数无法再优化时，把最后可行解返回</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li><p>需要一个初始可行解</p>
<ul>
<li>平凡解</li>
<li>其他算法（贪婪算法）得到近似解</li>
<li>有些问题得到初始可行解也不简单</li>
</ul>
</li>
<li><p>对可行解的改变需要考虑</p>
</li>
<li><p>局部极值问题</p>
</li>
</ul>
<h2 id="NP-Hard近似算法"><a href="#NP-Hard近似算法" class="headerlink" title="NP-Hard近似算法"></a>NP-Hard近似算法</h2><p>NP-Hard组合优化问题即使是分支界限法也不能保证优良性能，考虑
使用近似算法快速求解</p>
<ul>
<li>近似算法往往是基于特定问题的启发式算法</li>
<li>有些应用不要求最优解，较优解可能足够</li>
<li>且实际应用中常常处理不精确的数据，这种情况近似解更合适</li>
</ul>
<blockquote>
<ul>
<li><em>Heuristic Algorithm</em>：启发式算法，来自于经验而不是数学
  证明的<em>经验规则</em></li>
</ul>
</blockquote>
<h3 id="Perfermance-Ratio"><a href="#Perfermance-Ratio" class="headerlink" title="Perfermance Ratio"></a>Perfermance Ratio</h3><p>算法性能比：$R_A = \min{c|{r(s_a) \leqslant c}$</p>
<ul>
<li><p>$r(s_a) = \frac {f(s_a} {f(s^{<em>})}$：优化函数$f$在近似解
$s_a$下的</em>accuracy ratio*</p>
<ul>
<li>这里$f$为最小化问题</li>
<li>若$f$为最大化问题，则取倒数使得精确率总大于1</li>
<li>比值越接近1，近似解质量越高</li>
</ul>
</li>
<li><p>$R_A$即为：问题所有实例中，最差（大）精确率</p>
<ul>
<li>有些问题没有有限性能比的近似算法，如：旅行商问题
（除非$P = NP$）</li>
</ul>
</li>
<li><p>$R_A$是衡量近似算质量的主要指标</p>
<ul>
<li>需要寻找的是$R_A$接近1的算法</li>
<li>某些简单算法性能比趋于$\infty$，这些算法也可以使用，
只是需要注意其输出</li>
<li>算法也被称为$R_A$近似算法</li>
</ul>
</li>
</ul>
<h4 id="旅行商问题无有限近似比算法"><a href="#旅行商问题无有限近似比算法" class="headerlink" title="旅行商问题无有限近似比算法"></a>旅行商问题无有限近似比算法</h4><ul>
<li><p>若存在有限近似比算法，则
$\exists c, f(s_a) \leqslant cf(s^{*})$</p>
</li>
<li><p>将哈密顿回路问题图G变换为旅行商图$G^{‘}$，G中原有边距离
为1，不存在边距离为$cn+1$</p>
</li>
<li><p>近似算法能在多项式时间内生成解
$s_a, f(s_a) \leqslant cf(s^{*}) = cn$，</p>
<ul>
<li>若存在哈密顿回路，则旅行商问题中最优解$s^{*} = n$</li>
<li>否则，旅行商问题最优解$s^{*} &gt; cn+1$</li>
</ul>
</li>
<li><p>则近似算法能在多项式时间解决哈密顿回路问题，而哈密顿回路
问题为NPC问题，除非$P = NP$</p>
</li>
</ul>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li><p>虽然大多数NP-Hard问题的精确求解算法，对于可在多项式时间
相互转换问题难度级别相同，但是近似算法不是，某些问题的
求良好近似解比其他问题简单的多</p>
<ul>
<li>因为近似算法是基于特定问题的，不具有普遍性</li>
</ul>
</li>
<li><p>某些组合优化难题具有特殊的实例类型，这些类型在实际应用
中比较重要，而且也容易求解</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-05-25T11:55:48.000Z" title="5/25/2019, 7:55:48 PM">2019-05-25</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-02T09:30:14.000Z" title="8/2/2021, 5:30:14 PM">2021-08-02</time></span><span class="level-item"><a class="link-muted" href="/categories/Database/">Database</a></span><span class="level-item">23 minutes read (About 3403 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Database/optimizer_physical.html">物理查询优化</a></h1><div class="content"><h2 id="查询代价估算"><a href="#查询代价估算" class="headerlink" title="查询代价估算"></a>查询代价估算</h2><h3 id="代价模型"><a href="#代价模型" class="headerlink" title="代价模型"></a>代价模型</h3><p>代价估计模型：基于CPU代价、IO代价</p>
<script type="math/tex; mode=display">\begin{align*}
总代价 &= IO代价 + CPU代价 \\
COST &= P * CPUTimePerPage + W * T
\end{align*}</script><blockquote>
<ul>
<li>$P$：计划访问的页面数</li>
<li>$CPUTimePerPage$：读取每个页面的时间花费</li>
<li>$T$：访问的元组数，索引扫描应包括索引读取花费<blockquote>
<ul>
<li>反映CPU代价，因为访问页面上的元组需要解析元组结构，
 消耗CPU</li>
</ul>
</blockquote>
</li>
<li>$W$：<em>selectivity</em>，选择率/权重因子，表明IO、CPU的相关性</li>
</ul>
</blockquote>
<h3 id="Selectivity"><a href="#Selectivity" class="headerlink" title="Selectivity"></a><em>Selectivity</em></h3><p>选择率：在关系R中，满足<strong>条件</strong><code>A &lt;cond_op&gt; a</code>的元组数R和
所有元组数N的比值</p>
<ul>
<li>在CBO中占有重要地位</li>
<li>其精确程度直接影响最优计划的选择</li>
</ul>
<h4 id="估计方法"><a href="#估计方法" class="headerlink" title="估计方法"></a>估计方法</h4><ul>
<li><p><em>Non-Parametric Method</em>：非参方法，使用ad-hoc数据结构、
直方图维护属性值分布</p>
</li>
<li><p><em>Parametric Method</em>：参数方法，使用预先估计的分布函数
逼近真实分布</p>
</li>
<li><p><em>Curve Fitting</em>：曲线拟合法，使用多项式函数、最小标准差
逼近属性值分布</p>
</li>
<li><p><em>Sampling</em>：抽样法，从数据库中抽取部分元组，针对样本进行
查询，收集统计数据</p>
<ul>
<li>需要足够多样本被测试才能达到足够精度</li>
</ul>
</li>
<li><p>综合法</p>
</li>
</ul>
<h2 id="单表扫描算法"><a href="#单表扫描算法" class="headerlink" title="单表扫描算法"></a>单表扫描算法</h2><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h2 id="两表联接算法"><a href="#两表联接算法" class="headerlink" title="两表联接算法"></a>两表联接算法</h2><h1 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h1><h3 id="Nested-Loop"><a href="#Nested-Loop" class="headerlink" title="Nested Loop"></a><em>Nested Loop</em></h3><p>嵌套循环联接算法：扫描外表，读取记录根据<code>join</code>字段上的
<strong>索引</strong>去内表中查询</p>
<ul>
<li>适合场景<ul>
<li>外表记录较少（&lt;1w）</li>
<li>内表已经创建索引、性能较好</li>
<li>inner、left outer、left semi、left antisemi join</li>
</ul>
</li>
</ul>
<h4 id="嵌套循环联接算法"><a href="#嵌套循环联接算法" class="headerlink" title="嵌套循环联接算法"></a>嵌套循环联接算法</h4><ul>
<li>搜索时扫描整个表、索引</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each row R1 in the outer table:</span><br><span class="line">	<span class="keyword">for</span> each row R2 in the inner table:</span><br><span class="line">		<span class="keyword">if</span> R1 join with R2:</span><br><span class="line">			<span class="keyword">return</span> (R1, R2)</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>外部循环逐行消耗外部输入表，当其数据量很大时可以并行扫描
  内表</li>
<li>内表被外表驱动：内部循环为每个外部行执行，在内表中搜索
  匹配行</li>
</ul>
</blockquote>
<h4 id="基于块嵌套循环联接算法"><a href="#基于块嵌套循环联接算法" class="headerlink" title="基于块嵌套循环联接算法"></a>基于块嵌套循环联接算法</h4><ul>
<li>每次IO申请以“块”为单位尽量读入多个页面</li>
<li>改进获取元组的方式</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each chunk c1 of t1</span><br><span class="line">	<span class="keyword">if</span> c1 <span class="keyword">not</span> in memory:</span><br><span class="line">		read chunk c1 to memory</span><br><span class="line">	<span class="keyword">for</span> each row r1 in chunk c1:</span><br><span class="line">		<span class="keyword">for</span> each chunk c2 of t2:</span><br><span class="line">			<span class="keyword">if</span> c2 <span class="keyword">not</span> in memory:</span><br><span class="line">				read chunk c2 into memory</span><br><span class="line">			<span class="keyword">for</span> each row r2 in c2:</span><br><span class="line">				<span class="keyword">if</span> r1 join with r2:</span><br><span class="line">					<span class="keyword">return</span>(R1, R2)</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>内存循环最后一个块使用后作为下次循环循环使用的第一个块
  可以节省一次IO</li>
</ul>
</blockquote>
<h4 id="索引嵌套循环联接算法"><a href="#索引嵌套循环联接算法" class="headerlink" title="索引嵌套循环联接算法"></a>索引嵌套循环联接算法</h4><ul>
<li>索引嵌套循环连结：在内表中搜索时使用索引，可以加快联接
速度</li>
<li>临时索引嵌套循环连结：为查询临时生成索引作为查询计划的
一部分，查询完成后立刻将索引破坏</li>
</ul>
<h3 id="Sort-Merge-Join"><a href="#Sort-Merge-Join" class="headerlink" title="(Sort)Merge Join"></a><em>(Sort)Merge Join</em></h3><p>排序归并联接算法</p>
<ul>
<li>适合场景<ul>
<li>联接字段已经排序，如B+树索引</li>
<li>inner、left outer、left semi、left anti semi、
right outer、right semi、right anti semi join、union</li>
<li>等值、非等值联接，除<code>!=/&lt;&gt;</code></li>
</ul>
</li>
</ul>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>确保两个关联表都是按照关联字段进行排序</p>
<ul>
<li>若关联字段已经有排序一致的可用索引，可以利用索引直接
进行merge join操作</li>
<li>否则先对关联字段进行排序，表过大无法一次载入内存时
需要分块载入</li>
</ul>
</li>
<li><p>从每个表分别取记录开始匹配（升序）</p>
<ul>
<li>若符合关联条件，放入结果集</li>
<li>否则丢关联字段较小记录，取对应表中下条记录继续
匹配，直到整个循环结束</li>
<li>对于多对join，通常需要使用临时表进行操作<h1 id="todo-1"><a href="#todo-1" class="headerlink" title="todo"></a>todo</h1></li>
</ul>
</li>
</ul>
<h3 id="Hash-Join"><a href="#Hash-Join" class="headerlink" title="Hash Join"></a><em>Hash Join</em></h3><p>哈希联接：利用Hash Match联接</p>
<ul>
<li><p>HJ处理代价非常高，是服务器内存、CPU头号杀手，需要对数据
进行分区时，还会造成大量异步磁盘I/O，避免大数据的HJ，
尽量转化为高效的SMJ、NLJ</p>
<ul>
<li>表结构设计：冗余字段</li>
<li>索引调整设计</li>
<li>SQL优化</li>
<li>冗余表：静态表存储统计结果</li>
</ul>
</li>
<li><p>类似任何hash算法，内存小、数据偏斜严重时，散列冲突会比较
严重，此时应该考虑使用NIJ</p>
</li>
<li><p>适合场景</p>
<ul>
<li>两表数据量相差非常大</li>
<li>对CPU消耗明显，需要CPU资源充足</li>
<li>只适合（不）等值查询</li>
</ul>
</li>
</ul>
<h4 id="In-Memory-Hash-Join"><a href="#In-Memory-Hash-Join" class="headerlink" title="In-Memory Hash Join"></a><em>In-Memory Hash Join</em></h4><p><img src="/imgs/db_hash_join.png" alt="db_hash_join"></p>
<h5 id="build阶段"><a href="#build阶段" class="headerlink" title="build阶段"></a><em>build</em>阶段</h5><p>以操作涉及字段为hash key构造hash表</p>
<ul>
<li><p>从构造输入表中取记录，使用hash函数生成hash值</p>
</li>
<li><p>hash值对应hash表中的buckets，若一个hash值对应多个桶，
则使用链表将联接桶</p>
</li>
<li><p>构造输入表处理完毕之后，其中记录都被桶关联</p>
</li>
</ul>
<blockquote>
<ul>
<li>build表构建的hash表需要频繁访问，最好能全部加载在内存中
  ，因此尽量选择小表，避免使用GHJ</li>
</ul>
</blockquote>
<h5 id="probe阶段"><a href="#probe阶段" class="headerlink" title="probe阶段"></a><em>probe</em>阶段</h5><ul>
<li><p>从探测输入中取记录，使用同样hash函数生成hash值</p>
</li>
<li><p>根据hash值，在构造阶段构造的hash表中搜索对应桶</p>
</li>
</ul>
<blockquote>
<ul>
<li>为避免冲突，bucket可能会联接到其他bucket，探测操作
  会搜索整个冲突链上的buckets查找匹配记录</li>
</ul>
</blockquote>
<h5 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h5><p>以下操作内部实现其实都是hash join，只是对应算符不同而已</p>
<ul>
<li><p>join操作</p>
<ul>
<li>使用join字段计算hash值</li>
<li>使用<strong>顶端输入</strong>构造hash表，<strong>底端输入</strong>进行探测</li>
<li>按照联接类型规定的模式输出（不）匹配项</li>
<li>若多个联接使用相同的联接列，这些操作将分组为一个
哈希组</li>
</ul>
</li>
<li><p>grouby操作、unique操作</p>
<ul>
<li>使用groupby字段、所有select字段计算hash值</li>
<li>使用输入构造hash表，删除重复项、计算聚合表达式</li>
<li>扫描hash表输出所有项</li>
</ul>
</li>
<li><p>union操作、需要去除重复记录操作</p>
<ul>
<li>所有select字段计算hash值</li>
<li>第一个输入构建hash表，删除重复项</li>
<li>第二个输入进行探测<ul>
<li>若第二个输入没有重复项，直接返回没有匹配的项，
扫描hash表返回所有项</li>
<li>若第二个输入有重复项，则应该需要继续构建hash表，
最后统一输出整个hash表</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Grace-Hash-Join"><a href="#Grace-Hash-Join" class="headerlink" title="Grace Hash Join"></a><em>Grace Hash Join</em></h4><p><em>grace hash join</em>：磁盘分块HJ</p>
<ul>
<li><p>将两表按照相同hash函数分配至不同分片中</p>
<ul>
<li>在磁盘上为各分片、表建立相应文件</li>
<li>对表输入计算哈希值，根据哈希值写入分片、表对应文件</li>
</ul>
</li>
<li><p>再对不同分片进行普通<em>in-memory hash join</em></p>
<ul>
<li>若分片依然不能全部加载至内存，可以继续使用
<em>grace hash join</em></li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">grace_hash_join</span>(t1, t2):</span><br><span class="line">	<span class="comment">// Grace Hash Join实现</span></span><br><span class="line">	<span class="comment">// 输入：待join表t1、t2</span></span><br><span class="line">	<span class="keyword">for</span> row in t1:</span><br><span class="line">		hash_val = <span class="built_in">hash_func</span>(row)</span><br><span class="line">		N = hash_val % PART_COUNT</span><br><span class="line">		write row to file t1_N</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> row in t2:</span><br><span class="line">		hash_val = <span class="built_in">hash_func</span>(row)</span><br><span class="line">		N = hash_val % PART_COUNT</span><br><span class="line">		write row to file t2_N</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">0</span>, PART_COUNT):</span><br><span class="line">		<span class="built_in">join</span>(t1_i, t2_i)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>分片数量<code>PART_COUNT</code>决定磁盘IO效率</p>
<ul>
<li>分片数量过小：无法起到分治效果，分片仍然需要进行
<em>grace hash join</em>，降低效率</li>
<li>分片数量过大：磁盘是块设备，每次刷盘刷一定数量块才
高效，频繁刷盘不经济</li>
<li>即分片数量在保证刷盘经济的情况下，越大越好，这需要
优化器根据表统计信息确定</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>有磁盘I/O代价，会降低效率</li>
<li>适合参与join表非常大，无法同时载入内存中</li>
</ul>
</li>
</ul>
<h4 id="Hybrid-Hash-Join"><a href="#Hybrid-Hash-Join" class="headerlink" title="Hybrid Hash Join"></a><em>Hybrid Hash Join</em></h4><p><em>hybrid hash join</em>：GHJ基础上结合IMHJ的改进</p>
<ul>
<li>对build表分片过程中，尽量多把完整分片保留在内存中</li>
<li>对probe表分片时，对应分片可以直接进行probe操作</li>
</ul>
<blockquote>
<ul>
<li><em>hybrid hash join</em>有时也被直接视为<em>grace hash join</em>，
  不做区分</li>
</ul>
</blockquote>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ul>
<li><p>资源消耗</p>
<ul>
<li>HJ：CPU计算、内存（磁盘）中创建临时hash表</li>
<li>SMJ：磁盘I/O（扫描表、索引）</li>
<li>NLJ：磁盘I/O</li>
</ul>
</li>
<li><p>性能</p>
<ul>
<li><p>通常情况：HJ &gt; NPJ &lt;&gt; SMJ</p>
<ul>
<li>全表扫描比索引范围扫描再进行表访问更可取时，SMJ
优于NPJ？？？</li>
<li>而表特别小、特别大时，全表扫描优于索引范围扫描</li>
</ul>
</li>
<li><p>但若关联字段已排序，SMJ性能最优</p>
</li>
</ul>
</li>
<li><p>首条搜索结果</p>
<ul>
<li>NPJ能快速返回首条搜索结果</li>
<li>HJ、SMJ返回首条结果较慢</li>
</ul>
</li>
</ul>
<h2 id="多表联接算法"><a href="#多表联接算法" class="headerlink" title="多表联接算法"></a>多表联接算法</h2><p>多表联接算法：找到最优连接顺序（执行路径）</p>
<ul>
<li><p>表联接顺序对于查询结果没有影响，但是对资源消耗、性能影响
巨大</p>
</li>
<li><p>随着需要联接表数目增加，可能的联接排列非常多，基本不能
对所有可能穷举分析</p>
<ul>
<li><em>left-deep tree</em>/<em>linear (processing)tree</em>：$n!$</li>
<li><em>bushy tree</em>：$\frac {2(n-1)!} {(n-1)!}$
（包括left-deep tree、right-deep tree）</li>
</ul>
<p><img src="/imgs/left_deep_tree_bushy_tree.png" alt="left_deep_tree_bushy_tree"></p>
</li>
<li><p>事实上查询优化器不会穷尽搜索所有可能联接排列，而是使用
启发式算法进行搜索</p>
</li>
</ul>
<h3 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a><em>Dynamic Programming</em></h3><p>动态规划算法：依次求解各数量表最优联接顺序，直到求出最终结果</p>
<ol>
<li><p>构造第一层关系：每个关系的最优路径就是关系的最优单表扫描
方式</p>
</li>
<li><p>迭代依次构造之后n-1层关系联接最优解</p>
<ul>
<li>左深联接树方式：将第k-1层每个关系同第1层关系联接</li>
<li>紧密树联接方式：将第m(m &gt; 2)层每个关系同第k-m层关系
联接</li>
</ul>
<p><img src="/imgs/left_deep_tree_bushy_tree.png" alt="left_deep_tree_bushy_tree"></p>
</li>
</ol>
<h3 id="Heuristic-Algorithm"><a href="#Heuristic-Algorithm" class="headerlink" title="Heuristic Algorithm"></a><em>Heuristic Algorithm</em></h3><h3 id="Greedy-Algorithm"><a href="#Greedy-Algorithm" class="headerlink" title="Greedy Algorithm"></a><em>Greedy Algorithm</em></h3><p>贪心算法：认为每次连接表的连接方式都是最优的，即从未联接表中
选择使得下次联接代价最小者</p>
<ul>
<li><p>多表排序一般为</p>
<ul>
<li>常量表最前</li>
<li>其他表按可访问元组数量升序排序</li>
</ul>
</li>
<li><p>贪心算法得到的联接方式都是最优的</p>
<ul>
<li>则每次联接主要求解要联接表对象的最佳访问方式</li>
<li>即每次代价估计的重点在于单表扫描的代价</li>
</ul>
</li>
<li><p>求解结束后，局部最优查询计划生成</p>
<ul>
<li>得到左深树</li>
<li>最初始表位于最左下端叶子节点处</li>
</ul>
</li>
</ul>
<h3 id="System-R"><a href="#System-R" class="headerlink" title="System R"></a><em>System R</em></h3><p><em>System R</em>：对动态规划算法的改进</p>
<ul>
<li>保留子树查询最优、次优查询计划，用于上层查询计划生成，
使得查询计划整体较优</li>
</ul>
<h3 id="Genetic-Algorithm"><a href="#Genetic-Algorithm" class="headerlink" title="Genetic Algorithm"></a><em>Genetic Algorithm</em></h3><p>遗传算法：模拟自然界生物进化过程，采用人工进化的方式对目标
空间进行搜索</p>
<ul>
<li>本质是高效、并行、全局搜索方法</li>
<li>能在搜索过程中自动获取、积累有关搜索空间的知识，并自适应
的控制搜索过程以求的最佳解</li>
</ul>
<h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><ul>
<li>将问题域中可能解看作是染色体，将其编码为符号串的形式</li>
<li>对染色体群体反复进行基于遗传学的操作：选择、交叉、变异</li>
<li>根据预定目标适应度函数对每个个体进行评价，不断得到更优
群体，从中全局并行搜索得到优化群体中最优个体</li>
</ul>
<h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><ul>
<li><em>population</em>：群体，GA的遗传搜索空间</li>
<li><em>individual</em>：个体，搜索空间中可能解</li>
<li><em>chromosome</em>：染色体，个体特征代表<ul>
<li>由若干段基因组成</li>
<li>GA中基本操作对象</li>
</ul>
</li>
<li><em>gene</em>：基因<ul>
<li>染色体片段</li>
</ul>
</li>
<li><em>fitness</em>：适应度，个体对环境的适应程度</li>
</ul>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li><p><em>selection</em>：选择，根据个体适应度在群体中按照一定概率
选择个体作为父本</p>
<ul>
<li>适应度大个体被选择概率高</li>
<li>体现了适者生存、优胜劣汰的进化规则</li>
</ul>
</li>
<li><p><em>crossover</em>：交叉，将父本个体按照一定概率随机交换基因
形成新个体</p>
</li>
<li><p><em>mutate</em>：变异，按照一定概率随机改变某个体基因值</p>
</li>
</ul>
<h4 id="涉及问题"><a href="#涉及问题" class="headerlink" title="涉及问题"></a>涉及问题</h4><ul>
<li><p>串编码方式</p>
<ul>
<li>把问题的各种参数用二进串进行编码构成子串</li>
<li>把子串拼接成染色体<blockquote>
<ul>
<li>串长度、编码方式对算法收敛影响极大</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>适应度/对象函数确定</p>
<ul>
<li>一般可以把问题模型函数作为对象函数</li>
</ul>
</li>
<li><p>GA超参设置</p>
<ul>
<li>群体大小$n$：过小难以求出最优解，过大难收敛，一般取
$n = 30 ~ 160$</li>
<li>交叉概率$P_c$：太小难以前向搜索，太大容易破坏高适应
值结构，一般取$P_c = 0.25 ~ 0.75$</li>
<li>变异概率$P_m$：太小难以产生新结构，太大则变为单纯
随机搜索，一般取$P_m = 0.01 ~ 0.2$</li>
</ul>
</li>
</ul>
<h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><ol>
<li>随机初始化种群</li>
<li>估初始种群：为种群每个个体计算适应值、排序</li>
<li>若没有达到预定演化数，则继续，否则结束算法</li>
<li>选择父体<ul>
<li>杂交：得到新个体</li>
<li>变异：对新个体变异</li>
</ul>
</li>
<li>计算新个体适应值，把适应值排名插入种群，淘汰最后个体</li>
<li>重复3</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-05-25T11:55:48.000Z" title="5/25/2019, 7:55:48 PM">2019-05-25</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-05-25T11:55:48.000Z" title="5/25/2019, 7:55:48 PM">2019-05-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Data-Structure/">Data Structure</a></span><span class="level-item">6 minutes read (About 892 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Data-Structure/set.html">Set</a></h1><div class="content"><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合：互不相同项的无序组合</p>
<ul>
<li>要么指出集合的特殊属性，只有集合中元素才满足的特性</li>
<li>要么显式列出集合的所有成员</li>
</ul>
<h3 id="存储映像"><a href="#存储映像" class="headerlink" title="存储映像"></a>存储映像</h3><h4 id="位向量存储表示"><a href="#位向量存储表示" class="headerlink" title="位向量存储表示"></a>位向量存储表示</h4><p>位串表示法</p>
<ul>
<li>每个集合S使用一个位串表示，位串中每位代表全集U的一个元素</li>
<li>当且仅当全集$U$中第i个元素被包含在子集$S$中时，位向量
第i个元素为1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> BitSet[MAX_SET_SIZE/<span class="keyword">sizeof</span>(<span class="keyword">int</span>)];</span><br></pre></td></tr></table></figure>
<ul>
<li>可以实现快速的标准集合运算</li>
<li>以使用大量存储空间为代价的</li>
</ul>
<h4 id="线性表存储表示"><a href="#线性表存储表示" class="headerlink" title="线性表存储表示"></a>线性表存储表示</h4><p>线性表表示法</p>
<ul>
<li>每个集合使用一个线性表表示，线性表中存储集合元素</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> SqList SLSet;</span><br><span class="line">	<span class="comment">// 顺序表表示集合</span></span><br><span class="line"><span class="keyword">typedef</span> LinkList LLSet;</span><br><span class="line">	<span class="comment">// 链表表示集合</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>集合不能包含相同元素，列表可以</p>
<ul>
<li>可以引入<em>multiset</em>、<em>bag</em>绕过对唯一性的要求</li>
<li>多重集和包是可重复项的无序组合</li>
</ul>
</li>
<li><p>集合是元素的组合，而列表是集合的有序组合</p>
<ul>
<li>用线性表表示集合时，不必维护线性表的有序排列</li>
</ul>
</li>
</ul>
<h3 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h3><ul>
<li>检查元素是否属于集合</li>
<li>集合的并集</li>
<li>集合的交集</li>
</ul>
<h2 id="Disjoint-Set-Union-Find"><a href="#Disjoint-Set-Union-Find" class="headerlink" title="Disjoint Set/Union Find"></a><em>Disjoint Set/Union Find</em></h2><p>不相交集/并查集：由某个有限集的一系列<strong>不相交</strong>子集，及相应
操作构成</p>
<ul>
<li><strong>通常假设集合中元素为整数</strong>，或可以映射为整数</li>
<li>主要包括<em>find</em>、<em>union</em>操作</li>
</ul>
<h3 id="存储映像-1"><a href="#存储映像-1" class="headerlink" title="存储映像"></a>存储映像</h3><ul>
<li><p>实现应该对<em>find</em>、<em>union</em>有特殊优化</p>
<ul>
<li>按秩合并：将包含较少结点的集合合并到含有较多结点集合</li>
<li>路径压缩：将每个结点都直接指向根节点</li>
</ul>
</li>
<li><p>大多数实现会使用集合某个元素作为该集合代表</p>
<ul>
<li>有些对代表没有特殊约定</li>
<li>有的要求代表为子集中最小元素等</li>
</ul>
</li>
</ul>
<h4 id="树双亲表存储表示"><a href="#树双亲表存储表示" class="headerlink" title="树双亲表存储表示"></a>树双亲表存储表示</h4><p>双亲表示法</p>
<ul>
<li>使用树的双亲表示法作存储结构</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> PTree MFSet;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>以集合中某个元素作为树根、集合名，其余所有结点都作为根
的<strong>孩子结点</strong></p>
</li>
<li><p>每个结点只能有一个双亲结点，即只能属于一个集合，适合存储
不相交集</p>
</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li>生成不相交集<ul>
<li>求解无向图中连通分量数量</li>
<li>求解等价问题：两两等价元素作为一类，求解每类元素</li>
</ul>
</li>
<li>集合归并<ul>
<li>生成迷宫：连通入口、出口连通分量</li>
</ul>
</li>
</ul>
<h2 id="Map-Dictionary"><a href="#Map-Dictionary" class="headerlink" title="Map/Dictionary"></a><em>Map/Dictionary</em></h2><p>映射/字典：能查找给定元素、增加新元素、删除元素的集合</p>
<ul>
<li><p>需要处理的是动态内容的查找，因此需要在查找效率和其他两种
操作中达到平衡</p>
</li>
<li><p>数组、散列法、平衡查找树都可以实现字典</p>
<p>||散列表|平衡查找树|
|——-|——-|———|
|渐进时间效率|平均$\in \Theta(1)；最坏$\in \Theta(n)$|$\in \Theta(logn)|
|有序性保留|不假定键有序，不保证，不适合按序遍历、按范围查询|保证|</p>
</li>
</ul>
<h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><ul>
<li><em>Extendible Hashing</em>：可扩充散列，用于存储磁盘上大型字典<ul>
<li>查找时先计算可能包含查找键K的存储段磁盘地址</li>
<li>然后从磁盘中读取段中所有键，从中查找K</li>
<li>因为存取主存开销较磁盘小很多，宁可多次存取主存</li>
</ul>
</li>
</ul>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/22/">Previous</a></div><div class="pagination-next"><a href="/page/24/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/22/">22</a></li><li><a class="pagination-link is-current" href="/page/23/">23</a></li><li><a class="pagination-link" href="/page/24/">24</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/40/">40</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">36</span></span></a><ul><li><a class="level is-mobile" href="/categories/Algorithm/Data-Structure/"><span class="level-start"><span class="level-item">Data Structure</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Heuristic/"><span class="level-start"><span class="level-item">Heuristic</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Issue/"><span class="level-start"><span class="level-item">Issue</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Problem/"><span class="level-start"><span class="level-item">Problem</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Specification/"><span class="level-start"><span class="level-item">Specification</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/C-C/"><span class="level-start"><span class="level-item">C/C++</span></span><span class="level-end"><span class="level-item tag">34</span></span></a><ul><li><a class="level is-mobile" href="/categories/C-C/Cppref/"><span class="level-start"><span class="level-item">Cppref</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/Cstd/"><span class="level-start"><span class="level-item">Cstd</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/MPI/"><span class="level-start"><span class="level-item">MPI</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/STL/"><span class="level-start"><span class="level-item">STL</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/CS/"><span class="level-start"><span class="level-item">CS</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/CS/Character/"><span class="level-start"><span class="level-item">Character</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Parallel/"><span class="level-start"><span class="level-item">Parallel</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Program-Design/"><span class="level-start"><span class="level-item">Program Design</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Storage/"><span class="level-start"><span class="level-item">Storage</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Daily-Life/"><span class="level-start"><span class="level-item">Daily Life</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/Daily-Life/Maxism/"><span class="level-start"><span class="level-item">Maxism</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Database/"><span class="level-start"><span class="level-item">Database</span></span><span class="level-end"><span class="level-item tag">27</span></span></a><ul><li><a class="level is-mobile" href="/categories/Database/Hadoop/"><span class="level-start"><span class="level-item">Hadoop</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Database/SQL-DB/"><span class="level-start"><span class="level-item">SQL DB</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Database/Spark/"><span class="level-start"><span class="level-item">Spark</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/Scala/"><span class="level-start"><span class="level-item">Scala</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">42</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Bash-Programming/"><span class="level-start"><span class="level-item">Bash Programming</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Configuration/"><span class="level-start"><span class="level-item">Configuration</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/File-System/"><span class="level-start"><span class="level-item">File System</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/IPC/"><span class="level-start"><span class="level-item">IPC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Process-Schedual/"><span class="level-start"><span class="level-item">Process Schedual</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Shell/"><span class="level-start"><span class="level-item">Shell</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Tool/"><span class="level-start"><span class="level-item">Tool</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Tool/Vi/"><span class="level-start"><span class="level-item">Vi</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Model/"><span class="level-start"><span class="level-item">ML Model</span></span><span class="level-end"><span class="level-item tag">21</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Model/Linear-Model/"><span class="level-start"><span class="level-item">Linear Model</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Model-Component/"><span class="level-start"><span class="level-item">Model Component</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Nolinear-Model/"><span class="level-start"><span class="level-item">Nolinear Model</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Unsupervised-Model/"><span class="level-start"><span class="level-item">Unsupervised Model</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/"><span class="level-start"><span class="level-item">ML Specification</span></span><span class="level-end"><span class="level-item tag">17</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/Click-Through-Rate/"><span class="level-start"><span class="level-item">Click Through Rate</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/Click-Through-Rate/Recommandation-System/"><span class="level-start"><span class="level-item">Recommandation System</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/Computer-Vision/"><span class="level-start"><span class="level-item">Computer Vision</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Specification/FinTech/"><span class="level-start"><span class="level-item">FinTech</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/FinTech/Risk-Control/"><span class="level-start"><span class="level-item">Risk Control</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/Graph-Analysis/"><span class="level-start"><span class="level-item">Graph Analysis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Specification/NLP/"><span class="level-start"><span class="level-item">NLP</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Technique/"><span class="level-start"><span class="level-item">ML Technique</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Technique/Feature-Engineering/"><span class="level-start"><span class="level-item">Feature Engineering</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Technique/Neural-Network/"><span class="level-start"><span class="level-item">Neural Network</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Theory/"><span class="level-start"><span class="level-item">ML Theory</span></span><span class="level-end"><span class="level-item tag">11</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Theory/Loss/"><span class="level-start"><span class="level-item">Loss</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Theory/Model-Enhencement/"><span class="level-start"><span class="level-item">Model Enhencement</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Theory/Optimization/"><span class="level-start"><span class="level-item">Optimization</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Algebra/"><span class="level-start"><span class="level-item">Math Algebra</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Algebra/Linear-Algebra/"><span class="level-start"><span class="level-item">Linear Algebra</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Algebra/Universal-Algebra/"><span class="level-start"><span class="level-item">Universal Algebra</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Analysis/"><span class="level-start"><span class="level-item">Math Analysis</span></span><span class="level-end"><span class="level-item tag">23</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Analysis/Fourier-Analysis/"><span class="level-start"><span class="level-item">Fourier Analysis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Functional-Analysis/"><span class="level-start"><span class="level-item">Functional Analysis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Optimization/"><span class="level-start"><span class="level-item">Optimization</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Real-Analysis/"><span class="level-start"><span class="level-item">Real Analysis</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Mixin/"><span class="level-start"><span class="level-item">Math Mixin</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Mixin/Statistics/"><span class="level-start"><span class="level-item">Statistics</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Mixin/Time-Series/"><span class="level-start"><span class="level-item">Time Series</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Probability/"><span class="level-start"><span class="level-item">Probability</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">89</span></span></a><ul><li><a class="level is-mobile" href="/categories/Python/Cookbook/"><span class="level-start"><span class="level-item">Cookbook</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Jupyter/"><span class="level-start"><span class="level-item">Jupyter</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Keras/"><span class="level-start"><span class="level-item">Keras</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Matplotlib/"><span class="level-start"><span class="level-item">Matplotlib</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Numpy/"><span class="level-start"><span class="level-item">Numpy</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Pandas/"><span class="level-start"><span class="level-item">Pandas</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Py3Ref/"><span class="level-start"><span class="level-item">Py3Ref</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Py3std/"><span class="level-start"><span class="level-item">Py3std</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Pywin32/"><span class="level-start"><span class="level-item">Pywin32</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Readme/"><span class="level-start"><span class="level-item">Readme</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/TensorFlow/"><span class="level-start"><span class="level-item">TensorFlow</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Twists/"><span class="level-start"><span class="level-item">Twists</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/RLang/"><span class="level-start"><span class="level-item">RLang</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Rust/"><span class="level-start"><span class="level-item">Rust</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Set/"><span class="level-start"><span class="level-item">Set</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/"><span class="level-start"><span class="level-item">Tool</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/Tool/Editor/"><span class="level-start"><span class="level-item">Editor</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Markup-Language/"><span class="level-start"><span class="level-item">Markup Language</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Web-Browser/"><span class="level-start"><span class="level-item">Web Browser</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Windows/"><span class="level-start"><span class="level-item">Windows</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/Web/CSS/"><span class="level-start"><span class="level-item">CSS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/NPM/"><span class="level-start"><span class="level-item">NPM</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/Proxy/"><span class="level-start"><span class="level-item">Proxy</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/Thrift/"><span class="level-start"><span class="level-item">Thrift</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://octodex.github.com/images/hula_loop_octodex03.gif" alt="UBeaRLy"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">UBeaRLy</p><p class="is-size-6 is-block">Protector of Proxy</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">392</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">93</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">522</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/xyy15926" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/xyy15926"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-04T15:07:54.896Z">2021-08-04</time></p><p class="title"><a href="/uncategorized/README.html"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-03T07:46:51.000Z">2021-08-03</time></p><p class="title"><a href="/Web/NPM/hexo_config.html">Hexo 建站</a></p><p class="categories"><a href="/categories/Web/">Web</a> / <a href="/categories/Web/NPM/">NPM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-03T02:32:45.000Z">2021-08-03</time></p><p class="title"><a href="/Web/NPM/config.html">NPM 总述</a></p><p class="categories"><a href="/categories/Web/">Web</a> / <a href="/categories/Web/NPM/">NPM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-02T08:11:11.000Z">2021-08-02</time></p><p class="title"><a href="/Python/Py3std/internet_data.html">互联网数据</a></p><p class="categories"><a href="/categories/Python/">Python</a> / <a href="/categories/Python/Py3std/">Py3std</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-29T13:55:00.000Z">2021-07-29</time></p><p class="title"><a href="/Linux/Shell/sh_apps.html">Shell 应用程序</a></p><p class="categories"><a href="/categories/Linux/">Linux</a> / <a href="/categories/Linux/Shell/">Shell</a></p></div></article></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">Advertisement</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="pub-5385776267343559" data-ad-slot="6995841235" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="https://api.follow.it/subscription-form/WWxwMVBsOUtoNTdMSlJ4Z1lWVnRISERsd2t6ek9MeVpEUWs0YldlZGxUdXlKdDNmMEZVV1hWaFZFYWFSNmFKL25penZodWx3UzRiaVkxcnREWCtOYUJhZWhNbWpzaUdyc1hPangycUh5RTVjRXFnZnFGdVdSTzZvVzJBcTJHKzl8aXpDK1ROWWl4N080YkFEK3QvbEVWNEJuQjFqdWdxODZQcGNoM1NqbERXST0=/8" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="UBeaRLy" height="28"></a><p class="is-size-7"><span>&copy; 2021 UBeaRLy</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/xyy15926/proxy"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>