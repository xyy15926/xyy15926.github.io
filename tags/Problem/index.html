<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Tag: Problem - UBeaRLy</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="UBeaRLy&#039;s Proxy"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="UBeaRLy&#039;s Proxy"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="UBeaRLy"><meta property="og:url" content="https://xyy15926.github.io/"><meta property="og:site_name" content="UBeaRLy"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://xyy15926.github.io/img/og_image.png"><meta property="article:author" content="UBeaRLy"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xyy15926.github.io"},"headline":"UBeaRLy","image":["https://xyy15926.github.io/img/og_image.png"],"author":{"@type":"Person","name":"UBeaRLy"},"publisher":{"@type":"Organization","name":"UBeaRLy","logo":{"@type":"ImageObject","url":"https://xyy15926.github.io/img/logo.svg"}},"description":""}</script><link rel="alternate" href="/atom.xml" title="UBeaRLy" type="application/atom+xml"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/darcula.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><script data-ad-client="pub-5385776267343559" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><meta name="follow_it-verification-code" content="SVBypAPPHxjjr7Y4hHfn"><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="UBeaRLy" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Visit on GitHub" href="https://github.com/xyy15926/proxy"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">Tags</a></li><li class="is-active"><a href="#" aria-current="page">Problem</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-07-23T00:39:04.000Z" title="7/23/2019, 8:39:04 AM">2019-07-23</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-07-23T00:39:04.000Z" title="7/23/2019, 8:39:04 AM">2019-07-23</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Problem/">Problem</a></span><span class="level-item">26 minutes read (About 3885 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Problem/combination.html">组合问题</a></h1><div class="content"><h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><ul>
<li><p>寻找（明确地、隐含地）寻找一个组合对象</p>
<ul>
<li>排列</li>
<li>组合（整数规划）</li>
<li>子集</li>
</ul>
</li>
<li><p>这些对象能满足特定条件并具有想要的属性</p>
<ul>
<li>价值最大化</li>
<li>成本最小化</li>
</ul>
</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>无论从理论角度、实践角度而言，组合问题是计算领域最难的问题</p>
<ul>
<li><p>随着问题规模增大，组合对象数量增长极快</p>
</li>
<li><p>没有一种已知算法，能在可接受的时间范围内，精确的解决
大部分组合问题，且被普遍认为不存在（未被证实）</p>
</li>
<li><p>有些组合问题有高效求解算法，是幸运的例外</p>
</li>
</ul>
<p>从更抽象的角度看，旅行商问题、图填色问题也是组合问题的特例</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li><p><em>exhaustive search</em>：（穷举搜索）是简单的蛮力方法</p>
<ul>
<li>生成问题域每个元素</li>
<li>选出满足问题约束的元素</li>
<li>最后寻找期望元素</li>
</ul>
</li>
<li><p>因为可能性太多，基本可能从动态规划方向着手</p>
</li>
</ul>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p>给定n个重量为$w_1, w_2, \cdots, w_n$价值为$v_1, v_2, …, vn$
的物品和承重为$W$的背包，求能够装进背包的最有价值物品子集</p>
<h3 id="蛮力算法"><a href="#蛮力算法" class="headerlink" title="蛮力算法"></a>蛮力算法</h3><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ul>
<li>考虑所有n个物品的子集</li>
<li>计算每个子集重量，找出可行子集</li>
<li>找到可行子集中价值最大子集</li>
</ul>
<h3 id="经典自底向上动态规划"><a href="#经典自底向上动态规划" class="headerlink" title="经典自底向上动态规划"></a>经典自底向上动态规划</h3><p>依次求解所有子问题、记录</p>
<h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><p>设$F(i, j)$为由前i个物品、承重量为j的背包得到最优解</p>
<ul>
<li><p>不包括第i个物品的子集中，最优子集价值为$F(i-1, j)$</p>
</li>
<li><p>包括第i个物品的子集中，最优子集是由该物品和前i-1个物品
中能够放进承重量为$j-w_i$的背包的最优子集组成，总价值为
$v_i + F(i-1, j-w_i)$</p>
</li>
</ul>
<p>则递推式为</p>
<script type="math/tex; mode=display">
F(i, j) =
\left \{ \begin{array}{l}
    max\{F(i-1, j), v_i + F(i-1, j-w_i)\} & j-w_i \geqslant 0 \\
    F(i-1, j) & j-w_i \leqslant 0 \\
    0 & i=0 or j=0 (i, j \geqslant 0)
\end{array} \right.</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Knapsack(Ws[<span class="number">1.</span>.n], Vs[<span class="number">1.</span>.n], W)</span><br><span class="line">	<span class="comment">// 动态规划求解背包问题</span></span><br><span class="line">	<span class="comment">// 输入：Ws[1..n]物品重量、Vs[1..n]物品价值，W背包承重</span></span><br><span class="line">	<span class="comment">// 输出：背包能够装载的最大价值</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span> to n <span class="keyword">do</span></span><br><span class="line">		F[i, <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> j = <span class="number">0</span> to W <span class="keyword">do</span></span><br><span class="line">		F[<span class="number">0</span>, j] = <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> i = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">			<span class="keyword">if</span> j &gt;= Ws[i]:</span><br><span class="line">				F[i, j] = max(F[i<span class="number">-1</span>, j], Vs[i] + F[i<span class="number">-1</span>, j-Ws[i])</span><br><span class="line">				<span class="comment">// 这里用于比较的F值，在之前的循环中已经确定</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				F[i, j] = F[i<span class="number">-1</span>, j]</span><br><span class="line">	<span class="keyword">return</span> F[n, W]</span><br></pre></td></tr></table></figure>
<h4 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li>算法效率<ul>
<li>时间效率$\in \Theta(nW)$</li>
<li>空间效率$\in \Theta(nW)$</li>
<li>回溯求最优解组成效率$\in O(n)$</li>
</ul>
</li>
</ul>
<h3 id="自顶向下动态规划"><a href="#自顶向下动态规划" class="headerlink" title="自顶向下动态规划"></a>自顶向下动态规划</h3><h4 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">MFKnapsack(i, j)</span><br><span class="line">	<span class="comment">// 背包问题的记忆功能方法</span></span><br><span class="line">	<span class="comment">// 输入：i考虑的物品数量，j背包承重</span></span><br><span class="line">	<span class="comment">// 输出：前i个物品的最优可行子集</span></span><br><span class="line">	<span class="comment">// Ws[1..n]、Vs[1..n]、F[0..n, 0..W]作为全局变量</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span> to n <span class="keyword">do</span></span><br><span class="line">		F[i, <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> j = <span class="number">0</span> to W <span class="keyword">do</span></span><br><span class="line">		F[<span class="number">0</span>, j] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> F[i, j] &lt; <span class="number">0</span></span><br><span class="line">		<span class="keyword">if</span> j &lt; Ws[i]</span><br><span class="line">			value = MFKnapsack(i<span class="number">-1</span>, j)</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			value = max(MFKnapsack(i<span class="number">-1</span>, j),</span><br><span class="line">				Vs[i] + MFKnapsack(i<span class="number">-1</span>, j - Ws[i]))</span><br><span class="line">		F[i, j] = value</span><br><span class="line">	<span class="keyword">return</span> F[i, j]</span><br></pre></td></tr></table></figure>
<h4 id="算法特点-1"><a href="#算法特点-1" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li>算法效率<ul>
<li>相较于经典自底向上算法，时间效率提升常数因子，但是
效率仍然$\in \Theta(nW)$</li>
<li>相较于自底向上算法空间优化版版本而言，空间效率较低</li>
</ul>
</li>
</ul>
<h3 id="分支界限法"><a href="#分支界限法" class="headerlink" title="分支界限法"></a>分支界限法</h3><ul>
<li><p>不失一般性认为，物品按照价值重量比$v_i / w_i$降序排列，
可以简化问题</p>
</li>
<li><p>第i层节点上界可取$ub = v + (W - w)(v<em>{i+1} / w</em>{i+1})$</p>
<ul>
<li>$v$：已选物品价值</li>
<li>$W - w$：背包剩余承重量</li>
<li>$v<em>{i+1}/w</em>{i+1}$：剩余物品单位单位最大价值</li>
</ul>
</li>
<li><p>更紧密、复杂的上界
$ub = v + \sum<em>{k=i+1}^K v_k + (W - \sum</em>{k=1}^K w_k)v_K / w_K$</p>
</li>
</ul>
<h4 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h4><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>分支界限法求解背包问题中，每个中间节点都是给定物品的子集
，是背包问题的可行解</li>
</ul>
<h2 id="背包问题近似算法"><a href="#背包问题近似算法" class="headerlink" title="背包问题近似算法"></a>背包问题近似算法</h2><h3 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h3><h4 id="算法-4"><a href="#算法-4" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>对物品按照价值重量比$r_i = v_i / w_i, i=1,2,\cdots,n$
降序排列</p>
</li>
<li><p>重复以下直到有序列表中不留下物品</p>
<ul>
<li>如果列表中当前物品可以装入，则放入背包并处理下个物品</li>
<li>否则忽略，直接处理下个物品</li>
</ul>
</li>
</ul>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>原始的贪婪算法解的精确率没有上界</p>
<ul>
<li><p>考虑：承重量为$W$背包，如下物品</p>
<p>|物品|重量|价值|价值/重量|
|——-|——-|——-|——-|
|1|1|2|2|
|2|w|w|1|</p>
</li>
<li><p>则近似解精确率$r(s_a) = W/2$无上界</p>
</li>
</ul>
</li>
<li><p>增强版贪婪算法：取贪婪算法解、能装载的价值最大单个物品
价值中较大者</p>
<ul>
<li>此改进的性能比可以降到2</li>
</ul>
</li>
</ul>
<h3 id="近似方案"><a href="#近似方案" class="headerlink" title="近似方案"></a>近似方案</h3><p>背包问题的存在多项式时间的系列算法，可以调节算法中参数$k$
得到满足任意预定义精确率的近似解$s_a^{(k)}$</p>
<script type="math/tex; mode=display">
\frac {f(s^{*})} {f(s_a^{(k)}} \leqslant 1 + 1/k,
    k=1,2,\cdots, n-1</script><h4 id="Sahni方案"><a href="#Sahni方案" class="headerlink" title="Sahni方案"></a>Sahni方案</h4><ul>
<li>生成所有小于k个物品的子集</li>
<li>向贪婪算法一样，向每个能装入背包的子集添加剩余物品中
价值重量比最大者</li>
<li>得到最有价值的修改后子集作为结果返回</li>
</ul>
<h4 id="Fully-Polynomial-Scheme"><a href="#Fully-Polynomial-Scheme" class="headerlink" title="Fully Polynomial Scheme"></a>Fully Polynomial Scheme</h4><p>完全多项式方案</p>
<h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>Sahni方案理论意义远大于实用价值</p>
<ul>
<li>其效率$\in O(kn^{k+1})$是n的多项式函数</li>
<li>但是是k的指数函数</li>
</ul>
</li>
<li><p>完全多项式方案更加复杂，但没有效率为参数k指数的缺陷</p>
</li>
</ul>
<h2 id="Bin-Packing-Problem"><a href="#Bin-Packing-Problem" class="headerlink" title="Bin-Packing Problem"></a>Bin-Packing Problem</h2><p>装箱问题：给定n个问题，大小都是不超过1的有理数，将其装进数量
最少的大小为1的箱子中</p>
<h2 id="Graph-Coloring-Problem"><a href="#Graph-Coloring-Problem" class="headerlink" title="Graph-Coloring Problem"></a>Graph-Coloring Problem</h2><p>图着色问题：对给定图，求使得任何两个相邻顶点颜色都不同时，
需要分配给图顶点的颜色数量</p>
<h2 id="划分问题"><a href="#划分问题" class="headerlink" title="划分问题"></a>划分问题</h2><p>给定n个正整数${a_i, i=1,2,\cdots}，判定能够将其划分为和相等
的两个子集</p>
<h2 id="Subset-Sum-Problem"><a href="#Subset-Sum-Problem" class="headerlink" title="Subset-Sum Problem"></a>Subset-Sum Problem</h2><p>给定n个正整数${a_i, i=1,2,\cdots}$，求子集$S$和为正整数d</p>
<h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><p>约束</p>
<script type="math/tex; mode=display">
s + a_{i+1} > d \\
s + \sum_{j=i+1}^n a_j < d</script><ul>
<li>其中$s$为考虑考虑第i+1元素时，前i个元素选情况下的和</li>
</ul>
<h4 id="算法-5"><a href="#算法-5" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>假设集合元素按升序排列</p>
</li>
<li><p>根节点为未选择任何元素</p>
</li>
<li><p>依次考虑将元素$a_i$添加进子集S中</p>
<ul>
<li>若满足约束条件、下个元素未考虑，继续考虑</li>
<li>否则回溯，重新考虑父母节点</li>
</ul>
</li>
<li><p>直到找到子集满足和为d，或第二次回溯到根节点</p>
</li>
</ul>
<h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><h2 id="币值最大化"><a href="#币值最大化" class="headerlink" title="币值最大化"></a>币值最大化</h2><p>给定一排n个硬币，币值为正整数$c_i, i=1, 2, \cdots, n$（币值
不唯一），在原始位置不相邻的情况下，使得所选硬币总金额最大</p>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="算法-6"><a href="#算法-6" class="headerlink" title="算法"></a>算法</h4><p>记最大可选金额为$F(n)$将可行规划分为两组</p>
<ul>
<li>包含最后一枚硬币，最大金额为$c_n + F(n-2)$</li>
<li>不包含最后一枚硬币，最大金额为$F(n-1)$</li>
</ul>
<p>则递推方程为</p>
<script type="math/tex; mode=display">
F(n) = max\{c_n + F(n-2), F(n-1)\}, n>1 \\
F(0) = 0, F(1) = c_1</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CoinRow(C[<span class="number">1.</span>.n])</span><br><span class="line">	<span class="comment">// 在所选硬币不相邻，从一排硬币中选择最大金额</span></span><br><span class="line">	<span class="comment">// 输入：C[1..n]保存n个硬币面值</span></span><br><span class="line">	<span class="comment">// 输出：可选硬币最大金额</span></span><br><span class="line">	F[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	F[<span class="number">1</span>] = C[<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">2</span> to n <span class="keyword">do</span></span><br><span class="line">		F[i] = max(C[i] + F[i<span class="number">-2</span>], F[i<span class="number">-1</span>])</span><br><span class="line">	<span class="keyword">return</span> F[n]</span><br></pre></td></tr></table></figure>
<h4 id="算法特点-2"><a href="#算法特点-2" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li>时间效率$\in \Theta(n)$</li>
<li>空间效率$\in \Theta(n)$</li>
</ul>
<h2 id="找零问题"><a href="#找零问题" class="headerlink" title="找零问题"></a>找零问题</h2><p>需找零金额为n，最少需要多少面值为$d_1 &lt; d_2 &lt; \cdots &lt; d_n$
的硬币，考虑$d_1 = 1$的一般情况</p>
<h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="算法-7"><a href="#算法-7" class="headerlink" title="算法"></a>算法</h4><p>记$F(n)$为总金额为n的数量最少的硬币数目，定义$F(0)=0$</p>
<ul>
<li><p>得到n的途径只能是在$n-d_j$上加入面值为$d_j$的硬币，其中
$j=1, 2, \cdots, m$，且$n \geqslant d_j$</p>
</li>
<li><p>考虑所有满足条件$d_j$，选择使得且$F(n - d_j)$最小者</p>
</li>
</ul>
<p>则递推式有</p>
<script type="math/tex; mode=display">
F(n) =
\left \{ \begin{array}{l}
    min \{ j: n \geqslant d_j \} \{ F(n - d_j) \} + 1 & n > 0 \\
    0 & n = 0
\end{array} \right.</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ChangeMaking(D[<span class="number">1.</span>.m], n)</span><br><span class="line">	<span class="comment">// 动态规划法求解找零问题，d_1 = 1</span></span><br><span class="line">	<span class="comment">// 输入：正整数n，币值数组D[1..m]</span></span><br><span class="line">	<span class="comment">// 输出：总金额为n的最少硬币数目</span></span><br><span class="line">	F[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">		tmp = \infty</span><br><span class="line">		j = <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> j &lt;= m <span class="keyword">and</span> i &gt;= D[j] <span class="keyword">do</span></span><br><span class="line">			tmp = min(F[i-D[j], tmp)</span><br><span class="line">			j += <span class="number">1</span></span><br><span class="line">		F[i] = tmp + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> F[n]</span><br></pre></td></tr></table></figure>
<h2 id="硬币收集问题"><a href="#硬币收集问题" class="headerlink" title="硬币收集问题"></a>硬币收集问题</h2><p>在n * m格木板中存放有硬币，每格硬币最多一个，寻找左上角(1,1)
到右下角(n, m)路径，使得能够收集尽可能多硬币，每次只能向下、
向右移动</p>
<h3 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="算法-8"><a href="#算法-8" class="headerlink" title="算法"></a>算法</h4><p>记$F(i, j)$为截止到第i行、第j列单元格$(i, j)$能够收集到最大
硬币数</p>
<ul>
<li>单元格$(i, j)$只能经由$(i-1, j)$、$(i, j-1)$达到<ul>
<li>初值1：假定$F(0, j)=0, F(i, 0)=0$</li>
<li>初值2；递推求解$F[1, j], F[i, 1]$</li>
</ul>
</li>
</ul>
<p>则递推方程为</p>
<script type="math/tex; mode=display">
F(i, j) =
\left \{ \begin{array}{l}
    max \{F(i-1 ,j), F(i, j-1)\} + c_{ij} & 1 <= i <= n, i <= j <= m \\
    0 & i = 0 or j = 0
\end{array} \right.</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CoinCollection(C[<span class="number">1.</span>.n, <span class="number">1.</span>.m])</span><br><span class="line">	<span class="comment">// 动态规划算法求解硬币收集问题</span></span><br><span class="line">	<span class="comment">// 输出：矩阵C[1..n, 1..m]表示单元格是否有硬币</span></span><br><span class="line">	<span class="comment">// 输出：在单元格[n, m]能够收集到的最大硬币数</span></span><br><span class="line">	F[<span class="number">1</span>, <span class="number">1</span>] = C[<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">	<span class="keyword">for</span> j = <span class="number">2</span> to m <span class="keyword">do</span></span><br><span class="line">		F[<span class="number">1</span>, j] = F[<span class="number">1</span>, j<span class="number">-1</span>] + C[<span class="number">1</span>, j]</span><br><span class="line">		<span class="comment">// 初始化首行</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">2</span> to n <span class="keyword">do</span></span><br><span class="line">		F[i, <span class="number">1</span>] = F[i<span class="number">-1</span>, <span class="number">1</span>] + C[i, <span class="number">1</span>]</span><br><span class="line">		<span class="keyword">for</span> j = <span class="number">2</span> to n <span class="keyword">do</span></span><br><span class="line">			<span class="comment">// 先填列</span></span><br><span class="line">			F[i, j] = max(F[i<span class="number">-1</span>, j], F[i, j<span class="number">-1</span>]) + C[i, j]</span><br><span class="line">	<span class="keyword">return</span> F[n, m]</span><br></pre></td></tr></table></figure>
<h4 id="算法特点-3"><a href="#算法特点-3" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li>算法效率<ul>
<li>计算每个单元格$F[i, j]$花费常量时间，所以算法时间
效率$\in \Theta(nm)$</li>
<li>算法空间效率$\in Theta(nm)$</li>
</ul>
</li>
</ul>
<h2 id="n皇后问题"><a href="#n皇后问题" class="headerlink" title="n皇后问题"></a>n皇后问题</h2><p>将n个皇后放在$n * n$的棋盘上，使得皇后之间不能相互攻击</p>
<h3 id="回溯算法-1"><a href="#回溯算法-1" class="headerlink" title="回溯算法"></a>回溯算法</h3><h4 id="算法-9"><a href="#算法-9" class="headerlink" title="算法"></a>算法</h4><h4 id="算法特点-4"><a href="#算法特点-4" class="headerlink" title="算法特点"></a>算法特点</h4><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li>$n \geqslant 4$的n皇后问题都可以在线性时间内求解，已经
找到一些可选公式，用于计算n皇后的位置</li>
</ul>
<h2 id="生成排列"><a href="#生成排列" class="headerlink" title="生成排列"></a>生成排列</h2><p>生成集合排列问题可以抽象为生成${1,\cdots,n}$所有$n!$个排列的
问题</p>
<ul>
<li>假设$(n-1)!$个排列已经生成</li>
<li>则可以把n插入n-1个元素中可能的n个位置中去，得到较大规模
问题的解</li>
</ul>
<h3 id="最小变化"><a href="#最小变化" class="headerlink" title="最小变化"></a>最小变化</h3><ul>
<li>在元素上使用小箭头标记其方向：
$\overleftarrow 1 \overleftarrow 2 \overleftarrow 3$</li>
<li>如果元素k的箭头指向相邻的较小元素，称在此排列中是移动的</li>
</ul>
<h4 id="减常量法"><a href="#减常量法" class="headerlink" title="减常量法"></a>减常量法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JohnsonTrotter(n)</span><br><span class="line">	<span class="comment">// 生成排列</span></span><br><span class="line">	<span class="comment">// 输入：正整数n</span></span><br><span class="line">	<span class="comment">// 输出：&#123;1..n&#125;所有排列列表</span></span><br><span class="line">	将第一个排列初始化</span><br><span class="line">	<span class="keyword">while</span> 存在一个移动元素 <span class="keyword">do</span></span><br><span class="line">		求最大的移动元素k</span><br><span class="line">		把k和其箭头指向的相邻元素互换</span><br><span class="line">		调转所有大于k的元素的方向</span><br><span class="line">		将新排列添加到列表中</span><br></pre></td></tr></table></figure>
<h4 id="算法特点-5"><a href="#算法特点-5" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li>JsonTrotter是生成排列最有效算法之一，其运行时间和排列
数量成正比，即$\in \Theta(n!)$</li>
</ul>
<h3 id="字典序"><a href="#字典序" class="headerlink" title="字典序"></a>字典序</h3><h4 id="减常量法-1"><a href="#减常量法-1" class="headerlink" title="减常量法"></a>减常量法</h4><ul>
<li>找到序列中最长递减后缀
$a<em>{i+1} &gt; a</em>{i+2} &gt; \cdots &gt; a_{n}$</li>
<li>将$a_i$同序列中大于其的最小元素交换</li>
<li>将新后缀颠倒，使其变为递增序列，加入列表中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LexicographicPermute(n):</span><br><span class="line">	<span class="comment">// 以字典序产生排列</span></span><br><span class="line">	<span class="comment">// 输入：正整数n</span></span><br><span class="line">	<span class="comment">// 输出：字典序下，所有排列列表</span></span><br><span class="line">	初始化第一个排列为<span class="number">12.</span>..n</span><br><span class="line">	<span class="keyword">while</span> 最后一个排列有两成连续升序元素 <span class="keyword">do</span></span><br><span class="line">		找出使得a_i &lt; a_&#123;i+<span class="number">1</span>&#125;的最大的i</span><br><span class="line">			<span class="comment">// 即找到最长递减后缀</span></span><br><span class="line">		找到使得a_i &lt; a_j的最大索引</span><br><span class="line">			<span class="comment">// 即在后缀中大于其的最小元素索引</span></span><br><span class="line">		交换a_i和a_j</span><br><span class="line">		将a_&#123;i+<span class="number">1</span>&#125;和a_&#123;n&#125;的元素反序</span><br><span class="line">		将新排列添加至列表中</span><br></pre></td></tr></table></figure>
<h2 id="生成子集"><a href="#生成子集" class="headerlink" title="生成子集"></a>生成子集</h2><p>集合$A[a_1, \cdots, a_n}$的所有子集可以分为两组</p>
<ul>
<li>包含$a_n$：${a_1, \cdots, a_n}$的所有子集</li>
<li>不包含$a_n$的子集：把$a_n$添加进${a_1, \cdots, a_n}$子集
获得</li>
</ul>
<blockquote>
<ul>
<li>同样的可以把集合抽象为位串，每个位串表示一个子集</li>
</ul>
</blockquote>
<h3 id="减常量算法"><a href="#减常量算法" class="headerlink" title="减常量算法"></a>减常量算法</h3><h4 id="字典序-1"><a href="#字典序-1" class="headerlink" title="字典序"></a>字典序</h4><p>按生成字典序（位串字典序）生成子集</p>
<ul>
<li>将正序${1..n}$转换为二进制位串</li>
<li>依次按照二进制位串生成子集<ul>
<li>位串中为1表示对应元素在子集中</li>
</ul>
</li>
</ul>
<h4 id="挤压序"><a href="#挤压序" class="headerlink" title="挤压序"></a>挤压序</h4><p>按照挤压序（位串挤压序）生成子集</p>
<ul>
<li>将倒序{n..1}转换为二进制位串</li>
<li>依次按照二进制位串生成子集<ul>
<li>位串中为1表示对应元素在子集中</li>
</ul>
</li>
</ul>
<blockquote>
<p>   <em>Squashed Order</em>：所有包含$a<em>j$子集必须紧排在所有包含
    $a_1, \cdots, a</em>{j-1}$的子集之后</p>
</blockquote>
<h4 id="最小变化-1"><a href="#最小变化-1" class="headerlink" title="最小变化"></a>最小变化</h4><p>每个子集和其直接前趋之间，要么增加一个元素，要么减少一个元素</p>
<ul>
<li>即每个位串和直接前趋之间仅仅相差一位</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BRGC(n)</span><br><span class="line">	<span class="comment">// 递归生成二进制反射格雷码</span></span><br><span class="line">	<span class="comment">// 输入：正整数n</span></span><br><span class="line">	<span class="comment">// 输出：所有长度为n的格雷码位串列表</span></span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">1</span></span><br><span class="line">		表L包含位串<span class="number">0</span>、位串<span class="number">1</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		调用BRGC(n<span class="number">-1</span>)生成长度为n<span class="number">-1</span>的位串列表L1</span><br><span class="line">		表L1倒序后复制给表L2</span><br><span class="line">		把<span class="number">0</span>加到表L1每个位串前</span><br><span class="line">		表<span class="number">1</span>加到表L2每个位串前</span><br><span class="line">		把表L2添加到表L1后得到表L</span><br><span class="line">	<span class="keyword">return</span> L</span><br></pre></td></tr></table></figure>
<h2 id="球、桶问题"><a href="#球、桶问题" class="headerlink" title="球、桶问题"></a>球、桶问题</h2><p>n个球放入m个桶中情况数量</p>
<h3 id="球同、桶不同、无空桶"><a href="#球同、桶不同、无空桶" class="headerlink" title="球同、桶不同、无空桶"></a>球同、桶不同、无空桶</h3><ul>
<li><p>插板法</p>
<script type="math/tex; mode=display">\left \{ \begin{array}{l}
C_{n-1}^{m-1}, & n \geq m \\
0, & n < m
\end{array} \right.</script></li>
</ul>
<h3 id="球同、桶不同、可空桶"><a href="#球同、桶不同、可空桶" class="headerlink" title="球同、桶不同、可空桶"></a>球同、桶不同、可空桶</h3><ul>
<li><p>插板法：可以假设m个桶中已经放好球，即m+n个相同球放入m个
不同桶、不允许空桶</p>
<script type="math/tex; mode=display">
C_{n+m-1}^{m-1}</script></li>
</ul>
<h3 id="球同、桶同、可空桶"><a href="#球同、桶同、可空桶" class="headerlink" title="球同、桶同、可空桶"></a>球同、桶同、可空桶</h3><ul>
<li><p>动态规划</p>
<script type="math/tex; mode=display">dp_4[i][j] = \left \{ \begin{array}{l}
dp_4[i][j-1] + dp_4[i-j][j], & i \geq j \\
dp_4[i][j-1], & i < j \\
1, & i=1,0 or j=1
\end{array} \right.</script></li>
<li><p>球数$i \geq j$桶数时递推式</p>
<ul>
<li>若有桶均包含球：剩余球可能性$dp[i-j][j]$</li>
<li>若存在桶不包含球：剔除一个桶不影响总数</li>
<li>没有其余情况</li>
</ul>
</li>
</ul>
<h3 id="球同、桶同、无空桶"><a href="#球同、桶同、无空桶" class="headerlink" title="球同、桶同、无空桶"></a>球同、桶同、无空桶</h3><ul>
<li><p>动态规划：由$dp_4$得到</p>
<script type="math/tex; mode=display">dp_5[i][j] = \left \{ \begin{array}{l}
dp_4[i-j][j], & i \geq j \\
0, & i < j
\end{array} \right.</script></li>
</ul>
<h3 id="球不同、桶同、无空桶"><a href="#球不同、桶同、无空桶" class="headerlink" title="球不同、桶同、无空桶"></a>球不同、桶同、无空桶</h3><ul>
<li><p>第二类斯特林数</p>
<script type="math/tex; mode=display">dp[i][j] = \left \{ \begin{array}{l}
j*dp[i-1][j] + dp[i-1][j-1], & 1 \leq j < i \\
1, & i = j \\
0, & i < j
\end{array} \right.</script></li>
<li><p>球数$i&gt;j$桶数时递推式</p>
<ul>
<li>考虑前$i-1$球已经占满所有桶，则最后球放入任何桶都是
新情况</li>
<li>考虑前$i-1$只占满$j-1$个桶，则最后球必须放入空桶</li>
<li>其他情况不可能</li>
</ul>
</li>
</ul>
<h3 id="球不同、桶同、可空桶"><a href="#球不同、桶同、可空桶" class="headerlink" title="球不同、桶同、可空桶"></a>球不同、桶同、可空桶</h3><ul>
<li><p>在<strong>球不同、桶同、无空桶</strong>情况下<strong>枚举</strong>不空桶数目</p>
<script type="math/tex; mode=display">
dp_2[i][j] = \sum_{k=1}^j dp[i][j]</script></li>
</ul>
<h3 id="球不同、桶不同、无空桶"><a href="#球不同、桶不同、无空桶" class="headerlink" title="球不同、桶不同、无空桶"></a>球不同、桶不同、无空桶</h3><ul>
<li><p>在<strong>球不同、桶同、无空桶</strong>情况下对桶排序</p>
<script type="math/tex; mode=display">
dp_3[i][j] = dp[i][j] * (j!)</script></li>
</ul>
<h3 id="球不同、桶不同、可空桶"><a href="#球不同、桶不同、可空桶" class="headerlink" title="球不同、桶不同、可空桶"></a>球不同、桶不同、可空桶</h3><ul>
<li>每个球都有m中选择：$m^n$</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-07-23T00:39:04.000Z" title="7/23/2019, 8:39:04 AM">2019-07-23</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-07-23T00:39:04.000Z" title="7/23/2019, 8:39:04 AM">2019-07-23</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Problem/">Problem</a></span><span class="level-item">37 minutes read (About 5565 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Problem/searching.html">查找</a></h1><div class="content"><h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><p>在给定的集合、多重集（允许多个元素具有相同的值）中找给定值
（查找键，<em>search key</em>）</p>
<ul>
<li>顺序搜索</li>
<li>折半查找：效率高但应用受限</li>
<li>将原集合用另一种形式表示以方便查找</li>
</ul>
<h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p>没有任何一种查找算法在任何情况下都是最优的</p>
<ul>
<li>有些算法速度快，但是需要较多存储空间</li>
<li>有些算法速度快，但是只适合有序数组</li>
</ul>
<p>查找算法没有稳定性问题，但会发生其他问题</p>
<ul>
<li><p>如果应用里的数据相对于查找次数频繁变化，查找问题必须结合
添加、删除一起考虑</p>
</li>
<li><p>必须仔细选择数据结构、算法，以便在各种操作的需求间达到
平衡</p>
</li>
</ul>
<h2 id="无序线性表查找"><a href="#无序线性表查找" class="headerlink" title="无序线性表查找"></a>无序线性表查找</h2><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ul>
<li>将给定列表中连续元素和给定元素查找键进行比较<ul>
<li>直到遇到匹配元素：成功查找</li>
<li>匹配之前遍历完整个列表：失败查找</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SequentialSearch(A[<span class="number">0.</span>.n<span class="number">-1</span>], K)</span><br><span class="line">	<span class="comment">// 顺序查找，使用**查找键作限位器**</span></span><br><span class="line">	<span class="comment">// 输入：n个元素数组A、查找键K</span></span><br><span class="line">	<span class="comment">// 输出：第一个值为K的元素位置，查找失败返回-1</span></span><br><span class="line">	A[n] = K</span><br><span class="line">	i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> A[i] != K <span class="keyword">do</span></span><br><span class="line">		i = i + <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> i &lt; n</span><br><span class="line">		<span class="keyword">return</span> i</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><ul>
<li>将查找键添加找列表末尾，查找一定会成功，循环时将不必每次
检查是否到列表末尾</li>
<li>如果给定数组有序：遇到等于（查找成功）、大于（查找失败）
查找键元素，算法即可停止</li>
</ul>
<h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><ul>
<li>对数组构建二叉查找树</li>
<li>在二叉查找树上进行查找</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>算法效率：参见二叉查找树</p>
</li>
<li><p>构建二叉查找树（插入）和查找操作基本相同，效率特性也相同</p>
</li>
<li><p>减可变规模 + 输入增强</p>
</li>
</ul>
<h3 id="预排序查找"><a href="#预排序查找" class="headerlink" title="预排序查找"></a>预排序查找</h3><p>对线性表预排序，有序表中查找速度快得多</p>
<h4 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PreorderSearch(A[<span class="number">0.</span>.n<span class="number">-1</span>])</span><br><span class="line">	<span class="comment">// 对数组预排序然后查找</span></span><br><span class="line">	<span class="comment">// 输入：可排序数组A[0..n-1]</span></span><br><span class="line">	<span class="comment">// 输出：元素在数组中的位置</span></span><br><span class="line">	对B[(数组元素, 索引)]进行预排序</span><br><span class="line">	使用折半查找寻找二元组</span><br><span class="line">	返回二元组中索引</span><br></pre></td></tr></table></figure>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>算法时间效率：取决于排序算法</p>
<ul>
<li>查找算法在最差情况下总运行时间$\in \Theta(nlogn)$</li>
<li>如果需要在统一列表上进行多次查找，预排序才值得</li>
</ul>
</li>
<li><p>这种<strong>预排序</strong>思想可以用于<strong>众数</strong>、<strong>检验惟一性</strong>等，
此时算法执行时间都取决于排序算法
（优于蛮力法$\in \Theta(n^2)$）</p>
</li>
<li><p>变治法（输入增强）</p>
</li>
</ul>
<h5 id="预排序检验唯一性"><a href="#预排序检验唯一性" class="headerlink" title="预排序检验唯一性"></a>预排序检验唯一性</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PresortElementUniqueness(A[<span class="number">0.</span>.n<span class="number">-1</span>])</span><br><span class="line">	<span class="comment">// 先对数组排序，求解元素唯一性问题</span></span><br><span class="line">	<span class="comment">// 输入：n个可排序元素构成数[0..n-1]</span></span><br><span class="line">	<span class="comment">// 输出：A中有相等元素，返回true，否则false</span></span><br><span class="line">	对数组排序</span><br><span class="line">	<span class="keyword">for</span> i=<span class="number">0</span> to n<span class="number">-2</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span> A[i] = A[i+<span class="number">1</span>]</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h5 id="预排序求众数"><a href="#预排序求众数" class="headerlink" title="预排序求众数"></a>预排序求众数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PresortMode(A[<span class="number">0.</span>.n<span class="number">-1</span>])</span><br><span class="line">	<span class="comment">// 对数组预排序来计算其模式（众数）</span></span><br><span class="line">	<span class="comment">// 输入：可排序数组A[0..n-1]</span></span><br><span class="line">	<span class="comment">// 输出：数组模式</span></span><br><span class="line">	对数组A排序</span><br><span class="line">	i = <span class="number">0</span></span><br><span class="line">	modefrequency = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> i &lt;= n<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">		runlength = <span class="number">1</span></span><br><span class="line">		runvalue = A[i]</span><br><span class="line">		<span class="keyword">while</span> i + runlength &lt;= n<span class="number">-1</span> <span class="keyword">and</span> A[i+runlength] == runvalue</span><br><span class="line">			<span class="comment">// 相等数值邻接，只需要求出邻接次数最大即可</span></span><br><span class="line">			runlength = runlength+<span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> runlength &gt; modefrequency</span><br><span class="line">			modefrequency = runlength</span><br><span class="line">			modevalue = runvalue</span><br><span class="line">		i = i+runlength</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> modevalue</span><br></pre></td></tr></table></figure>
<h2 id="有序顺序表查找"><a href="#有序顺序表查找" class="headerlink" title="有序顺序表查找"></a>有序顺序表查找</h2><ul>
<li><p>有序顺序表的查找关键是利用有序减规模</p>
</li>
<li><p>但关键不是有序，而是<strong>减规模</strong>，即使顺序表不是完全有序，
信息足够减规模即可</p>
</li>
</ul>
<h3 id="折半查找-二分查找"><a href="#折半查找-二分查找" class="headerlink" title="折半查找/二分查找"></a>折半查找/二分查找</h3><p>二分查找：利用数组的有序性，通过对查找区间中间元素进行判断，
缩小查找区间至一般大小</p>
<ul>
<li><p>依赖数据结构，需能够快速找到中间元素，如数组、二叉搜索树</p>
</li>
<li><p>一般模板：比较中间元素和目标的大小关系、讨论</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">left, right = ...</span><br><span class="line"><span class="keyword">while</span> condition(search_space is <span class="keyword">not</span> <span class="literal">NULL</span>):</span><br><span class="line">	mid = (left + right) <span class="comment">// 2</span></span><br><span class="line">	<span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">		<span class="comment">// do something</span></span><br><span class="line">	elif nums[mid] &gt; target:</span><br><span class="line">		<span class="comment">// do something</span></span><br><span class="line">	elif nums[mid] &lt; target:</span><br><span class="line">		<span class="comment">// do somthing</span></span><br></pre></td></tr></table></figure>
<ul>
<li>函数独立时，找到<code>target</code>可在循环内直接返回</li>
<li>函数体嵌入其他部分时，为方便找到<code>target</code>应<code>break</code>，
此时涉及跳出循环时<code>target</code>可能存在的位置<ul>
<li>找到<code>target</code>中途<code>break</code></li>
<li>未找到<code>target</code>直到循环终止条件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="基本版"><a href="#基本版" class="headerlink" title="基本版"></a>基本版</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BinarySearchEndReturnV1(nums[<span class="number">0.</span>.n-<span class="number">1</span>], target):</span><br><span class="line">	// 非递归折半查找基本版，不直接返回，方便嵌入</span><br><span class="line">	// 输入：升序数组nums[<span class="number">0.</span>.n-<span class="number">1</span>]、查找键target</span><br><span class="line">	// 输出：存在返回数组元素下标m，否则返回-<span class="number">1</span></span><br><span class="line">	left, right = <span class="number">0</span>, n-<span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> left &lt;= right:</span><br><span class="line">		mid = (left + right) // <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">			left = mid+<span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			right = mid-<span class="number">1</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">assert</span>(mid == right == left-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 仅最后返回，方便嵌入，下同</span></span><br><span class="line">	<span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">		<span class="keyword">return</span> mid</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>输入判断：无需判断输入列表是否为空</p>
<ul>
<li>终止条件保证不会进入，即不会越界</li>
</ul>
</li>
<li><p>初始条件：<code>left, right = 0, n-1</code></p>
<ul>
<li>左、右均未检查、需检查</li>
<li>即代码中查找区间为<strong>闭区间</strong>$[left, right]$，此时
搜索区间非空</li>
</ul>
</li>
<li><p>中点选择：<code>mid = (left + right) // 2</code></p>
<ul>
<li>向下取整</li>
<li>对此版本无影响，<code>left</code>、<code>right</code>总是移动，不会死循环</li>
</ul>
</li>
<li><p>循环条件：<code>left &lt;= right</code></p>
<ul>
<li>搜索区间为闭区间，则相应检查条件为<code>left &lt;= right</code>，
否则有元素未被检查</li>
<li>在循环内<code>left</code>、<code>right</code>可能重合</li>
</ul>
</li>
<li><p>更新方式：<code>left=mid+1, right=mid-1</code></p>
<ul>
<li>为保证搜索区间始终为闭区间，需剔除<code>mid</code></li>
</ul>
</li>
<li><p>终止情况：<code>right=left-1</code>、<code>mid=left/right</code></p>
<ul>
<li>循环条件、循环内部<code>+1</code>保证：上轮循环<code>left==right</code></li>
<li>越界终止情况：左、右指针均剔除<code>mid</code>，两侧均可能越界<ul>
<li><code>mid=right=n-1, left=n</code></li>
<li><code>mid=left=0, right=-1</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>target</code>位置</p>
<ul>
<li>若存在<code>target</code>：必然在<code>mid</code>处，循环结束只需判断<code>mid</code></li>
<li>若不存在<code>target</code><ul>
<li><code>target</code>位于<code>[right, left]</code>间</li>
<li><code>left=mid+1=right+1</code>表示小于<code>target</code>元素数量</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>需要和<strong>左右邻居（查找结束后）</strong>、<code>left</code>、<code>right</code>比较
  情况下，容易考虑失误，不适合扩展使用</li>
</ul>
</blockquote>
<h4 id="高级版1"><a href="#高级版1" class="headerlink" title="高级版1"></a>高级版1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BinarySearchV2(nums[<span class="number">0.</span>.n<span class="number">-1</span>], target):</span><br><span class="line">	left, right = <span class="number">0</span>, n</span><br><span class="line">	<span class="keyword">while</span> left &lt; right:</span><br><span class="line">		mid = (left + right) <span class="comment">// 2</span></span><br><span class="line">		<span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		elif nums[mid] &lt; target:</span><br><span class="line">			left = mid+<span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			right = mid</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		assert(mid<span class="number">-1</span> == left == right)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">		<span class="keyword">return</span> mid</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>输入判断：无需判断输入列表是否为空</p>
<ul>
<li>终止条件保证不会进入，即不会越界</li>
</ul>
</li>
<li><p>初始条件：<code>left, right = 0, n</code></p>
<ul>
<li>左未检查、需检查，右无需检查</li>
<li>即代码中查找区间为<strong>左闭右开区间</strong>$[left, right)$</li>
</ul>
</li>
<li><p>中点选择：<code>mid = (left + right) // 2</code></p>
<ul>
<li>向下取整</li>
<li>此处必须选择向下取整，否则<code>left=right-1</code>时进入死循环</li>
<li>即：<strong>循环内检查所有元素，取整一侧指针必须移动</strong></li>
</ul>
</li>
<li><p>循环条件：<code>left &lt; right</code></p>
<ul>
<li>搜索区间为左闭右开区间，则检查条件为<code>left &lt; right</code>，
此时搜索区间非空</li>
<li>在循环内<code>left</code>、<code>right</code>不会重合</li>
</ul>
</li>
<li><p>更新方式：<code>left=mid+1, right=mid</code></p>
<ul>
<li>为保证搜索区间始终为左闭右开区间<ul>
<li>移动左指针时需剔除<code>mid</code></li>
<li>移动右指针时无需剔除<code>mid</code></li>
</ul>
</li>
</ul>
</li>
<li><p>终止情况：<code>right=left</code>、<code>mid=left/left-1</code></p>
<ul>
<li>循环条件、循环内部<code>+1</code>保证：上轮循环<ul>
<li><code>left+1=mid=right-1</code></li>
<li><code>left=mid=right-1</code></li>
</ul>
</li>
<li>越界终止情况：仅左指针剔除<code>mid</code>，仅可能右侧越界<ul>
<li><code>left=right=n=mid+1</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>target</code>位置</p>
<ul>
<li>若存在<code>target</code>：必然在<code>mid</code>处，循环结束只需判断<code>mid</code></li>
<li>若不存在<code>target</code><ul>
<li><code>left=mid=right</code>：循环过程中<code>target</code>可能已不在
搜索区间中，最终位于<code>(mid-1, mid)</code></li>
<li><code>mid+1=left=right</code>：<code>(mid, left)</code></li>
<li><code>left</code>表示小于<code>target</code>元素数量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="高级版2"><a href="#高级版2" class="headerlink" title="高级版2"></a>高级版2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">BainarySearchEndReturnV3(nums[<span class="number">0.</span>.n<span class="number">-1</span>], target):</span><br><span class="line">	<span class="comment">// 折半查找，保持左右指针顺序、不重合</span></span><br><span class="line">	<span class="comment">// 输入：升序数组nums、查找键target</span></span><br><span class="line">	<span class="comment">// 输出：存在返回数组元素下标m，否则返回-1</span></span><br><span class="line">	left, right = <span class="number">-1</span>, n</span><br><span class="line">	<span class="keyword">while</span> left &lt; right:</span><br><span class="line">		mid = (left + right + <span class="number">1</span>) <span class="comment">// 2</span></span><br><span class="line">		<span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		elif nums[mid] &lt; target:</span><br><span class="line">			right = mid<span class="number">-1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			left = mid</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">		<span class="keyword">return</span> mid</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>输入判断：无需判断输入列表是否为空</p>
<ul>
<li>终止条件保证不会进入，即不会越界</li>
</ul>
</li>
<li><p>初始条件：<code>left, right = -1, n-1</code></p>
<ul>
<li>左无需检查，右未检查、需检查</li>
<li>即代码中查找区间为<strong>左开右闭区间</strong>$(left, right]$</li>
</ul>
</li>
<li><p>中点选择：<code>mid = (left + right + 1) // 2</code></p>
<ul>
<li><strong>向上取整</strong></li>
<li>此处必须选择向上取整，否则<code>left=right-1</code>时进入死循环
（或放宽循环条件，添加尾判断）</li>
<li>即：<strong>循环内检查所有元素，取整一侧指针必须移动</strong></li>
</ul>
</li>
<li><p>循环条件：<code>left &lt; right</code></p>
<ul>
<li>搜索区间为左开右闭区间，则检查条件为<code>left &lt; right</code>，
此时搜索区间非空</li>
<li>在循环内<code>left</code>、<code>right</code>不会重合</li>
</ul>
</li>
<li><p>更新方式：<code>left=mid, right=mid+1</code></p>
<ul>
<li>为保证搜索区间始终为左闭右开区间<ul>
<li>移动右指针时需剔除<code>mid</code></li>
<li>移动左指针时无需剔除<code>mid</code></li>
</ul>
</li>
</ul>
</li>
<li><p>终止情况：<code>left=right</code>、<code>mid=left/left+1</code></p>
<ul>
<li>循环条件、循环内部<code>+1</code>保证：上轮循环<ul>
<li><code>left+1=mid=right-1</code></li>
<li><code>left+1=mid=right</code></li>
</ul>
</li>
<li>越界终止情况：仅右指针剔除<code>mid</code>，仅可能左侧越界<ul>
<li><code>left=right=-1=mid-1</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>target</code>位置</p>
<ul>
<li>若存在<code>target</code>：必然在<code>mid</code>处，循环结束只需判断<code>mid</code></li>
<li>若不存在<code>target</code><ul>
<li><code>left=mid=right</code>：循环过程中<code>target</code>可能已不在
搜索区间中，最终位于<code>(right, right+1)</code></li>
<li><code>mid+1=left=right</code>：<code>(left, right)</code></li>
<li><code>left+1</code>表示小于<code>target</code>元素数量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="高级版3"><a href="#高级版3" class="headerlink" title="高级版3"></a>高级版3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">BinarySearchEndReturnV2(nums[<span class="number">0.</span>.n-<span class="number">1</span>], target):</span><br><span class="line">	// 折半查找，保持左右指针顺序、不重合</span><br><span class="line">	// 输入：升序数组nums、查找键target</span><br><span class="line">	// 输出：存在返回数组元素下标m，否则返回-<span class="number">1</span></span><br><span class="line">	left, right = -<span class="number">1</span>, n</span><br><span class="line">	<span class="keyword">while</span> left &lt; right-<span class="number">1</span>:</span><br><span class="line">		mid = (left + right) // <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">			left = mid</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			right = mid</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">		<span class="keyword">return</span> mid</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>输入判断：无需判断输入列表是否为空</p>
<ul>
<li>终止条件保证不会进入，即不会越界</li>
</ul>
</li>
<li><p>初始条件：<code>left, right = -1, n</code></p>
<ul>
<li>左、右均无需检查</li>
<li>即代码中查找区间为<strong>开区间</strong>$(left, right)$</li>
</ul>
</li>
<li><p>中点选择：<code>mid = (left + right) // 2</code></p>
<ul>
<li>向下取整、向上取整均可</li>
</ul>
</li>
<li><p>循环条件：<code>left &lt; right-1</code></p>
<ul>
<li>搜索区间为左开右闭区间，则检查条件为<code>left &lt; right-1</code>，
此时搜索区间非空</li>
<li>在循环内<code>left</code>、<code>right</code>不会重合</li>
</ul>
</li>
<li><p>更新方式：<code>left=mid, right=mid</code></p>
<ul>
<li>循环终止条件足够宽泛，不会死循环</li>
</ul>
</li>
<li><p>终止情况：<code>left=right-1</code>、<code>mid=right/right-1</code></p>
<ul>
<li>循环条件、循环内部<code>+1</code>保证：上轮循环<ul>
<li><code>left+1=mid=right-1</code></li>
</ul>
</li>
<li>越界终止情况：左右初始条件均越界，则左、右均可能越界<ul>
<li><code>mid=left=n-1</code>、<code>right=n</code></li>
<li><code>left=-1</code>、<code>mid=right=0</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>target</code>位置</p>
<ul>
<li>若存在<code>target</code>：必然在<code>mid</code>处，循环结束只需判断<code>mid</code></li>
<li>若不存在<code>target</code><ul>
<li><code>target</code>始终在搜索区间<code>(left, right)</code>内</li>
<li>最终位于<code>(left, right)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="高级版1-原"><a href="#高级版1-原" class="headerlink" title="高级版1-原"></a>高级版1-原</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">BinarySearchKeep1(nums[<span class="number">0.</span>.n<span class="number">-1</span>], target):</span><br><span class="line">	<span class="comment">// 折半查找，保持左右指针顺序、不重合</span></span><br><span class="line">	<span class="comment">// 输入：升序数组nums、查找键target</span></span><br><span class="line">	<span class="comment">// 输出：存在返回数组元素下标m，否则返回-1</span></span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">	left, right = <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> left &lt; right - <span class="number">1</span>:</span><br><span class="line">		mid = <span class="built_in">floor</span>((left + right) / <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">			<span class="keyword">return</span> mid</span><br><span class="line"></span><br><span class="line">		elif nums[mid] &lt; target:</span><br><span class="line">			right = mid</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			left = mid</span><br><span class="line"></span><br><span class="line">	<span class="comment">// post-procesing</span></span><br><span class="line">	<span class="keyword">if</span> nums[left] == target:</span><br><span class="line">		<span class="keyword">return</span> left</span><br><span class="line">	<span class="keyword">if</span> nums[right] == target:</span><br><span class="line">		<span class="keyword">return</span> right</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>初始条件：<code>left = 0, right = n-1</code></li>
<li><strong>终止情况</strong>：<code>left = right - 1</code></li>
<li>指针移动：<code>left = mid, right= mid</code></li>
</ul>
</blockquote>
<ul>
<li><p><strong>关键特点</strong></p>
<ul>
<li><code>n&gt;1</code>时<code>left</code>、<code>mid</code>、<code>right</code>循环内不会重合</li>
<li><code>mid</code>可以<code>left</code>、<code>right</code>任意比较，无需顾忌重合</li>
<li>需要和<strong>左右邻居</strong>、<code>left</code>、<code>right</code>比较时适合使用</li>
<li>扩展使用需要进行真后处理，对<code>left</code>、<code>right</code>进行判断</li>
</ul>
</li>
<li><p>终止情况：<code>left = right - 1</code></p>
<ul>
<li>循环过程中会保证<strong>查找空间至少有3个元素</strong>，剩下两个
元素时，循环终止</li>
<li>循环终止后，<code>left</code>、<code>right</code>不会越界，可以直接检查</li>
</ul>
</li>
<li><p><code>target</code>位置</p>
<ul>
<li><p>若存在<code>target</code>，可能位于<code>mid</code>、<code>left</code>、<code>right</code></p>
<ul>
<li><code>mid</code>：因为找到<code>nums[mid]==target</code>跳出</li>
<li><code>left</code>：<code>left=0</code>，循环中未检查</li>
<li><code>right</code>：<code>right=n-1</code>，循环中未检查</li>
</ul>
</li>
<li><p>不存在<code>target</code>，则<code>target</code>位于<code>(left, right)</code>之间</p>
</li>
<li><p>适合<strong>访问目标在数组中索引、极其左右邻居</strong></p>
</li>
</ul>
</li>
<li><p><strong>仅仅二分查找的话</strong>，后处理其实不能算是真正的后处理</p>
<ul>
<li><p><code>nums[mid]</code>都会被检查，普通<code>left</code>、<code>right</code>肯定不会
是<code>target</code>所在的位置</p>
</li>
<li><p>真正处理的情况：<code>target</code>在端点</p>
<ul>
<li><code>left=0, right=1</code>终止循环，<code>left=0</code>未检查</li>
<li><code>left=n-2, right=n-1</code>终止循环，<code>right=n-1</code>未检查</li>
</ul>
</li>
<li><p>即这个处理是可以放在循环之前进行处理</p>
</li>
</ul>
</li>
</ul>
<h4 id="高级版2-原"><a href="#高级版2-原" class="headerlink" title="高级版2-原"></a>高级版2-原</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">BinarySearchKeep0(nums[<span class="number">0.</span>.n<span class="number">-1</span>], target):</span><br><span class="line">	<span class="comment">// 折半查找，保证左右指针不交错</span></span><br><span class="line">	<span class="comment">// 输入：升序数组nums、查找键target</span></span><br><span class="line">	<span class="comment">// 输出：存在返回数组元素下标m，否则返回-1</span></span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">	left, right = <span class="number">0</span>, n</span><br><span class="line">	<span class="keyword">while</span> left &lt; right:</span><br><span class="line">		mid = <span class="built_in">floor</span>((left + right) / <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">			<span class="keyword">return</span> mid</span><br><span class="line"></span><br><span class="line">		elif nums[mid] &lt; target:</span><br><span class="line">			left = mid + <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			right = mid</span><br><span class="line"></span><br><span class="line">	<span class="comment">// post-processing</span></span><br><span class="line">	<span class="keyword">if</span> left != len(nums) <span class="keyword">and</span> nums[left] == target:</span><br><span class="line">		<span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>初始条件：<code>left = 0, right = n</code>，保证<code>n-1</code>可以被正确处理</li>
<li><strong>终止情况</strong>：<code>left = right</code></li>
<li>指针移动：<code>left = mid + 1, right = mid</code></li>
<li>中点选择对此有影响，指针移动行为非对称，取<code>ceiling</code>则
  终止情况还有<code>left = right + 1</code></li>
</ul>
</blockquote>
<ul>
<li><p><strong>关键特点</strong></p>
<ul>
<li><code>left</code>、<code>right</code>循环内不会重合</li>
<li>由于<code>floor</code>的特性，<code>mid</code>可以<code>right</code>任意比较，无需
顾忌和<code>right</code>重合</li>
<li>需要和<strong>右邻居</strong>、<code>right</code>比较时适合使用</li>
</ul>
</li>
<li><p>终止情况：<code>left = right</code></p>
<ul>
<li>循环过程中会保证<strong>查找空间至少有2个元素</strong>，否则循环
终止</li>
<li>循环终止条件导致退出循环时，可能<code>left=right=n</code>越界</li>
</ul>
</li>
<li><p><code>target</code>位置</p>
<ul>
<li>若存在<code>target</code>，可能位于<code>mid</code>、<code>left=right</code></li>
<li>若不存在<code>target</code>，则<code>target</code>位于<code>(left-1, left)</code></li>
<li>适合<strong>访问目标在数组中索引、及其直接右邻居</strong></li>
</ul>
</li>
<li><p><strong>仅二分查找</strong>，甚至无需后处理</p>
</li>
<li><p>判断<code>nums</code>长度在某些语言中也可以省略</p>
</li>
</ul>
<h4 id="高级版3-原"><a href="#高级版3-原" class="headerlink" title="高级版3-原"></a>高级版3-原</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">BinarySearchNoKeep(nums[<span class="number">0.</span>.n<span class="number">-1</span>], target):</span><br><span class="line">	<span class="comment">// 折半查找，保证左右指针不交错</span></span><br><span class="line">	<span class="comment">// 输入：升序数组nums、查找键target</span></span><br><span class="line">	<span class="comment">// 输出：存在返回数组元素下标m，否则返回-1</span></span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">	left, right = <span class="number">-1</span>, n<span class="number">-1</span></span><br><span class="line">	<span class="keyword">while</span> left &lt; right - <span class="number">1</span>:</span><br><span class="line">		mid = <span class="built_in">floor</span>((left + right) / <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">			<span class="keyword">return</span> mid</span><br><span class="line"></span><br><span class="line">		elif nums[mid] &lt; target:</span><br><span class="line">			left = mid</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			right = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// post-processing</span></span><br><span class="line">	<span class="keyword">if</span> right &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[right] == target:</span><br><span class="line">		<span class="keyword">return</span> right</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>初始条件：<code>left = -1, right = n-1</code></li>
<li><strong>终止情况</strong>：<code>left = right</code>、<code>left = right + 1</code></li>
<li>指针移动：<code>left = mid, right = mid - 1</code></li>
<li>中点选择对此有影响，指针移动行为非对称，取<code>ceiling</code>则
  同高级版本2</li>
</ul>
</blockquote>
<ul>
<li><p>终止条件：<code>left = right</code>、<code>left = right - 1</code></p>
<ul>
<li><p>循环过程中保证<strong>查找空间至少有3个元素</strong>，否则循环
终止</p>
</li>
<li><p>由于<code>floor</code>特性，必须在<code>left &lt; right - 1</code>时即终止
循环，否则可能死循环</p>
</li>
<li><p>循环终止后，<code>left=right=-1</code>可能越界</p>
</li>
</ul>
</li>
<li><p><code>target</code>位置</p>
<ul>
<li>若存在<code>target</code>，可能位于<code>mid</code>、<code>left=right</code></li>
<li>若不存在<code>target</code>，则<code>target</code>位于<code>(left, left+1)</code></li>
<li>适合<strong>访问目标在数组中索引、及其直接左邻居</strong></li>
</ul>
</li>
<li><p>此版本仅想实现二分查找<strong>必须后处理</strong></p>
<ul>
<li><p>终止条件的原因，最后一次<code>right=left + 1</code>时未被检查
即退出循环</p>
</li>
<li><p>可能在任何位置发生，不是端点问题</p>
</li>
</ul>
</li>
</ul>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>前两个版本比较常用，最后两个版本逻辑类似</p>
</li>
<li><p>折半查找时间效率</p>
<ul>
<li>最坏情况下：$\in \Theta(log n)$</li>
<li>平均情况下仅比最差稍好</li>
</ul>
</li>
<li><p>就<strong>依赖键值比较</strong>的查找算法而言，折半查找已经是最优算法
，但是插值算法、散列法等具有更优平均效率</p>
</li>
<li><p>减常因子因子法</p>
</li>
</ul>
<h3 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h3><p>Interpolation Search：查找有序数组，在折半查找的基础上考虑
查找键的值</p>
<h4 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>假设数组值是线性递增，即<em>数字值~索引</em>为一条直线，则根据
直线方程，可以估计查找键K在A[l..r]所在的位置</p>
<script type="math/tex; mode=display">
x = l + \left \lfloor \frac {(K-A[l])(r-l)}
   {A[r] - A[l]} \right \rfloor</script></li>
<li><p>若k == A[x]，则算法停止，否则类似折半查找得到规模更小的
问题</p>
</li>
</ul>
<h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>即使数组值不是线性递增，也不会影响算法正确性，只是每次
估计查找键位置不够准确，影响算法效率</p>
</li>
<li><p>统计考虑</p>
<ul>
<li>折半插值类似于非参方法，只考虑秩（索引）方向</li>
<li>插值查找类似参数方法，构建了秩（索引）和数组值模型，
但是线性关系基于假设</li>
<li>如果模型错误可能会比折半查找效率更差，即在数据分布
分布偏差较大的情况下非参方法好于参数方法</li>
</ul>
</li>
<li><p>所以是否可以考虑取样方法，先取5个点构建模型，然后估计</p>
</li>
<li><p>算法效率</p>
<ul>
<li>对随机列表，算法比较次数小于$log_2log_n+1$</li>
<li>最差情况，比较次数为线性，没有折半查找稳定</li>
<li>Robert Sedgewick的Algorithms中研究表明，对较小文件
折半查找更好，大文件、比较开销大插值查找更好</li>
</ul>
</li>
<li><p>减可变规模</p>
</li>
</ul>
<h2 id="子串匹配"><a href="#子串匹配" class="headerlink" title="子串匹配"></a>子串匹配</h2><h3 id="蛮力字符串匹配"><a href="#蛮力字符串匹配" class="headerlink" title="蛮力字符串匹配"></a>蛮力字符串匹配</h3><h4 id="算法-4"><a href="#算法-4" class="headerlink" title="算法"></a>算法</h4><ul>
<li>将pattern对齐文本前m个字符，从左向右匹配相应字符<ul>
<li>m个字符全部匹配，匹配成功，算法停止</li>
<li>遇到不匹配字符则</li>
</ul>
</li>
<li>模式右移1位，然后从模式首个字符开始重复以上匹配</li>
<li>在n-m位置无法匹配成功，则无足够匹配字符，算法停止</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BruteForceStringMatch(T[<span class="number">0.</span>.n<span class="number">-1</span>], P[<span class="number">0.</span>.m<span class="number">-1</span>])</span><br><span class="line">	<span class="comment">// 蛮力字符串匹配</span></span><br><span class="line">	<span class="comment">// 输入：文本T：n个字符的字符数组</span></span><br><span class="line">	<span class="comment">//       模式：m个字符的字符数组</span></span><br><span class="line">	<span class="comment">// 输出：查找成功返回文本第一个匹配子串中第一个字符位置</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span> to m-m <span class="keyword">do</span></span><br><span class="line">		j = <span class="number">0</span></span><br><span class="line">		<span class="keyword">while</span> j &lt; m <span class="keyword">and</span> P[j] = T[i+j] <span class="keyword">do</span></span><br><span class="line">			j = j + <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> j = m</span><br><span class="line">				<span class="keyword">return</span> i</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><ul>
<li>最坏情况下，算法比较次数属于$O(nm)$<ul>
<li>即在移动模式之前，算法需要做足m次比较</li>
<li>但是一般在自然语言中，算法平均效率比最差好得多</li>
<li>在随机文本中，有线性效率</li>
</ul>
</li>
</ul>
<h3 id="Horspool算法"><a href="#Horspool算法" class="headerlink" title="Horspool算法"></a>Horspool算法</h3><p>算法<strong>从右往左</strong>匹配，在<strong>任意位置</strong>匹配不成功时只考虑
<strong>同模式最后字符匹配的文本字符<code>c</code></strong>，确定安全移动距离，在
不会错过匹配子串的情况下移动最长距离</p>
<ul>
<li>如果<code>c</code>在模式中出现，则模式移动到其最后<code>c</code>至同文本中<code>c</code>
匹配</li>
<li>否则移动模式长度m</li>
<li>特别的，如果<code>c</code>只在模式最后字符出现，则也应该移动m</li>
</ul>
<h4 id="算法-5"><a href="#算法-5" class="headerlink" title="算法"></a>算法</h4><ul>
<li>对给定长度m的模式及文本中用到的字母表，构造移动表<code>t</code></li>
<li>将模式同文本开始对齐</li>
<li>重复以下过程直至发了了匹配子串或模式达到了文本字符外<ul>
<li>从模式<strong>最后字符开始</strong>，比较模式、文本相应字符</li>
<li>若m个字符匹配，停止</li>
<li>遇到不匹配字符<code>c</code>，若为当前文本中和模式最后匹配字符
对齐的字符，将模式移动<code>t(c)</code>个字符</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ShiftTable(P[<span class="number">0.</span>.m<span class="number">-1</span>])</span><br><span class="line">	<span class="comment">// 用Horspool算法、Boyer-Moore算法填充移动表</span></span><br><span class="line">	<span class="comment">// 输入：模式P[0..m-1]、可能出现字符表</span></span><br><span class="line">	<span class="comment">// 输出：以字符表为为索引的数组Table[0..size-1]</span></span><br><span class="line">	<span class="keyword">for</span> i=<span class="number">0</span> to size<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">		Table[i] = m</span><br><span class="line">		<span class="comment">// 初始化所有字符对应移动距离为m</span></span><br><span class="line">	<span class="keyword">for</span> j=<span class="number">0</span> to m<span class="number">-2</span> <span class="keyword">do</span></span><br><span class="line">		Table[P[j]] = m - <span class="number">1</span> - j</span><br><span class="line">		<span class="comment">// 对模式中存在的字符重新计算移动距离</span></span><br><span class="line">	<span class="keyword">return</span> Table</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HorspoolMatching(P[<span class="number">0.</span>.m<span class="number">-1</span>], T[<span class="number">0.</span>.n<span class="number">-1</span>])</span><br><span class="line">	<span class="comment">// 实现Horspool字符串匹配算法</span></span><br><span class="line">	<span class="comment">// 输入：模式P[0..m-1]、文本T[0..n-1]</span></span><br><span class="line">	<span class="comment">// 输出：第一个匹配子串最左端字符下标，未匹配返回-1</span></span><br><span class="line">	Table = ShiftTable(P[<span class="number">0.</span>.m<span class="number">-1</span>])</span><br><span class="line">	i = m - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> i &lt;= n<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">		k = <span class="number">0</span></span><br><span class="line">		<span class="keyword">while</span> k &lt;= m<span class="number">-1</span> <span class="keyword">and</span> P[m<span class="number">-1</span>-k]=T[i-k] <span class="keyword">do</span></span><br><span class="line">			k = k+<span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> k == m</span><br><span class="line">			<span class="keyword">return</span> i-m+<span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			i = i+Table[T[i]]</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h4 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>算法效率</p>
<ul>
<li>最差情况下模式为相同字符，效率$\in O(nm)$</li>
<li>对随机文本效率$\in O(n)$</li>
</ul>
</li>
<li><p>输入增强</p>
</li>
</ul>
<h3 id="Boyer-Moore算法"><a href="#Boyer-Moore算法" class="headerlink" title="Boyer-Moore算法"></a>Boyer-Moore算法</h3><ul>
<li>坏符号移动：模式、文本中相应不匹配字符<strong>确定</strong>的移动
（不是Horspool中简单根据最后字符确定移动）</li>
<li>好后缀移动：模式、文本匹配的后缀<strong>确定</strong>的移动</li>
</ul>
<h4 id="算法-6"><a href="#算法-6" class="headerlink" title="算法"></a>算法</h4><ul>
<li>对给定长度m的模式及文本用到的字母表，构造坏符号移动表<code>t</code></li>
<li>对给定长度m的模式构造后缀移动表</li>
<li>将模式与文本开始处对齐</li>
<li>重复以下直到找到匹配子串或模式达到文本字符以外<ul>
<li>从模式最后字符开始比较模式、文本相应字符</li>
<li>所有m个字符匹配，则停止</li>
<li>若<code>c</code>是不匹配字符，移动坏符号表、后缀移动表决定的
距离较大者</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BadSymbolShift(P[<span class="number">0.</span>.m<span class="number">-1</span>])</span><br><span class="line">	<span class="comment">// 创建坏符号移动表</span></span><br><span class="line">	<span class="comment">// 输入：模式P[0..m-1]</span></span><br><span class="line">	<span class="comment">// 输出：坏符号移动表</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>算法效率</p>
<ul>
<li>算法效率最差也是线性的</li>
</ul>
</li>
<li><p>输入增强</p>
</li>
</ul>
<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>算法<strong>从左往右</strong>匹配，失败时不回溯指针，利用已经得到的
<strong>部分匹配</strong>结果尽可能将模式滑动一段距离，从模式中间<em>next</em>
字符开始比较</p>
<script type="math/tex; mode=display">
next[i] =
\left \{ \begin{array} {l}
    -1 & i=0 \\
    Max\{k|0<k<m-1, 'p_0 \cdots p_{k-1}' == \
        'p_{i-k} \cdots p_{i-1}\}' \
        & 此集合不空 \\
    0 & 其他情况 \\
\end{array} \right.</script><h4 id="算法-7"><a href="#算法-7" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">KMPShift(P[<span class="number">0.</span>.m<span class="number">-1</span>])</span><br><span class="line">	<span class="comment">// 计算KMP算法next值</span></span><br><span class="line">	<span class="comment">// 输入：模式P[0..m-1]</span></span><br><span class="line">	<span class="comment">// 输出：模式中各元素next值数组</span></span><br><span class="line">	i = <span class="number">-1</span></span><br><span class="line">		<span class="comment">// 表示开始比较文本中下个字符</span></span><br><span class="line">	j = <span class="number">0</span></span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">		<span class="comment">// 即如果模式首字符都不匹配，比较文本下个字符</span></span><br><span class="line">	<span class="keyword">while</span> j &lt; m</span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">-1</span> <span class="keyword">or</span> P[j] == P[i]</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">			j += <span class="number">1</span></span><br><span class="line">			<span class="comment">// 当前字符匹配成功，决定下个字符next值</span></span><br><span class="line">			next[j] = i</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			i = next[i]</span><br><span class="line">			<span class="comment">// 若当前字符没有匹配成功，不会立即处理下个字符</span></span><br><span class="line">			<span class="comment">// next值，而是反复迭代、查询已匹配部分next值，</span></span><br><span class="line">			<span class="comment">// 以获得最大匹配前缀</span></span><br><span class="line">	<span class="keyword">return</span> next</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">KMPShiftVal(P[<span class="number">0.</span>.m<span class="number">-1</span>])</span><br><span class="line">	<span class="comment">// 计算KMP算法next值修正版（考虑next值与当前相等）</span></span><br><span class="line">	<span class="comment">// 输入：模式P[0..m-1]</span></span><br><span class="line">	<span class="comment">// 输出：模式中各元素next_val值数组u</span></span><br><span class="line">	i = <span class="number">-1</span></span><br><span class="line">		<span class="comment">// 表示开始比较文本中下个字符</span></span><br><span class="line">	j = <span class="number">0</span></span><br><span class="line">	next_val[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">	<span class="keyword">while</span> j &lt; m <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">-1</span> <span class="keyword">or</span> P[j] == P[i]</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">			j += <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> T[j] != T[i]</span><br><span class="line">				next_val[j] = i</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				next_val[j] = next_val[i]</span><br><span class="line">				<span class="comment">// 考虑了next值相同时，可以再滑动一次</span></span><br><span class="line">				<span class="comment">// 这里会导致next_val值跳跃</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			i = next_val[i]</span><br><span class="line">	<span class="keyword">return</span> next_val</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">KMPMatching(P[<span class="number">0.</span>.m<span class="number">-1</span>], T[<span class="number">0.</span>.n<span class="number">-1</span>])</span><br><span class="line">	<span class="comment">// 实现KMP字符串匹配算法</span></span><br><span class="line">	<span class="comment">// 输入：模式P[0..m-1]、文本T[0..n-1]</span></span><br><span class="line">	<span class="comment">// 输出：第一个匹配子串最左端字符下标，未匹配返回-1</span></span><br><span class="line">	i = <span class="number">0</span></span><br><span class="line">	j = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> i &lt; m <span class="keyword">and</span> j &lt; n <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">-1</span> <span class="keyword">or</span> P[i] == T[j]</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">			j += <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			i = next[i]</span><br><span class="line">	<span class="keyword">if</span> i &gt;= m</span><br><span class="line">		<span class="keyword">return</span> j - m + <span class="number">1</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h4 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>算法效率</p>
<ul>
<li>算法时间效率$\in O(m+n)$</li>
</ul>
</li>
<li><p>文本指针不需要回溯，整个匹配过程只需要对文本扫描一次，
对流程处理十分有效，可以边读边匹配</p>
</li>
<li><p>输入增强</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-18T05:32:24.000Z" title="4/18/2019, 1:32:24 PM">2019-04-18</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-04-18T05:32:24.000Z" title="4/18/2019, 1:32:24 PM">2019-04-18</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Problem/">Problem</a></span><span class="level-item">23 minutes read (About 3521 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Problem/sorting.html">排序</a></h1><div class="content"><h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><ul>
<li>按照升序重新排列给定列表中的数据项</li>
<li>为了让问题有意义，列表中的数据项应该能够排序（数据之间
有一种全序关系）</li>
<li>键：在对记录排序时，需要选取的、作为排序的依据的一段信息</li>
</ul>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ul>
<li>排序可能是所求解的问题输出要求</li>
<li>排序能够更方便的求解和列表相关的问题<ul>
<li>查找问题</li>
</ul>
</li>
<li>在其他领域的重要算法中，排序也被作为辅助步骤</li>
</ul>
<h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><ul>
<li><p>排序领域已经有很多不错的算法，只需要做$nlog_{x}^{n}$次
比较就能完成长度为$n$的任意数组排序，且没有一种基于
<strong>键</strong>值比较（相较于比较键值部分内容而言）的排序算法能
在本质上操作其，</p>
</li>
<li><p>但是还是需要不断探寻新的算法虽然有些算法比其他的要好，
但是没有任何算法在任何情况下是最优的</p>
<ul>
<li>有些算法比较简单，但速度较慢</li>
<li>有些算法适合随机排列的输入，而有些适合基本有序的列表</li>
<li>有些算法适合驻留在快速存储器中的列表，而有些适合存储
在磁盘上的大型文件排序</li>
</ul>
</li>
</ul>
<h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><ul>
<li>稳定性：排序算法保留等值元素在输入中的相对顺序<ul>
<li>一般来说，将相隔很远的键交换位置的算法虽然不稳定，
但往往很快</li>
</ul>
</li>
<li>在位性：排序算法不需要额外的存储空间，除极个别存储单元外</li>
</ul>
<h2 id="线性表排序"><a href="#线性表排序" class="headerlink" title="线性表排序"></a>线性表排序</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul>
<li>每轮<strong>选择出</strong>剩余元素中最小值，放在对于位置上</li>
</ul>
<h4 id="顺序表算法"><a href="#顺序表算法" class="headerlink" title="顺序表算法"></a>顺序表算法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SelectionSort(A[<span class="number">0.</span>.n-<span class="number">1</span>]):</span><br><span class="line">	// 选择排序排序数组</span><br><span class="line">	// 输入：可排序数组A[<span class="number">0.</span>.n-<span class="number">1</span>]</span><br><span class="line">	// 输出：升序排序数组A[<span class="number">0.</span>.n-<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span> to n-<span class="number">1</span> do</span><br><span class="line">		<span class="built_in">min</span> = i</span><br><span class="line">		<span class="keyword">for</span> j = i to n-<span class="number">1</span> do</span><br><span class="line">			<span class="keyword">if</span> A[j] &lt; A[<span class="built_in">min</span>]</span><br><span class="line">				<span class="built_in">min</span> = j</span><br><span class="line">		swap A[i] <span class="keyword">and</span> A[<span class="built_in">min</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>扫描整个列表找到最小元素，然后和首个元素交换，将其放在
最终位置上</li>
<li>从第2个元素开始寻找之后最小元素，和第2个元素交换，将其
放在最终位置上</li>
<li>重复n-1次，列表有序</li>
</ul>
<h4 id="链表算法"><a href="#链表算法" class="headerlink" title="链表算法"></a>链表算法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">SelectionSort(linked):</span><br><span class="line">	// 选择排序排序链表</span><br><span class="line">	// 输入：可排序链表linked头</span><br><span class="line">	// 输出：排序后链表头</span><br><span class="line">	<span class="keyword">if</span> linked == NULL:</span><br><span class="line">		<span class="keyword">return</span> NULL</span><br><span class="line">	linked_head = ListNode()</span><br><span class="line">		// 为方便附设头结点</span><br><span class="line">	linked_head.<span class="built_in">next</span> = linked</span><br><span class="line">	unsorted_head = linked_head</span><br><span class="line">		// 未排序头结点</span><br><span class="line">		// 后续过程中是链表中元素</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> unsorted_head.<span class="built_in">next</span> != NULL:</span><br><span class="line">		cur_node = unsorted_head</span><br><span class="line">		min_node = unsorted_head</span><br><span class="line">			// 全是链表中元素</span><br><span class="line">		<span class="keyword">while</span> cur_node.<span class="built_in">next</span> != NULL:</span><br><span class="line">			<span class="keyword">if</span> cur_node.<span class="built_in">next</span>.val &lt; min_node.<span class="built_in">next</span>.val:</span><br><span class="line">				min_node = cur_node</span><br><span class="line">			cur_node = cur_node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">		// 若`min_node.<span class="built_in">next</span>`就是`unsorted_start.<span class="built_in">next</span>`，以下</span><br><span class="line">			// 代码中的断开、重组链表操作会出现环</span><br><span class="line">		// 完全切开再重组链表，则需要判断`unsorted_start`</span><br><span class="line">			// 是否为空</span><br><span class="line">		<span class="keyword">if</span> unsorted_start.<span class="built_in">next</span> != min_node.<span class="built_in">next</span>:</span><br><span class="line">			_tmp_node = unsorted_head.<span class="built_in">next</span></span><br><span class="line">				// 记录原`unsorted_head.<span class="built_in">next</span>`</span><br><span class="line"></span><br><span class="line">			unsorted_head.<span class="built_in">next</span> = min_node.<span class="built_in">next</span></span><br><span class="line">				// `unsorted_head.<span class="built_in">next</span>`断开、连接`min_node`</span><br><span class="line"></span><br><span class="line">			min_node.<span class="built_in">next</span> = min_node.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">				// `min_node.<span class="built_in">next</span>`断开、跳过`min_node`重连</span><br><span class="line">				// 若`min_node.<span class="built_in">next</span>`是`unsorted_start.<span class="built_in">next</span>`</span><br><span class="line">					// 会断开`unsorted_start`和`min_node`</span><br><span class="line"></span><br><span class="line">			unsorted_head.<span class="built_in">next</span>.<span class="built_in">next</span> = _tmp_node</span><br><span class="line">				// 原`min_node`重连原`unsorted_head.<span class="built_in">next</span>`</span><br><span class="line"></span><br><span class="line">		unsorted_start = unsorted_start.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> linked_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>对任何输入，选择排序键值比较都是$\Theta(n^2)$</li>
<li>键交换次数仅为$\Theta(n)$<ul>
<li>选择排序此特性优于许多其他排序算法</li>
</ul>
</li>
</ul>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul>
<li>比较表中相邻元素，如果逆序就交换位置</li>
<li>重复多次则最大元素被“沉到”列表最后位置</li>
<li>第2轮比较将第2大元素“沉到”其最终位置</li>
<li>重复比较n-1轮，列表有序</li>
</ul>
<h4 id="顺序表算法-1"><a href="#顺序表算法-1" class="headerlink" title="顺序表算法"></a>顺序表算法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BubbleSort(A[<span class="number">0.</span>.n-<span class="number">1</span>]):</span><br><span class="line">	// 冒泡排序排序数组</span><br><span class="line">	// 输入：可排序数组A[<span class="number">0.</span>.n-<span class="number">1</span>]</span><br><span class="line">	// 输出：升序排序数组A[<span class="number">0.</span>.n-<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span> to n-<span class="number">2</span> do</span><br><span class="line">		<span class="keyword">for</span> j = <span class="number">0</span> to n-<span class="number">2</span>-i do</span><br><span class="line">			<span class="keyword">if</span> A[j+i] &lt; A[j]</span><br><span class="line">				swap A[j] <span class="keyword">and</span> A[j+<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="链表算法-1"><a href="#链表算法-1" class="headerlink" title="链表算法"></a>链表算法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BublleSort(head):</span><br><span class="line">	// 冒泡排序排序链表</span><br><span class="line">	// 输入：可排序链表首个元素</span><br><span class="line">	// 输出：排序后列表首个元素</span><br></pre></td></tr></table></figure>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>对任何输入，冒泡排序键值比较都是$\Theta(n^2)$</li>
<li>其交换次数取决于特定输入<ul>
<li>最坏情况是遇到降序排列数组，此时键交换次数同比较次数</li>
</ul>
</li>
<li>冒泡排序看起来就像是选择排序的<strong>一直交换+最大优先</strong>版本</li>
</ul>
<h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><ul>
<li>如果对列表比较一轮后没有交换任何元素，说明列表有序，可以
结束算法</li>
</ul>
<h3 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h3><p>插入排序：利用减一技术对数组$A[0..n-1]$进行排序</p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ul>
<li>假设对较小数组$A[0..i-2]$排序已经解决</li>
<li>从右至左（方便将将元素右移）扫描有序子数组，直到遇到首个
小于等于$A[i-1]$元素，将$A[i-1]$插入其后</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">InsertionSort(A[<span class="number">0.</span>.n-<span class="number">1</span>])</span><br><span class="line">	// 用插入排序对给定数组排序</span><br><span class="line">	// 输入：n个可排序元素构成数组</span><br><span class="line">	// 输出：非降序排序数组</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span> to n-<span class="number">1</span> do</span><br><span class="line">		v = A[i]</span><br><span class="line">		j = i - <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> A[j] &gt; v do</span><br><span class="line">			A[j+<span class="number">1</span>] = A[j]</span><br><span class="line">			j = j - <span class="number">1</span></span><br><span class="line">		A[j+<span class="number">1</span>] = v</span><br><span class="line">		// 上一步比较元素已经赋值给其后，所以应该覆盖其值</span><br></pre></td></tr></table></figure>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>插入排序是自顶向下基于递归思想，但是自底向上使用迭代实现
算法效率更高</p>
</li>
<li><p>算法时间效率</p>
<ul>
<li>算法基本操作是键值比较，比较次数依赖于特定输入</li>
<li>最坏情况（递减数组）下：每轮比较次数都到达最大，此时
键值比较次数$\in \Theta(n^2)$</li>
<li>最优情况（递增数组）下：每轮比较次数仅为1，此时键值
比较次数$\in \Theta(n)$</li>
<li>对随机序列：比较次数$\in \Theta(n^2)$</li>
<li>许多应用中都会遇到基本有序的文件，插入排序能保证良好
性能</li>
</ul>
</li>
<li><p>减常量法</p>
</li>
</ul>
<h3 id="Shell-Sort"><a href="#Shell-Sort" class="headerlink" title="Shell Sort"></a>Shell Sort</h3><p>插入排序的扩展，Shell排序基于<em>h有序</em></p>
<h4 id="H有序"><a href="#H有序" class="headerlink" title="H有序"></a>H有序</h4><p>数组中任意间隔为h的元素都是有序的，对应的数组称为<em>h有序数组</em></p>
<ul>
<li><em>h有序数组</em>：就是h个互相独立的有序数组<strong>编织</strong>在一起数组</li>
<li><em>h有序数组</em>具有分离、局部有序的特点</li>
</ul>
<h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><ul>
<li>使用插入排序对<em>h子数组</em>独立排序，每次交换相隔h的元素</li>
<li>h逐渐减小到1，shell排序退化（最后一轮）为插入排序</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ShellSort(A[<span class="number">0.</span>.n-<span class="number">1</span>])</span><br><span class="line">	// 用插入排序对给定数组排序</span><br><span class="line">	// 输入：n个可排序元素构成数组</span><br><span class="line">	// 输出：非降序排序数组</span><br><span class="line">	h = <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> h &lt; n/<span class="number">3</span></span><br><span class="line">		h = h*<span class="number">3</span> + <span class="number">1</span></span><br><span class="line">		// 获取初始h值，之后每轮h变为<span class="number">1</span>/<span class="number">3</span></span><br><span class="line">	<span class="keyword">while</span> h &gt;= <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">for</span> i = h to n-<span class="number">1</span>:</span><br><span class="line">			v = A[i]</span><br><span class="line">			j = i - h</span><br><span class="line">			<span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> A[j] &gt; v do</span><br><span class="line">				A[j] = A[j-h]</span><br><span class="line">				j = j - h</span><br><span class="line">			A[j+h] = v</span><br><span class="line">		h = h/<span class="number">3</span></span><br></pre></td></tr></table></figure>
<h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>Shell排序全衡量子数组规模、有序性，更加高效</p>
</li>
<li><p>h递增序列</p>
<ul>
<li>子数组部分有序程度取决于h递增序列的选择</li>
<li>不同的h递增序列对算法效率有常数倍的变动，但是在实际
应用中效果不明显</li>
</ul>
</li>
<li><p>Shell排序是唯一无法准确描述其对于乱序数组性能特征的排序
方法</p>
</li>
<li><p>减常量法</p>
</li>
</ul>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="Mergesort"><a href="#Mergesort" class="headerlink" title="Mergesort"></a>Mergesort</h4><ul>
<li>将需要排序的数组A[0..n-1]均分的</li>
<li>对两个子数组<strong>递归排序</strong>，然后把排序后的子数组合并为有序
数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Mergesort(A[<span class="number">0.</span>.n-<span class="number">1</span>]):</span><br><span class="line">	// 递归调用MergeSort对数组排序</span><br><span class="line">	// 输入：可排序数组A[<span class="number">0.</span>.n-<span class="number">1</span>]</span><br><span class="line">	// 输出：非降序排列数组A[<span class="number">0.</span>.n-<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">if</span> n &gt; <span class="number">1</span>:</span><br><span class="line">		copy A[<span class="number">0.</span>.floor(n/<span class="number">2</span>)-<span class="number">1</span>] to B[<span class="number">0.</span>.floor(n/<span class="number">2</span>)-<span class="number">1</span>]</span><br><span class="line">		copy A[floor(n/<span class="number">2</span>)..n-<span class="number">1</span>] to C[<span class="number">0.</span>.ceiling(n/<span class="number">2</span>)-<span class="number">1</span>]</span><br><span class="line">		Mergesort(B[<span class="number">0.</span>.floor(n/<span class="number">2</span>)-<span class="number">1</span>])</span><br><span class="line">		Mergesort(C[<span class="number">0.</span>.ceiling(n/<span class="number">2</span>)-<span class="number">11</span>])</span><br><span class="line">		Merge(B, C, A)</span><br></pre></td></tr></table></figure>
<h4 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h4><ul>
<li>初始两只指针指向待合并数组首个元素</li>
<li>比较两个元素大小，将较小元素添加到新数组中，被复制元素
的数组指针右移</li>
<li>重复直到某一数组处理完毕，将未处理完数组复制到新数组尾部</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Merge(B[<span class="number">0.</span>.p-<span class="number">1</span>], C[<span class="number">0.</span>.q-<span class="number">1</span>], A[<span class="number">0.</span>.p+q-<span class="number">1</span>]):</span><br><span class="line">	// 将两个有序数组合并为新的有序数组</span><br><span class="line">	// 输入：有序数组B[<span class="number">0.</span>.p-<span class="number">1</span>]、C[<span class="number">0.</span>.q-<span class="number">1</span>]</span><br><span class="line">	// 输出：存放有B、C中元素的有序数组A[<span class="number">0.</span>.p+q-<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">while</span> i &lt; p <span class="keyword">and</span> j &lt; q:</span><br><span class="line">		<span class="keyword">if</span> B[i] &lt;= C[j]</span><br><span class="line">			A[k] = B[i]</span><br><span class="line">			i = i + <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			A[k] = C[j]</span><br><span class="line">			j = j + <span class="number">1</span></span><br><span class="line">		k = k + <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> i == p:</span><br><span class="line">		copy C[j..q-<span class="number">1</span>] to A[k..p+q-<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		copy B[i..p-<span class="number">1</span>] to A[k..p+q-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>算法时间效率</p>
<ul>
<li>最坏情况下比较次数$\in \Theta(nlogn)$，为
$nlog_2n-n+1$，十分接近基于比较的排序算法理论上能够
达到的最少次数</li>
</ul>
</li>
<li><p>相较于快排、堆排序</p>
<ul>
<li>合并排序比较稳定，缺点在于需要线性额外空间</li>
<li>虽然能做到在位，但是算法过于复杂，只具有理论上意义</li>
</ul>
</li>
<li><p>算法可以自底向上合并数组的元素对，再合并有序对</p>
<ul>
<li>这可以避免使用堆栈递归调用时时空开销</li>
</ul>
</li>
<li><p>可以把数组划分为待排序的多个部分，再对其递归排序，最后
合并在一起</p>
<ul>
<li>这尤其适合对存在二级存储空间的文件进行排序</li>
<li>也称为<em>Multiway Mergesort</em></li>
</ul>
</li>
<li><p>分治算法</p>
</li>
</ul>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>相较于合并排序按照元素在数组中的位置进行划分，快速排序按照
元素值对其进行划分</p>
<h4 id="Quicksort"><a href="#Quicksort" class="headerlink" title="Quicksort"></a>Quicksort</h4><ul>
<li>对数组中元素重新排列，使得A[s]左边元素均小于A[s]，A[s]
右边元素都大于等于A[s]<ul>
<li>此时A[s]已经位于它在有序数组中的最终位置</li>
</ul>
</li>
<li>接下来对A[s]左右子数组进行排序</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Quicksort(A[l..]r)</span><br><span class="line">	// 对给定可比较数组进行排序</span><br><span class="line">	// 输入：可比较数组A[<span class="number">0.</span>.n-<span class="number">1</span>]子数组A[l..r]</span><br><span class="line">	// 输出：非降序排序的子数组A[l..r]</span><br><span class="line">	<span class="keyword">if</span> l&lt;r</span><br><span class="line">		s = partition(A[l..r])</span><br><span class="line">		Quicksort(A[l..s-<span class="number">1</span>])</span><br><span class="line">		Quicksort(A[s+<span class="number">1.</span>.r])</span><br></pre></td></tr></table></figure>
<h4 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>需要选择合适的划分算法J</p>
<ul>
<li><em>LomutoPartition</em></li>
<li><em>HoarePartition</em></li>
</ul>
</li>
<li><p>算法效率</p>
<ul>
<li>最优情况：分裂点都位于数组中点，算法比较次数为
$nlog_2n$</li>
<li>最差情况：分裂点都趋于极端（逆序输入），算法比较
次数$\in \Theta(n^2)$</li>
<li>平均：比较次数为$2nlnn \approx 1.39nlog_2n$</li>
<li>且算法内层循环效率非常高，在处理随机排列数组时，速度
比合并排序快</li>
</ul>
</li>
<li><p>快速排序缺点</p>
<ul>
<li>不稳定</li>
<li>需要堆栈存储未被排序的子数组参数，尽管可以先对较短
子数组排序使得堆栈大小降低到$O(logn)$，但是还是比
堆排序的$O(1)$差</li>
<li>仍然存在最差情况出现的可能性，即使有很多巧妙地中轴
选择办法</li>
<li>对随机数组排序性能的好坏，不仅与算法具体实现有关，
还和计算机系统结构、数据类型有关</li>
</ul>
</li>
<li><p>分治算法</p>
</li>
</ul>
<h4 id="算法改良"><a href="#算法改良" class="headerlink" title="算法改良"></a>算法改良</h4><ul>
<li><p>更好的中轴选择方法</p>
<ul>
<li>randomized quicksort：随机快速排序，使用随机元素作为
中轴</li>
<li>median-of-three method：三平均划分法，以数组最左边、
最右边、最中间的中位数作为中轴</li>
</ul>
</li>
<li><p>子数组足够小时（5~15），改用插入排序；或者直接不对小数组
排序，而是在快速排序结束后使用插入排序对整个近似有序的
数组进行排序</p>
</li>
<li><p>改进划分方法</p>
<ul>
<li>三路划分：将数组划分为3段，小于、等于、大于中轴元素</li>
</ul>
</li>
</ul>
<h3 id="比较计数排序"><a href="#比较计数排序" class="headerlink" title="比较计数排序"></a>比较计数排序</h3><h4 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h4><ul>
<li>遍历待排序列表中每个元素</li>
<li>计算、记录列表中小于该元素的元素个数</li>
<li>更新大于其的元素的小于元素的元素个数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ComparisonCountingSort(A[<span class="number">0.</span>.n-<span class="number">1</span>])</span><br><span class="line">	// 用比较计数法排序</span><br><span class="line">	// 输入：可排序数组A[<span class="number">0.</span>.n-<span class="number">1</span>]</span><br><span class="line">	// 输出：将A中可排序数组按照升序排列数组</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span> to n-<span class="number">1</span> do</span><br><span class="line">		count[i] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span> to n-<span class="number">2</span> do</span><br><span class="line">		<span class="keyword">for</span> j = i+<span class="number">1</span> to n-<span class="number">1</span> do</span><br><span class="line">			<span class="keyword">if</span> A[i] &lt; A[j]</span><br><span class="line">				count[j] += <span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				count[i] += <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span> to n-<span class="number">1</span> do</span><br><span class="line">		S[count[i]] = A[i]</span><br></pre></td></tr></table></figure>
<h4 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>算法效率</p>
<ul>
<li>算法比较次数为$n(n-1)/2$</li>
<li>占用了线性数量的额外空间</li>
</ul>
</li>
<li><p>算法使得键值的可能移动次数最小化，能够直接将键值放在在
有序数组最终位置</p>
</li>
<li><p>输入增强</p>
</li>
</ul>
<h3 id="分布计数排序"><a href="#分布计数排序" class="headerlink" title="分布计数排序"></a>分布计数排序</h3><ul>
<li>待排序元素来自于某个已知小集合$[l..u]$</li>
</ul>
<h4 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h4><ul>
<li>扫描列表，计算、存储列表中元素出现频率于数组$F[l..u]$中</li>
<li>再次扫描列表，根据值填入相应位置</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DistributionCountingSort(A[<span class="number">0.</span>.n-<span class="number">1</span>], l, u):</span><br><span class="line">	// 分布计数法排序，对元素来自有限范围整数的数组排序</span><br><span class="line">	// 输入：数组[<span class="number">0.</span>.n-<span class="number">1</span>]，数组中整数位于l、u间</span><br><span class="line">	// 输出：A中元素构成非降序数组S[<span class="number">0.</span>.n-<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">for</span> j = <span class="number">0</span> to u-l do</span><br><span class="line">		D[j] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span> to n=<span class="number">1</span> do</span><br><span class="line">		D[A[i]-l] += <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> j = <span class="number">1</span> to u-l do</span><br><span class="line">		D[j] += D[j-<span class="number">1</span>]</span><br><span class="line">		// 存储各元素最后出现索引+<span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i = n-<span class="number">1</span> downto <span class="number">0</span> do</span><br><span class="line">		j = A[i] - l</span><br><span class="line">		S[D[j]-<span class="number">1</span>] = A[i]</span><br><span class="line">		D[j] -= <span class="number">1</span></span><br><span class="line">		// 更新应该存储的位置，类似于压栈</span><br><span class="line">	<span class="keyword">return</span> S</span><br></pre></td></tr></table></figure>
<h4 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>算法效率</p>
<ul>
<li>如果元素值范围固定，效率为线性（不是基于比较的排序，
$nlogn$没有限制）</li>
<li>用空间换时间，其实可以看作是hash</li>
<li>利用了输入列表独特自然属性</li>
</ul>
</li>
<li><p>变治法（输入增强）</p>
</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li>判断线性表元素是否唯一</li>
<li>寻找线性表众数</li>
<li>快速查找</li>
</ul>
<h2 id="线性表顺序统计量"><a href="#线性表顺序统计量" class="headerlink" title="线性表顺序统计量"></a>线性表顺序统计量</h2><p>寻找列表中第k小的元素</p>
<ul>
<li><p>也即：求出给定列表中k个最小元素问题</p>
</li>
<li><p>采用partitioning的思路，需要将给定列表根据某个值先行划分</p>
<ul>
<li><em>Lumuto</em>划分算法</li>
</ul>
</li>
</ul>
<h3 id="QuickSelect算法"><a href="#QuickSelect算法" class="headerlink" title="QuickSelect算法"></a>QuickSelect算法</h3><h4 id="算法-4"><a href="#算法-4" class="headerlink" title="算法"></a>算法</h4><ul>
<li>对划分完后出数组，s为分割位置<ul>
<li>若：s == k-1，则中轴p就是第k小元素</li>
<li>若：s &lt; k-1，则应该是数组右边划分第k-s小元素</li>
<li>若：s &gt; k-1，则应该是数组左边划分第k小元素</li>
</ul>
</li>
<li>这样就得到规模更小的问题实例</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QuickSelect(A[l..r], k)</span><br><span class="line">	// 用基于划分递归算法解决选择问题</span><br><span class="line">	// 输入：可排序数组A[<span class="number">0.</span>.n-<span class="number">1</span>]的子数组A[l..r]、整数k</span><br><span class="line">	// 输出：A[l..r]中第k小元素</span><br><span class="line">	s = Partition(A[l..r])</span><br><span class="line">	<span class="keyword">if</span> s = l+k-<span class="number">1</span></span><br><span class="line">		<span class="keyword">return</span> A[s]</span><br><span class="line">	<span class="keyword">elif</span> s &gt; l+k-<span class="number">1</span></span><br><span class="line">		QuickSelect(A[l..s-<span class="number">1</span>], k)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		QuickSelect(A[s+<span class="number">1.</span>.r], l+k-<span class="number">1</span>-s)</span><br></pre></td></tr></table></figure>
<h4 id="特点-8"><a href="#特点-8" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>时间效率：和划分算法有关（对<em>Lomuto</em>算法）</p>
<ul>
<li>最好情况下只需要划分一次即找到，需要比较$n-1$次</li>
<li>最坏情况下需要比较$n(n-1)/2$次，这比直接基于排序更差</li>
<li>数学分析表明，基于划分的算法平均情况下效率是线性的</li>
</ul>
</li>
<li><p>已经找到复杂算法替代<em>Lomuto</em>算法用于在快速选择中选出
中轴，在最坏情况下仍保持线性时间效率</p>
</li>
<li><p>QuickSelect算法可以不用递归实现，且非递归版本中甚至
不需要调整参数k值，只需要最后<code>s == k-1</code>即可</p>
</li>
<li><p>减可变规模：<em>Lomuto</em>算法性质</p>
</li>
</ul>
<h2 id="线性表有序划分"><a href="#线性表有序划分" class="headerlink" title="线性表有序划分"></a>线性表有序划分</h2><h3 id="LomutoPartition"><a href="#LomutoPartition" class="headerlink" title="LomutoPartition"></a>LomutoPartition</h3><h4 id="算法-5"><a href="#算法-5" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>考虑子数组A[l..r]分为三段，按顺序排在中轴p之后</p>
<ul>
<li>小于p的元素，最后元素索引记为s</li>
<li>大于等于p的元素，最后元素索引记为i</li>
<li>未同p比较过元素</li>
</ul>
</li>
<li><p>从左至右扫描A[l..r]，比较其中元素和p大小</p>
<ul>
<li>若<code>A[i] &gt;= p</code>，扩大大于等于p元素段</li>
<li>若<code>A[i] &lt; p</code>，需要扩大小于等于p元素段</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LomutoPartition(A[l..r])</span><br><span class="line">	// 采用Lomuto算法，用首个元素作中轴划分数组</span><br><span class="line">	// 输入：可排序数组A[<span class="number">0.</span>.n-<span class="number">1</span>]的子数组A[l..r]</span><br><span class="line">	// 输出：A[l..r]的划分、中轴位置</span><br><span class="line">	p = A[l]</span><br><span class="line">	s = l</span><br><span class="line">	<span class="keyword">for</span> i = l+<span class="number">1</span> to r</span><br><span class="line">		<span class="keyword">if</span> A[i] &lt; p</span><br><span class="line">			s = s+<span class="number">1</span></span><br><span class="line">			swap(A[s], A[i])</span><br><span class="line">	swap(A[l], A[s])</span><br><span class="line">	<span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<h3 id="HoarePartition"><a href="#HoarePartition" class="headerlink" title="HoarePartition"></a>HoarePartition</h3><h4 id="算法-6"><a href="#算法-6" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>选择一个元素p作为中轴（最简单的，首个元素p=A[l]）</p>
</li>
<li><p>从数组A[l..r]两端进行扫描，将扫描到的元素同中轴比较</p>
<ul>
<li>从左至右的扫描忽略小于中轴元素，直到遇到大于等于中轴
元素停止（从第二个元素开始i=l+1）</li>
<li>从右至左的扫描忽略大于中轴元素，直到遇到小于等于中轴
元素停止(j=r-1)</li>
</ul>
</li>
<li><p>若扫描停止后</p>
<ul>
<li>两指针不相交i &lt; j，交换A[i]、A[j]，i=i+1、j=j-1，
继续扫描</li>
<li>若指针相交i &gt; j，把中轴和A[j]交换即得到数组一个划分
，分裂点为s=j</li>
<li>如果指针重合i==j，此元素一定等于p，也得到数组的一个
划分，分裂点为s==i==j</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">HoarePartition(A[l..r])</span><br><span class="line">	// 以首元素为中轴，对数组进行划分</span><br><span class="line">	// 输入：可排序数组A[<span class="number">1.</span>.n]的子数组A[l..r]</span><br><span class="line">	// 输出：A[l..r]的一个划分，返回分裂点位置</span><br><span class="line">	p = A[l]</span><br><span class="line">	i = l</span><br><span class="line">	j = r+<span class="number">1</span></span><br><span class="line">	repeat</span><br><span class="line">		repeat i = i+<span class="number">1</span> until A[i] &gt;= p</span><br><span class="line">			// 这里i有可能越界，可以添加一个限位器</span><br><span class="line">		repeat j = j-<span class="number">1</span> until j[i] &lt;= p</span><br><span class="line">			// 从左右两端都是遇到等于p的元素就停止扫描</span><br><span class="line">			// 这样可以保证即使数组中有许多和p相等的元素</span><br><span class="line">			// 也能够将数组划分得比较均匀</span><br><span class="line">		swap(A[i], A[j])</span><br><span class="line">			// 这样写没有关系，不需要在这里给调整i、j</span><br><span class="line">			// 因为循环下一步就是调整i、j</span><br><span class="line">	until i &gt;= j</span><br><span class="line">	swap(A[i], A[j])</span><br><span class="line">		// 撤销算法最后一次交换</span><br><span class="line">	swap(A[l], A[j])</span><br><span class="line">	<span class="keyword">return</span> j</span><br></pre></td></tr></table></figure>
<h3 id="三路划分"><a href="#三路划分" class="headerlink" title="三路划分"></a>三路划分</h3><h4 id="算法-7"><a href="#算法-7" class="headerlink" title="算法"></a>算法</h4></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-12T08:01:20.000Z" title="4/12/2019, 4:01:20 PM">2019-04-12</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-04-12T08:01:20.000Z" title="4/12/2019, 4:01:20 PM">2019-04-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Problem/">Problem</a></span><span class="level-item">an hour read (About 9286 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Problem/graph.html">图算法</a></h1><div class="content"><h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><ul>
<li>图的遍历算法：如何一次访问到网络中所有节点</li>
<li>最短路线算法：两个城市间最佳路线</li>
<li>有向图拓扑排序：课程、预备课程是否有矛盾</li>
<li>All-Pairs Shortest-Paths Problem：完全最短路径问题，找到
每个顶点到其他所有顶点的距离</li>
</ul>
<h2 id="遍历算法"><a href="#遍历算法" class="headerlink" title="遍历算法"></a>遍历算法</h2><h3 id="Depth-First-Search"><a href="#Depth-First-Search" class="headerlink" title="Depth-First Search"></a>Depth-First Search</h3><p>深度优先查找（DFS）</p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>从<strong>任意顶点</strong>开始访问图顶点，然后标记为已访问</p>
</li>
<li><p>每次迭代时，紧接着处理与当前顶点<strong>邻接的未访问顶点</strong>，
直到遇到终点，该顶点所有邻接顶点均已访问过</p>
</li>
<li><p>在终点上，算法<strong>沿着来路</strong>后退一条边，继续从那里访问未
访问顶点</p>
</li>
<li><p>后退到<strong>起始点</strong>，且起始点也是终点时，算法停止，这样
起始点所在的连通分量的所有顶点均已访问过</p>
</li>
<li><p>若存在未访问顶点，则必须从其中任一顶点开始重复上述</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line">	<span class="comment">// 全局变量：访问次序（次数）</span></span><br><span class="line">DFS(G)</span><br><span class="line">	<span class="comment">// 对给定图的深度优先查找遍历</span></span><br><span class="line">	<span class="comment">// 输入：图G=&lt;V, E&gt;</span></span><br><span class="line">	<span class="comment">// 输出：图G顶点按照DFS遍历第一次访问到的先后次序，</span></span><br><span class="line">	<span class="comment">//       未访问到标记未0</span></span><br><span class="line">	<span class="keyword">for</span> each vertex v in V <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span> v is marked with <span class="number">0</span></span><br><span class="line">			dfs(v)</span><br><span class="line">dfs(v)</span><br><span class="line">	<span class="comment">// 递归访问所有和v相连接的未访问顶点，赋予count值</span></span><br><span class="line">	count = count+<span class="number">1</span></span><br><span class="line">	mark v with count</span><br><span class="line">	<span class="keyword">for</span> each vertex w in V adjecnt to v <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span> w is marked with <span class="number">0</span></span><br><span class="line">			dfs(w)</span><br></pre></td></tr></table></figure>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>算法效率非常高效，消耗时间和表示图的数据结构规模成正比</p>
<ul>
<li>邻接矩阵：遍历时间效率$\in \Theta(|V|^2)$</li>
<li>邻接链表：遍历时间效率$\in \Theta(|V|+|E|)$</li>
</ul>
</li>
<li><p>可以方便地用栈跟踪深度优先查找</p>
<ul>
<li>首次访问顶点，将顶点入栈</li>
<li>当顶点成为终点时，将其出栈</li>
<li>运行时就是实际上就是栈，所以深度优先可以直接利用递归
实现</li>
</ul>
</li>
<li><p><em>Depth-First Search Foreat</em>：参见
<em>algorithm/data_structure/graph</em></p>
</li>
<li><p>DFS产生两种节点排列顺序性质不同，有不同应用</p>
<ul>
<li>入栈（首次访问顶点）次序</li>
<li>出栈（顶点成为终点）次序</li>
</ul>
</li>
</ul>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul>
<li>检查图连通性：算法第一次停止后，是否所有顶点已经访问</li>
<li>检查图无环性：DFS是否包含回边</li>
<li>拓扑排序：见<em>键值法</em><ul>
<li>DFS节点出栈逆序就是拓扑排序的一个解（图中无回边，
即为有向无环图）</li>
<li>DAG中顶点v出栈前，不存在顶点u拥有到v的边，否则存在
回边，图不是DAG</li>
</ul>
</li>
</ul>
<h3 id="Broad-First-Search"><a href="#Broad-First-Search" class="headerlink" title="Broad-First Search"></a>Broad-First Search</h3><p>广度优先查找（BFS）</p>
<h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>首先访问所有和初始顶点邻接的顶点</p>
</li>
<li><p>然后是离它两条边的所有未访问顶点</p>
</li>
<li><p>以此类推，直到所有与初始顶点在同一连通分类顶点均已访问</p>
</li>
<li><p>若存在未访问顶点，从图其他连通分量任意顶点开始</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line">	<span class="comment">// 全局变量：访问次序（次数）</span></span><br><span class="line">BFS(G)</span><br><span class="line">	<span class="comment">// 给定图广度优先查找变量</span></span><br><span class="line">	<span class="comment">// 输入：图G=&lt;V, E&gt;</span></span><br><span class="line">	<span class="comment">// 输出：图G的顶点按照被BFS遍历第一次访问到次序，</span></span><br><span class="line">	<span class="comment">//       未访问顶点标记未0</span></span><br><span class="line">	<span class="keyword">for</span> each vertax v in V <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span> v is marked with <span class="number">0</span></span><br><span class="line">			bfs(v)</span><br><span class="line">bfs(v)</span><br><span class="line">	<span class="comment">// 访问所有和v相连接的顶点，赋count值</span></span><br><span class="line">	count = count+<span class="number">1</span></span><br><span class="line">	whilte <span class="built_in">queue</span> is <span class="keyword">not</span> empty <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">for</span> each vertex w in V adjcent to the front vertex <span class="keyword">do</span></span><br><span class="line">			<span class="keyword">if</span> w is marked with <span class="number">0</span></span><br><span class="line">				count = count+<span class="number">1</span></span><br><span class="line">				mark w with count</span><br><span class="line">				add w to the <span class="built_in">queue</span></span><br><span class="line">		remove the front vertex from the <span class="built_in">queue</span></span><br></pre></td></tr></table></figure>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>算法效率同DFS</p>
<ul>
<li>邻接矩阵：遍历时间效率$\in \Theta(|V|^2)$</li>
<li>邻接链表：遍历时间效率$\in \Theta(|V|+|E|)$</li>
</ul>
</li>
<li><p>使用队列可以方便地跟踪广度优先查找操作</p>
<ul>
<li>从遍历初始顶点开始，标记、入队</li>
<li>每次迭代时，算法查找所有和队头顶点邻接未访问，标记
、入队、将队头顶点出队</li>
</ul>
</li>
<li><p><em>Breadth-First Search Forest</em>：参见
<em>algorithm/data_struture/graph</em></p>
</li>
<li><p>BFS只产生顶点的一种排序，因为队列时FIFO结构，顶点入队、
出队次序相同</p>
</li>
</ul>
<h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><ul>
<li><p>和DFS一样可以检查图的连通性、无环性，但是无法用于比较
复杂的应用</p>
</li>
<li><p>求给定两个顶点间最短路径：从一顶点开始BFS遍历，访问到
另一节点结束（难以证明？）</p>
</li>
</ul>
<h2 id="有向图强连通分量"><a href="#有向图强连通分量" class="headerlink" title="有向图强连通分量"></a>有向图强连通分量</h2><h3 id="Kosaraju算法"><a href="#Kosaraju算法" class="headerlink" title="Kosaraju算法"></a>Kosaraju算法</h3><p>考虑有向图中强连通分量之间不连通的情况</p>
<ul>
<li><p>强连通分量之间没有边</p>
<ul>
<li><p>在任意连通分量中任意结点开始深度优先遍历</p>
</li>
<li><p>访问完所有结点需要DFS次数就是强连通分量数量，每轮
DFS访问的点就是强连通分量中的顶点</p>
</li>
</ul>
</li>
<li><p>强连通分量之间只有单向边</p>
<ul>
<li><p>将强连通分量视为<strong>单个结点</strong>，则整个图可以视为一个
靠连通分量间单向边连接的有向无环图</p>
</li>
<li><p>从最底层强连通分量中任选结点开始进行DFS，则此轮DFS
只能访问当前连通分量中结点</p>
</li>
<li><p>逆序依次在各强连通分量中选择结点进行DFS，则每轮DFS只
访问当前连通分量中结点（其下层连通分量已访问）</p>
</li>
<li><p>直至所有结点访问完毕，则得到所有强连通分量，即每轮
进行DFS访问的结点</p>
</li>
<li><p>以下图为例，从图中连通分量B中任意结点开始进行DFS，
则经过两轮DFS即能找所有强连通分量</p>
<p><img src="/imgs/strongly_connected_two_components.png" alt="strongly_connected_two_components"></p>
</li>
</ul>
</li>
</ul>
<p>由以上分析</p>
<ul>
<li><p>只需要保证<strong>底层强连通分量进行DFS优先搜索</strong></p>
</li>
<li><p>也即在结点搜索优先级中，底层强连通分量中至少有一个结点
在其上层连通分量所有结点之前</p>
</li>
<li><p>可以利用<strong>原图的反向</strong>的DFS<strong>逆后序排列</strong>得到满足条件
的结点优先级序列</p>
<p><img src="/imgs/strongly_connected_two_components_reversed.png" alt="strongly_connected_two_components_reversed"></p>
<ul>
<li><p>若从反向图中最底层强连通分量某结点开始，则只能遍历
自身，反向图中其余连通分量位于其所有结点之前</p>
</li>
<li><p>若从反向图中非最底层强连通分量某结点开始，则能依次
遍历其底层所有强连通分量中结点，且至少该结点位于其余
连通分量所有结点之前</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>逆后序排列参见<em>algorithm/data_structure/graph</em></li>
</ul>
</blockquote>
<h4 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h4><ul>
<li>对原图G每条路径求反，得到反向图$G^R$</li>
<li>对反向图$G^R$求解逆后序序列</li>
<li>按照逆序序列优先级，对原图G进行DFS，每棵DFS生成树就是
一个强连通分量</li>
</ul>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul>
<li>算法效率<ul>
<li>时间效率$\in O(|V| + |E|)$</li>
<li>算法需要对图进行两次DFS，速度较Tanjar算法更慢</li>
</ul>
</li>
</ul>
<h3 id="Tarjan算法"><a href="#Tarjan算法" class="headerlink" title="Tarjan算法"></a>Tarjan算法</h3><p>Tarjan算法：基于图深度优先搜索的算法</p>
<ul>
<li><p>为每个结点维护两个标记，通过此标记确定是否存在回路</p>
<ul>
<li><code>DFN</code>：深度优先搜索中搜索到次序</li>
<li><code>Low</code>：通过回边能访问到的前驱被搜索到的次序</li>
</ul>
<blockquote>
<ul>
<li>还可以维护一个<code>Flag</code>，判断结点是否仍在DFS栈中</li>
</ul>
</blockquote>
</li>
<li><p>对图进行深度优先搜索</p>
<ul>
<li><p>未处理结点入栈，设置其<code>DFN</code>、<code>Low</code>被搜索到的次序</p>
</li>
<li><p>对已处理结点，考虑到深度优先的搜索、退栈方式</p>
<ul>
<li><p>仍然在栈中，则肯定是栈顶元素前驱，连接边为回边，
存在<strong>栈顶节点到该前驱结点的回路</strong></p>
</li>
<li><p>不在栈中，该节点不是祖先结点，连接边为交叉边，
该结点已经在其他连通分量中出栈</p>
</li>
</ul>
</li>
<li><p>使用栈中前驱结点<code>Low/DFN</code>次序更新当前（栈顶）结点，
并递归更新，即使用<strong>子节点访问先驱次序更新父节点</strong></p>
</li>
</ul>
</li>
<li><p>DFS回溯、退栈，考虑栈中每个结点<code>DFN</code>、<code>Low</code></p>
<ul>
<li><p>若<code>DFN[u] &gt; Low[u]</code>：结点<code>u</code>和其<strong>前驱</strong>之间有回路，
即其属于同一个强连通分量</p>
</li>
<li><p>若<code>DFN[u] ==  Low[u]</code>：结点<code>u</code>和其前驱之间没有通路，
没有更多结点属于其所属强连通分量，以结点<code>u</code>为根子树
是一个强连通分量</p>
<ul>
<li>则从栈顶元素开始退栈直至结点<code>u</code>退栈，退栈的所有
元素构成强连通分量</li>
</ul>
</li>
</ul>
</li>
<li><p>每个强连通分量为深度优先搜索树中一个子树</p>
</li>
</ul>
<script type="math/tex; mode=display">
Low[v] = \min\{DFN[v], Low[w], DFN[k]\}</script><blockquote>
<ul>
<li>$w, (w, v) \in E$：顶点v的直接前驱</li>
<li>$k, (v, k) \in E$：顶点v的祖先（即栈中结点）</li>
</ul>
</blockquote>
<h4 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">S = initStack()</span><br><span class="line">DFN[MAX_VERTAX], Low[MAX_VERTEX]</span><br><span class="line">index = <span class="number">0</span></span><br><span class="line">QList = InitList(Queue())</span><br><span class="line"></span><br><span class="line">tarjan(u, E):</span><br><span class="line">	<span class="comment">// 比较DFS搜索次序、回边到达次序判断强连通分量</span></span><br><span class="line">	<span class="comment">// 输入：结点u，边集合E</span></span><br><span class="line">	<span class="comment">// 输出：强连通分量队列列表</span></span><br><span class="line">	DFN[u] = Low[u] = ++ index</span><br><span class="line">	S.push(u)</span><br><span class="line">	<span class="keyword">for</span> each (u, v) in E:</span><br><span class="line">		<span class="keyword">if</span> (v is <span class="keyword">not</span> visited):</span><br><span class="line">			tarjan(v)</span><br><span class="line">			Low[u] = min(Low[u], Low[v])</span><br><span class="line">			<span class="comment">// 使用v找到的前驱更新u能找到前驱，递归更新</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (v in S):</span><br><span class="line">			<span class="comment">// 判断边是否为回边</span></span><br><span class="line">			Low[u] = min(Low[u], DFN[v])</span><br><span class="line">			<span class="comment">// Low[u] = min(Low[u], Low[v])</span></span><br><span class="line">				<span class="comment">// 应该也行</span></span><br><span class="line">	<span class="keyword">if</span>(DFN[u] == Low[u]):</span><br><span class="line">		Q = QList.next()</span><br><span class="line">		repeat</span><br><span class="line">			v = S.pop()</span><br><span class="line">			Q.push(v)</span><br><span class="line">		until (u == v)</span><br></pre></td></tr></table></figure>
<h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><ul>
<li>算法效率<ul>
<li>时间效率$\in O(|V|+|E|)$</li>
</ul>
</li>
</ul>
<h2 id="关节点"><a href="#关节点" class="headerlink" title="关节点"></a>关节点</h2><h3 id="类Tarjan算法"><a href="#类Tarjan算法" class="headerlink" title="类Tarjan算法"></a>类Tarjan算法</h3><ul>
<li>类似Tarjan算法为每个节点维护<code>DFN</code>、<code>Low</code>两个次序<ul>
<li>对非根结点v，<strong>存在</strong>其直接后继w有<code>Low[w] &gt;= DFN[v]</code>
，则v为关节点</li>
<li>对根节点，有两棵以上子树则为关节点</li>
</ul>
</li>
</ul>
<h4 id="算法-4"><a href="#算法-4" class="headerlink" title="算法"></a>算法</h4><p>此算法具体实现和Tarjan算法细节有差异</p>
<ul>
<li>此算法中不需要使用栈保存访问过顶点中是前驱者<ul>
<li>连通无向图DFS只会有回边，已访问点必然是前驱结点</li>
</ul>
</li>
<li>需要对根结点额外判断是否为关节点</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">DFN[MAX_VERTAX], Low[MAX_VERTEX]</span><br><span class="line">index = <span class="number">0</span></span><br><span class="line">Q = InitQueue()</span><br><span class="line"></span><br><span class="line">FindArticul(G):</span><br><span class="line">	<span class="comment">// 输入：无向连通图G</span></span><br><span class="line">	<span class="comment">// 输出：关节点队列</span></span><br><span class="line">	vroot = G.V.pop()</span><br><span class="line">	TarjanArticul(vroot, G)</span><br><span class="line">	<span class="keyword">for</span>(v in G.V <span class="keyword">if</span> v <span class="keyword">not</span> visited)</span><br><span class="line">		<span class="comment">// 根节点有两棵及以上子树</span></span><br><span class="line">		TarjanAricul(vroot, G)</span><br><span class="line">		Q.push(vroot)</span><br><span class="line">		<span class="comment">// 根节点也是关节点</span></span><br><span class="line">	<span class="keyword">return</span> Q</span><br><span class="line"></span><br><span class="line">TarjanArticul(u, G):</span><br><span class="line">	<span class="comment">// 比较DFS搜索次序、回边到达次序判断关节点</span></span><br><span class="line">	<span class="comment">// 输入：结点u，无向连通图G</span></span><br><span class="line">	<span class="comment">// 输出：关节点队列</span></span><br><span class="line">	DFN[u] = Low[u] = ++ index</span><br><span class="line">	<span class="keyword">for</span> each (u, v) in G.E:</span><br><span class="line">		<span class="keyword">if</span> (v is <span class="keyword">not</span> visited):</span><br><span class="line">			tarjan(v)</span><br><span class="line">			Low[u] = min(Low[u], Low[v])</span><br><span class="line">			<span class="comment">// 使用v找到的前驱更新u能找到前驱，递归更新</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			Low[u] = min(Low[u], DFN[v])</span><br><span class="line">			<span class="comment">// Low[u] = min(Low[u], Low[v])</span></span><br><span class="line">				<span class="comment">// 应该也行</span></span><br><span class="line">	<span class="keyword">for</span>(v connected by u)</span><br><span class="line">		<span class="keyword">if</span>(Low[v] &lt;= DFN[u])</span><br><span class="line">			Q.push(u)</span><br><span class="line">	<span class="keyword">return</span> Q</span><br></pre></td></tr></table></figure>
<h2 id="无权路径"><a href="#无权路径" class="headerlink" title="无权路径"></a>无权路径</h2><h3 id="路径数量"><a href="#路径数量" class="headerlink" title="路径数量"></a>路径数量</h3><p>图中顶点i到顶点j之间长度为k的不同路径数量为$A^k[i, j]$</p>
<ul>
<li>A为图的邻接矩阵</li>
<li>可以使用数学归纳法证明</li>
<li>对无向、有向图均适用</li>
</ul>
<h3 id="Warshall算法"><a href="#Warshall算法" class="headerlink" title="Warshall算法"></a>Warshall算法</h3><p>Warshall算法：生成有向图传递闭包</p>
<ul>
<li><p>构造n+1个n阶布尔矩阵$R^{(k)}, k=0,1,\cdots, n$</p>
<ul>
<li><p>$R^{(k)}_{ij}=1$：顶点i、j直接存在中间顶点<strong>编号</strong>
不大于k的有效路径</p>
</li>
<li><p>$R^{(0)}$：邻接矩阵，顶点直接连接</p>
</li>
<li><p>$R^{(k)}, 0&lt;k&lt;n$：路径中间顶点编号最大为<code>k</code></p>
</li>
<li><p>$R^{(n)}$：传递闭包，允许所有类型路径</p>
</li>
<li><p>后继矩阵相对前趋，允许作为路径上顶点增加，可能包含
1数量更多</p>
</li>
</ul>
</li>
<li><p>考虑$R^{(k)}$通过直接前趋$R^{(k-1)}$计算得到</p>
<ul>
<li><p>$R^{(k-1)}$中已有路径在$R^{(k)}$保留</p>
</li>
<li><p>考虑$R^{(k)}$相较于$R^{(k-1)}$新增$r_{ij}=1$</p>
<ul>
<li><p>表示顶点i、j之间存在包含k的路径</p>
</li>
<li><p>若k在路径中出现多次，则将删除回路，得到新路径</p>
</li>
<li><p>则存在ik和kj之间路径满足中间顶点编号小于k，即在
$R^{(k-1)}$中有$r<em>{ik}=1, r</em>{kj}=1$</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="算法-5"><a href="#算法-5" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>若元素$r_{ij}$在$R^{(k-1)}$中为1，则在$R^{(k)}$也是1</p>
</li>
<li><p>若元素$r<em>{ij}$在$R^{(k-1)}$中为0，当且仅当存在v使得
$R^{(k-1)}$中$r</em>{iv}=1, r_{vj}=1$</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Warshall(A[<span class="number">1.</span>.n, <span class="number">1.</span>.n])</span><br><span class="line">	<span class="comment">// 计算传递闭包的Warshall算法</span></span><br><span class="line">	<span class="comment">// 输入：A[1..n, 1..n]包含n个顶点的有向图的邻接矩阵</span></span><br><span class="line">	<span class="comment">// 输出：A的传递闭包</span></span><br><span class="line">	R^<span class="number">0</span> = A</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">for</span> i = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">			<span class="keyword">for</span> j = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">				<span class="keyword">if</span> R^(k<span class="number">-1</span>)[i, j] == <span class="number">1</span> <span class="keyword">or</span></span><br><span class="line">					(R^(k<span class="number">-1</span>)[i, k] == <span class="number">0</span> <span class="keyword">and</span> R^(k<span class="number">-1</span>)[k, j] == <span class="number">0</span>)</span><br><span class="line">					R^k[i, j] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> R^n</span><br></pre></td></tr></table></figure>
<h4 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>算法效率</p>
<ul>
<li>时间效率$\in \Theta(n^3)$<ul>
<li>重新构造最内层循环，可以提高对某些输入的处理速度</li>
<li>将矩阵行视为位串，使用或运算也可以加速</li>
</ul>
</li>
<li>空间效率取决于如何处理布尔矩阵</li>
</ul>
</li>
<li><p>蛮力法：所有点分别作为起点作一次搜索，记录能够访问的顶点</p>
<ul>
<li>对有向图遍历多次</li>
<li>使用邻接链表表示稀疏图，蛮力法渐进效率好于Warshall算法</li>
</ul>
</li>
</ul>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><p>Prim算法：求解最小图最小生成树算法</p>
<ul>
<li>每次添加距离当前树距离最近顶点进树</li>
<li>不断迭代构造最小生成树</li>
</ul>
<h4 id="算法-6"><a href="#算法-6" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>从图顶点集V中任选单顶点作为序列中初始子树</p>
</li>
<li><p>对图中顶点维护两个标记：树中最近顶点、相应距离</p>
<ul>
<li>与树不直接相连顶点置：<code>NULL</code>、$\infty$</li>
<li>每次添加新节点更新两个标记</li>
<li>可使用优先队列维护提高效率</li>
</ul>
</li>
<li><p>以贪婪的方式扩张当前生成树，添加不在树中的<strong>最近顶点</strong></p>
</li>
<li><p>更新顶点和树距离最近的顶点、相应距离</p>
<ul>
<li>只需考察与新添加顶点直接相连顶点即可</li>
</ul>
</li>
<li><p>不断迭代直到所有点都在树中</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Prim(G):</span><br><span class="line">	<span class="comment">// 构造最小生成树Prim算法</span></span><br><span class="line">	<span class="comment">// 输入：加权连通图G=&lt;V, E&gt;</span></span><br><span class="line">	<span class="comment">// 输出：E_T, 组成G最小生成树的边集合</span></span><br><span class="line">	V_T = &#123;v_0&#125;</span><br><span class="line">		<span class="comment">// 使用任意顶点初始化树顶点集合</span></span><br><span class="line">	E_T = <span class="literal">NULL</span></span><br><span class="line">		<span class="comment">// 初始化生成树边为空集</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span> to |V|</span><br><span class="line">		<span class="keyword">if</span> i connect V_T</span><br><span class="line">			connect_V[i] = <span class="number">0</span></span><br><span class="line">			connect_D[i] = e(<span class="number">0</span>, i)</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			connect_V[i] = <span class="literal">NULL</span></span><br><span class="line">			connect_D[i] = \infty</span><br><span class="line">	<span class="comment">// 初始化节点和树最近节点列表、节点与树距离列表</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span> to |V|<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">		<span class="comment">// 重复n-1次，直到树包含所有顶点</span></span><br><span class="line">		edge = min(connect_D)</span><br><span class="line">			<span class="comment">// 寻找距离树最近的点</span></span><br><span class="line">		v = vertex(edge)</span><br><span class="line"></span><br><span class="line">		V_T = V_T <span class="keyword">union</span> &#123;v&#125;</span><br><span class="line">		E_T = E_T <span class="keyword">union</span> &#123;edge&#125;</span><br><span class="line"></span><br><span class="line">		connect_V[v] = <span class="literal">NULL</span></span><br><span class="line">		connect_D[v] = \infty</span><br><span class="line">		更新和v相连的顶点两个标记值</span><br><span class="line">	<span class="keyword">return</span> E_T</span><br></pre></td></tr></table></figure>
<h4 id="算法特点-1"><a href="#算法特点-1" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>算法时间效率依赖实现优先队列、存储图数据结构</p>
<ul>
<li>图权重矩阵、优先队列无序数组$\in \Theta(|V|^2)$</li>
<li>图邻接链表、二叉最小堆$\in O(|E|log|V|)$</li>
<li>图邻接链表、Fibonacci Heap $\in O(|E| + |V|log|V|)$</li>
</ul>
</li>
<li><p>对树进行扩展时用到的边的集合表示算法生成树</p>
</li>
<li><p>穷举查找构造生成树，生成树数量呈指数增长，且构造生成树
不容易</p>
</li>
</ul>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>Kruskal算法：把最小生成树看作是具有$|V|-1$条边、且边权重最小
的无环子图，通过对子图不断扩展构造最小生成树</p>
<h4 id="算法-7"><a href="#算法-7" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>按照权重非递减顺序对图中边排序</p>
</li>
<li><p>从空子图开始扫描有序列表，试图把列表中下条边加到当前子图
中，如果添加边导致回路则跳过</p>
</li>
<li><p>不断添加边直到达到$|V|-1$</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Kruskal(G)</span><br><span class="line">	<span class="comment">// 构造最小生成树的Kruskal算法</span></span><br><span class="line">	<span class="comment">// 输入：G=&lt;V, E&gt;加权连通图</span></span><br><span class="line">	<span class="comment">// 输出：E_T，组成G的最小生成树边集</span></span><br><span class="line">	reverse_sort([w(e_i)])</span><br><span class="line">		<span class="comment">// 按照边权非递减顺序对边集排序</span></span><br><span class="line">	E_T = <span class="literal">NULL</span></span><br><span class="line">	ecounter = <span class="number">0</span></span><br><span class="line">	k = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> ecounter &lt; |V|<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">		k += <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> E_T <span class="keyword">union</span> &#123;e_k&#125; 无回路</span><br><span class="line">			<span class="comment">// 常用并查算法检查`e_k`连接的两个顶点是否在</span></span><br><span class="line">			<span class="comment">// 同一棵树（并查集）中</span></span><br><span class="line">			E_T = E_T <span class="keyword">union</span> &#123;e_k&#125;</span><br><span class="line">			ecounter += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span>  E_T</span><br></pre></td></tr></table></figure>
<h4 id="算法特点-2"><a href="#算法特点-2" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>Kruskal每次迭代都需要检查添加新边是否会导致回路，其实
效率不一定比Prim算法高</p>
</li>
<li><p>Kruskal算法中间阶段会生成一系列无环子图（树）</p>
<ul>
<li>子图不总是联通的</li>
<li>可以看作是对包含给定图所有顶点、部分边的森林所作的
连续动作</li>
<li>初始森林由|V|棵普通树构成，包含单独顶点</li>
<li>最终森林为单棵树，包含图中所有顶点</li>
<li>每次迭代从图的边有序列表中取出下条边，找到包含其端点
的树，若不是同一棵树，则加入边生成一棵更大的树</li>
</ul>
</li>
<li><p>算法效率</p>
<ul>
<li>如果检查顶点是否位于同一棵树算法高效，则算法运行时间
取决于排序算法，时间效率$\in O(|E|log|E|)$</li>
</ul>
</li>
</ul>
<h3 id="Sollin算法"><a href="#Sollin算法" class="headerlink" title="Sollin算法"></a>Sollin算法</h3><p>Sollin算法：Prim算法、Kruskal算法的结合，将图每个顶点视为
子树，每次添加多条边合并子树直至得到最小生成树</p>
<h4 id="算法-8"><a href="#算法-8" class="headerlink" title="算法"></a>算法</h4><ul>
<li>将图中每个顶点视为一棵树，整个图表示森林$F^{(0)}$</li>
<li>为森林$F$中每棵树选择最小代价边<strong>合并</strong>两棵树</li>
<li>重复以上，直至所有树合并为一棵树</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Sollin(G):</span><br><span class="line">	<span class="comment">// 无向图最小生成树Sollin算法</span></span><br><span class="line">	<span class="comment">// 输入：无向图G</span></span><br><span class="line">	<span class="comment">// 输出：最小生成树边集</span></span><br><span class="line">	MST_E = <span class="literal">NULL</span></span><br><span class="line">	Forest = G.V</span><br><span class="line">	<span class="keyword">while</span> |MST_E| &lt; |G.V|:</span><br><span class="line">		<span class="keyword">for</span> tree in Forest:</span><br><span class="line">			e = find_min(G.E)</span><br><span class="line">			tree_b = get_tree(e)</span><br><span class="line">			MET_E.add(e)</span><br><span class="line">			tree.<span class="keyword">union</span>(tree_b)</span><br></pre></td></tr></table></figure>
<h1 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h1><h4 id="算法特点-3"><a href="#算法特点-3" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li>算法效率<ul>
<li>每轮子树数量减少一半，则最多重复<code>log|V|</code>轮算法终止</li>
<li>时间效率$\in O(|E|log|V|)$</li>
</ul>
</li>
</ul>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p>Dijkstra算法：求解单起点、<strong>权值非负</strong>最短路径算法</p>
<ul>
<li><p>按照从给定起点到图中各顶点的距离，<strong>顺序</strong>求出离起始点
最近的顶点、相应最短路径</p>
</li>
<li><p>第i次迭代前，算法已经确定了i-1条连接起点、离起点前i-1近
顶点的最短路径</p>
<ul>
<li>这些构成了给定图的一棵子树$T_i$</li>
<li>可以在同$T_i$顶点邻接的顶点中找到和起点最接近的顶点
（边权非负）</li>
</ul>
</li>
<li><p>算法类似于Prim算法，两个对代价评价标准不同</p>
<ul>
<li>Dijkstra算法是各条路径长度：有重复边，考虑整个路径</li>
<li>Prim算法是评价各边总和：无重复边，只考虑一条边</li>
</ul>
</li>
</ul>
<h4 id="算法-9"><a href="#算法-9" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>对顶点维护两个标记：起点到该顶点最短路径长度<code>d</code>、路径上
前个顶点<code>pre_v</code></p>
<ul>
<li>一般使用优先队列维护最短路径长度</li>
<li>对所有顶点维护：$\infty$、<code>NULL</code>标记不在树中、不与树
邻接顶点</li>
<li>仅对生成树中顶点、邻接顶点维护：每次迭代更新列表</li>
</ul>
</li>
<li><p>根据标记选择邻接顶点中和起始点距离<code>d</code>最小顶点，添加进树</p>
</li>
<li><p>更新顶点标记</p>
<ul>
<li>因为生成树只新添加一个顶点，只需要考虑与新添加顶点
直接相连、未在树中顶点</li>
<li>比较与起始点距离是否改变</li>
</ul>
</li>
<li><p>不断迭代直至所有点均在树中</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Dijkstra(G, s)</span><br><span class="line">	<span class="comment">// 单起点最短路径Dijkstra算法</span></span><br><span class="line">	<span class="comment">// 输入：G=&lt;V, E&gt;非负权重加权连通图，顶点s起始点</span></span><br><span class="line">	<span class="comment">// 输出：对V中每个顶点，从s到v的最短路径长度d_v</span></span><br><span class="line">	Initialize(Q)</span><br><span class="line">		<span class="comment">// 将顶点优先队列初始化为空</span></span><br><span class="line">	<span class="keyword">for</span> v in V</span><br><span class="line">		d_v = \infty</span><br><span class="line">		p_v = <span class="literal">NULL</span></span><br><span class="line">		Insert(Q, s, d_s)</span><br><span class="line">			<span class="comment">// 初始化有限队列中顶点优先级</span></span><br><span class="line">	d_s = <span class="number">0</span></span><br><span class="line">	Decrease(Q, s, d_s)</span><br><span class="line">		<span class="comment">// 更新s优先级为d_s</span></span><br><span class="line">	V_T = <span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span> to |V|<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">		u* = DeleteMin(Q)</span><br><span class="line">			<span class="comment">// 删除优先级最小元素</span></span><br><span class="line">		V_T = V_T \<span class="keyword">union</span> &#123;u*&#125;</span><br><span class="line">		<span class="keyword">for</span> v in V-V_T 中与u*邻接顶点 <span class="keyword">do</span></span><br><span class="line">			<span class="keyword">if</span> d_u* + w(u*, u) &lt; d_u</span><br><span class="line">				d_u = d_u* + w(u*, u)</span><br><span class="line">				p_u = u*</span><br><span class="line">				Decrease(Q, u, d_u)</span><br></pre></td></tr></table></figure>
<h4 id="算法特点-4"><a href="#算法特点-4" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li>算法时间效率同Prim算法</li>
</ul>
<h3 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h3><p>Bellman-Ford算法：求解单节点、权值正负无限制最短距离</p>
<ul>
<li>权值正负无限制意味着贪心策略不再有效</li>
<li>要求路径中不存在负权值回路</li>
<li>对n个顶点图，路径最长为n-1，否则删除回路路径长度不增加</li>
</ul>
<h4 id="算法-10"><a href="#算法-10" class="headerlink" title="算法"></a>算法</h4><p>考虑使用动态规划算法</p>
<ul>
<li><p>令$dist^{(l)}[u]$表示从起点v到节点u边数不超过l的最短
路径长度</p>
<ul>
<li><p>在不允许出现负权值回路的前提下，构造最短路算法过程
最多只需要考虑n-1条边</p>
</li>
<li><p>即$dist^{(n-1)}$是从v到u不限制路径中边数目的最短路径
长度</p>
</li>
</ul>
</li>
<li></li>
</ul>
<h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><p>Floyd算法：求解完全最短路径问题，有向、无向、加权图均适用
（边距离不为负，否则距离可以任意小）</p>
<ul>
<li><p>构造n+1个距离矩阵$D^{(k)}, k=0,1,\cdots,n$</p>
<ul>
<li><p>$D^{(k)}$中元素$d_{ij}$表示顶点i、j之间由编号小于k的
顶点作为中间顶点的距离</p>
</li>
<li><p>$D^{(0)}$：初始权重矩阵</p>
</li>
<li><p>$D^{(k)}, 0&lt;i&lt;n$：路径中顶点编号最大为<code>k</code></p>
</li>
<li><p>$D^{(n)}$：目标距离矩阵</p>
</li>
<li><p>后继矩阵相对前趋，允许作为路径上顶点增加，各顶点间
距离可能缩短</p>
</li>
</ul>
</li>
<li><p>考虑$D^{(k)}$通过直接前趋$D^{(k-1)}$计算得到，其中距离
（路径）分为两类</p>
<ul>
<li><p>$d^{(k)}<em>{ij} = d^{(k-1)}</em>{ij}$：不包含顶点k作为中间
节点的路径</p>
</li>
<li><p>$d^{(k)}<em>{ij} = d^{(k-1)}</em>{ik} + d^{(k-1)}<em>{kj} &lt; d^{(k-1)}</em>{ij}$：
包含顶点k作为中间节点的路径</p>
</li>
</ul>
</li>
</ul>
<h4 id="算法-11"><a href="#算法-11" class="headerlink" title="算法"></a>算法</h4><script type="math/tex; mode=display">
d^{(k)}_{ij} = \min \{ d^{(k-1)}_{ik} + d^{(k-1)}_{kj},
    d^{(k-1)}_{ij}, d^{(k-1)}_{ij} \}</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Floyd(W[<span class="number">1.</span>.n, <span class="number">1.</span>.n])</span><br><span class="line">	<span class="comment">// 计算完全最短路径的Floyd算法</span></span><br><span class="line">	<span class="comment">// 输入：W不包含负距离的距离矩阵</span></span><br><span class="line">	<span class="comment">// 输出：包含最短距离的距离矩阵</span></span><br><span class="line">	D^<span class="number">0</span> = W</span><br><span class="line">	<span class="keyword">for</span> k = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">for</span> i = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">			<span class="keyword">for</span> j = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">				D[i, j] = min(D[i, j], D[i, k] + D[k, j])</span><br><span class="line">	<span class="keyword">return</span> D</span><br></pre></td></tr></table></figure>
<h4 id="算法特点-5"><a href="#算法特点-5" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>算法效率</p>
<ul>
<li>时间效率同Warshall算法为立方级</li>
<li>如上伪码的空间效率为平方级（没有创建n+1距离矩阵）</li>
</ul>
</li>
<li><p>Floyd算法类似于Warshall算法</p>
</li>
<li><p>Floyd算法利用最优性原理，即最短路径中子路径也是最短</p>
</li>
</ul>
<h2 id="最大流量问题"><a href="#最大流量问题" class="headerlink" title="最大流量问题"></a>最大流量问题</h2><h3 id="Augmenting-Path-Method"><a href="#Augmenting-Path-Method" class="headerlink" title="Augmenting-Path Method"></a>Augmenting-Path Method</h3><h4 id="Shortest-Augmented-Path算法"><a href="#Shortest-Augmented-Path算法" class="headerlink" title="Shortest-Augmented-Path算法"></a>Shortest-Augmented-Path算法</h4><p>最短增益路径法（<em>first-labeled first-scanned algorithm</em>）</p>
<ul>
<li><p>对网络中顶点维护两个标记</p>
<ul>
<li>从源点到被标记顶点能增加流量数</li>
<li>路径中前个顶点名称<ul>
<li><code>+</code>：从前向边访问到当前顶点</li>
<li><code>-</code>：从后向边访问到当前顶点</li>
</ul>
</li>
</ul>
</li>
<li><p>对网络的每条边$(i, j)$，初始化流量为$x_{ij}=0$</p>
</li>
<li><p>从源点开始同时沿着前向边、后向边进行广度优先搜索</p>
<ul>
<li>先更新前向边</li>
<li>只有有增益空间边（顶点）才能被访问</li>
<li>更新搜索到顶点标记</li>
</ul>
</li>
<li><p>源点被标记表明得到一条增量路径，沿着标记反向更新边流量</p>
</li>
<li><p>若广度优先搜索无法达到源点，表明不存在流量增益路径，当前
流量值作为最大值返回</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">ShortestAugmentingPath(G)</span><br><span class="line">	<span class="comment">// 最短增量路径算法</span></span><br><span class="line">	<span class="comment">// 输入：流量网络G</span></span><br><span class="line">	<span class="comment">// 输出：最大流量x</span></span><br><span class="line">	对网络中每条边，设置x[i, j] = <span class="number">0</span></span><br><span class="line">	把源点标记为(\infty, -)，加入空队列Q中</span><br><span class="line">		<span class="comment">// 使用队列实现广度优先搜索</span></span><br><span class="line">	<span class="keyword">while</span> <span class="keyword">not</span> Empty(Q) <span class="keyword">do</span></span><br><span class="line">		i = Front(Q)</span><br><span class="line">		Dequeue(Q)</span><br><span class="line">		<span class="keyword">for</span> 从i到j的每条边 <span class="keyword">do</span></span><br><span class="line">			<span class="comment">// 遍历从i出发的边，前向边</span></span><br><span class="line">			<span class="keyword">if</span> j未被标记</span><br><span class="line">				r[i, j] = = u[i, j] - x[i, j]</span><br><span class="line">				<span class="keyword">if</span> r[i, j] &gt; <span class="number">0</span></span><br><span class="line">					l[j] = min&#123;l[i], r[i, j]&#125;</span><br><span class="line">					<span class="comment">/// 更新从源点到顶点j能增加的流量数</span></span><br><span class="line">					用l[j], i+标记j</span><br><span class="line">					Enqueue(Q, j)</span><br><span class="line">		<span class="keyword">for</span> 从j到i的每条边 <span class="keyword">do</span></span><br><span class="line">			<span class="comment">// 遍历到达i的边，后向边</span></span><br><span class="line">			<span class="keyword">if</span> j未被标记</span><br><span class="line">				<span class="keyword">if</span> x[j, i] &gt; <span class="number">0</span></span><br><span class="line">					l[j] = min&#123;l[i], x[j, i]&#125;</span><br><span class="line">					<span class="comment">// 更新源点到顶点j能增加的流量数</span></span><br><span class="line">					用l[j], i-标记j</span><br><span class="line">					Enqueue(Q, j)</span><br><span class="line">		<span class="keyword">if</span> 汇点被标记</span><br><span class="line">			<span class="comment">// 沿着找的增益路径进行增益</span></span><br><span class="line">			j = n</span><br><span class="line">			<span class="keyword">while</span> j != <span class="number">1</span></span><br><span class="line">				<span class="comment">// 反向更新到源点为止</span></span><br><span class="line">				<span class="keyword">if</span> 顶点j前个节点为i+</span><br><span class="line">					<span class="comment">// 通过前向边访问到顶点j</span></span><br><span class="line">					x[i, j] = x[i, j] + l[n]</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					x[j, i] -= l[n]</span><br><span class="line">				j = i</span><br><span class="line">		去除除源点外所有顶点标记</span><br><span class="line">		重新初始化化队列Q</span><br></pre></td></tr></table></figure>
<h4 id="算法特点-6"><a href="#算法特点-6" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>算法正确性可以（联合）最大流-最小割定理证明</p>
</li>
<li><p>算法时间效率</p>
<ul>
<li>可以证明最短增益路径算法用到的增益路径数量不超过
$|V||E|/2$</li>
<li>对使用邻接列表表示的网络，用广度优先查找找到一条增益
路径的时间$\int O(|V|+|E|)$</li>
<li>所有算法时间效率$\in O(|V||E|^2)$</li>
</ul>
</li>
<li><p>迭代算法</p>
</li>
</ul>
<h3 id="Preflow推进算法"><a href="#Preflow推进算法" class="headerlink" title="Preflow推进算法"></a>Preflow推进算法</h3><p>预流：满足容量约束，但是不满足流量守恒约束</p>
<ul>
<li>把过剩流量向汇点处移动，直到网络所有中间顶点都满足流量
守恒约束为止</li>
</ul>
<h4 id="算法特点-7"><a href="#算法特点-7" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li>算法时间效率<ul>
<li>这类算法中较快者最差效率可以接近$O(|V||E|)$</li>
</ul>
</li>
</ul>
<h3 id="Dinitz算法"><a href="#Dinitz算法" class="headerlink" title="Dinitz算法"></a>Dinitz算法</h3><h3 id="Karzanov算法"><a href="#Karzanov算法" class="headerlink" title="Karzanov算法"></a>Karzanov算法</h3><h3 id="Malhotra-Kamar-Maheshweari算法"><a href="#Malhotra-Kamar-Maheshweari算法" class="headerlink" title="Malhotra-Kamar-Maheshweari算法"></a>Malhotra-Kamar-Maheshweari算法</h3><h3 id="Goldberg-Tarjan算法"><a href="#Goldberg-Tarjan算法" class="headerlink" title="Goldberg-Tarjan算法"></a>Goldberg-Tarjan算法</h3><h3 id="单纯形法"><a href="#单纯形法" class="headerlink" title="单纯形法"></a>单纯形法</h3><p>此问题仍然是线性规划问题，可以使用单纯形法等通用解法求解</p>
<h2 id="最大匹配（二分图）"><a href="#最大匹配（二分图）" class="headerlink" title="最大匹配（二分图）"></a>最大匹配（二分图）</h2><h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><h4 id="算法-12"><a href="#算法-12" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>对U中每个顶点维护一个标记：与其匹配的对偶顶点</p>
</li>
<li><p>从V中的一个自由顶点v出发，按<strong>广度优先搜索</strong>找到U中自由
顶点u，寻找增益路径，搜索过程中</p>
<ul>
<li><p>V中顶点：按照广度优先搜索，得到不在匹配M中的边</p>
<ul>
<li>搜索到U中自由顶点，则停止<strong>得到增益路径</strong></li>
<li>搜索到U中被标记顶点，则连接上已有匹配</li>
</ul>
</li>
<li><p>U中顶点：直接找到其在V中的对偶顶点，得到在M中边</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>得到一个增益路径，沿着增益路径<strong>回溯</strong>，奇数边加入匹配</p>
</li>
<li><p>未找到自由顶点时，则无法得到增益路径</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">MaximumBipartiteMatching(G)</span><br><span class="line">	<span class="comment">// 用类似广度优先算法遍历求二分图的一个最大匹配</span></span><br><span class="line">	<span class="comment">// 输入：二分图G=&lt;V, U, E&gt;</span></span><br><span class="line">	<span class="comment">// 输出：输入图中一个最大基数匹配</span></span><br><span class="line">	初始边集合M包含某些合法的匹配（例如空集合）</span><br><span class="line">	初始队列Q包含V的所有自由顶点（任意序）</span><br><span class="line">	<span class="function"><span class="keyword">while</span> <span class="keyword">not</span> <span class="title">Empty</span><span class="params">(Q)</span> <span class="keyword">do</span></span></span><br><span class="line"><span class="function">		w </span>= Front(Q)</span><br><span class="line">		Dequeue(Q)</span><br><span class="line">		<span class="keyword">if</span> w \in V</span><br><span class="line">			<span class="keyword">for</span> 邻接w的每个顶点u <span class="keyword">do</span></span><br><span class="line">				<span class="comment">// 二分图性质保证u一定在U中</span></span><br><span class="line">				<span class="keyword">if</span> u是自由顶点</span><br><span class="line">					<span class="comment">// 增益</span></span><br><span class="line">					M = M \<span class="keyword">union</span> (w, u)</span><br><span class="line">						<span class="comment">// 首边进匹配</span></span><br><span class="line">					v = w</span><br><span class="line">					<span class="keyword">while</span> v已经被标记 <span class="keyword">do</span></span><br><span class="line">						<span class="comment">// 从增益路径回溯生成匹配</span></span><br><span class="line">						u = 以v标记的点</span><br><span class="line">						M -= (v, u)</span><br><span class="line">							<span class="comment">// 偶数边出匹配</span></span><br><span class="line">						v = 以u标记的点</span><br><span class="line">						M += (v, u)</span><br><span class="line">							<span class="comment">// 奇数边进匹配</span></span><br><span class="line">					删除所以顶点标记</span><br><span class="line">					用V中所有自由顶点重新初始化Q</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">						<span class="comment">// 增益后，重新搜索</span></span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="comment">// u已经匹配</span></span><br><span class="line">					<span class="keyword">if</span> (w, u) <span class="keyword">not</span> \in M <span class="keyword">and</span> u未标记</span><br><span class="line">						用w标记u</span><br><span class="line">						Enqueue(Q, u)</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="comment">// w \in U，此时w必然已经匹配</span></span><br><span class="line">			用w标记w的对偶v</span><br><span class="line">				<span class="comment">// 将已有匹配添加进增益路径中</span></span><br><span class="line">			Enqueue(Q, v)</span><br><span class="line">	<span class="keyword">return</span> M</span><br><span class="line">		<span class="comment">// 当前匹配已经是最大匹配</span></span><br></pre></td></tr></table></figure>
<h4 id="算法特点-8"><a href="#算法特点-8" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>注意：从自由顶点开始寻求匹配时，无论是否找到增益路径，
路径中中U中节点标记已经更新，匹配仅在得到增益路径才更新</p>
</li>
<li><p>算法时间效率</p>
<ul>
<li>每次迭代花费时间$\in O(|E|+|V|)$，迭代次数
$\in O(|V|/2 + 1)$</li>
<li>若每个顶点的信息（自由、匹配、对偶）能在常数时间内
得到（如存储在数组中）</li>
<li>则算法时间效率$\in O(|V|(|V| + |E|))$</li>
</ul>
</li>
<li><p>算法正确性参见图<em>graph_undirected</em>关于增益路径-最大匹配</p>
</li>
<li><p>迭代算法</p>
</li>
</ul>
<h3 id="霍普克罗夫-卡普算法"><a href="#霍普克罗夫-卡普算法" class="headerlink" title="霍普克罗夫-卡普算法"></a>霍普克罗夫-卡普算法</h3><h4 id="算法特点-9"><a href="#算法特点-9" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>对匈牙利算法的改进，把多次迭代在一个阶段完成，然后用一次
查找把最大数量边添加到匹配中</p>
</li>
<li><p>算法时间效率：$\in O(\sqrt {|V|}(|V| + |E|))$</p>
</li>
</ul>
<h2 id="稳定婚姻问题"><a href="#稳定婚姻问题" class="headerlink" title="稳定婚姻问题"></a>稳定婚姻问题</h2><h3 id="婚姻稳定算法"><a href="#婚姻稳定算法" class="headerlink" title="婚姻稳定算法"></a>婚姻稳定算法</h3><p>存在自由男士，任选<em>求婚</em>、<em>回应</em>之一执行，直至不存在自由男士</p>
<ul>
<li><p>求婚：自由男士m向女士w求婚，w为其优先级最大、之前未拒绝
过其女士（可以是已匹配）</p>
</li>
<li><p>回应：若女士w自由则接受男士m求婚，与之配对；女士w不自由
则把m同当前配偶匹配，选择其中优先级较高者</p>
</li>
</ul>
<h4 id="算法-13"><a href="#算法-13" class="headerlink" title="算法"></a>算法</h4><h4 id="算法特点-10"><a href="#算法特点-10" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>算法会在$n^2$次迭代内终止：至多每位男士向所有女士求婚</p>
</li>
<li><p><em>性别倾向</em>：总是生成<em>man-optimal</em>的稳定匹配，优先满足
男士偏好</p>
<ul>
<li>在任何稳定婚姻中，总是尽可能把优先级最高的女士分配给
男性</li>
<li>使用女士进行求婚也只会把性别偏见反向，而不能消除</li>
</ul>
</li>
<li><p>对给定的参与者优先选择集合而言，男士（女士）最优匹配唯一</p>
<ul>
<li>由性别性别倾向容易证明</li>
<li>所以算法的输出不取决于自由男士（女士）求婚顺序，可以
使用任何数据结构表示参与者集合而不影响结果</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>算法最终输出匹配M为稳定婚姻匹配证明参见<em>graph</em></li>
</ul>
</blockquote>
<h2 id="分配问题（二分图）"><a href="#分配问题（二分图）" class="headerlink" title="分配问题（二分图）"></a>分配问题（二分图）</h2><p>n个任务分配给n个人执行（一人一个），将任务j分配个人i的成本为
$C_{ijd}$，求最小成本分配方案</p>
<blockquote>
<ul>
<li>类似问题：最大权重匹配问题</li>
</ul>
</blockquote>
<h3 id="蛮力算法"><a href="#蛮力算法" class="headerlink" title="蛮力算法"></a>蛮力算法</h3><h4 id="算法-14"><a href="#算法-14" class="headerlink" title="算法"></a>算法</h4><ul>
<li>生成整数n的全部排列</li>
<li>根据成本矩阵计算每个分配方案总成本</li>
<li>选择和最小的方案</li>
</ul>
<h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><ul>
<li>算法排列次数为$n!$</li>
</ul>
<h3 id="分支界限法"><a href="#分支界限法" class="headerlink" title="分支界限法"></a>分支界限法</h3><ul>
<li><p>第i层节点下界可取：$lb = c + \sum_{k=i+1}^n min{c_k}$</p>
<ul>
<li>$c$：当前成本</li>
<li>$min{c_k}$：成本矩阵第k行最小值</li>
</ul>
</li>
</ul>
<h4 id="算法-15"><a href="#算法-15" class="headerlink" title="算法"></a>算法</h4><h4 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h4><h3 id="匈牙利算法-1"><a href="#匈牙利算法-1" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><h4 id="算法-16"><a href="#算法-16" class="headerlink" title="算法"></a>算法</h4><h4 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h4><h2 id="Topological-Sorting"><a href="#Topological-Sorting" class="headerlink" title="Topological Sorting"></a>Topological Sorting</h2><p>拓扑排序：按照次序列出有向图的顶点，使得对图中每条边，其
起始顶点总在结束顶点之前</p>
<h3 id="删点法"><a href="#删点法" class="headerlink" title="删点法"></a>删点法</h3><h4 id="算法-17"><a href="#算法-17" class="headerlink" title="算法"></a>算法</h4><ul>
<li>在有向图中求出源（没有输出边的顶点），然后把删除其和所有
从它出发的边</li>
<li>不断重复，直到不存在源，如果此时图中还有顶点，则图中存在
环，无解</li>
<li>则删除节点顺序即为拓扑排序可行解</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">TopologicalSort(G):</span><br><span class="line">	<span class="comment">// 从有向图中不断删除入度为0的点、入栈，判断有向图G是否</span></span><br><span class="line">		<span class="comment">// 为DAG，并给出拓扑排序栈</span></span><br><span class="line">	<span class="comment">// 输入：有向图G</span></span><br><span class="line">	<span class="comment">// 输出：拓扑排序栈T</span></span><br><span class="line">	InitStack(S)</span><br><span class="line">	indgree = [v.indegree <span class="keyword">for</span> v in G]</span><br><span class="line">	<span class="keyword">for</span> v in G:</span><br><span class="line">		<span class="keyword">if</span> v.indgree == <span class="number">0</span></span><br><span class="line">			S.push(v)</span><br><span class="line">		<span class="comment">// 存储0入度结点栈</span></span><br><span class="line">	count = <span class="number">0</span></span><br><span class="line">		<span class="comment">// 删除结点计数</span></span><br><span class="line">	<span class="keyword">while</span>(!S.empty())</span><br><span class="line">		v = S.pop()</span><br><span class="line">		T.push(v)</span><br><span class="line">		count++</span><br><span class="line">		<span class="keyword">for</span>(u connected to v)</span><br><span class="line">			<span class="keyword">if</span> --indgree.u == <span class="number">0</span></span><br><span class="line">				S.push(u)</span><br><span class="line">	<span class="keyword">if</span> count &lt; |G.V|</span><br><span class="line">		<span class="comment">// 结点未删除完毕，但无0入度结点</span></span><br><span class="line">		<span class="comment">// G中有回路，报错</span></span><br><span class="line">		<span class="keyword">return</span> ERROR</span><br><span class="line">	<span class="keyword">return</span> T</span><br></pre></td></tr></table></figure>
<h4 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a>特点</h4><ul>
<li>算法效率<ul>
<li>时间效率$\in O(|V|+|E|)$</li>
</ul>
</li>
<li>减常数法</li>
</ul>
<h3 id="DFS逆后序遍历"><a href="#DFS逆后序遍历" class="headerlink" title="DFS逆后序遍历"></a>DFS逆后序遍历</h3><p>图中<strong>无环</strong>时，由某点出发进行DFS</p>
<ul>
<li><p>最先退出DFS的为出度为0的点，即拓扑有序序列中最后顶点</p>
</li>
<li><p>按照DFS退出先后次序得到序列即为逆向拓扑有序序列</p>
<ul>
<li>使用逆后序方式存储DFS访问顶点，判断是否有环、出栈
次序即为正向拓扑有序序列</li>
</ul>
</li>
</ul>
<h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><ul>
<li>判断庞大项目中相互关联任务不矛盾，然后才能合理安排，使得
项目整体完成时间最短（需要CPM、PERT算法支持）</li>
</ul>
<h2 id="Cirtical-Path问题"><a href="#Cirtical-Path问题" class="headerlink" title="Cirtical Path问题"></a><em>Cirtical Path</em>问题</h2><p>找出使用AOE网表示的工程的中关键路径</p>
<ul>
<li>关键路径由关键活动构成</li>
<li>即耗费时间变动对工程整体完成时间有影响的活动</li>
</ul>
<h3 id="拓扑排序求解"><a href="#拓扑排序求解" class="headerlink" title="拓扑排序求解"></a>拓扑排序求解</h3><ul>
<li>最早、最晚开始时间检查是否为关键活动</li>
<li>建立活动（边）、事件（顶点）发生事时间关系</li>
<li>拓扑排序求解事件发生最早、最晚时间</li>
</ul>
<blockquote>
<ul>
<li>具体参见<em>algorithm/data_structure/graphdi_specials</em></li>
</ul>
</blockquote>
<h4 id="算法-18"><a href="#算法-18" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">TopologicalOrder(G):</span><br><span class="line">	<span class="comment">// 从有向图中不断删除入度为0的点、入栈，判断有向图G是否</span></span><br><span class="line">		<span class="comment">// 为DAG，并给出拓扑排序栈</span></span><br><span class="line">	<span class="comment">// 输入：有向图G</span></span><br><span class="line">	<span class="comment">// 输出：拓扑排序栈T、顶点事件最早发生事件ve</span></span><br><span class="line">	InitStack(S)</span><br><span class="line">	indgree = [v.indegree <span class="keyword">for</span> v in G]</span><br><span class="line">	ve[<span class="number">0.</span>.|G.V|] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> v in G:</span><br><span class="line">		<span class="keyword">if</span> v.indgree == <span class="number">0</span></span><br><span class="line">			S.push(v)</span><br><span class="line">		<span class="comment">// 存储0入度结点栈</span></span><br><span class="line">	count = <span class="number">0</span></span><br><span class="line">		<span class="comment">// 删除结点计数</span></span><br><span class="line">	<span class="keyword">while</span>(!S.empty())</span><br><span class="line">		v = S.pop()</span><br><span class="line">		T.push(v)</span><br><span class="line">		count++</span><br><span class="line">		<span class="keyword">for</span>(u connected by v)</span><br><span class="line">			ve[u] = max&#123;ve[u], ve[v] + len(v, u)&#125;</span><br><span class="line">				<span class="comment">// 若有更长路径，更新</span></span><br><span class="line">			<span class="keyword">if</span> --indgree[u] == <span class="number">0</span></span><br><span class="line">				S.push(u)</span><br><span class="line">	<span class="keyword">if</span> count &lt; |G.V|</span><br><span class="line">		<span class="comment">// 结点未删除完毕，但无0入度结点</span></span><br><span class="line">		<span class="comment">// G中有回路，报错</span></span><br><span class="line">		<span class="keyword">return</span> ERROR</span><br><span class="line">	<span class="keyword">return</span> T, ve</span><br><span class="line"></span><br><span class="line">CriticalPath(G, T, ve):</span><br><span class="line">	<span class="comment">// 逆序求顶点事件最晚发生时间，求出关键活动</span></span><br><span class="line">	<span class="comment">// 输入：有向无环图G，G拓扑排序</span></span><br><span class="line">	<span class="comment">// 输出：关键活动队列Q</span></span><br><span class="line">	vl[<span class="number">0.</span>.|G.V|] = ve</span><br><span class="line">	Q = InitQueue()</span><br><span class="line">	<span class="keyword">while</span>(!T.empty())</span><br><span class="line">		v = T.pop()</span><br><span class="line">		<span class="keyword">for</span> (u connect to v)</span><br><span class="line">			vl[u] = min&#123;vl[u], vl[v] - len(u, v)&#125;</span><br><span class="line">	<span class="keyword">for</span>(v in G.V)</span><br><span class="line">		<span class="keyword">for</span> (u connected by v)</span><br><span class="line">			ee = ve[v]</span><br><span class="line">			el = vl[u] - len(v)</span><br><span class="line">			<span class="keyword">if</span>(el == ee)</span><br><span class="line">				Q.push(G.edge(v, u))</span><br><span class="line">	<span class="keyword">return</span> Q</span><br></pre></td></tr></table></figure>
<ul>
<li><p>以上算法中在生成拓扑排序栈时同时得到各顶点事件最早发生
时间</p>
</li>
<li><p>可以只获取拓扑排序栈，然后处理其获得顶点事件最早发生时间
，将两个功能分离，只是处理一遍顶点而已</p>
</li>
<li><p>也可以使用其他算法获得拓扑排序栈</p>
<ul>
<li>DFS遍历甚至可以遍历顶点一遍，同时获得顶点事件最早、
最晚发生时间</li>
</ul>
</li>
</ul>
<h4 id="特点-8"><a href="#特点-8" class="headerlink" title="特点"></a>特点</h4><ul>
<li>算法效率<ul>
<li>时间效率$\in O(|V|+|E|)$</li>
</ul>
</li>
</ul>
<h2 id="哈密顿回路问题"><a href="#哈密顿回路问题" class="headerlink" title="哈密顿回路问题"></a>哈密顿回路问题</h2><p>确定给定图中是否在包含一条哈密顿回路</p>
<h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><h4 id="算法-19"><a href="#算法-19" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>对所有节点维护标记：是否位于当前路径中</p>
</li>
<li><p>选择某节点<em>a</em>作为哈密顿回路起点顶点，即回溯状态空间树根</p>
</li>
<li><p>从根节点开始处理</p>
<ul>
<li>若节点周围还有未标记节点，选择下个加入路径、标记</li>
<li>若节点周围没有未标记节点，回溯到之前节点重新处理</li>
</ul>
</li>
<li><p>直到所有节点都被标记，且当前节点和根节点相邻</p>
</li>
</ul>
<h4 id="特点-9"><a href="#特点-9" class="headerlink" title="特点"></a>特点</h4><h2 id="旅商问题"><a href="#旅商问题" class="headerlink" title="旅商问题"></a>旅商问题</h2><p>Traveling Salesman Problem：对相互之间距离已知为正整数的n座
城市，求最短漫游路径，使得在回到出发城市之前，对每个城市只
访问一次</p>
<ul>
<li>即：对权重为正整数的无向完全图寻找最短哈密顿回路</li>
</ul>
<h3 id="蛮力算法-1"><a href="#蛮力算法-1" class="headerlink" title="蛮力算法"></a>蛮力算法</h3><h4 id="算法-20"><a href="#算法-20" class="headerlink" title="算法"></a>算法</h4><ul>
<li>生成n-1个中间城市的组合得到所有旅行线路</li>
<li>计算线路长度，求得最短路径</li>
</ul>
<h4 id="特点-10"><a href="#特点-10" class="headerlink" title="特点"></a>特点</h4><ul>
<li>算法排序次数为$(n-1)!/2$</li>
</ul>
<h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><ul>
<li>线路成对出现，只是方向相反，可考虑任意两个相邻顶点，只
考虑包含其某个排序的线路</li>
</ul>
<h3 id="分支界限法-1"><a href="#分支界限法-1" class="headerlink" title="分支界限法"></a>分支界限法</h3><ul>
<li><p>第i层下界可取$lb = \sum<em>{k=i+1}^n d</em>{k1}$</p>
</li>
<li><p>更紧密、也不复杂的下界
$lb = \lceil \frac {\sum<em>{k=i+1}^n (d</em>{k1} + d_{k2})} 2 \rceil$</p>
<ul>
<li><p>$d<em>{k1}, d</em>{k2}$：城市$i+1$到最近的两个城市距离</p>
</li>
<li><p>最短路径为两个端点共享，至多只能有一个端点能够成为
该边起点</p>
</li>
<li><p>若要求所有哈密顿回路中必须包括某些边，则在考虑相应
边端点城市时，使用必须边（若不是节点最短边）替换其中
次短边</p>
</li>
</ul>
</li>
<li><p>只需要生成某对节点有序的路径：可以消去状态空间树中部分
分支</p>
</li>
</ul>
<h4 id="算法-21"><a href="#算法-21" class="headerlink" title="算法"></a>算法</h4><h4 id="特点-11"><a href="#特点-11" class="headerlink" title="特点"></a>特点</h4><h2 id="旅商问题非精确算法"><a href="#旅商问题非精确算法" class="headerlink" title="旅商问题非精确算法"></a>旅商问题非精确算法</h2><p>以下均是讨论TSP问题的欧几里得实例，不对称实例等已经证明更难
解决，对精确算法、启发式算法都是如此</p>
<h3 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h3><h4 id="Nearest-Neighbor算法"><a href="#Nearest-Neighbor算法" class="headerlink" title="Nearest-Neighbor算法"></a>Nearest-Neighbor算法</h4><ul>
<li>任意选择城市开始</li>
<li>每次访问和当前城市k最接近的城市，直到访问完所有城市</li>
<li>回到开始城市</li>
</ul>
<h4 id="Multifregment-Heuristic算法"><a href="#Multifregment-Heuristic算法" class="headerlink" title="Multifregment-Heuristic算法"></a>Multifregment-Heuristic算法</h4><p>求给定加权完全图的最小权重边集合，且每个顶点连通度均为2</p>
<ul>
<li><p>将边按权重升序排列，将要构造的旅途边集合开始时空集合</p>
</li>
<li><p>不断尝试将排序列表中下条边加入旅途边集合</p>
<ul>
<li>边加入不会使得某节点连通度大于2</li>
<li>不会产生长度小于n的回路</li>
<li>否则忽略这条边</li>
</ul>
</li>
<li><p>返回旅途集合</p>
</li>
</ul>
<h4 id="算法特点-11"><a href="#算法特点-11" class="headerlink" title="算法特点"></a>算法特点</h4><p>对属于<strong>欧几里得类型</strong>的旅商问题实例（大部分）</p>
<ul>
<li>此时虽然两个算法的精确性能比无法界定，但是满足
$\frac {f(s_a)} {f(s^{*})} \leqslant \frac 1 2 (\lceil log_2 n \rceil + 1)$</li>
</ul>
<h3 id="Minimum-Spaning-Tree-Based-Algorithm"><a href="#Minimum-Spaning-Tree-Based-Algorithm" class="headerlink" title="Minimum-Spaning-Tree-Based Algorithm"></a>Minimum-Spaning-Tree-Based Algorithm</h3><p>基于最小生成树的算法</p>
<ul>
<li>哈密顿回路中去掉一条边就能得到一棵生成树$T_h$</li>
<li>可以先构造一棵最小生成数$T^{*}$，然后在其基础上构造近似
最短路径</li>
</ul>
<h4 id="Twice-Around-The-Tree算法"><a href="#Twice-Around-The-Tree算法" class="headerlink" title="Twice-Around-The-Tree算法"></a>Twice-Around-The-Tree算法</h4><ul>
<li>对给定实例构造最小生成树$T^{<em>}$（</em>Prim, Kruskal*）</li>
<li>从任意顶点开始，（利用深度优先遍历）绕树散步一周，记录
经过顶点</li>
<li>扫描顶点列表，消去重复出现顶点（走捷径，直接去新城市），
除列表尾部重复起点，得到一条哈密顿回路</li>
</ul>
<blockquote>
<ul>
<li>可能是考虑到最小生成树能够选出部分最短路径？？？</li>
</ul>
</blockquote>
<h4 id="特点-12"><a href="#特点-12" class="headerlink" title="特点"></a>特点</h4><p>对属于<strong>欧几里得类型</strong>的旅商问题</p>
<ul>
<li><p>绕树两周算法是2近似算法：$2f(s^{*}) &gt; f(s_a)$</p>
<ul>
<li>$f(s^{<em>} &gt; w(T_h) \geqslant w(T^{</em>})$：最优哈密顿
回路去掉一条边后长度大于等于最小生成树长度</li>
<li>$f(s^{<em>}) &lt; 2w(T^{</em>})$：第二次扫描走捷径距离小于绕树
一周距离</li>
<li>这里限定了特点类型实例，并没有找到对所有旅商问题的
优先近似算法</li>
</ul>
</li>
</ul>
<h3 id="Christofides算法"><a href="#Christofides算法" class="headerlink" title="Christofides算法"></a>Christofides算法</h3><p>同样利用问题与最小生成树的出关系，但更复杂</p>
<h4 id="算法-22"><a href="#算法-22" class="headerlink" title="算法"></a>算法</h4><ul>
<li>对给定实例构造最小生成树$T^{*}$</li>
<li>构造包含包含$T^{*}$的欧拉回路<ul>
<li>找出最小生成树中所有连通度为奇数的顶点</li>
<li>求出这些顶点的最小权重匹配（匈牙利算法）</li>
<li>将最小权重匹配边加入树中得到多重图欧拉回路</li>
</ul>
</li>
<li>使用走捷径方法将欧拉回路转换为哈密顿回路</li>
</ul>
<h4 id="特点-13"><a href="#特点-13" class="headerlink" title="特点"></a>特点</h4><p>对属于<strong>欧几里得类型</strong>的旅商问题</p>
<ul>
<li><p>绕最小生成树一周得到的路径是多重图的一条欧拉回路，其中
多重图为将当前图每条边重复一遍得到</p>
<ul>
<li>绕树两周算法：直接原始欧拉回路上走捷径</li>
<li>Christofides算法：重新构建更短的欧拉回路，在此基础
上走捷径</li>
</ul>
</li>
<li><p>Christofides算法是1.5近似算法</p>
<ul>
<li>实际应用中，Christofides算法近似解明显好于绕树两周</li>
<li>可以对连通度大于2顶点尝试不同访问次序，即将<strong>回路</strong>
中邻接顶点分别<strong>两两组合</strong>，找到访问其的最佳路径</li>
</ul>
</li>
</ul>
<h3 id="迭代改进算法"><a href="#迭代改进算法" class="headerlink" title="迭代改进算法"></a>迭代改进算法</h3><p>Local Search Heuristics：本地查找启发法</p>
<ul>
<li><p>这类算法从某个初始旅途（随机或简单近似算法生成）开始</p>
</li>
<li><p>每次迭代把当前旅途一些边用其他边代替，试图得到和当前旅途
稍有差别的旅途</p>
<ul>
<li>若能得到优于当前旅途的新旅途，则替换当前旅途，继续
寻找</li>
<li>否则，返回当前旅途，停止</li>
</ul>
</li>
</ul>
<h4 id="2选算法"><a href="#2选算法" class="headerlink" title="2选算法"></a>2选算法</h4><p>删除旅途中2条非临边，把两条边端点用另一对边重新连接</p>
<ul>
<li>此操作称为<em>2改变</em></li>
<li>为保证重连后得到合法哈密顿回路，重连方法只有一种</li>
</ul>
<h4 id="3选算法"><a href="#3选算法" class="headerlink" title="3选算法"></a>3选算法</h4><p>删除3条非临边后重连</p>
<ul>
<li>重连方法有3种</li>
<li>事实上可以推广到k选，但是只有3改变被证明有意义</li>
</ul>
<h4 id="Lin-Kernighan算法"><a href="#Lin-Kernighan算法" class="headerlink" title="Lin-Kernighan算法"></a>Lin-Kernighan算法</h4><p>变选算法算法的一种</p>
<ul>
<li>可以视为在3选操作后进行一系列2选操作</li>
</ul>
<h4 id="算法特点-12"><a href="#算法特点-12" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li>迭代改进算法求得的近似解效果质量非常好</li>
<li>Lin-Kernighan算法是公认的求解高质量近似解的最佳算法</li>
</ul>
<h3 id="Held-Karp-Bound"><a href="#Held-Karp-Bound" class="headerlink" title="Held-Karp Bound"></a>Held-Karp Bound</h3><p>Held-Karp下界</p>
<ul>
<li>将TSP描述为线性规划问题求解（忽略整数约束）得到，计算
速度快</li>
<li>一般和最优旅途长度非常接近，误差不超过1%</li>
<li>可使用其代替最短旅途估计近似算法的精确度</li>
</ul>
<h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><ul>
<li>10000个随机点：坐标、距离取整</li>
<li>Comqaq ES40：500MHz的Alpha处理器、2GB内存</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>启发式算法</th>
<th>超过Held-Karp下界的%</th>
<th>运行时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>最近邻居</td>
<td>24.79</td>
<td>0.28</td>
</tr>
<tr>
<td>多片段</td>
<td>16.42</td>
<td>0.20</td>
</tr>
<tr>
<td>Christofides</td>
<td>9.81</td>
<td>1.04</td>
</tr>
<tr>
<td>2选</td>
<td>4.70</td>
<td>1.41</td>
</tr>
<tr>
<td>3选</td>
<td>2.88</td>
<td>1.50</td>
</tr>
<tr>
<td>Lin-Kernighan</td>
<td>2.00</td>
<td>2.06</td>
</tr>
</tbody>
</table>
</div>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-04T17:01:03.000Z" title="4/5/2019, 1:01:03 AM">2019-04-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-04-04T17:01:03.000Z" title="4/5/2019, 1:01:03 AM">2019-04-05</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Problem/">Problem</a></span><span class="level-item">10 minutes read (About 1521 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Problem/game_theory.html">博弈论</a></h1><div class="content"><h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><h2 id="约瑟夫斯问题"><a href="#约瑟夫斯问题" class="headerlink" title="约瑟夫斯问题"></a>约瑟夫斯问题</h2><p>n个人围成圈编号{0..n-1}，从1号开始每次消去第m个人直到最后一个
人，计算最后人编号$J(n)$。</p>
<h3 id="减1法"><a href="#减1法" class="headerlink" title="减1法"></a>减1法</h3><p>考虑每次消去1人后剩余人的编号情况</p>
<ul>
<li><p>还剩k人时，消去1人后，以下个人编号为0开始，将剩余人重新
编号，得到每个人在剩k-1人时的编号</p>
</li>
<li><p>相较于剩k人时，剩k-1人时每个人编号都减少m，即每个人在剩
k人时编号满足</p>
<script type="math/tex; mode=display">J_k = (J_{k-1} + m) \% k</script></li>
<li><p>考虑只剩1人时，其编号为0，则可以递推求解</p>
</li>
</ul>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Joseph_1(n, m):</span><br><span class="line">	<span class="comment">// 减1法求解Joseph问题</span></span><br><span class="line">	<span class="comment">// 输入：人数n、消去间隔m</span></span><br><span class="line">	<span class="comment">// 输出：最后留下者编号</span></span><br><span class="line">	j_n = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> k from <span class="number">2</span> to n:</span><br><span class="line">		j_n = (j_n + m) % k</span><br></pre></td></tr></table></figure>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>算法效率<ul>
<li>时间效率$\in O(n)$</li>
</ul>
</li>
</ul>
<h3 id="减常因子"><a href="#减常因子" class="headerlink" title="减常因子"></a>减常因子</h3><p>剩余人数$k &gt;= m$时考虑所有人都报数一次后剩余人的编号变化情况</p>
<ul>
<li><p>还剩k人时，报数一圈后消去<code>k//m</code>人，以最后被消去人的下个人
编号为0开始，将剩余人重新编号，得到剩<code>k-k/m</code>人时的编号</p>
</li>
<li><p>相较于剩k人时，剩<code>k-k//m</code>人时每个人编号满足</p>
<script type="math/tex; mode=display">\begin{align*}
J_k & = \left \{ \begin{array}{l}
   J_{k - d} + d * m, & J_{k - d} < n\%m \\
   J_{k - d} // (m-1) * m + (J_{k - d} - n\%m)
       \% (m - 1), & J_{k - d} > n\%m
\end{array} \right. \\
& = \left \{ \begin{array}{l}
   s + n, & s < 0 \\
   s + s // (m-1), & s >= 0
\end{array} \right.
\end{align*}</script><blockquote>
<ul>
<li>$d = k // m$</li>
<li>$s = J_{k - d} - n\%m$</li>
</ul>
</blockquote>
</li>
<li><p>$k &lt; m$时，使用减1法计算</p>
<ul>
<li>m很大时，以$k &lt; m$作为调用减1法很容易使得递归超出
最大值</li>
<li>另外$m &lt; k &lt;= d * m$时，每轮也不过消去$d$个人，而
递推式复杂许多、需要递归调用</li>
<li>所以具体代码实现中应该选择较大的$d$值，如5</li>
</ul>
</li>
</ul>
<h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Joseph_factor(n, m):</span><br><span class="line">	<span class="comment">// 减常因子法求解Joseph问题</span></span><br><span class="line">	<span class="comment">// 输入：人数n、消去间隔m</span></span><br><span class="line">	<span class="comment">// 输出：最后留下者编号</span></span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">5</span> * m:</span><br><span class="line">		j_n = <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> k from <span class="number">2</span> to n</span><br><span class="line">			j_n = (j_n + m) % k</span><br><span class="line">		<span class="keyword">return</span> j_n</span><br><span class="line"></span><br><span class="line">	s = Joseph(n-n/m, m) - k % m</span><br><span class="line">	<span class="keyword">if</span> s &lt; <span class="number">0</span>:</span><br><span class="line">		retrun s + n</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> s + s <span class="comment">// (m-1)</span></span><br><span class="line">	<span class="keyword">return</span> j_n</span><br></pre></td></tr></table></figure>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>算法效率</p>
<ul>
<li>时间效率$\in O(log n) + m$</li>
</ul>
</li>
<li><p>特别的，对$m=2$时</p>
<ul>
<li>$n=2k$为偶数时，$J(2k)=2J(k)-1$</li>
<li>$n=2k+1$为奇数时，$J(2k+1)=2J(k)+1$</li>
</ul>
</li>
</ul>
<h3 id="任意第k个"><a href="#任意第k个" class="headerlink" title="任意第k个"></a>任意第k个</h3><ul>
<li><p>考虑报数不重置，则第k个被消去的人报数为$k * m - 1$</p>
</li>
<li><p>对报数为$p = k * m + a, 0 \leq a &lt; m$的人</p>
<ul>
<li><p>此时已经有k个人被消去，剩余n-k个人</p>
</li>
<li><p>则经过$n - k$个剩余人报数之后，该人才继续报数，则
其下次报数为$q = p + n - k = n + k*(m-1) + a$</p>
</li>
</ul>
</li>
<li><p>若该人报数$p$时未被消去，则$a \neq m-1$，则可以得到
$p = (q - n) // (m-1) * m +  (q-n) \% (m-1)$</p>
</li>
</ul>
<h4 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Joseph_k(n, m, k):</span><br><span class="line">	<span class="comment">// 计算Joseph问题中第k个被消去人编号</span></span><br><span class="line">	<span class="comment">// 输入：人数n、间隔m、被消去次序k</span></span><br><span class="line">	<span class="comment">// 输出：第k个被消去人编号</span></span><br><span class="line">	j_k = k*m - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> j_k &gt;= n:</span><br><span class="line">		j_k = (j_k-n) <span class="comment">// (m-1) * m - (j_k-n)%(m-1)</span></span><br><span class="line">	<span class="keyword">return</span> j_k</span><br></pre></td></tr></table></figure>
<h4 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>算法效率</p>
<ul>
<li>时间效率$\in O(log n)$</li>
</ul>
</li>
<li><p>特别的，m=2时对n做一次<strong>向左循环移位</strong>就是最后者编号</p>
</li>
</ul>
<h2 id="双人游戏"><a href="#双人游戏" class="headerlink" title="双人游戏"></a>双人游戏</h2><ul>
<li>双人游戏中往往涉及两个概念<ul>
<li><em>state</em>：状态，当前游戏状态、数据</li>
<li><em>move</em>：走子，游戏中所有可能发生的状态改变</li>
</ul>
</li>
<li>状态、走子彼此之间相互“调用”<ul>
<li>状态调用走子<strong>转化</strong>为下个状态</li>
<li>走子调用状态<strong>评价</strong>当前状态</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">make_move(state, move):</span><br><span class="line">	<span class="keyword">switch</span> move:</span><br><span class="line">		<span class="keyword">case</span> move_1:</span><br><span class="line">			state = move_1(state)</span><br><span class="line">			evaluate_state(state)</span><br><span class="line">		...other cases...</span><br><span class="line"></span><br><span class="line">evaluate_state(state):</span><br><span class="line">	<span class="keyword">switch</span> state:</span><br><span class="line">		<span class="keyword">case</span> state_1:</span><br><span class="line">			make_move(state, move_1)</span><br><span class="line">		...other cases...</span><br><span class="line">	end game</span><br></pre></td></tr></table></figure>
<h3 id="拈游戏"><a href="#拈游戏" class="headerlink" title="拈游戏"></a>拈游戏</h3><p>同样局面，每个玩家都有同样可选走法，每种步数有限的走法都能
形成游戏的一个较小实例，最后能移动的玩家就是胜者。</p>
<ul>
<li>拈游戏（单堆版）：只有一堆棋子n个，两个玩家轮流拿走最少
1个，最多m个棋子</li>
<li>拈游戏（多堆版）：有I堆棋子，每堆棋子个数分别为
${n_1,\cdots,n_I}$，可以从任意一堆棋子中拿走任意允许数量
棋子，甚至拿走全部一堆</li>
</ul>
<h4 id="减可变规模算法"><a href="#减可变规模算法" class="headerlink" title="减可变规模算法"></a>减可变规模算法</h4><h5 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h5><p>（单堆）从较小的n开始考虑胜负（标准流程）</p>
<ul>
<li>n=0：下个人失败</li>
<li>1&lt;=n&lt;=m：下个人胜利（可以拿走全部）</li>
<li>n=m+1：下个人失败（无论拿走几个，对方符合1&lt;=n&lt;=m
胜利条件）</li>
<li>数学归纳法可以证明：n=k(m+1)时为败局，其余为胜局</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个函数轮流递归调用</span></span><br><span class="line">find_good_move(coins):</span><br><span class="line">	<span class="comment">// 判断当前是否有成功步骤</span></span><br><span class="line">	<span class="comment">// 输入：棋子数目</span></span><br><span class="line">	<span class="comment">// 输出：成功策略或没有成功策略</span></span><br><span class="line">	<span class="keyword">for</span> taken=<span class="number">1</span> to limit <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span>(is_bad_position(coins-taken))</span><br><span class="line">			<span class="comment">// 对手没有成功策略</span></span><br><span class="line">			<span class="keyword">return</span> taken</span><br><span class="line">	<span class="keyword">return</span> NO_GOOD_MOVE</span><br><span class="line"></span><br><span class="line">is_bad_position(coins):</span><br><span class="line">	<span class="comment">// 判断当前是否是good position</span></span><br><span class="line">	<span class="comment">// 输入：棋子数量</span></span><br><span class="line">	<span class="comment">// 输出：是否有成功策略</span></span><br><span class="line">	<span class="keyword">if</span> (coins == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	<span class="keyword">return</span> find_good_move(coins) == NO_GOOD_MOVE</span><br><span class="line">		<span class="comment">// 没有成功策略</span></span><br></pre></td></tr></table></figure>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>堆为2时，需要对两堆是否相同分别考虑</p>
</li>
<li><p>对更一般的I堆时</p>
<ul>
<li>对每堆数量的位串计算<em>二进制数位和</em></li>
<li>结果中包含至少一个1则对下个人为胜局，全为0则为负局</li>
<li><p>则玩家下步要拿走的棋子数量要使得位串二进制数位和全0
，则对方陷入负局</p>
</li>
<li><h1 id="todo又是二进制？？？和约瑟夫斯问题一样了"><a href="#todo又是二进制？？？和约瑟夫斯问题一样了" class="headerlink" title="todo又是二进制？？？和约瑟夫斯问题一样了"></a>todo又是二进制？？？和约瑟夫斯问题一样了</h1></li>
<li>但是这里没有涉及最多能拿几个啊，不一定能够成功拿到
使拈和全为0啊</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>二进制数位和（拈和）：每位求和并忽略进位（奇或）</li>
</ul>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:37.000Z" title="3/21/2019, 5:27:37 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-02-22T03:21:40.000Z" title="2/22/2019, 11:21:40 AM">2019-02-22</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Problem/">Problem</a></span><span class="level-item">7 minutes read (About 1029 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Problem/geometry.html">几何问题</a></h1><div class="content"><h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><p>处理类似于点、线、多面体这样的几何对象</p>
<h2 id="最近对问题"><a href="#最近对问题" class="headerlink" title="最近对问题"></a>最近对问题</h2><p>给定平面上的n个点中，距离最近的两个点</p>
<ul>
<li>点数量n不大3时，可以通过蛮力算法求解的</li>
<li>假设集合中每个点均不相同、点按其x坐标升序排列</li>
<li>另外使用算法得到点按照y坐标升序排列的列表Q</li>
</ul>
<h3 id="蛮力算法"><a href="#蛮力算法" class="headerlink" title="蛮力算法"></a>蛮力算法</h3><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BruteForceClosestPoints(p)</span><br><span class="line">	<span class="comment">// 蛮力算法求平面中距离最近的点</span></span><br><span class="line">	<span class="comment">// 输入：n个点的列表p；p_i = (x_i, y_i)</span></span><br><span class="line">	<span class="comment">// 输出：两个最近点的距离</span></span><br><span class="line">	d = \infty</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span> to n <span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">for</span> j = i+<span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">			d = min(d, <span class="built_in">sqrt</span>((x_i - x_j)^<span class="number">2</span> + (y_i - y_j)^<span class="number">2</span>))</span><br><span class="line">	<span class="keyword">return</span> d</span><br></pre></td></tr></table></figure>
<h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><ul>
<li>忽略平方根函数，只比较平方</li>
</ul>
<h4 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h4><ul>
<li><p>在点集在x轴方向中位数m作垂线，将点集分成大小为
$\lceiling n/2 \rceiling, \lfloor n/2 \rfloor$两个子集
$P_l, P_r$，然后递归求解子问题$P_l, P_r$得到最近点问题解</p>
</li>
<li><p>定义$d=min{d_l, d_r}$</p>
<ul>
<li>d不一定是所有点对最小距离</li>
<li>最小距离点对可能分别位于分界线两侧，在合并子问题的
解时需要考虑</li>
</ul>
</li>
<li><p>只需要考虑关于m对称的2d垂直带中的点，记S为来自Q、位于
分隔带中的点列表</p>
<ul>
<li>S同样升序排列</li>
<li>扫描S，遇到距离更近的点对时更新最小距离$d_{min}=d$</li>
<li>对于S中点P，只需考虑<strong>在其后、y坐标差小于$d_min$</strong>
的矩形范围内点（因为S有序，P前的点已经考虑过）</li>
<li>该矩形范围内点数目不超过6个（包括P），所以考虑下个点
前，至多考虑5个点</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">EfficientClosestPair(P, Q)</span><br><span class="line">	<span class="comment">// 分治法解决最近点问题</span></span><br><span class="line">	<span class="comment">// 输入：P存储平面上n个点，按x轴坐标升序排列</span></span><br><span class="line">			Q存储和P相同的n个点，按y坐标升序排列</span><br><span class="line">	<span class="comment">/// 输出：最近点直接欧几里得距离</span></span><br><span class="line">	<span class="keyword">if</span> n &lt;= <span class="number">3</span></span><br><span class="line">		<span class="keyword">return</span> 蛮力法最小距离</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		将P前ceiling(n/<span class="number">2</span>)个点复制到P_l</span><br><span class="line">		将Q相应的ceiling(n/<span class="number">2</span>)点复制到Q_l</span><br><span class="line">		将P余下<span class="built_in">floor</span>(n/<span class="number">2</span>)个点复制到P_r</span><br><span class="line">		将Q余下<span class="built_in">floor</span>(n/<span class="number">2</span>)个点复制到Q_r</span><br><span class="line"></span><br><span class="line">		d_l = EfficientClosestPair(P_l, Q_l)</span><br><span class="line">		d_r = EfficientClosestPair(P_r, Q_r)</span><br><span class="line">		d = min&#123;d_l, d_r&#125;</span><br><span class="line"></span><br><span class="line">		m = P[ceiling(n/<span class="number">2</span>) - <span class="number">1</span>].x</span><br><span class="line">		将Q中所有|x-m|&lt;d的点复制到数组S[<span class="number">0.</span>.num<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">		dminsq = d^<span class="number">2</span></span><br><span class="line">		<span class="keyword">for</span> i=<span class="number">0</span> to num<span class="number">-2</span> <span class="keyword">do</span></span><br><span class="line">			k = i+<span class="number">1</span></span><br><span class="line">			<span class="keyword">while</span> k &lt;= num<span class="number">-1</span> <span class="keyword">and</span> (S[k].y - S[i].y)^<span class="number">2</span> &lt; dminsq</span><br><span class="line">				dminsq = min((S[k].x - S[i].x)^<span class="number">2</span> + (S[k].y - S[i].y)^<span class="number">2</span>, dminsq)</span><br><span class="line">				k = k+<span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>(dminsq)</span><br></pre></td></tr></table></figure>
<h4 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>算法时间效率</p>
<ul>
<li>将问题划分为规模相同子问题、合并子问题解，算法都只
需要线性时间</li>
<li>运行时间递推式$T(n) = 2T(n/2) + f(n)$，其中
$f(n) \in \Theta(n)$，则$T(n) \in \Theta(nlogn)$</li>
<li>已经证明在对算法可以执行的操作没有特殊假设情况下，
这是可能得到的最好效率</li>
</ul>
</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li>聚类分析</li>
</ul>
<h2 id="凸包问题"><a href="#凸包问题" class="headerlink" title="凸包问题"></a>凸包问题</h2><p>寻找能把给定集合中所有点都包含在里面的最小凸多边形</p>
<ul>
<li>设集合S中点按照x坐标升序排列，存储在列表P中
（x坐标相同，按y坐标升序）</li>
</ul>
<h3 id="蛮力算法-1"><a href="#蛮力算法-1" class="headerlink" title="蛮力算法"></a>蛮力算法</h3><h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><ul>
<li>对于n个点集中两个点$p_i$、$p_j$，当且仅当集合中其他点
都位于穿过这两点的直线<strong>同侧</strong>时，其连线是该集合凸包边界
一部分</li>
<li>检验每对点，满足条件的点即构成凸包边界</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>算法时间效率为$O(n^3)$</li>
</ul>
<h3 id="快包算法（分治法）"><a href="#快包算法（分治法）" class="headerlink" title="快包算法（分治法）"></a>快包算法（分治法）</h3><h4 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>$p_1、$p_n$显然是凸包顶点，且$\overrightarrow{p_1p_n}$
将点集分为左右两部分$S_1$、$S_2$</p>
<ul>
<li>其上的点不是凸包顶点，之后不必考虑</li>
<li>S的凸包也被划分为upper hull、lower hull，可以使用
相同的方法构造</li>
</ul>
</li>
<li><p>若$S<em>1$为空，则上包就是线段$p_1p_n$；否则寻找距离
$p_1p_n$最大点$p</em>{max}$，若有多个，则选择使得夹角
$\angle p_{max}p_1p_n$最大点</p>
<ul>
<li>$p_max$是上包顶点</li>
<li>包含在$\triangle p<em>1p</em>{max}p_2$中的点不是上包顶点，
之后不必考虑</li>
<li>不存在同时位于$\overrightarrow{p<em>1p</em>{max}}$、
$\overrightarrow{p_{max}p_n}$左侧的点</li>
</ul>
</li>
<li><p>对$\overrightarrow{p<em>1p</em>{max}}$及其左侧点构成的集合
$S<em>{1,1}$、$\overrightarrow{p</em>{max}p<em>n}$及其左侧的点构成
集合$S</em>{1,2}$，重复以上即可继续得到上包顶点</p>
</li>
<li><p>类似的可以对$S_2$寻找下包顶点</p>
</li>
</ul>
<blockquote>
<p>   向量左侧、距离计算参考线代</p>
</blockquote>
<h4 id="算法特点-1"><a href="#算法特点-1" class="headerlink" title="算法特点"></a>算法特点</h4><p>快包和快排很类似</p>
<ul>
<li>最差效率$\Theta(n)$，平均效率好得多</li>
<li>也一般会把问题平均的分成两个较小子问题，提高效率</li>
<li>对于均匀分布在某些凸区域（园、矩形）的点，快包平均效率
可以达到线性</li>
</ul>
<h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><ul>
<li>计算机动画中使用凸包替换物体本身，加快碰撞检测速度</li>
<li>车辆路径规划</li>
<li>地理信息系统中根据卫星图像计算accessibility map</li>
<li>数理统计中用于进行异常值检测</li>
<li>计算点集直径的高效算法中需要用到</li>
</ul>
<h2 id="欧几里得最小生成树问题"><a href="#欧几里得最小生成树问题" class="headerlink" title="欧几里得最小生成树问题"></a>欧几里得最小生成树问题</h2><p>给定平面上n个点，构造顶点为这n个点的总长度最小的树</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h2 id="二维散点"><a href="#二维散点" class="headerlink" title="二维散点"></a>二维散点</h2><h3 id="Convex-Hull"><a href="#Convex-Hull" class="headerlink" title="Convex Hull"></a>Convex Hull</h3><p>凸包：包含点集S的<strong>最小</strong>凸集合</p>
<ul>
<li>离散点集：包含所有点的<strong>最小凸多边形</strong></li>
<li>最小：凸包一定是所有包含S的凸集合的子集</li>
<li>凸包能方便地提供目标形状或给定数据集地一个近似</li>
</ul>
<h3 id="Extreme-Point"><a href="#Extreme-Point" class="headerlink" title="Extreme Point"></a>Extreme Point</h3><p>极点：对于任何以集合中点为端点的线段，不是线段中点的点</p>
<ul>
<li><p>极点有一些特性是凸集中其他点不具备的性质</p>
<ul>
<li>单纯形法：如果存在极值，则一定可以在极点处取到</li>
<li>找到极点、极点排序方向即可解决凸包问题</li>
</ul>
</li>
<li><p>举例</p>
<ul>
<li>三角形中3个顶点</li>
<li>圆周上所有点</li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:37.000Z" title="3/21/2019, 5:27:37 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-02T10:16:43.000Z" title="8/2/2021, 6:16:43 PM">2021-08-02</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Problem/">Problem</a></span><span class="level-item">19 minutes read (About 2882 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Problem/numeric_analysis.html">数值问题</a></h1><div class="content"><h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><p>涉及连续性数学问题</p>
<ul>
<li>解方程、方程组，计算定积分，函数求值</li>
<li>和离散数学中：图、树、排序、组合相对</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><p>大部分此类问题只能近似求解</p>
<ul>
<li>泰勒展开求解$e^x$</li>
<li><em>Composite Trapezoidal rule</em>：组合梯形法则，计算
定积分</li>
</ul>
</li>
<li><p>此类问题大部分要操作实数，而实数在计算机内部只能近似表示
，大量对近近似数的算术操作可能会叠加误差，输出错误结果</p>
</li>
</ul>
<h2 id="整数乘法"><a href="#整数乘法" class="headerlink" title="整数乘法"></a>整数乘法</h2><h3 id="俄式乘法"><a href="#俄式乘法" class="headerlink" title="俄式乘法"></a>俄式乘法</h3><p>两个正整数n、m相乘的非主流算法</p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ul>
<li>反复应用以下公式，简化每步的计算<script type="math/tex; mode=display">
n为奇数：n * m = \frac n 2 * 2m + m \\
n为偶数：n * m = \frac n 2 * 2m</script></li>
<li>以$1 * m$作为算法终止条件</li>
</ul>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>n为奇数步骤中的m，可以最后累加即可</p>
</li>
<li><p>算法中只有折半、加倍、相加操作</p>
<ul>
<li>手动计算非常简便</li>
<li>计算机硬件对折半、加倍只需要移位就可</li>
</ul>
</li>
<li><p>减常因子法</p>
</li>
</ul>
<h3 id="大整数乘法"><a href="#大整数乘法" class="headerlink" title="大整数乘法"></a>大整数乘法</h3><h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><p>考虑a、b两个n位整数，n为偶数</p>
<ul>
<li><p>从中间把数字分段，得到$a_1, a_0, b_1, b_0$</p>
</li>
<li><p>则有</p>
<script type="math/tex; mode=display">\begin{align}
c & = a * b = (a_1 10^{n/2} + a_0) * (b_1 10^{n/2} + b_0) \\
& = (a_1 * b_1)10^n + (a_1 * b_0 + a_0 * b_1) 10^{n/2} + (a_0 + b_0) \\
& = c_2 10^n + c_1 10^{n/2} + c_0
\end{align}</script><ul>
<li>$c_2 = a_1 * b_1$</li>
<li>$c_0 = a_0 * b_0$</li>
<li>$c_1 = (a_1 + a_0) * (b_1 + b_0) - (c_2 + c_0)</li>
</ul>
</li>
<li><p>若n/2也是偶数，可以使用相同的方法计算得到三个乘法表达式</p>
<ul>
<li>若n为2的幂次，就可以得到计算n位数积的递归乘法</li>
<li>n迭代到足够小时，递归就可以停止</li>
</ul>
</li>
</ul>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>算法效率</p>
<ul>
<li>乘法次数递推式：$M(n)=3M(n/2), M(1)=1$，则
$M(n) = n^(log_2 3) \approx n^{1.585}$</li>
<li>加法次数递推式：$A(n)=3A(n/2) + cn, A(1)=1$，则
$A(n) \in \Theta(n^{log_2 3})$</li>
</ul>
</li>
<li><p>算法有渐进效率优势，实际性能依赖于计算机系统、算法实现
质量，在某些情况下</p>
<ul>
<li>计算8位乘法时，分治算法速度快于传统方法</li>
<li>计算超过100位时，速度是传统算法2倍</li>
</ul>
</li>
<li><p>分治法</p>
</li>
</ul>
<h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><p>计算最大公约数、最大公倍数</p>
<h4 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h4><script type="math/tex; mode=display">gcd(m, n) = gcd(n, m mod n)</script><ul>
<li>n为0，返回m作为结果结束</li>
<li>将m处以n的余数赋给r</li>
<li>将n付给m，r赋给n，返回第一步</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Euclid(m, n)</span><br><span class="line">	while n != 0 do</span><br><span class="line">		r = m mod n</span><br><span class="line">		m = n</span><br><span class="line">		n = r</span><br><span class="line">	return m</span><br></pre></td></tr></table></figure>
<h4 id="最大公倍数"><a href="#最大公倍数" class="headerlink" title="最大公倍数"></a>最大公倍数</h4><script type="math/tex; mode=display">lcm(m, n) = \frac {m * n} {gcd(m, n)}</script><ul>
<li>利用最大公约数计算最小公倍数</li>
</ul>
<h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><ul>
<li>变治法（+减可变规模）</li>
</ul>
<h2 id="特定点求值"><a href="#特定点求值" class="headerlink" title="特定点求值"></a>特定点求值</h2><h3 id="霍纳法则（计算多项式）"><a href="#霍纳法则（计算多项式）" class="headerlink" title="霍纳法则（计算多项式）"></a>霍纳法则（计算多项式）</h3><p>霍纳法则：不断将x作为公因子提取出来，合并降次后的项，然后
计算多项式在特定点的值</p>
<h4 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Horner(P[<span class="number">0.</span>.n], x)</span><br><span class="line">	<span class="comment">// 用霍纳法则求多项式在给定点的值</span></span><br><span class="line">	<span class="comment">// 输入：多项式系数数组P[0..n]、数字x</span></span><br><span class="line">	<span class="comment">// 输出：多项式在x点的值</span></span><br><span class="line">	p = P[n]</span><br><span class="line">	<span class="keyword">for</span> i = n<span class="number">-1</span> downto <span class="number">0</span> <span class="keyword">do</span></span><br><span class="line">		p = x*p + P[i]</span><br><span class="line">	<span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>
<h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>算法效率</p>
<ul>
<li>效率始终为n，只相当于直接计算中$a_n x^n$的乘法数量</li>
</ul>
</li>
<li><p>变治法</p>
</li>
</ul>
<h3 id="二进制（计算）幂"><a href="#二进制（计算）幂" class="headerlink" title="二进制（计算）幂"></a>二进制（计算）幂</h3><p>将幂次转换为二进制位串，利用二进制位串简化计算</p>
<h4 id="从左至右二进制幂"><a href="#从左至右二进制幂" class="headerlink" title="从左至右二进制幂"></a>从左至右二进制幂</h4><ul>
<li>对位串应用霍纳法则</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LeftRightBinaryExponentiation(a, B[<span class="number">0.</span>.n<span class="number">-1</span>])</span><br><span class="line">	<span class="comment">// 从左至右二进制幂算法计算a^n</span></span><br><span class="line">	<span class="comment">// 输入：数字a、表示幂次的二级制位串B[0..n-1]</span></span><br><span class="line">	<span class="comment">// 输出：a^n的值</span></span><br><span class="line">	product = a</span><br><span class="line">	<span class="keyword">for</span> i = n<span class="number">-1</span> downto <span class="number">0</span> <span class="keyword">do</span></span><br><span class="line">		product = product * product</span><br><span class="line">		<span class="keyword">if</span> B[i] == <span class="number">1</span>:</span><br><span class="line">			prduct = product * a</span><br><span class="line">	<span class="keyword">return</span> product</span><br></pre></td></tr></table></figure>
<h4 id="从右至左二进制幂"><a href="#从右至左二进制幂" class="headerlink" title="从右至左二进制幂"></a>从右至左二进制幂</h4><ul>
<li>累次计算二进制位串中为1部分值，将其累乘</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RightLeftBinaryExponentiation(a, B[<span class="number">0.</span>.n<span class="number">-1</span>])</span><br><span class="line">	<span class="comment">// 从右至左二进制幂算法</span></span><br><span class="line">	<span class="comment">// 输入：数字a、表示幂次的二级制位串B[0..n-1]</span></span><br><span class="line">	<span class="comment">// 输出：a^n的值</span></span><br><span class="line">	term = a</span><br><span class="line">	<span class="keyword">if</span> B[<span class="number">0</span>] == <span class="number">1</span></span><br><span class="line">		product = a</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		product = <span class="number">1</span></span><br><span class="line">		<span class="comment">// 保存累乘值</span></span><br><span class="line">	<span class="keyword">for</span> i = i to n <span class="keyword">do</span></span><br><span class="line">		term *= <span class="number">2</span></span><br><span class="line">		<span class="comment">// 保存二进制位为1部分值</span></span><br><span class="line">		<span class="keyword">if</span> B[i] = <span class="number">1</span></span><br><span class="line">			product = product * term</span><br><span class="line">	<span class="keyword">return</span> product</span><br></pre></td></tr></table></figure>
<h4 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>算法效率</p>
<ul>
<li>两个算法效率取决于位串长度，是对数级的</li>
</ul>
</li>
<li><p>变治法</p>
</li>
</ul>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul>
<li>在密码技术中，需要对超过100位十进制整数进行乘法运算，而
计算机往往不能直接运算</li>
</ul>
<h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><h3 id="Strassen矩阵乘法"><a href="#Strassen矩阵乘法" class="headerlink" title="Strassen矩阵乘法"></a>Strassen矩阵乘法</h3><script type="math/tex; mode=display">\begin{align}
\begin{bmatrix}
C_{00} & C_{01} \\
C_{10} & C_{11}
\end{bmatrix}
    & =
\begin{bmatrix}
A_{00} & A_{01} \\
A_{10} & A_{11}
\end{bmatrix}
\begin{bmatrix}
B_{00} & B_{01} \\
B_{10} & B_{11}
\end{bmatrix} \\
    & =
\begin{bmatrix}
M_1+M_2-M_5+M_7 & M_3+M_5 \\
M_2+M_4 & M_1+M_3-M_2+M_6
\end{bmatrix} \\

M_1 & = (A_{00} + A_{11}) · (B_{00} + B_{11}) \\
M_2 & = (A_{10} + A_{11}) · B_{00} \\
M_3 & = A_{00} · (B_{01} - B_{11}) \\
M_4 & = A_{11} · (B_{10} - B_{00}) \\
M_5 & = (A_{00} + A_{01}) · B_{11} \\
M_6 & = (A_{10} - A_{00}) · (B_{00} + B_{01}) \\
M_7 & = (A_{01} + A_{11}) · (B_{10} + B_{11}) \\
\end{align}</script><h4 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h4><p>若A、B是两个n阶方阵（若n不是2幂次，考虑填充0）</p>
<ul>
<li>将A、B、C均分块为4个n/2子矩阵</li>
<li>递归使用Strassen方程中定义的矩阵M进行计算计算C各个子阵</li>
</ul>
<h4 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>对2 * 2分块计算，Strassen算法执行了7次乘法、18次加减法，
蛮力算法需要执行8次乘法、4次加法</p>
</li>
<li><p>算法效率</p>
<ul>
<li>乘法次数递推式：$M(n) = 7M(n/2), M(1) = 1$，则
$M(n) = 7^{log<em>2 n} = n^{log_2 7} \approx n</em>{2.807}$</li>
<li>加法次数递推式：$A(n) = 7A(n/2) + 18(n/2)^2, A(1)=0$
，则$A(n) \in \Theta(n^{log_2 7})$</li>
<li>矩阵趋于无穷大时，算法表现出的渐进效率卓越</li>
</ul>
</li>
<li><p>还有一些算法能运行时间$\in \Theta(n^\alpha)$，最小能达到
2.376，但是这些算法乘法常量很大、算法复杂，没有实用价值</p>
</li>
<li><p>矩阵乘法效率下界为$n^2$，目前得到的最优效率和其还有很大
距离</p>
</li>
<li><p>分治法</p>
</li>
</ul>
<h2 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h2><ul>
<li>假设方程组系数矩阵为n阶方阵，且解唯一</li>
<li>主要思想都是高斯消元法（变治法），只是出于效率、误差有
不同实现方式</li>
</ul>
<h3 id="前向消去法"><a href="#前向消去法" class="headerlink" title="前向消去法"></a>前向消去法</h3><h4 id="算法-4"><a href="#算法-4" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ForwardElimination(A[<span class="number">1.</span>.n, <span class="number">1.</span>.n], b[<span class="number">1.</span>.n])</span><br><span class="line">	<span class="comment">// 对方程组扩展矩阵[A|b]使用高斯消元法</span></span><br><span class="line">	<span class="comment">// 输入：矩阵A[1..n, 1..n]，向量b[1..n]</span></span><br><span class="line">	<span class="comment">// 输出：扩展的上三角矩阵</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">		A[i, n+<span class="number">1</span>] = b[i]</span><br><span class="line">		<span class="comment">// 得到扩展矩阵</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span> to n<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">for</span> j = i+<span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">			<span class="keyword">for</span> k = n+<span class="number">1</span> downto i <span class="keyword">do</span></span><br><span class="line">				A[j, k] = A[j, k] - A[i, k]*A[j, i] / A[i, i]</span><br></pre></td></tr></table></figure>
<h4 id="算法特点-1"><a href="#算法特点-1" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>前向消去法不一定正确</p>
<ul>
<li>如果A[i, i]==0，不能以其作为除数，此时需要交换行
（解唯一时总是存在非0行）</li>
<li>A[i, i]非常小，导致比例因子A[j, i] / A[i, i]非常大，
产生大的舍入误差</li>
</ul>
</li>
<li><p>最内层循环效率低</p>
</li>
</ul>
<h3 id="部分选主元法"><a href="#部分选主元法" class="headerlink" title="部分选主元法"></a>部分选主元法</h3><h4 id="算法-5"><a href="#算法-5" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BetterForwardElimination(A[<span class="number">1.</span>.n, <span class="number">1.</span>.n], b[<span class="number">1.</span>.n])</span><br><span class="line">	<span class="comment">// 用部分选主元法实现高斯消去</span></span><br><span class="line">	<span class="comment">// 输入：矩阵A[1..n, 1..n]，向量b[1..n]</span></span><br><span class="line">	<span class="comment">// 输出：扩展的上三角矩阵</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">		A[i, n+<span class="number">1</span>] = b[i]</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span> to n<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">		pivotrow = i</span><br><span class="line">		<span class="keyword">for</span> j = i+<span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">			<span class="keyword">if</span> |A[j, i]| &gt; A[pivot, i]</span><br><span class="line">				pivotrow = j</span><br><span class="line">				<span class="comment">// 选择第i列系数最大的行作为第i次迭代基点</span></span><br><span class="line">				<span class="comment">// 保证比例因子绝对值不会大于1</span></span><br><span class="line">			<span class="keyword">for</span> k = i to n+<span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">				swap(A[i, k], A[pivot, k])</span><br><span class="line">			<span class="keyword">for</span> j = j+<span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">				temp = A[j, i] / A[i, i]</span><br><span class="line">				<span class="comment">// 这样只需要计算依次比例因子</span></span><br><span class="line">				<span class="keyword">for</span> k = i to n+<span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">					A[j, k] = A[j, k] - A[i, k] * temp</span><br></pre></td></tr></table></figure>
<h4 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h4><ul>
<li>部分选主元法克服了前向消去法弊端<ul>
<li>最内层乘法（加法）执行次数为
$\frac {n(n-1)(2n+5) 6 \approx \frac n^3 3 \in \Theta(n^3)$</li>
<li>始终能保证比例因子绝对值不大于1</li>
</ul>
</li>
</ul>
<h3 id="反向替换法"><a href="#反向替换法" class="headerlink" title="反向替换法"></a>反向替换法</h3><p>在得到上三角系数矩阵中</p>
<ul>
<li>从最后一个方程中可以立刻求出$x_n$</li>
<li>将$x<em>n$带入倒数第二个方程求出$x</em>{n-1}$</li>
<li>逐次递推得到所以解</li>
</ul>
<h4 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a>特点</h4><ul>
<li>算法时间效率$\in \Theta(n^2)$</li>
</ul>
<h3 id="高斯消去法应用"><a href="#高斯消去法应用" class="headerlink" title="高斯消去法应用"></a>高斯消去法应用</h3><ul>
<li>矩阵（可逆矩阵）中应用<ul>
<li>LU分解（Doolittle分解）</li>
<li>Cholesky分解（要求矩阵正定）</li>
<li>求逆</li>
<li>求行列式</li>
</ul>
</li>
<li>高斯消元法整个算法效率取决于消去部分，是立方级<ul>
<li>事实上此方法在计算机上求解大规模方程组很难，因为舍入
误差在计算过程中会不断累积</li>
</ul>
</li>
</ul>
<h2 id="非线性方程求解"><a href="#非线性方程求解" class="headerlink" title="非线性方程求解"></a>非线性方程求解</h2><ul>
<li><p>5次及以上多项式没有只包含多项式系数、算术操作、开根号
的通用求根公式</p>
</li>
<li><p>方程的代数解并不具有很大的意义，充其量只是为方程的根设置
一个符号，然后再说方程有一个根等于这个符号（高斯）</p>
</li>
</ul>
<h3 id="平分法"><a href="#平分法" class="headerlink" title="平分法"></a>平分法</h3><p>基于连续函数界值定理，类似于连续版折半查找</p>
<h4 id="算法-6"><a href="#算法-6" class="headerlink" title="算法"></a>算法</h4><p>在区间[a, b]的端点上，$f(x)$符号取反</p>
<ul>
<li>计算$f(x<em>{mid}), x</em>{mid}= \frac {a+b} 2$的值</li>
<li>若$f(x_{mid})=0$，则求得一个</li>
<li>否则选择使得$f(x)$能在端点上取得相反值区间$[a, x<em>{mid}$
、$[x</em>{mid}, b]$</li>
<li>当包含根得区间小于预定义得$\epsilon &gt; 0$时，就可以停止
算法</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Bisection(f(x), a, b, eps, N)</span><br><span class="line">	<span class="comment">// 评分法求f(x) = 0的一个根</span></span><br><span class="line">	<span class="comment">// 输入：f(a)f(b) &lt; 0，eps绝对误差上界，N迭代次数上界</span></span><br><span class="line">	<span class="comment">// 输出：(a, b)上的一个根近似（精确）值，或包含根的区间</span></span><br><span class="line">	n = <span class="number">1</span></span><br><span class="line">		<span class="comment">// 迭代计数</span></span><br><span class="line">	<span class="keyword">while</span> n &lt;= N <span class="keyword">do</span></span><br><span class="line">		x = (a + b)/<span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> x - a &lt; eps</span><br><span class="line">			 <span class="keyword">return</span> x</span><br><span class="line">		fval = f(x)</span><br><span class="line">		<span class="keyword">if</span> fval = <span class="number">0</span></span><br><span class="line">			<span class="keyword">return</span> x</span><br><span class="line">		<span class="keyword">if</span> fval*f(a) &lt; <span class="number">0</span>:</span><br><span class="line">			b = x</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			a = x</span><br><span class="line">		n += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> a, b</span><br><span class="line">		<span class="comment">// 达到迭代限制，返回包含根的区间</span></span><br></pre></td></tr></table></figure>
<h4 id="特点-8"><a href="#特点-8" class="headerlink" title="特点"></a>特点</h4><ul>
<li>求解精度<ul>
<li>理论上迭代次数足够$x_n$可以任意接近真实根$x^{*}$</li>
<li>实际上，机器使用0表示非常小的值，$\epsilon$小于特定
机器阈值时，算法不会停止，也无法得到满足条件的解</li>
<li>d对目标函数求值时可能会发生舍入误差</li>
</ul>
</li>
<li>缺点<ul>
<li>相较于其他已经算法，收敛速度较慢</li>
<li>并且无法扩展到更加一般的方程、方程组领域</li>
</ul>
</li>
<li>优点<ul>
<li>区间特性容易检验</li>
</ul>
</li>
</ul>
<h3 id="Method-of-False-Position"><a href="#Method-of-False-Position" class="headerlink" title="Method of False Position"></a>Method of False Position</h3><p>试位法：类似于连续版差值查找</p>
<h4 id="算法-7"><a href="#算法-7" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>类似平分法每次也使用某个区间$[a_n, b_n]$括住连续函数的
根，函数在端点取值符号相反</p>
</li>
<li><p>使用穿过$(a_n, f(a_n)), (b_n, f(b_n))$的直线在x轴截距
$x=\frac {a_nf(b_n) - b_nf(a_n)} {f(b_n) - f(a_n)}$作为
分割点</p>
</li>
</ul>
<h4 id="特点-9"><a href="#特点-9" class="headerlink" title="特点"></a>特点</h4><ul>
<li>对许多实例，试位法收敛速度较平分法更快</li>
</ul>
<h3 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h3><p>Newton-Raphon Method</p>
<h4 id="算法-8"><a href="#算法-8" class="headerlink" title="算法"></a>算法</h4><ul>
<li>方法产生近似解序列：函数切线在x轴截距
$x_{n+1} = x_n - \frac {f(x_n)} {f^{‘}(x_n)},n=0,1,\cdots$</li>
</ul>
<h4 id="特点-10"><a href="#特点-10" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>大多数情况下，若初值$x_0$足够接近根，牛顿法能够保证序列
收敛与根；对远离根的初值，无法保证一定会收敛</p>
</li>
<li><p>优点</p>
<ul>
<li>牛顿法相较于平分法、试位法收敛速度更快，选定合适的
初值能够快速收敛</li>
<li>能够应用于更一般类型的方程、方程组</li>
</ul>
</li>
<li><p>方法每次都迭代需要重新求函数、导数值</p>
<ul>
<li>导数值等于0，则牛顿法失效</li>
<li>导数绝对值越大，牛顿法越有效</li>
</ul>
</li>
<li><p>牛顿法不会把根括起来</p>
</li>
</ul>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">36</span></span></a><ul><li><a class="level is-mobile" href="/categories/Algorithm/Data-Structure/"><span class="level-start"><span class="level-item">Data Structure</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Heuristic/"><span class="level-start"><span class="level-item">Heuristic</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Issue/"><span class="level-start"><span class="level-item">Issue</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Problem/"><span class="level-start"><span class="level-item">Problem</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Specification/"><span class="level-start"><span class="level-item">Specification</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/C-C/"><span class="level-start"><span class="level-item">C/C++</span></span><span class="level-end"><span class="level-item tag">34</span></span></a><ul><li><a class="level is-mobile" href="/categories/C-C/Cppref/"><span class="level-start"><span class="level-item">Cppref</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/Cstd/"><span class="level-start"><span class="level-item">Cstd</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/MPI/"><span class="level-start"><span class="level-item">MPI</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/STL/"><span class="level-start"><span class="level-item">STL</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/CS/"><span class="level-start"><span class="level-item">CS</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/CS/Character/"><span class="level-start"><span class="level-item">Character</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Parallel/"><span class="level-start"><span class="level-item">Parallel</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Program-Design/"><span class="level-start"><span class="level-item">Program Design</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Storage/"><span class="level-start"><span class="level-item">Storage</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Daily-Life/"><span class="level-start"><span class="level-item">Daily Life</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/Daily-Life/Maxism/"><span class="level-start"><span class="level-item">Maxism</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Database/"><span class="level-start"><span class="level-item">Database</span></span><span class="level-end"><span class="level-item tag">27</span></span></a><ul><li><a class="level is-mobile" href="/categories/Database/Hadoop/"><span class="level-start"><span class="level-item">Hadoop</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Database/SQL-DB/"><span class="level-start"><span class="level-item">SQL DB</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Database/Spark/"><span class="level-start"><span class="level-item">Spark</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/Scala/"><span class="level-start"><span class="level-item">Scala</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">42</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Bash-Programming/"><span class="level-start"><span class="level-item">Bash Programming</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Configuration/"><span class="level-start"><span class="level-item">Configuration</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/File-System/"><span class="level-start"><span class="level-item">File System</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/IPC/"><span class="level-start"><span class="level-item">IPC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Process-Schedual/"><span class="level-start"><span class="level-item">Process Schedual</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Shell/"><span class="level-start"><span class="level-item">Shell</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Tool/"><span class="level-start"><span class="level-item">Tool</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Tool/Vi/"><span class="level-start"><span class="level-item">Vi</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Model/"><span class="level-start"><span class="level-item">ML Model</span></span><span class="level-end"><span class="level-item tag">21</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Model/Linear-Model/"><span class="level-start"><span class="level-item">Linear Model</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Model-Component/"><span class="level-start"><span class="level-item">Model Component</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Nolinear-Model/"><span class="level-start"><span class="level-item">Nolinear Model</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Unsupervised-Model/"><span class="level-start"><span class="level-item">Unsupervised Model</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/"><span class="level-start"><span class="level-item">ML Specification</span></span><span class="level-end"><span class="level-item tag">17</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/Click-Through-Rate/"><span class="level-start"><span class="level-item">Click Through Rate</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/Click-Through-Rate/Recommandation-System/"><span class="level-start"><span class="level-item">Recommandation System</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/Computer-Vision/"><span class="level-start"><span class="level-item">Computer Vision</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Specification/FinTech/"><span class="level-start"><span class="level-item">FinTech</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/FinTech/Risk-Control/"><span class="level-start"><span class="level-item">Risk Control</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/Graph-Analysis/"><span class="level-start"><span class="level-item">Graph Analysis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Specification/NLP/"><span class="level-start"><span class="level-item">NLP</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Technique/"><span class="level-start"><span class="level-item">ML Technique</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Technique/Feature-Engineering/"><span class="level-start"><span class="level-item">Feature Engineering</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Technique/Neural-Network/"><span class="level-start"><span class="level-item">Neural Network</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Theory/"><span class="level-start"><span class="level-item">ML Theory</span></span><span class="level-end"><span class="level-item tag">11</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Theory/Loss/"><span class="level-start"><span class="level-item">Loss</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Theory/Model-Enhencement/"><span class="level-start"><span class="level-item">Model Enhencement</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Theory/Optimization/"><span class="level-start"><span class="level-item">Optimization</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Algebra/"><span class="level-start"><span class="level-item">Math Algebra</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Algebra/Linear-Algebra/"><span class="level-start"><span class="level-item">Linear Algebra</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Algebra/Universal-Algebra/"><span class="level-start"><span class="level-item">Universal Algebra</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Analysis/"><span class="level-start"><span class="level-item">Math Analysis</span></span><span class="level-end"><span class="level-item tag">23</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Analysis/Fourier-Analysis/"><span class="level-start"><span class="level-item">Fourier Analysis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Functional-Analysis/"><span class="level-start"><span class="level-item">Functional Analysis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Optimization/"><span class="level-start"><span class="level-item">Optimization</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Real-Analysis/"><span class="level-start"><span class="level-item">Real Analysis</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Mixin/"><span class="level-start"><span class="level-item">Math Mixin</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Mixin/Statistics/"><span class="level-start"><span class="level-item">Statistics</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Mixin/Time-Series/"><span class="level-start"><span class="level-item">Time Series</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Probability/"><span class="level-start"><span class="level-item">Probability</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">89</span></span></a><ul><li><a class="level is-mobile" href="/categories/Python/Cookbook/"><span class="level-start"><span class="level-item">Cookbook</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Jupyter/"><span class="level-start"><span class="level-item">Jupyter</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Keras/"><span class="level-start"><span class="level-item">Keras</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Matplotlib/"><span class="level-start"><span class="level-item">Matplotlib</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Numpy/"><span class="level-start"><span class="level-item">Numpy</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Pandas/"><span class="level-start"><span class="level-item">Pandas</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Py3Ref/"><span class="level-start"><span class="level-item">Py3Ref</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Py3std/"><span class="level-start"><span class="level-item">Py3std</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Pywin32/"><span class="level-start"><span class="level-item">Pywin32</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Readme/"><span class="level-start"><span class="level-item">Readme</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/TensorFlow/"><span class="level-start"><span class="level-item">TensorFlow</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Twists/"><span class="level-start"><span class="level-item">Twists</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/RLang/"><span class="level-start"><span class="level-item">RLang</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Rust/"><span class="level-start"><span class="level-item">Rust</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Set/"><span class="level-start"><span class="level-item">Set</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/"><span class="level-start"><span class="level-item">Tool</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/Tool/Editor/"><span class="level-start"><span class="level-item">Editor</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Markup-Language/"><span class="level-start"><span class="level-item">Markup Language</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Web-Browser/"><span class="level-start"><span class="level-item">Web Browser</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Windows/"><span class="level-start"><span class="level-item">Windows</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/Web/CSS/"><span class="level-start"><span class="level-item">CSS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/NPM/"><span class="level-start"><span class="level-item">NPM</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/Proxy/"><span class="level-start"><span class="level-item">Proxy</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/Thrift/"><span class="level-start"><span class="level-item">Thrift</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://octodex.github.com/images/hula_loop_octodex03.gif" alt="UBeaRLy"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">UBeaRLy</p><p class="is-size-6 is-block">Protector of Proxy</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">392</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">93</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">522</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/xyy15926" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/xyy15926"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-04T15:07:54.896Z">2021-08-04</time></p><p class="title"><a href="/uncategorized/README.html"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-03T07:46:51.000Z">2021-08-03</time></p><p class="title"><a href="/Web/NPM/hexo_config.html">Hexo 建站</a></p><p class="categories"><a href="/categories/Web/">Web</a> / <a href="/categories/Web/NPM/">NPM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-03T02:32:45.000Z">2021-08-03</time></p><p class="title"><a href="/Web/NPM/config.html">NPM 总述</a></p><p class="categories"><a href="/categories/Web/">Web</a> / <a href="/categories/Web/NPM/">NPM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-02T08:11:11.000Z">2021-08-02</time></p><p class="title"><a href="/Python/Py3std/internet_data.html">互联网数据</a></p><p class="categories"><a href="/categories/Python/">Python</a> / <a href="/categories/Python/Py3std/">Py3std</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-29T13:55:00.000Z">2021-07-29</time></p><p class="title"><a href="/Linux/Shell/sh_apps.html">Shell 应用程序</a></p><p class="categories"><a href="/categories/Linux/">Linux</a> / <a href="/categories/Linux/Shell/">Shell</a></p></div></article></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">Advertisement</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="pub-5385776267343559" data-ad-slot="6995841235" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="https://api.follow.it/subscription-form/WWxwMVBsOUtoNTdMSlJ4Z1lWVnRISERsd2t6ek9MeVpEUWs0YldlZGxUdXlKdDNmMEZVV1hWaFZFYWFSNmFKL25penZodWx3UzRiaVkxcnREWCtOYUJhZWhNbWpzaUdyc1hPangycUh5RTVjRXFnZnFGdVdSTzZvVzJBcTJHKzl8aXpDK1ROWWl4N080YkFEK3QvbEVWNEJuQjFqdWdxODZQcGNoM1NqbERXST0=/8" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="UBeaRLy" height="28"></a><p class="is-size-7"><span>&copy; 2021 UBeaRLy</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/xyy15926/proxy"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>