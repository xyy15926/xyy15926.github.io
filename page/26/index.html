<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>UBeaRLy</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="UBeaRLy&#039;s Proxy"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="UBeaRLy&#039;s Proxy"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="UBeaRLy"><meta property="og:url" content="https://xyy15926.github.io/"><meta property="og:site_name" content="UBeaRLy"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://xyy15926.github.io/img/og_image.png"><meta property="article:author" content="UBeaRLy"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xyy15926.github.io"},"headline":"UBeaRLy","image":["https://xyy15926.github.io/img/og_image.png"],"author":{"@type":"Person","name":"UBeaRLy"},"publisher":{"@type":"Organization","name":"UBeaRLy","logo":{"@type":"ImageObject","url":"https://xyy15926.github.io/img/logo.svg"}},"description":""}</script><link rel="alternate" href="/atom.xml" title="UBeaRLy" type="application/atom+xml"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/darcula.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><script data-ad-client="pub-5385776267343559" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><meta name="follow_it-verification-code" content="SVBypAPPHxjjr7Y4hHfn"><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="UBeaRLy" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Visit on GitHub" href="https://github.com/xyy15926/proxy"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-05-14T15:42:55.000Z" title="5/14/2019, 11:42:55 PM">2019-05-14</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-05-14T15:42:55.000Z" title="5/14/2019, 11:42:55 PM">2019-05-14</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Py3Ref/">Py3Ref</a></span><span class="level-item">21 minutes read (About 3137 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Py3Ref/compound_stmts.html">Compound Statements</a></h1><div class="content"><h2 id="复合语句"><a href="#复合语句" class="headerlink" title="复合语句"></a>复合语句</h2><p>复合语句：包含其他语句（语句组）的语句</p>
<ul>
<li><p>复合语句由一个、多个子句组成，子句包含句头、句体</p>
<ul>
<li>子句头<ul>
<li>都处于相同的缩进层级</li>
<li>以作为唯一标识的关键字开始、冒号结束</li>
</ul>
</li>
<li>子句体<ul>
<li>在子句头冒号后、与其同处一行的一条或多条分号分隔
的多条简单语句</li>
<li>或者是在其之后缩进的一行、多行语句，此形式才能
<strong>包含嵌套的复合语句</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>其会以某种方式影响、控制所包含的其他语句执行</p>
</li>
</ul>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">compound_stmt ::=  if_stmt</span><br><span class="line">                   | while_stmt</span><br><span class="line">                   | for_stmt</span><br><span class="line">                   | try_stmt</span><br><span class="line">                   | with_stmt</span><br><span class="line">                   | funcdef</span><br><span class="line">                   | classdef</span><br><span class="line">                   | async_with_stmt</span><br><span class="line">                   | async_for_stmt</span><br><span class="line">                   | async_funcdef</span><br><span class="line">suite         ::=  stmt_list NEWLINE | NEWLINE INDENT statement+ DEDENT</span><br><span class="line">statement     ::=  stmt_list NEWLINE | compound_stmt</span><br><span class="line">stmt_list     ::=  simple_stmt (<span class="string">&quot;;&quot;</span> simple_stmt)* [<span class="string">&quot;;&quot;</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>语句总以<code>NEWLINE</code>结束，之后可能跟随<code>DEDENT</code></li>
<li>可选的后续子句总是以不能作为语句开头的关键字作为开头，
  不会产生歧义</li>
</ul>
</blockquote>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a><code>if</code></h3><p>if语句：有条件的执行</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if_stmt ::=  <span class="string">&quot;if&quot;</span> expression <span class="string">&quot;:&quot;</span> suite</span><br><span class="line">             (&quot;elif&quot; expression &quot;:&quot; suite)*</span><br><span class="line">             [&quot;else&quot; &quot;:&quot; suite]</span><br></pre></td></tr></table></figure>
<ul>
<li>对表达式逐个求值直至找到真值，在子句体中选择唯一匹配者
执行</li>
<li>若所有表达式均为假值，则<code>else</code>子句体如果存在被执行</li>
</ul>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a><code>while</code></h3><p>while语句：在表达式保持为真的情况下重复执行</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while_stmt ::=  <span class="string">&quot;while&quot;</span> expression <span class="string">&quot;:&quot;</span> suite</span><br><span class="line">                [&quot;else&quot; &quot;:&quot; suite]</span><br></pre></td></tr></table></figure>
<ul>
<li>重复检验表达式<ul>
<li>若为真，则执行第1个子句体</li>
<li>若为假，则<code>else</code><strong>子句体存在</strong>就被执行并终止循环</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>第1个子句体中<code>break</code>语句执行将终止循环，且不执行<code>else</code>
  子句体</li>
<li>第1个子句体中<code>continue</code>语句执行将跳过子句体中剩余部分，
  直接检验表达式</li>
</ul>
</blockquote>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a><code>for</code></h3><p>for语句：对序列（字符串、元组、列表）或其他可迭代对象中元素
进行迭代</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for_stmt ::= <span class="string">&quot;for&quot;</span> target_list <span class="string">&quot;in&quot;</span> expression_list <span class="string">&quot;:&quot;</span> suite</span><br><span class="line">	[&quot;else&quot; : suite]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>表达式列表被求值一次</p>
<ul>
<li>应该产生可迭代对象</li>
<li>python将为其结果创建可迭代对象创建迭代器</li>
</ul>
</li>
<li><p>迭代器每项会按照标准赋值规则被依次赋值给目标列表</p>
<ul>
<li>为迭代器每项执行依次子句体</li>
<li>所有项被耗尽<code>raise StopIteration</code>时，<code>else</code>子句体
存在则会被执行</li>
</ul>
</li>
<li><p>目标列表中名称在循环结束后不会被删除</p>
<ul>
<li>但若序列为空，其不会被赋值</li>
</ul>
</li>
<li><p>序列在循环子句体中被修改可能导致问题</p>
<ul>
<li>序列的<code>__iter__</code>方法默认实现依赖内部计数器和序列长度
的比较</li>
<li>若在子句体中增、删元素会使得内部计数器“错误工作”</li>
<li>可以<strong>对整个序列使用切片创建临时副本</strong>避免此问题</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>第1个子句体中<code>break</code>语句执行将终止循环，且不执行<code>else</code>
  子句体</li>
<li>第1个子句体中<code>continue</code>语句执行将跳过子句体中剩余部分，
  转至下个迭代项执行</li>
</ul>
</blockquote>
<h3 id="try"><a href="#try" class="headerlink" title="try"></a><code>try</code></h3><p>try语句：为一组语句指定异常处理器、清理代码</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try_stmt  ::=  try1_stmt | try2_stmt</span><br><span class="line">try1_stmt ::=  <span class="string">&quot;try&quot;</span> <span class="string">&quot;:&quot;</span> suite</span><br><span class="line">               (&quot;except&quot; [expression [&quot;as&quot; identifier]] &quot;:&quot; suite)+</span><br><span class="line">               [&quot;else&quot; &quot;:&quot; suite]</span><br><span class="line">               [&quot;finally&quot; &quot;:&quot; suite]</span><br><span class="line">try2_stmt ::=  <span class="string">&quot;try&quot;</span> <span class="string">&quot;:&quot;</span> suite</span><br><span class="line">               &quot;finally&quot; &quot;:&quot; suite</span><br></pre></td></tr></table></figure>
<h4 id="except子句"><a href="#except子句" class="headerlink" title="except子句"></a><code>except</code>子句</h4><p><code>except</code>子句：指定一个、多个异常处理器</p>
<ul>
<li><p><code>try</code>子句中没有异常时，没有异常处理器执行</p>
</li>
<li><p>否则，依次检查<code>except</code>子句直至找到和异常匹配的子句</p>
<ul>
<li>无表达式子句必须是最后一个，将匹配任何异常</li>
<li>有表达式子句中表达式被求值，求值结果同异常兼容则匹配
成功<ul>
<li>若在表达式求值引发异常，则对原异常处理器搜索取消</li>
<li>其被视为整个<code>try</code>语句引发异常，将在周边代码、
主调栈中为新异常启动搜索</li>
</ul>
</li>
<li>若无法找到匹配的异常子句，则在周边代码、主调栈中继续
搜索异常处理器</li>
</ul>
<blockquote>
<ul>
<li>兼容：是异常对象所属类、基类，或包含兼容异常对象元组</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li><p>当找到匹配<code>except</code>子句时</p>
<ul>
<li>异常将被赋值给<code>as</code>子句后目标，若存在<code>as</code>子句</li>
<li>对应子句体被执行（所有<code>except</code>子句都需要子句体）</li>
<li><p><code>as</code>后目标在<code>except</code>子句结束后被清除</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">except</span> E <span class="keyword">as</span> N:</span><br><span class="line">	foo</span><br><span class="line">	<span class="comment"># 被转写为</span></span><br><span class="line"><span class="keyword">except</span> E <span class="keyword">as</span> N:</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		foo</span><br><span class="line">	<span class="keyword">finally</span>:</span><br><span class="line">		<span class="keyword">del</span> N</span><br></pre></td></tr></table></figure>
<ul>
<li>避免因异常附加回溯信息而形成栈帧的循环引用，使得
所有局部变量存活直至下次垃圾回收</li>
<li>则异常必须赋值给其他名称才能在<code>except</code>子句后继续
引用</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><code>except</code>子句体执行前，有关异常信息存放在<code>sys</code>模块中，
  参见<em>cs_python/py3std/os_sys.md</em></li>
</ul>
</blockquote>
<h4 id="else子句"><a href="#else子句" class="headerlink" title="else子句"></a><code>else</code>子句</h4><p><code>else</code>子句：在以下情况将被执行，若存在</p>
<ul>
<li>控制流离开<code>try</code>子句体没有引发异常</li>
<li>没有执行<code>return</code>、<code>continue</code>、<code>break</code>语句</li>
</ul>
<h4 id="finally子句"><a href="#finally子句" class="headerlink" title="finally子句"></a><code>finally</code>子句</h4><p><code>finally</code>子句：指定清理处理器，子句体在任何情况下都被执行</p>
<ul>
<li><p>执行期间程序不能获取任何异常信息</p>
<ul>
<li><p>在<code>try</code>、<code>except</code>、<code>else</code>子句中引发的任何未处理异常
将被临时保存，执行完<code>finally</code>子句后被重新引发</p>
</li>
<li><p>但若<code>finally</code>子句中执行<code>return</code>、<code>break</code>语句，则临时
保存异常被丢弃</p>
</li>
<li><p>若<code>finally</code>子句引发新的异常，临时保存异常作为新异常
上下文被串联</p>
</li>
</ul>
<blockquote>
<ul>
<li>显式异常串联参见<em>cs_python/py3ref/simple_stmt</em></li>
</ul>
</blockquote>
</li>
<li><p><code>try</code>子句中执行<code>return</code>、<code>break</code>、<code>continue</code>语句时，
<code>finally</code>子句在控制流离开try语句前被执行</p>
<ul>
<li><p>函数返回值由<strong>最后被执行</strong>的<code>return</code>语句决定，而
<code>finally</code>子句总是最后被执行</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def foo():</span><br><span class="line">	try:</span><br><span class="line">		return &quot;try&quot;</span><br><span class="line">	finally:</span><br><span class="line">		return &quot;finally&quot;</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">	# 返回&quot;finally&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="with"><a href="#with" class="headerlink" title="with"></a><code>with</code></h3><p><code>with</code>语句：包装上下文管理器定义方法中代码块的执行</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with_stmt ::=  <span class="string">&quot;with&quot;</span> with_item (<span class="string">&quot;,&quot;</span> with_item)* <span class="string">&quot;:&quot;</span> suite</span><br><span class="line">with_item ::=  expression [<span class="string">&quot;as&quot;</span> target]</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>with</code>句头中有多个项目，被视为多个<code>with</code>语句嵌套处理多个
上下文管理器</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">with A() as a, B() as b:</span><br><span class="line">	suite</span><br><span class="line">	# 等价于</span><br><span class="line">with A() as a:</span><br><span class="line">	wiht B() as b:</span><br><span class="line">		suite</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><ul>
<li>对表达式求值获得上下文管理器</li>
<li>载入上下文管理器<code>__exit__</code>以便后续使用</li>
<li>调用上下文管理器<code>__enter__</code>方法</li>
<li>若包含<code>as</code>子句，<code>__enter__</code>返回值将被赋值给其后目标<ul>
<li><code>with</code>语句保证若<code>__enter__</code>方法返回时未发生错误，
<code>__exit__</code>总会被执行</li>
<li>若在对目标列表赋值期间发生错误，视为在语句体内部发生
错误</li>
</ul>
</li>
<li>执行<code>with</code>语句体</li>
<li>调用上下文关管理器<code>__exit__</code>方法<ul>
<li>若语句体退出由异常导致<ul>
<li>其类型、值、回溯信息将被作为参数传递给<code>__exit__</code>
方法；否则提供三个<code>None</code>作为参数</li>
<li>若<code>__exit__</code>返回值为假，该异常被重新引发；否则
异常被抑制，继续执行<code>with</code>之后语句</li>
</ul>
</li>
<li>若语句体由于异常以外任何原因退出<ul>
<li><code>__exit__</code>返回值被忽略</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a><em>Function</em></h2><p>函数定义：对用户自定义函数的定义</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">funcdef                 ::=  [decorators] <span class="string">&quot;def&quot;</span> funcname <span class="string">&quot;(&quot;</span> [parameter_list] <span class="string">&quot;)&quot;</span></span><br><span class="line">                             [&quot;-&gt;&quot; expression] &quot;:&quot; suite</span><br><span class="line">decorators              ::=  decorator+</span><br><span class="line">decorator               ::=  <span class="string">&quot;@&quot;</span> dotted_name [<span class="string">&quot;(&quot;</span> [argument_list [<span class="string">&quot;,&quot;</span>]] <span class="string">&quot;)&quot;</span>] NEWLINE</span><br><span class="line">dotted_name             ::=  identifier (<span class="string">&quot;.&quot;</span> identifier)*</span><br><span class="line">parameter_list          ::=  defparameter (<span class="string">&quot;,&quot;</span> defparameter)* [<span class="string">&quot;,&quot;</span> [parameter_list_starargs]]</span><br><span class="line">                             | parameter_list_starargs</span><br><span class="line">parameter_list_starargs ::=  <span class="string">&quot;*&quot;</span> [parameter] (<span class="string">&quot;,&quot;</span> defparameter)* [<span class="string">&quot;,&quot;</span> [<span class="string">&quot;**&quot;</span> parameter [<span class="string">&quot;,&quot;</span>]]]</span><br><span class="line">                             | &quot;**&quot; parameter [&quot;,&quot;]</span><br><span class="line">parameter               ::=  identifier [<span class="string">&quot;:&quot;</span> expression]</span><br><span class="line">defparameter            ::=  parameter [<span class="string">&quot;=&quot;</span> expression]</span><br><span class="line">funcname                ::=  identifier</span><br></pre></td></tr></table></figure>
<ul>
<li><p>函数定义是可执行语句</p>
<ul>
<li>在当前局部命名空间中将函数名称绑定至函数对象（函数
可执行代码包装器）</li>
<li>函数对象包含对当前全局命名空间的引用以便调用时使用</li>
</ul>
</li>
<li><p>函数定义不执行函数体，仅函数被调用时才会被执行</p>
</li>
</ul>
<h3 id="Decorators"><a href="#Decorators" class="headerlink" title="Decorators"></a><em>Decorators</em></h3><p>装饰器：函数定义可以被一个、多个装饰器表达式包装</p>
<ul>
<li>函数被定义时将在包含该函数定义作用域中对装饰器表达式求值
，求值结果须为可调用对象</li>
<li>其将以该函数对象作为唯一参数被调用；返回值将被绑定至函数
名称</li>
<li>多个装饰器会以嵌套方式被应用</li>
</ul>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@f1(arg)</span><br><span class="line">@f2</span><br><span class="line">def func():</span><br><span class="line">	pass</span><br><span class="line">	# 大致等价，仅以上不会临时绑定函数对象至名称</span><br><span class="line">def func():</span><br><span class="line">	pass</span><br><span class="line">func = f1(arg)(f2(func))</span><br></pre></td></tr></table></figure>
<h3 id="Parameter-Types"><a href="#Parameter-Types" class="headerlink" title="Parameter Types"></a><em>Parameter Types</em></h3><p>形参类型</p>
<ul>
<li><p><em>POSITIONAL_OR_KEYWORD</em>：之前没有<em>VAR_POSITIONAL</em>类型的
参数</p>
<ul>
<li>可以通过<strong>位置</strong>、<strong>关键字</strong>传值</li>
</ul>
</li>
<li><p><em>KEYWORD_ONLY</em>：之前存在<em>VAR_POSITION</em>类型、或<code>*</code>的参数</p>
<ul>
<li>只能通过<strong>关键字</strong>传值</li>
</ul>
</li>
<li><p><em>VAR_POSITIONAL</em>：<code>*args</code>形式参数</p>
<ul>
<li>只能通过<strong>位置</strong>传值</li>
<li>隐式默认值为<code>()</code></li>
</ul>
</li>
<li><p><em>VAR_KEYWORD</em>：<code>**kwargs</code>形式参数</p>
<ul>
<li>只能通过关键字传值</li>
<li>隐式默认值为<code>&#123;&#125;</code></li>
</ul>
</li>
<li><p><em>POSITIONAL_ONLY</em>：只能通过位置传值的参数</p>
<ul>
<li>某些实现可能提供的函数包含没有名称的位置参数</li>
<li>唯一不能使用关键字传参参数类型</li>
</ul>
<blockquote>
<ul>
<li>CPython：C编写、<code>PyArg_ParseTuple()</code>解析参数的函数</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="Default-Parameters-Values"><a href="#Default-Parameters-Values" class="headerlink" title="Default Parameters Values"></a><em>Default Parameters Values</em></h3><p>默认参数值：具有<code>parameter = expression</code>形式的形参</p>
<ul>
<li><p>具有默认值的形参，对应<code>argument</code>可以在调用中可被省略</p>
</li>
<li><p>默认形参值将在执行函数定义时按从左至右的顺序被求值</p>
<ul>
<li>即函数定义时的预计算值将在每次调用时被使用</li>
<li>则被作为默认值的列表、字典等可变对象将被所有未指定该
参数调用共享，应该避免<ul>
<li>可以设置默认值为<code>None</code>，并在函数体中显式测试</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><em>POSITION_OR_KEYWORD</em>、有默认值形参必须位于无默认值者后
  ，即若形参具有默认值，后续所有在<code>*</code>前形参必须具有默认值</li>
<li><em>KEYWORD_ONLY</em>、有默认值形参可位于无默认值者前</li>
</ul>
</blockquote>
<h3 id="Annotations"><a href="#Annotations" class="headerlink" title="Annotations"></a><em>Annotations</em></h3><blockquote>
<ul>
<li>形参标注：<code>param:expression</code></li>
<li>函数返回标注：<code>-&gt; expression</code></li>
</ul>
</blockquote>
<ul>
<li>标注不会改变函数语义</li>
<li>标注可以是任何有效python表达式<ul>
<li>默认在执行函数定义时被求值</li>
<li>使用future表达式<code>from __future__ import annotations</code>
，则标注在运行时被保存为字符串以启用延迟求值特性</li>
</ul>
</li>
<li>标注默认存储在函数对象<code>__annotation__</code>属性字典中<ul>
<li>可以通过对应参数名称、<code>&quot;return&quot;</code>访问</li>
</ul>
</li>
</ul>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a><em>Class</em></h2><p>类定义：对类的定义</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">classdef    ::=  [decorators] <span class="string">&quot;class&quot;</span> classname [inheritance] <span class="string">&quot;:&quot;</span> suite</span><br><span class="line">inheritance ::=  <span class="string">&quot;(&quot;</span> [argument_list] <span class="string">&quot;)&quot;</span></span><br><span class="line">classname   ::=  identifier</span><br></pre></td></tr></table></figure>
<ul>
<li><p>类定义为可执行语句</p>
<ul>
<li>继承列表<code>inheritance</code>通常给出基类列表、元类</li>
<li>基类列表中每项都应当被求值为运行派生子类的类</li>
<li>没有继承类列表的类默认继承自基类<code>object</code></li>
</ul>
</li>
<li><p>类定义语句执行过程</p>
<ul>
<li>类体将在新的执行帧中被执行</li>
<li>使用新创建的局部命名空间和原有的全局命名空间</li>
<li>类体执行完毕之后<ul>
<li>丢弃执行帧</li>
<li>保留局部命名空间</li>
</ul>
</li>
<li>创建类对象<ul>
<li>给定继承列表作为基类</li>
<li>保留的局部命名空间作为属性字典<code>__dict__</code></li>
</ul>
</li>
<li>类名称将在原有的全局命名空间中绑定至该类对象</li>
</ul>
</li>
<li><p>类可以类似函数一样被装饰</p>
<ul>
<li>装饰器表达式求值规则同函数装饰器</li>
<li>结果被绑定至类名称</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>类中属性、方法参见<em>#todo</em></li>
<li>类属性可以作为实例属性的默认值，但注意使用可变类型值可能
  导致未预期结果</li>
</ul>
</blockquote>
<h2 id="Coroutine"><a href="#Coroutine" class="headerlink" title="Coroutine"></a><em>Coroutine</em></h2><p>协程函数</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">async_funcdef ::=  [decorators] <span class="string">&quot;async&quot;</span> <span class="string">&quot;def&quot;</span> funcname <span class="string">&quot;(&quot;</span> [parameter_list] <span class="string">&quot;)&quot;</span></span><br><span class="line">                   [&quot;-&gt;&quot; expression] &quot;:&quot; suite</span><br></pre></td></tr></table></figure>
<ul>
<li>协程函数可以在多个位置上挂起（保存局部状态）、恢复执行</li>
<li>协程函数体内部<ul>
<li><code>await</code>、<code>async</code>是保留关键字</li>
<li><code>await</code>表达式、<code>async for</code>、<code>async with</code>只能在协程
函数体内部使用</li>
<li>使用<code>yield from</code>表达式将<code>raise SyntaxError</code></li>
</ul>
</li>
</ul>
<h3 id="async-for语句"><a href="#async-for语句" class="headerlink" title="async for语句"></a><code>async for</code>语句</h3><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">async_for_stmt ::= <span class="string">&quot;async&quot;</span> for_stmt</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>async for</code>语句允许方便的对异步迭代器进行迭代</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">for</span> TARGET <span class="keyword">in</span> ITER:</span><br><span class="line">	...BLOCK1...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	...BLOCK2...</span><br></pre></td></tr></table></figure>
<p>在语义上等价于</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">iter</span> = (ITER)</span><br><span class="line"><span class="built_in">iter</span> = <span class="built_in">type</span>(<span class="built_in">iter</span>).__aiter__(<span class="built_in">iter</span>)</span><br><span class="line">running = <span class="literal">True</span></span><br><span class="line"><span class="keyword">while</span> running:</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		TARGET = <span class="keyword">await</span> <span class="built_in">type</span>(<span class="built_in">iter</span>).__anext__(<span class="built_in">iter</span>)</span><br><span class="line">	<span class="keyword">except</span> StopAsyncIteration:</span><br><span class="line">		running = <span class="literal">False</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		BLOCK1</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	BLOCK2</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="async-with语句"><a href="#async-with语句" class="headerlink" title="async with语句"></a><code>async with</code>语句</h3><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">async_with_stmt ::= <span class="string">&quot;async&quot;</span> with_stmt</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>async with</code>语句允许方便使用异步上下文管理器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> EXPR <span class="keyword">as</span> VAR:</span><br><span class="line">	BLOCK</span><br></pre></td></tr></table></figure>
<p>语义上等价于</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mgf = (EXPR)</span><br><span class="line">aexit = <span class="built_in">type</span>(mgr).__aexit__</span><br><span class="line">aenter = <span class="built_in">type</span>(mgr).__aenter__(mgr)</span><br><span class="line"></span><br><span class="line">VAR = <span class="keyword">await</span> aenter</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	BLOCK</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">await</span> aexit(mgr, *sys.exc_info()):</span><br><span class="line">		<span class="keyword">raise</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="keyword">await</span> aexit(mgr, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-05-11T01:58:31.000Z" title="5/11/2019, 9:58:31 AM">2019-05-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-02T08:16:31.000Z" title="8/2/2021, 4:16:31 PM">2021-08-02</time></span><span class="level-item"><a class="link-muted" href="/categories/CS/">CS</a><span> / </span><a class="link-muted" href="/categories/CS/Character/">Character</a></span><span class="level-item">25 minutes read (About 3746 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/CS/Character/char_encoding.html">编码问题</a></h1><div class="content"><h2 id="Abstract-Charater-Repertoire"><a href="#Abstract-Charater-Repertoire" class="headerlink" title="Abstract Charater Repertoire"></a><em>Abstract Charater Repertoire</em></h2><p>抽象字符集：<em>ACR</em></p>
<h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><p>字母、数字、标点、表意文字（汉字）、符号或其他文本形式的
“原子”</p>
<h3 id="抽象字符"><a href="#抽象字符" class="headerlink" title="抽象字符"></a>抽象字符</h3><p>抽象的字符，包括空白、不可打印的字符</p>
<ul>
<li><p>对于某些语言中，抽象字符应该还包括发音字符</p>
</li>
<li><p>如：印度语中单词“नमस्ते”</p>
<ul>
<li>有6个字符[‘न’, ‘म’, ‘स’, ‘्’, ‘त’, ‘े’]，</li>
<li>其中4、6两个字符在单词不出现，是发音字符</li>
</ul>
</li>
</ul>
<h3 id="Abstract-Charater-Repertoire-1"><a href="#Abstract-Charater-Repertoire-1" class="headerlink" title="Abstract Charater Repertoire"></a><em>Abstract Charater Repertoire</em></h3><p>抽象字符集：<em>ACR</em>，抽象字符的集合</p>
<ul>
<li>集合表明无序性</li>
<li>有时也简称为字符集（charater set）</li>
<li>有开放（字符不会改变）和封闭之分（会扩张）</li>
</ul>
<h2 id="Coded-Character-Set"><a href="#Coded-Character-Set" class="headerlink" title="Coded Character Set"></a><em>Coded Character Set</em></h2><p>编码字符集：CCS</p>
<h3 id="Code-Point"><a href="#Code-Point" class="headerlink" title="Code Point"></a><em>Code Point</em></h3><p>码位：抽象字符集中与字符关联的数字编号</p>
<ul>
<li>一般是非负整数</li>
<li>习惯上有16进制表示</li>
</ul>
<h3 id="Coded-Character-Set-1"><a href="#Coded-Character-Set-1" class="headerlink" title="Coded Character Set"></a><em>Coded Character Set</em></h3><p>编码字符集：<em>CCS</em>，每个所属字符都分配了码位的抽象字符集</p>
<ul>
<li>经常简称为字符集（<em>charater set</em>），同<em>ACR</em>弄混</li>
<li>字符与码位一一映射</li>
<li>可以更加方便的引用字符集中的某个元素</li>
<li>可以类比于dict</li>
</ul>
<h3 id="字符集（抽象、编码）举例"><a href="#字符集（抽象、编码）举例" class="headerlink" title="字符集（抽象、编码）举例"></a>字符集（抽象、编码）举例</h3><h4 id="US-ASCII"><a href="#US-ASCII" class="headerlink" title="US-ASCII"></a><em>US-ASCII</em></h4><p><em>ACSII</em>字符集</p>
<ul>
<li><p>128个抽象字符，封闭字符集</p>
</li>
<li><p>主要包括</p>
<ul>
<li>控制字符：回车、退格、换行</li>
<li>可显示字符：英文大小写、阿拉伯数字、西文符号</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>一般字符集都是兼容ascii编码字符集，即相同字符的码位相同</li>
</ul>
</blockquote>
<h4 id="ISO-8859-X"><a href="#ISO-8859-X" class="headerlink" title="ISO-8859-X"></a><em>ISO-8859-X</em></h4><p>扩展的ASCII字符集</p>
<ul>
<li>涵盖了大多数西欧语言字符、希腊语</li>
</ul>
<h4 id="GBXXXX"><a href="#GBXXXX" class="headerlink" title="GBXXXX"></a><em>GBXXXX</em></h4><p>国标系列字符集：每个标准包含的字符数量不同、对应的编码方案
也不不完全相同</p>
<ul>
<li><p><em>GB2312</em>：信息交换用汉字编码字符集基本集</p>
<ul>
<li>包含汉字覆盖99.75%的使用频率</li>
<li>人名、古汉语等罕用字不能处理</li>
</ul>
</li>
<li><p><em>GBK</em>：汉字内码扩展规范</p>
<ul>
<li>包括21003个汉字</li>
<li>支持国际标准<em>ISO/IEC10646-1</em>和国家标准<em>GB13000-1</em>中
全部中日韩汉字</li>
<li>包含了<em>BIG5</em>编码中的所有汉字</li>
<li>兼容<em>GB2312</em></li>
</ul>
</li>
<li><p><em>GB18030</em>：信息技术中文编码字符集</p>
<ul>
<li>其中收入汉字70000余个</li>
<li>以汉字为主并包含多种我国少数民族文字（如藏、蒙古、
傣、彝、朝鲜、维吾尔文等）的超大型中文编码字符集
强制性标准</li>
<li>兼容<em>GBK</em></li>
</ul>
</li>
</ul>
<h4 id="Big5"><a href="#Big5" class="headerlink" title="Big5"></a><em>Big5</em></h4><p><em>Big5</em>字符集：主要包含台湾、香港地区繁体字</p>
<h4 id="Universal-Character-Set-Unicode-UCS"><a href="#Universal-Character-Set-Unicode-UCS" class="headerlink" title="Universal Character Set/Unicode/UCS"></a><em>Universal Character Set</em>/<em>Unicode</em>/<em>UCS</em></h4><p>统一字符集/Unicode字符集：<em>ISO/IEC 10646</em>定义的编码字符</p>
<ul>
<li><p>开放字符集，码位无上限，容纳一切字符，包括emoji等</p>
</li>
<li><p><em>UCS</em>中码位不是连续分配的</p>
<ul>
<li><p>目前为止，分为<code>0x0000~0x10FFFF</code>共17个平面</p>
</li>
<li><p>其中0平面<code>0x0000~0xFFFF</code>称为
<em>basic multilingual plane</em></p>
</li>
<li><p><code>BMP</code>中码位只有16bit长度，能够节约大量存储空间，有
战略意义</p>
</li>
<li><p>因此“常用”语言的常用字符放在<code>BMP</code>，其他不常用的字符
只能放在其他平面</p>
</li>
</ul>
</li>
<li><p><em>unicode</em>本身是指一系列用于计算机表示所有语言字符的标准</p>
</li>
</ul>
<h2 id="Character-Encoding-Form"><a href="#Character-Encoding-Form" class="headerlink" title="Character Encoding Form"></a><em>Character Encoding Form</em></h2><p>字符编码表：<em>CEF</em>，将码位映射为码元序列</p>
<ul>
<li><p><em>fixed-length-encoding</em>：定长编码，对每个码位（字符）
赋予长度同为m的码元（位串）</p>
<ul>
<li><em>封闭字符集</em>符号有限，可以直接确定一一对应编码表</li>
</ul>
</li>
<li><p><em>variable-length-encoding</em>：变长编码，允许对不同码位
赋予不同长度的码元</p>
<ul>
<li><em>开放字符集</em>包括符号无上限，无法定长码元表示码位，
必须有某种方式将码位一一映射为码元序列</li>
<li><em>封闭字符集</em>出于节约成本考量，也可能使用变长编码
如：<em>Huffman</em>编码</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>码元：能用于处理或交换编码文本的最小比特组合（位串）</li>
</ul>
</blockquote>
<h3 id="Unicode定义的CEF"><a href="#Unicode定义的CEF" class="headerlink" title="Unicode定义的CEF"></a><em>Unicode</em>定义的CEF</h3><p>本质思想：预留标记位值使码元序列的长度实现变长</p>
<h4 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a><em>UTF-8</em></h4><ul>
<li>码元为1B</li>
<li>对<em>BMP</em>中字符一般需要<em>1~3B</em>，<em>BMP</em>外需要4B</li>
<li>兼容<em>ASCII</em>编码表（方案）<ul>
<li>不同于<strong>编码字符集兼容</strong>的意义，基本上编码字符集都
兼容<em>ASCII</em>编码字符集，即对应字符码位相同</li>
<li>兼容编码表指，“<em>ASCII</em>编码方案”可以使用<em>UTF-8</em>解码
方案直接解码</li>
</ul>
</li>
</ul>
<h4 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a><em>UTF-16</em></h4><ul>
<li>码元为2B</li>
<li>对<em>BMP</em>中字符一般需要2B，<em>BMP</em>外需要4B</li>
</ul>
<h4 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a><em>UTF-32</em></h4><ul>
<li>码元为4B</li>
</ul>
<h3 id="Prefix-Free-Code"><a href="#Prefix-Free-Code" class="headerlink" title="Prefix-Free Code"></a><em>Prefix-Free Code</em></h3><p>（自由）前缀码：所有代码码元都不是另一个字符码元的前缀</p>
<ul>
<li><p>可以简单扫描位串直到得到一组有效码元，转换为相应字符</p>
</li>
<li><p>这样编码表可以很容易用一棵（编码）二叉树表示</p>
<ul>
<li>树左向边标记为0、右向边标记为1</li>
<li>叶子节点表示字符，根节点到叶子节点路径为其码元</li>
<li>树中叶子节点到其他叶子节点的简单路径不存在，即码元
不可能为其他码元前缀</li>
<li>所以任何二叉树对应一套编码表</li>
</ul>
</li>
<li><p>这种编码方案一般用于产生<strong>平均长度最短</strong>的位串</p>
<ul>
<li>因此这类编码方案以bit为单位，而不是以byte为单位</li>
</ul>
</li>
</ul>
<h4 id="Huffman-Encoding"><a href="#Huffman-Encoding" class="headerlink" title="Huffman Encoding"></a><em>Huffman Encoding</em></h4><p>哈夫曼编码：<em>prefix-free code</em>的一种</p>
<ul>
<li><p>根据字符出现频率进行编码</p>
<ul>
<li>需要事先知道字符出现概率</li>
<li>可以事先扫描给定文本，对文本中字符出现字符计数</li>
<li>将较短位串分配给高频字符、较长位串分配给低频字符</li>
</ul>
</li>
<li><p>若字符独立出现，则哈夫曼编码是最优编码（最短长度编码）</p>
</li>
<li><p>需要把编码树信息包含在编码文本中才能正确解码</p>
</li>
</ul>
<blockquote>
<ul>
<li>构造哈夫曼树的贪婪算法参见组合问题</li>
</ul>
</blockquote>
<h4 id="Adaptive-Huffman-Encoding"><a href="#Adaptive-Huffman-Encoding" class="headerlink" title="Adaptive Huffman Encoding"></a><em>Adaptive Huffman Encoding</em></h4><p>利用已经处理字符串动态更新编码</p>
<h4 id="Lempel-ziv"><a href="#Lempel-ziv" class="headerlink" title="Lempel-ziv"></a><em>Lempel-ziv</em></h4><p>对字符串编码</p>
<h2 id="Character-Encoding-Schema"><a href="#Character-Encoding-Schema" class="headerlink" title="Character Encoding Schema"></a><em>Character Encoding Schema</em></h2><p>字符编码方案：<em>CES</em>，<strong>字符编码表+字节序列化方案</strong>，将码位
映射为<strong>字节流</strong></p>
<ul>
<li>大小端序问题：码元高位还是低位字节在前</li>
<li>字节序标记问题：不同程序之间端序交流</li>
</ul>
<blockquote>
<ul>
<li>通常所说编码、解码就是指使用<em>CES</em></li>
</ul>
</blockquote>
<h3 id="应用场合"><a href="#应用场合" class="headerlink" title="应用场合"></a>应用场合</h3><ul>
<li><p><em>CES</em>是真正的应用层面，需要给出具体<strong>存储方案实现</strong>，
前述都是理论上<strong>protocol</strong></p>
</li>
<li><p>所有字符串存储介质中，磁盘、<strong>内存</strong>都采用某种具体<em>CES</em>
实现存储</p>
<ul>
<li><p>Java、Python3这样的偏上层语言，字符串对象在内存中
通常采用<em>UTF-16</em></p>
</li>
<li><p>C这样偏底层语言，基本上按照源文件的编码确定，即将
源文件中对应字符串对应字节，但现在C/C++中还有一种
宽字符<em>w_char</em>类型</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>以上仅对<em>Unicode</em>而言，对于<em>ASCII</em>来说没有区分必要</li>
</ul>
</blockquote>
<h4 id="内存CSE说明"><a href="#内存CSE说明" class="headerlink" title="内存CSE说明"></a>内存CSE说明</h4><ul>
<li><p>内存中如果不使用某种<em>CES</em>实现，直接使用码元，一样会出现
长度问题，所以显然会使用某种<em>CES</em>方案</p>
</li>
<li><p>虽然在内存中，字符仍然使用某种编码方案得到字节流存储，但
这个字节流并不是这个字符，码位才“是”这个字符</p>
<ul>
<li><p>大部分提供Unicode处理语言会自动处理<strong>字符</strong>，不仅仅
是字节</p>
</li>
<li><p>在考虑字符串问题时，可以“抽象的”忽略具体存储方式，
认为存储的就是“码位”本身</p>
</li>
</ul>
</li>
</ul>
<h3 id="Byte-Order-Mark"><a href="#Byte-Order-Mark" class="headerlink" title="Byte Order Mark"></a><em>Byte Order Mark</em></h3><p>字节序标：<em>BOM</em>，放置于编码字节开始处的特殊字节序列，表明
序列大小端序</p>
<ul>
<li><code>0xFFFE</code>：小端序，低位在前</li>
<li><code>0xFEFF</code>：大端序，高位在前</li>
</ul>
<h3 id="Unicode族CES方案"><a href="#Unicode族CES方案" class="headerlink" title="Unicode族CES方案"></a><em>Unicode</em>族CES方案</h3><h4 id="UTF"><a href="#UTF" class="headerlink" title="UTF"></a><em>UTF</em></h4><p><em>unicode transfromation format</em>：历史上是指CES，而<em>UTF-X</em>
现在可以同时指代CES和CEF，<em>Unicode</em>族标准CEF方案</p>
<ul>
<li><p><em>UTF-8</em>：utf-8编码表码元为1B，不存在字节序问题</p>
<ul>
<li>指代CES和CEF没有什么区别，CEF只有一种</li>
</ul>
</li>
<li><p><em>UTF-16</em>：指代CES和CEF时有歧义，需要明确指明是
<em>UTF-16 encoding form</em>（码元序列）、
<em>UTF-16 encoding schema</em>（字节流）</p>
<ul>
<li><em>UTF-16-le</em>：utf-16编码表小端版本</li>
<li><em>UTF-16-be</em>：yutf-16编码表大端版本</li>
<li><em>UTF-16</em>：utf-16编码表带BOM版本，大小端均可</li>
</ul>
<blockquote>
<ul>
<li><em>UTF-16 CES</em>表示BMP（包含大部分常用字符）只需要2B，
 权衡了内存占用、处理便捷，适合作为内存中字符串的
 编码方案</li>
</ul>
</blockquote>
</li>
<li><p><em>UTF-32</em></p>
<ul>
<li><em>UTF-32le</em>：</li>
<li><em>UTF-32be</em></li>
<li><em>UTF-32</em></li>
</ul>
</li>
</ul>
<h4 id="UCS"><a href="#UCS" class="headerlink" title="UCS"></a><em>UCS</em></h4><p><em>Unicode</em>还有两种非标准CES</p>
<ul>
<li><em>UCS-2</em>：使用2B定长序列化码位<ul>
<li>可以视为<em>UTF-16</em>的子集</li>
<li>不支持<em>BMP</em>外的字符表示</li>
</ul>
</li>
<li><em>UCS-4</em>：使用4B定长序列化码位<ul>
<li>可以视为<em>UTF-32</em>的子集</li>
</ul>
</li>
</ul>
<h3 id="其他字符集CES方案"><a href="#其他字符集CES方案" class="headerlink" title="其他字符集CES方案"></a>其他字符集CES方案</h3><p>US-ASCII、GBK都有自己的编码方案，只是编码方案太简单，以至于
CCS、CEF、CES三层合一</p>
<ul>
<li>ASCII编码方案：1B的低7位表示一个字符</li>
<li>ISO-8895-1编码方案：1B表示一个字符</li>
<li>GB2312编码方案：2B表示一个汉字<ul>
<li>第一个字节：区字节，高位字节</li>
<li>第二个字节：位字节，低位字节</li>
</ul>
</li>
<li>GBK编码方案：2B表示一个汉字<ul>
<li>兼容GB2312方案</li>
<li>编码范围：<code>0x8140~0xFEFE</code>，剔除<code>0xxx7F</code></li>
</ul>
</li>
<li>GB18030编码方案：变长字节1B、2B、4B<ul>
<li>兼容GBK方案</li>
</ul>
</li>
<li>Big5编码方案：2B表示一个汉字<ul>
<li>字节顺序类似GB2312</li>
</ul>
</li>
</ul>
<h4 id="ANSI编码"><a href="#ANSI编码" class="headerlink" title="ANSI编码"></a><em>ANSI</em>编码</h4><ul>
<li><p>各个国家、地区独立制定、兼容ASCII编码，但彼此之间不兼容
的编码方案，微软<strong>统称为ANSI编码</strong></p>
</li>
<li><p>ANSI编码一般代表系统（仅win）默认编码方式，在不同系统中
指不同的编码方案</p>
<ul>
<li>英文操作系统：<em>ISO-8859-1</em></li>
<li>简体中文：<em>GBxxxx</em>编码</li>
<li>繁体中文：<em>Big5</em>编码</li>
<li>日文：<em>Shift JIS</em>编码</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>默认ANSI编码可以通过设置系统<code>Locale</code>更改<blockquote>
<ul>
<li>win下系统<code>Locale</code>决定代码页，用户<code>Locale</code>决定数字、
 数字、货币、时间与日期格式</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="Transfer-Encoding-Syntax"><a href="#Transfer-Encoding-Syntax" class="headerlink" title="Transfer Encoding Syntax"></a><em>Transfer Encoding Syntax</em></h2><p>传输编码语法：<em>TES</em>，有时候需要对字节流再次编码以进行传输</p>
<ul>
<li>如：某些字符不允许出现在传输流中</li>
</ul>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><ul>
<li><em>base64编码</em>：将字节流映射成64个安全字符集组成的字符流</li>
</ul>
<h2 id="输入、输出辨析"><a href="#输入、输出辨析" class="headerlink" title="输入、输出辨析"></a>输入、输出辨析</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>所有的输入都是经过CES编码的字节流（包括数字）</p>
<ul>
<li>文件输入流：文件编码方案决定</li>
<li>标准输入流（terminal）：terminal编码方案决定</li>
<li>管道传输流：由管道输入端的编码方案决定</li>
</ul>
<h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><p>这里应该有两种处理方式</p>
<ul>
<li><p>将输入视为<strong>字节流</strong>，不做任何处理，直接按字节存储在
内存中</p>
<ul>
<li>将输入字节流视为其自身编码方案字节流，直接储存</li>
</ul>
</li>
<li><p>将输入视为<strong>字符串</strong>，尝试解码</p>
<ul>
<li><p>若解码发现无法解释位串</p>
<ul>
<li><em>strict</em>：报错</li>
<li><em>replace</em>：将违规字符<strong>替换</strong>为有效字符<ul>
<li>替换为某种<code>?</code>：很多应用采用此方式，是乱码
发生的主要原因</li>
<li>有些也替换为Unicode码位</li>
</ul>
</li>
<li><em>ignore</em>：忽略该位串</li>
</ul>
</li>
<li><p>而解码后字符串的在内存中的存储，取决于解释器、编译器
、系统等处理主体的编码方案</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>以上只是对真正有字符串类型的语言Python、Java有这样区分</li>
<li>对于没有字符串类型的语言C并没有真正意义上的字符串，只有
  字节串，不涉及解码、自身字符串内存存储的问题，仅有换行符
  转义问题（若处理换行符被视为解码）</li>
</ul>
</blockquote>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>所有输出都是编码后字节流（包括数字）</p>
<ul>
<li>文件输出流：<code>write</code></li>
<li>标准输出流（terminal）：<code>print</code></li>
<li>管道传输流</li>
</ul>
<blockquote>
<ul>
<li>需要注意的是，输出的字节流编码方案和处理主体在内存中编码
  方案不一定相同，和编程实现、平台等因素都有关，比如很多
  默认输出编码方案为<em>utf-8</em></li>
<li>同样的，此输出流是对于其接收者而言仅仅是字节流，需要自行
  决定如何处理字节流</li>
<li>此输出是指传递给<strong>直接输出外部</strong>的输出，有些语言在输出前
  会隐式调用函数生成字符串</li>
</ul>
</blockquote>
<h3 id="其他常见问题"><a href="#其他常见问题" class="headerlink" title="其他常见问题"></a>其他常见问题</h3><h4 id="乱码"><a href="#乱码" class="headerlink" title="乱码"></a>乱码</h4><p>乱码主要有以下3种可能</p>
<ul>
<li>读取乱码：真正的乱码<ul>
<li>读取时没有正确解码，内容被替换，打印输出</li>
</ul>
</li>
<li>存储乱码：保存时已经是“乱码”，其实也不能算是乱码<ul>
<li>读取时没有正确解码，内存中内容已经被错误，保存后内容
保持错误</li>
<li>内存中数据正确，但保存使用的编码方案不支持某些字符，
内容被替换</li>
</ul>
</li>
<li>缺少字体库</li>
</ul>
<blockquote>
<ul>
<li>乱码不是其实已经是将不能打印的字符剔除、替换，能看到的
  乱码已经是程序认为“正确解码的字符串”</li>
</ul>
</blockquote>
<h4 id="换行符处理"><a href="#换行符处理" class="headerlink" title="换行符处理"></a>换行符处理</h4><ul>
<li><p>鉴于以下两种行为</p>
<ul>
<li>win下换行需要两个字符<code>\r\n</code>标识，linux下只需要<code>\n</code>
即可</li>
<li>编程语言往往类似Linux只需要<code>\n</code>即标识换行</li>
</ul>
<blockquote>
<ul>
<li>Vim中在内存中以<code>&lt;CR&gt;</code>标识换行</li>
</ul>
</blockquote>
</li>
<li><p>在win下很多语言以字符串模式：读取字节流时会自动将<code>\r\n</code>
替换为<code>\n</code>、写出字节流时替换回<code>\r\n</code></p>
<ul>
<li>Python这种原生支持字符串语言，这个特性可以看作字符串
解码的行为</li>
<li>C这种原生只支持字节串的语言，这个特性可能是二进制、
字符串读写的唯一区别</li>
</ul>
</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>以UTF-8编码方案为例</p>
<ul>
<li><p>输入的所有的内容都是由<em>UTF-8</em>编码方案编码的字节流</p>
</li>
<li><p>处理主体获取字节序列，根据指令处理字节序列</p>
<ul>
<li>比如字节序列编码和处理主体编码不同，将其<strong>解码</strong>为
<strong>主体编码方案</strong></li>
<li>比如按照<strong>约定</strong>将字节序列转变为不同类型的数据</li>
</ul>
</li>
<li><p>输出则是将需要输出的内容（包括数字等）转换字节流传给底层
函数</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-05-11T01:55:22.000Z" title="5/11/2019, 9:55:22 AM">2019-05-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-04T02:51:37.000Z" title="8/4/2021, 10:51:37 AM">2021-08-04</time></span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a><span> / </span><a class="link-muted" href="/categories/Linux/Tool/">Tool</a><span> / </span><a class="link-muted" href="/categories/Linux/Tool/Vi/">Vi</a></span><span class="level-item">3 minutes read (About 523 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Linux/Tool/Vi/builtins.html">Vim 内建函数、变量</a></h1><div class="content"><h2 id="文件、路径相关函数"><a href="#文件、路径相关函数" class="headerlink" title="文件、路径相关函数"></a>文件、路径相关函数</h2><ul>
<li><code>expand(option)</code>：根据参数返回当前文件相关信息</li>
<li><code>fnamemodify(file_name, option)</code>：返回当前文件夹下文件
信息</li>
<li><code>globpath(dir, type)</code>：返回的<code>dir</code>下符合<code>type</code>的文件
列表值字符串，使用<code>,</code>分隔，<code>type</code>为<code>**</code>时将递归的列出
文件夹及文件</li>
</ul>
<h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><p>command-line模式的特殊变量，在执行命令前会将其替换为相应的
变量</p>
<ul>
<li><code>&lt;cword&gt;</code>：光标处单词</li>
<li><code>&lt;cWORD&gt;</code>：光标处单词大写形式</li>
</ul>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><h3 id="寄存器相关快捷键、命令"><a href="#寄存器相关快捷键、命令" class="headerlink" title="寄存器相关快捷键、命令"></a>寄存器相关快捷键、命令</h3><ul>
<li><code>&lt;c-r&gt;&lt;reg&gt;</code>：insert模式下直接输入<code>&lt;reg&gt;</code>中的值</li>
</ul>
<h3 id="一般寄存器"><a href="#一般寄存器" class="headerlink" title="一般寄存器"></a>一般寄存器</h3><h3 id="Readonly-Register"><a href="#Readonly-Register" class="headerlink" title="Readonly Register"></a>Readonly Register</h3><h3 id="Expression-Register（-quot-）"><a href="#Expression-Register（-quot-）" class="headerlink" title="Expression Register（&quot;=）"></a>Expression Register（<code>&quot;=</code>）</h3><p><code>&quot;=</code>实际上并不是一个寄存器，这是使用命令表达式的一种方法，
按下<code>=</code>之后，光标会移动到命令行，此时可以输入任何表达式，
（不只有<code>&quot;=</code>才会激活命令行，<code>&lt;c-m&gt;&quot;</code>也能激活）
输入表达式之后</p>
<ul>
<li>按下<code>&lt;esc&gt;</code>，表达式值被丢弃</li>
<li>按下<code>&lt;cr&gt;</code>，表达式值计算后存入<code>&quot;=</code>中<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">nnoremap</span> time <span class="string">&quot;=strftime(&quot;</span>%<span class="keyword">c</span><span class="comment">&quot;)&lt;cr&gt;p</span></span><br><span class="line">:<span class="keyword">inoremap</span> time <span class="symbol">&lt;c-r&gt;</span><span class="built_in">strftime</span>(<span class="string">&quot;%c&quot;</span>)<span class="symbol">&lt;cr&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>之后<code>:put</code>或者按下<code>p</code>将粘贴<code>&quot;=</code>中的值</p>
<blockquote>
<p>   寄存器中的值一定是字符串，如果是其他类型变量，会被强制
    转换之后存入<code>&quot;=</code>寄存器中</p>
</blockquote>
<h2 id="Vim特殊"><a href="#Vim特殊" class="headerlink" title="Vim特殊"></a>Vim特殊</h2><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><ul>
<li><p><code>\0</code>：空转义序列（ASCII码位0）<code>&lt;Nul&gt;</code></p>
<ul>
<li><code>&lt;c-v&gt; 000</code>：输入<code>&lt;Nul&gt;</code></li>
<li>Vim在内存中使用<code>&lt;NL&gt;</code>存储<code>&lt;Nul&gt;</code>，在读、写文件时即
发生转换</li>
</ul>
<blockquote>
<ul>
<li>Vi无法处理<code>&lt;Nul&gt;</code>，应该是为了兼容Vi</li>
</ul>
</blockquote>
</li>
<li><p><code>\n</code>：换行转义序列<code>&lt;NL&gt;</code></p>
<ul>
<li><code>&lt;c-v&gt;&lt;c-j&gt;</code>：输入<code>&lt;NL&gt;</code>，会被替换为输入<code>&lt;Nul&gt;</code>，
等同于<code>&lt;c-v&gt; 000</code></li>
<li>在搜索表达式中：字面意义的<code>newline</code>序列被匹配</li>
<li>在替换表达式中：在内部被替换为<code>&lt;Nul&gt;</code>被输入，即
<strong>不再表示newline</strong></li>
</ul>
</li>
<li><p><code>\r</code>：回车转义序列<code>&lt;CR&gt;</code></p>
<ul>
<li>被Vim视为为换行，可在替换表达中表示<code>&lt;NL&gt;</code></li>
<li><code>&lt;c-v&gt;&lt;c-j&gt;</code>：输入<code>&lt;CR&gt;</code>字符本身</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>vim在内存换行应该同一使用<code>&lt;CR&gt;</code>，在读、写时，根据当前
  <code>fileformat</code>设置自动转换换行字符（序列）</li>
</ul>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-05-09T17:01:26.000Z" title="5/10/2019, 1:01:26 AM">2019-05-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-05-09T17:01:26.000Z" title="5/10/2019, 1:01:26 AM">2019-05-10</time></span><span class="level-item"><a class="link-muted" href="/categories/C-C/">C/C++</a><span> / </span><a class="link-muted" href="/categories/C-C/STL/">STL</a></span><span class="level-item">17 minutes read (About 2489 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/C-C/STL/io.html">IO</a></h1><div class="content"><ul>
<li><p>C++中数据输入/输出操作是通过I/O流库实现</p>
</li>
<li><p>流：数据之间的传输操作</p>
<ul>
<li>输出流：数据从内存中传送到某个载体、设备中</li>
<li>输入流：数据从某个载体、设备传送到内存缓冲区</li>
</ul>
</li>
<li><p>C++中流类型</p>
<ul>
<li>标准流I/O流：内存与标准输入、输出设备之间信息传递</li>
<li>文件I/O流：内存与外部文件之间信息传递</li>
<li>字符串I/O流：<strong>内存变量</strong>与表示字符串流的字符数组
之间信息传递</li>
</ul>
</li>
</ul>
<h2 id="lt-ios-gt"><a href="#lt-ios-gt" class="headerlink" title="&lt;ios&gt;"></a><code>&lt;ios&gt;</code></h2><h3 id="class-ios"><a href="#class-ios" class="headerlink" title="class ios"></a><code>class ios</code></h3><p><code>ios</code>：流基类</p>
<ul>
<li>所有流的父类</li>
<li>保存流状态、处理错误</li>
</ul>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li><p><code>.fail()</code>：判断流是否失效</p>
<ul>
<li>尝试超出文件的结尾读取数据时</li>
<li>输入流中字符串无法被正确解析</li>
</ul>
</li>
<li><p><code>.eof()</code>：判断流是否处于文件末尾</p>
<ul>
<li>基于C++流库语义，<code>.eof</code>方法只用在<code>.fail</code>调用之后，
用于判断错故障是否是由于到达文件结尾引起的</li>
</ul>
</li>
<li><p><code>.clear()</code>：重置与流相关状态位</p>
<ul>
<li>故障发生后，任何时候重新使用新流都必须调用此函数</li>
</ul>
</li>
<li><p><code>if(stream)</code>：判断流是否有效</p>
<ul>
<li>大部分情况下等同于<code>if(!stream.fial())</code></li>
</ul>
</li>
<li><p><code>.open(filename)</code>：尝试打开文件filename并附加到流中</p>
<ul>
<li>流方向由流类型决定：输入流对于输入打开、输出流对于
输出打开</li>
<li>可以调用<code>.fail</code>判断方法是否失败</li>
</ul>
</li>
<li><p><code>.close()</code>：关闭依附于流的文件</p>
</li>
</ul>
<h5 id="un-setf"><a href="#un-setf" class="headerlink" title=".[un]setf"></a><code>.[un]setf</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UKNOWN <span class="title">setf</span><span class="params">(setflag, unsetfield)</span></span>;</span><br><span class="line"><span class="function">UKNOWN <span class="title">unsetf</span><span class="params">(unsetflag)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途</p>
<ul>
<li><code>.setf</code>：设置某个流操纵符</li>
<li><code>.unsetf()</code>：取消某个流操纵符</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><code>setflag</code>：需要设置的操纵符</li>
<li><code>unsetflag</code>：取消设置的操纵符</li>
<li><code>unsetfield</code>：需要清空的格式设置位组合</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>不能像<code>&lt;&lt;</code>、<code>&gt;&gt;</code>中省略操纵符<code>ios::</code>前缀</li>
</ul>
</blockquote>
<h5 id="rdbuf"><a href="#rdbuf" class="headerlink" title=".rdbuf"></a><code>.rdbuf</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Elem</span>, <span class="keyword">class</span> <span class="title">Traits</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">basic_ios</span>:</span> <span class="keyword">public</span> ios_base&#123;</span><br><span class="line">	basic_streambuf &lt;_Elem, _Traits&gt; *_Mystrbuf,</span><br><span class="line"></span><br><span class="line">	<span class="function">_Mysb * <span class="title">rdbuf</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (_Mystrbuf);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">_Mysb * <span class="title">rdbuf</span><span class="params">(_Mysb * _Strbuf)</span></span>&#123;</span><br><span class="line">		_Mysb * _Oldstrbuf = _Mystrbuf;</span><br><span class="line">		_Mystrbuf = _Strbuf;</span><br><span class="line">		<span class="keyword">return</span> (_Oldstrbuf);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用途：获得输入、输出流对象中指向缓冲区类<code>streambuf</code>指针<ul>
<li><code>&gt;&gt;</code>、<code>&lt;&lt;</code>操作符对其有重载，可以方便读取、写入</li>
</ul>
</li>
</ul>
<h3 id="class-istream"><a href="#class-istream" class="headerlink" title="class istream"></a><code>class istream</code></h3><p><code>istream</code>：输入流基类</p>
<ul>
<li>将流缓冲区中数据作格式化、非格式化之间的转换</li>
<li>输入</li>
</ul>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul>
<li><code>.unget()</code>：复制流的内部指针，以便最后读取的字符能再次
被下个<code>get</code>函数读取</li>
</ul>
<h5 id="get"><a href="#get" class="headerlink" title=".get"></a><code>.get</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">int_type <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">basic_istream&amp; <span class="title">get</span><span class="params">(E&amp; c)</span></span>;</span><br><span class="line"><span class="function">basic_istream&amp; <span class="title">get</span><span class="params">(E *s, streamsize n)</span></span>;</span><br><span class="line"><span class="function">basic_istream&amp; <span class="title">get</span><span class="params">(E *s, streamsize n, E delim)</span></span>;</span><br><span class="line"><span class="function">basic_istream&amp; <span class="title">get</span><span class="params">(basic_stream&lt;E, T&gt; &amp;sb)</span></span>;</span><br><span class="line"><span class="function">basci_istream&amp; <span class="title">get</span><span class="params">(basci_stream&lt;E, T&gt; &amp;sb, E delim)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：从输入流中获取字符、字符串</p>
</li>
<li><p>参数</p>
<ul>
<li><code>delim</code>：分隔符，缺省<code>\n</code></li>
<li><code>n</code>：</li>
</ul>
</li>
</ul>
<h4 id="（友元）函数"><a href="#（友元）函数" class="headerlink" title="（友元）函数"></a>（友元）函数</h4><h5 id="getline"><a href="#getline" class="headerlink" title="getline"></a><code>getline</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class E, class T, class A&gt;</span></span><br><span class="line"><span class="function">basic_istream&lt;E, T&gt;&amp; <span class="title">getline</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	basic_istream&lt;E, T&gt;&amp; is,</span></span></span><br><span class="line"><span class="params"><span class="function">	basic_string&lt;E, T, A&gt;&amp; str,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class E, class T, class A&gt;</span></span><br><span class="line"><span class="function">basic_istream&lt;E, T&gt;&amp; <span class="title">getline</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	basic_istream&lt;E, T&gt;&amp; is,</span></span></span><br><span class="line"><span class="params"><span class="function">	basic_string&lt;E, T, A&gt;&amp; str,</span></span></span><br><span class="line"><span class="params"><span class="function">	E delim,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：从流<code>is</code>读取以<code>delim</code>为界，到字符串中</p>
<ul>
<li>保留开头空白字符、丢弃行尾分割符</li>
<li>读取字符直到分隔符，若首字符为分隔符则返回空字符串</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><code>delim</code>：分隔符，缺省为换行符<code>\n</code></li>
</ul>
</li>
</ul>
<h3 id="class-ostream"><a href="#class-ostream" class="headerlink" title="class ostream"></a><code>class ostream</code></h3><p><code>ostream</code>：输出流基类</p>
<ul>
<li>将流缓冲区中数据作格式化、非格式化之间的转换，输出</li>
</ul>
<h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><ul>
<li><code>.put(ch)</code>：将字符<code>ch</code>写入输出流</li>
</ul>
<h3 id="class-iostream"><a href="#class-iostream" class="headerlink" title="class iostream"></a><code>class iostream</code></h3><p><code>iosstream</code>：多目的输入、输出流基类</p>
<h3 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a><em>Operator</em></h3><h4 id="Insertion-Operator"><a href="#Insertion-Operator" class="headerlink" title="Insertion Operator"></a><em>Insertion Operator</em></h4><p><code>&lt;&lt;</code>：插入操作符，将数据插入流中</p>
<ul>
<li><p>左操作数是输出流</p>
</li>
<li><p>右操作数是需要插入流中的数据</p>
<ul>
<li><p>基本类型：<code>&lt;&lt;</code>会将其自动转换为字符串形式</p>
<ul>
<li>整形：默认10进制格式</li>
<li><code>[unsigned ]char</code>类型：总是插入单个字符</li>
</ul>
</li>
<li><p><code>streambuf</code>类型指针：插入缓冲区对象中所有字符</p>
</li>
</ul>
</li>
</ul>
<h4 id="Extraction-Operator"><a href="#Extraction-Operator" class="headerlink" title="Extraction Operator"></a><em>Extraction Operator</em></h4><p><code>&gt;&gt;</code>：提取操作符，从输入流中读取<strong>格式化数据</strong></p>
<ul>
<li><p>左操作数为输入流</p>
</li>
<li><p>右操作数存储从输入流中读取的数据</p>
<ul>
<li><p>缺省</p>
<ul>
<li><code>skipws</code>：忽略开头所有空白字符</li>
<li>空白字符分隔：读取字符直到遇到空白字符</li>
</ul>
</li>
<li><p><code>streambuf</code>类型指针：把输入流对象中所有字符写入该
缓冲区</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>几乎不提供任何支持检测用户输入是否有效的功能<blockquote>
<ul>
<li>数据格式由<strong>变量类型控制</strong></li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h3><h4 id="缓冲类型"><a href="#缓冲类型" class="headerlink" title="缓冲类型"></a>缓冲类型</h4><blockquote>
<ul>
<li>ISO C要求<blockquote>
<ul>
<li>当且仅当不涉及交互设备时，标准输入、输出全缓存</li>
<li>标准错误绝不是全缓存</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<ul>
<li><p>无缓冲：不缓冲字符</p>
<ul>
<li><p>适用情况：标准错误</p>
</li>
<li><p>标准库不缓冲不意味着系统、设备驱动不缓冲</p>
</li>
</ul>
</li>
<li><p>行缓冲：在输入、输出遇到换行符时才会执行I/O操作</p>
<ul>
<li>适用情况：涉及交互设备，如标准输入、输出</li>
</ul>
</li>
<li><p>全缓冲：I/O操作只会在缓冲区填满后才会进行</p>
<ul>
<li><p>适用情况：大部分情况，如驻留在磁盘的文件</p>
</li>
<li><p><em>flush</em>描述I/O缓冲写操作</p>
<ul>
<li>标准I/O函数自动<em>flush</em></li>
<li>手动调用对流调用死<code>fflush</code>函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>缓冲区一般是在第一次对流进行I/O操作时，由标准I/O函数调用
  <code>malloc</code>函数分配得到</li>
</ul>
</blockquote>
<h4 id="文件自定义缓冲区"><a href="#文件自定义缓冲区" class="headerlink" title="文件自定义缓冲区"></a>文件自定义缓冲区</h4><ul>
<li>文件必须已打开、未做任何操作</li>
</ul>
<h5 id="setbuf"><a href="#setbuf" class="headerlink" title="setbuf"></a><code>setbuf</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE * <span class="keyword">restrict</span> fp, <span class="keyword">char</span> * <span class="keyword">restrict</span> buf)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>用途：打开或关闭缓冲区<ul>
<li>打开：<code>buf</code>必须为大小为<code>BUFSIZ</code>的缓存<ul>
<li><code>BUFSIZ</code>：定义在<code>stdio.h</code>中，至少256</li>
</ul>
</li>
<li>关闭：将<code>buf</code>设置为<code>NULL</code></li>
</ul>
</li>
</ul>
<h5 id="setvbuf"><a href="#setvbuf" class="headerlink" title="setvbuf"></a><code>setvbuf</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE * <span class="keyword">restrict</span> fp, <span class="keyword">char</span> * <span class="keyword">restrict</span> buf,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>用途：设置缓冲区类型</li>
</ul>
<h4 id="流自定义缓冲区"><a href="#流自定义缓冲区" class="headerlink" title="流自定义缓冲区"></a>流自定义缓冲区</h4><h5 id="setbuf-1"><a href="#setbuf-1" class="headerlink" title="setbuf"></a><code>setbuf</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> basic_streambuf * <span class="title">setbuf</span><span class="params">(E *s, streamsize n)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Manipulator"><a href="#Manipulator" class="headerlink" title="Manipulator"></a><em>Manipulator</em></h2><p>（流）操纵符：控制格式化输出的一种特定类型值</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><blockquote>
<ul>
<li>短暂的：只影响下个插入流中的数据</li>
<li><p>持久的：直到被明确改变为止</p>
</li>
<li><p>双操纵符条目中，前者为默认</p>
</li>
<li><code>setw</code>、<code>setprecision</code>、<code>setfill</code>还需要包含<code>&lt;iomanip&gt;</code></li>
</ul>
</blockquote>
<h4 id="组合格式"><a href="#组合格式" class="headerlink" title="组合格式"></a>组合格式</h4><ul>
<li><code>adjustfield</code>：对齐格式位组合</li>
<li><code>basefield</code>：进制位组合</li>
<li><code>floatfield</code>：浮点表示方式位组合</li>
</ul>
<h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><ul>
<li><code>endl</code>：将行结束序列插入输出流，确保输出字符被写入目的流</li>
<li><code>setw(n)</code>：短暂的</li>
<li><code>setfill(ch)</code>：持久的，指定填充字符，缺省空格</li>
<li><code>left</code>：持久的，指定有效值靠左</li>
<li><code>right</code>：持久的，指定有效值靠右</li>
<li><code>internal</code>：持久的，指定填充字符位于符号、数值间</li>
</ul>
<h4 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h4><ul>
<li><code>showbase</code>：为整数添加表示其进制的前缀</li>
<li><code>fixed</code>：持久的，完整输出浮点数</li>
<li><code>scientific</code>：持久的，科学计数法输出浮点数</li>
<li><p><code>setprecision(digits)</code>：持久的，精度设置依赖于其他设置</p>
<ul>
<li><code>fixed</code>/<code>scientific</code>：指定小数点后数字位数</li>
<li>其他：有效数字位数</li>
</ul>
</li>
<li><p><code>hex</code>：持久的，16进制输出<strong>无符号整形</strong></p>
</li>
<li><code>oct</code>：持久的，8进制输出<strong>无符号整形</strong></li>
<li><p><code>dec</code>：持久的，10进制输出整形</p>
</li>
<li><p><code>noshowpoint</code>/<code>showpoint</code>：持久的，否/是强制要求包含
小数点</p>
</li>
<li><code>noshowpos</code>/<code>showpos</code>：持久的，要求正数前没有/有<code>+</code></li>
<li><code>nouppercase</code>/<code>uppercase</code>：持久的，控制作为数据转换部分
产生任意字符小/大写，如：科学计数法中的<code>e</code></li>
<li><code>noboolalpha</code>/<code>boolalpha</code>：持久的，控制布尔值以数字/
字符形式输出</li>
</ul>
<h4 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h4><ul>
<li><code>unitbuf</code>：插入、提取操作之后清空缓冲</li>
<li><code>stdio</code>：每次输出后清空stdout、stderr</li>
</ul>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><ul>
<li><code>skipws</code>/<code>noskipws</code>：持久的，读取之前是/否忽略空白字符</li>
<li><code>ws</code>：从<strong>输入流中读取空白字符</strong>，直到不属于空白字符为止</li>
</ul>
<h2 id="lt-iostream-gt"><a href="#lt-iostream-gt" class="headerlink" title="&lt;iostream&gt;"></a><code>&lt;iostream&gt;</code></h2><ul>
<li><p><code>ifstream_withassign</code>：标准输入流类</p>
<ul>
<li><code>cin</code>：标准文件stdin</li>
</ul>
</li>
<li><p><code>ofstream_withassign</code>：标准输出、错误、log流</p>
<ul>
<li><code>cout</code>：标准文件stdout</li>
<li><code>cerr</code>：标准文件stderr</li>
<li><code>clog</code>：标准文件stderr</li>
</ul>
</li>
</ul>
<h2 id="lt-fstream-gt"><a href="#lt-fstream-gt" class="headerlink" title="&lt;fstream&gt;"></a><code>&lt;fstream&gt;</code></h2><ul>
<li><p><code>ifstream</code>：文件输入流类</p>
<ul>
<li>默认操作：<code>ios::in</code></li>
</ul>
</li>
<li><p><code>ofstream</code>：文件输出流类</p>
<ul>
<li>默认操作：<code>ios::out|ios::trunc</code></li>
</ul>
</li>
<li><p><code>fstream</code>：文件流输入、输出类</p>
</li>
</ul>
<h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ifstream infile;</span><br><span class="line">	ofstream outfile;</span><br><span class="line">		<span class="comment">// 声明指向某个文件的流变量</span></span><br><span class="line"></span><br><span class="line">	infile.<span class="built_in">open</span>(filename)</span><br><span class="line">		<span class="comment">// 打开文件：在所声明变量和实际文件间建立关联</span></span><br><span class="line"></span><br><span class="line">	infile.<span class="built_in">close</span>()</span><br><span class="line">		<span class="comment">// 关闭文件：切断流与所关联对象之间联系</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="流操作复制文件"><a href="#流操作复制文件" class="headerlink" title="流操作复制文件"></a>流操作复制文件</h4><ul>
<li><p>逐字符复制</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="function">std::ifstream <span class="title">input</span><span class="params">(<span class="string">&quot;in&quot;</span>, ios::binary)</span></span>;</span><br><span class="line"><span class="function">std::ofstream <span class="title">output</span><span class="params">(<span class="string">&quot;out&quot;</span>, ios::binary)</span></span>;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">while</span>(input.<span class="built_in">get</span>(ch))&#123;</span><br><span class="line">	output &lt;&lt; ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>input &gt;&gt; ch</code>默认会跳过空白符，需要使用
<code>input.unsetf(ios::skipws)</code>取消</li>
</ul>
</li>
<li><p>逐行复制</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line">std::string line;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(input, line))&#123;</span><br><span class="line">	output &lt;&lt; line &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>若文件最后没有换行符，则复制文件会末尾多<code>\n</code></li>
</ul>
</li>
<li><p>迭代器复制</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">input.<span class="built_in">unsetf</span>(ios::skipws);</span><br><span class="line"><span class="built_in">copy</span>(<span class="built_in">istream_iterator</span>(input), <span class="built_in">istream_iterator</span>(),</span><br><span class="line">	<span class="built_in">ostream_iterator</span>(output, <span class="string">&quot;&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>缓冲区复制</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output &lt;&lt; input.<span class="built_in">rdbuf</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>丢失<code>\n</code></li>
</ul>
</li>
</ul>
<h4 id="标准输出文件内容"><a href="#标准输出文件内容" class="headerlink" title="标准输出文件内容"></a>标准输出文件内容</h4><ul>
<li><p><code>&lt;&lt;</code>操作符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">input</span><span class="params">(<span class="string">&quot;in&quot;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; input.<span class="built_in">rdbuf</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>.get</code>方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(input.<span class="built_in">get</span>(*cout.<span class="built_in">rdbuf</span>()).<span class="built_in">eof</span>())&#123;</span><br><span class="line">	<span class="comment">// 读取一行</span></span><br><span class="line">	<span class="keyword">if</span>(input.<span class="built_in">fail</span>())&#123;</span><br><span class="line">		<span class="comment">// `get`遇到空行无法提取字符，会设置失败标志</span></span><br><span class="line">		input.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="comment">// 清除错误标志</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">char</span></span>(input.<span class="built_in">get</span>());</span><br><span class="line">	<span class="comment">// 提取换行符，转换为`char`类型输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>.get</code>方法2</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input.<span class="built_in">get</span>(*cout.<span class="built_in">rdbuf</span>(), EOF);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="lt-sstream-gt"><a href="#lt-sstream-gt" class="headerlink" title="&lt;sstream&gt;"></a><code>&lt;sstream&gt;</code></h2><ul>
<li><p>基于C类型字符串<code>char *</code>编写</p>
<ul>
<li><code>istrstream</code>：串输入流类</li>
<li><code>ostrstream</code>：串输出流类</li>
<li><code>strstream</code>：串输入、输出流类</li>
</ul>
</li>
<li><p>基于<code>std::string</code>编写：推荐</p>
<ul>
<li><code>istringstream</code>：串输入流类</li>
<li><code>ostringstream</code>：串输出流类</li>
<li><code>stringstream</code>：串输入、输出流类</li>
</ul>
</li>
</ul>
<h3 id="例-1"><a href="#例-1" class="headerlink" title="例"></a>例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">string_to_integer</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">	<span class="function">instringstream <span class="title">istream</span><span class="params">(str)</span></span></span><br><span class="line"><span class="function">		<span class="comment">// 类似`ifstream`，使用流操作符从字符串中读取数据</span></span></span><br><span class="line"><span class="function">	<span class="keyword">int</span> value</span>;</span><br><span class="line"></span><br><span class="line">	istream &gt;&gt; value &gt;&gt; ws;</span><br><span class="line">		<span class="comment">// `&gt;&gt;`忽略流开头空白字符，`ws`读取尾部空白</span></span><br><span class="line">	<span class="keyword">if</span>(stream.fail() || !stream.eof())&#123;</span><br><span class="line">		<span class="comment">// 如果字符串不能作为整数解析，`.fail`返回`true`</span></span><br><span class="line">		<span class="comment">// `.eof`返回`false`，说明字符串包含其他字符</span></span><br><span class="line">		error(<span class="string">&quot;string to integer: illegal integer format&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">integer_to_string</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="built_in">ostringstream</span> ostream;</span><br><span class="line">	ostream &lt;&lt; n;</span><br><span class="line">	<span class="keyword">return</span> stream.str();</span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-05-09T17:01:26.000Z" title="5/10/2019, 1:01:26 AM">2019-05-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-05-09T17:01:26.000Z" title="5/10/2019, 1:01:26 AM">2019-05-10</time></span><span class="level-item"><a class="link-muted" href="/categories/Database/">Database</a><span> / </span><a class="link-muted" href="/categories/Database/SQL-DB/">SQL DB</a></span><span class="level-item">17 minutes read (About 2484 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Database/SQL-DB/psql.html">Postgre SQL笔记</a></h1><div class="content"><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li>交互式客户端：<code>postgresql</code></li>
<li>服务器：<code>postgres-server</code></li>
<li>额外功能：<code>postgresql-contrib</code></li>
<li>开发工具：<code>postgresql-devel</code></li>
</ul>
<h3 id="OpenSuSe"><a href="#OpenSuSe" class="headerlink" title="OpenSuSe"></a>OpenSuSe</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo zypper <span class="keyword">in</span> postgresql postgresql-server \</span></span><br><span class="line"><span class="bash">	postgresql-contrib postgresql-devel</span></span><br></pre></td></tr></table></figure>
<h3 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install postgresql postgresql-server \</span></span><br><span class="line"><span class="bash">	postgresql-contrib postgresql-devel</span></span><br></pre></td></tr></table></figure>
<h4 id="其他版本"><a href="#其他版本" class="headerlink" title="其他版本"></a>其他版本</h4><ul>
<li><p>从中选择合适版本下载：<a target="_blank" rel="noopener" href="https://yum.postgresql.org/repopackages.php">Postgres Yum repositories</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget https://download.postgresql.org/pub/repos/yum/9.6/redhat/rhel-7-x86_64/pgdg-centos96-9.6-3.noarch.rpm</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装下载的RPM（依赖EPEL repo）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install pgdg-centos96-9.6-3.noarch.rpm</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>更新Yum、安装指定PG版本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install postgresql96-sever postgresql96-contrib</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<ul>
<li>安装的PG带有版本后缀，初始化、启动时注意</li>
</ul>
</blockquote>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul>
<li><p>postgres安装完成后，默认创建Linux用户</p>
<ul>
<li>用户密码为空，要为其设置密码以切换到其<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo passwd postgres</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> su - postgres</span></span><br></pre></td></tr></table></figure></li>
<li>用户目录默认是<code>/var/lib/pgsql</code></li>
<li>很多命令可以切换到用户<code>postgres</code>直接执行</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>初始化数据库簇后，默认创建数据库角色<code>postgres</code>、数据库
  <code>postgres</code></li>
</ul>
</blockquote>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li><p>创建新PostgreSQL数据库簇</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo postgresql-setup initdb</span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> 或</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo inidb -D /var/lib/pgsql/data</span></span><br></pre></td></tr></table></figure>
<ul>
<li>默认数据库存储路径为<code>/var/lib/pgsql/data</code></li>
</ul>
</li>
<li><p>开启PG密码认证：修改<em>host-based authentication</em>设置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /var/lib/pgsql/data/pg_hba.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE		DATABASE	USER	ADDRESS			MEHTOD</span></span><br><span class="line">host		all			all		127.0.0.1/32	md5</span><br><span class="line">host		all			all		::1/128			md5</span><br></pre></td></tr></table></figure>
<ul>
<li>替换默认<code>ident</code>为<code>md5</code>开启密码认证</li>
<li>修改之后需要重启PG</li>
</ul>
</li>
<li><p>修改<code>postgres</code>用户密码，以可以通过密码作为<code>postgres</code>连接
数据库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> su - postgres</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> psql -d template1 -c <span class="string">&quot;ALTER USER postgres with password &#x27;&lt;passwd&gt;&#x27;&quot;</span></span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> 也可以在数据库prompt中执行</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="启动数据库"><a href="#启动数据库" class="headerlink" title="启动数据库"></a>启动数据库</h3><ul>
<li><p>作为服务：<code>start</code>、<code>enable</code>PG</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start postgresql</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> postgresql</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>作为普通程序启动：<code>pg_ctl</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> su - postgres</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pg_ctl start -D /var/lib/pgsql/data</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Roles"><a href="#Roles" class="headerlink" title="Roles"></a><em>Roles</em></h2><p>PG使用概念<em>roles</em>处理认证、权限问题</p>
<ul>
<li><p>角色相较于区分明显的用户、组概念更加灵活</p>
</li>
<li><p><code>create user</code>和<code>create role</code>几乎完全相同</p>
<ul>
<li><code>create user</code>：创建角色默认带<code>LOGIN</code>属性</li>
<li><code>create role</code>：创建角色默认不带<code>LOGIN</code>属性</li>
</ul>
</li>
</ul>
<h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><ul>
<li><code>SUPERUSER</code>/<code>NOSUPERUSER</code>：数据库超级用户</li>
<li><code>CREATEDB</code>/<code>NOCREATEDB</code>：创建数据库</li>
<li><code>CREATEUSER</code>/<code>NOCREATEUSER</code></li>
<li><code>CREATEROLE</code>/<code>NOCREATEROLE</code>：创建、删除普通用户角色</li>
<li><code>INHERIT</code>/<code>INHERIT</code>：角色可以继承所属用户组权限</li>
<li><code>LOGIN</code>/<code>NONLOGIN</code>：作连接数据库初始角色名</li>
<li><code>REPLICATION</code>/<code>NOREPLICATION</code>：流复制时用到</li>
<li><code>CONNECTION LIMIT connlimit</code></li>
<li>[<code>ENCRYPTED</code>/<code>UNENCRYPTED</code>]<code>PASSWORD &#39;&lt;passwd&gt;&#39;</code></li>
<li><code>VALID UNTIL &#39;&lt;timestamp&gt;&#39;</code></li>
<li><code>IN ROLE &lt;role_name&gt;[, ...]</code>：角色所属用户组</li>
<li><code>IN GROUP &lt;role_name&gt;[, ...]</code></li>
<li><code>ROLE &lt;role_name&gt;[, ...]</code></li>
<li><code>ADMIN &lt;role_name&gt;[, ...]</code></li>
<li><code>USER &lt;role_name&gt;[, ...]</code></li>
<li><code>SYSID uid</code></li>
</ul>
<h4 id="角色赋权"><a href="#角色赋权" class="headerlink" title="角色赋权"></a>角色赋权</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">psql&gt;</span><span class="bash"> create role/user &lt;name&gt; [[with] &lt;option&gt; [...]];</span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> 创建角色时直接赋权</span></span><br><span class="line"><span class="meta">psql&gt;</span><span class="bash"> alter role/user &lt;name&gt; [[with] &lt;option&gt; [...]];</span></span><br><span class="line"><span class="meta">psql&gt;</span><span class="bash"> grant connect on database &lt;db_name&gt; to &lt;name&gt;;</span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> 修改已创建角色权限</span></span><br></pre></td></tr></table></figure>
<h4 id="组赋权"><a href="#组赋权" class="headerlink" title="组赋权"></a>组赋权</h4><ul>
<li>把多个角色归为组，通过给组赋权、撤销权限实现权限管理</li>
<li>PG中角色赋权是通过<code>inherit</code>方式实现的</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">psql&gt;</span><span class="bash"> create role father login createdb createrole;</span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> 创建组角色、赋权</span></span><br><span class="line"><span class="meta">psql&gt;</span><span class="bash"> create role son1 inherit;</span></span><br><span class="line"><span class="meta">psql&gt;</span><span class="bash"> grant father to son1;</span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> 创建有`inherit`权限的用户、赋权</span></span><br><span class="line"><span class="meta">psql&gt;</span><span class="bash"> create role son2 inherit <span class="keyword">in</span> role father;</span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> 创建用户时直接赋组权</span></span><br></pre></td></tr></table></figure>
<h3 id="认证方式"><a href="#认证方式" class="headerlink" title="认证方式"></a>认证方式</h3><h4 id="Peer-Authentication"><a href="#Peer-Authentication" class="headerlink" title="Peer Authentication"></a>Peer Authentication</h4><p><code>peer</code>：从内核中获取操作系统中用户名，作为数据库角色名连接</p>
<ul>
<li>默认连接同名数据库</li>
<li>信任Linux用户身份（认证），不询问密码<ul>
<li>即使<code>-W</code>强制输入密码，也不会检查密码正确性</li>
</ul>
</li>
<li>只有<code>local</code>连接支持此方法</li>
</ul>
<h4 id="Trust-Authentication"><a href="#Trust-Authentication" class="headerlink" title="Trust Authentication"></a>Trust Authentication</h4><p><code>trust</code>：允许任何数据库角色名的连接</p>
<ul>
<li><p>信任任何连接、不询问密码</p>
<ul>
<li>只应该在操作系统层面上能提供足够保护下情况下使用<ul>
<li>文件系统权限：限制对Linux域套接字文件的访问</li>
</ul>
</li>
<li>适合单用户、本地连接</li>
</ul>
</li>
<li><p>数据库、用户权限限制仍然存在</p>
</li>
</ul>
<h4 id="Ident-Authentication"><a href="#Ident-Authentication" class="headerlink" title="Ident Authentication"></a>Ident Authentication</h4><p><code>ident</code>：从ident服务器中获取操作系统中用户名，用于连接数据库</p>
<ul>
<li><p>仅在<code>TCP/IP</code>连接情况下支持</p>
<ul>
<li>若被指定给<code>local</code>连接，将使用<code>peer</code>认证</li>
</ul>
</li>
<li><p>数据库服务器向客户端ident服务器询问“连接数据库的”用户，
据此判断连</p>
<ul>
<li>此流程依赖于客户端完整性，若客户端机器不可信，则
攻击者可以在113端口执行任何程序返回任何用户名</li>
<li>故此认证方法只适合封闭网络，所以客户端机器都被严格
控制</li>
<li>有些ident服务器开启非标准选项导致返回的加密用户名，
此选项应该关闭</li>
</ul>
<blockquote>
<ul>
<li>基本每个类Unix操作系统都带有ident服务器，用于监听
 113端口TCP</li>
</ul>
</blockquote>
</li>
</ul>
<h5 id="涉及配置"><a href="#涉及配置" class="headerlink" title="涉及配置"></a>涉及配置</h5><ul>
<li><code>map</code>：运行系统、数据库用户名之间映射</li>
</ul>
<h4 id="Password-Authentication"><a href="#Password-Authentication" class="headerlink" title="Password Authentication"></a>Password Authentication</h4><p>Password认证：基于密码的认证方式</p>
<blockquote>
<ul>
<li><code>password</code>：明文传输密码验证</li>
<li><code>md5</code>：MD5-hashed传输密码o</li>
</ul>
</blockquote>
<ul>
<li><p><code>md5</code>可以避免密码嗅探攻击</p>
</li>
<li><p><code>password</code>总应该尽量避免使用</p>
<ul>
<li>启用<code>db_user_namespace</code>特性时无法使用<code>md5</code></li>
<li>SSL加密连接下<code>password</code>也能安全使用</li>
</ul>
</li>
<li><p>每个数据库的密码存储在<code>pg_authid</code>系统表中</p>
<ul>
<li>若用户没有设置密码，则存储的密码为<code>null</code>，密码验证
也总是失败</li>
<li>使用<code>create user</code>、<code>alter role</code>等SQL语句修改密码</li>
</ul>
</li>
</ul>
<h4 id="GSSAPI-Authentication"><a href="#GSSAPI-Authentication" class="headerlink" title="GSSAPI Authentication"></a>GSSAPI Authentication</h4><p>GSSAPI：定义在<em>RFC 2743</em>中的安全认证产业界标准协议</p>
<ul>
<li>GSSAPI为支持其的系统自动提供认证<ul>
<li>认证本身是安全的，但是通过数据库连接的数据默认没有
加密，除非使用SSL</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>PG中GSSAPI需要编译时启用支持</li>
</ul>
</blockquote>
<h4 id="SSPI-Authentication"><a href="#SSPI-Authentication" class="headerlink" title="SSPI Authentication"></a>SSPI Authentication</h4><p><code>negotiate</code>：windows的安全认证技术</p>
<ul>
<li>PG将尽可能使用<em>Kerberos</em>，并自动回滚为<em>NTLM</em></li>
<li>仅服务器、客户端均在windows下或GSSAPI可用的情况下才能
工作</li>
</ul>
<blockquote>
<ul>
<li>使用Kerberos情况下，SSPI、GSSAPI工作方式相同</li>
</ul>
</blockquote>
<h5 id="涉及配置-1"><a href="#涉及配置-1" class="headerlink" title="涉及配置"></a>涉及配置</h5><ul>
<li><code>include_realm</code></li>
<li><code>map</code></li>
<li><code>krb_realm</code></li>
</ul>
<h4 id="Kerberos-Authentication"><a href="#Kerberos-Authentication" class="headerlink" title="Kerberos Authentication"></a>Kerberos Authentication</h4><p>Kerberos：适合公共网络上分布式计算的产业界标准安全认证系统</p>
<ul>
<li>Kerberos提供不加密的语句、数据安全认证，若需要加密则使用
SSL</li>
<li>PG支持Kerberos第5版，需要在build时开启Kerberos支持</li>
</ul>
<h5 id="涉及配置-2"><a href="#涉及配置-2" class="headerlink" title="涉及配置"></a>涉及配置</h5><ul>
<li><code>map</code></li>
<li><code>include_realm</code></li>
<li><code>krb_realm</code></li>
<li><code>krb_server_hostname</code></li>
</ul>
<h4 id="LDAP-Authentication"><a href="#LDAP-Authentication" class="headerlink" title="LDAP Authentication"></a>LDAP Authentication</h4><p>LDAP：类似<code>password</code>，只是使用<em>LDAP</em>作为密码认证方法</p>
<h5 id="涉及配置-3"><a href="#涉及配置-3" class="headerlink" title="涉及配置"></a>涉及配置</h5><ul>
<li><code>ldapserver</code></li>
<li><code>ldapport</code></li>
<li><code>ldaptls</code></li>
<li><code>ldapprefix</code></li>
<li><code>ldapsuffix</code></li>
<li><code>ldapbasedn</code></li>
<li><code>ldapbinddn</code></li>
<li><code>ldapbindpasswd</code></li>
<li><code>ldapsearchattribute</code></li>
</ul>
<h4 id="RADIUS-Authentication"><a href="#RADIUS-Authentication" class="headerlink" title="RADIUS Authentication"></a>RADIUS Authentication</h4><p>RADIUS：类似<code>password</code>，只是使用<em>RADIUS</em>作为密码认证方法</p>
<h5 id="涉及配置-4"><a href="#涉及配置-4" class="headerlink" title="涉及配置"></a>涉及配置</h5><ul>
<li><code>radiusserver</code></li>
<li><code>radiussecret</code></li>
<li><code>radiusport</code></li>
<li><code>radiusidentifier</code></li>
</ul>
<h4 id="Certificate-Authentication"><a href="#Certificate-Authentication" class="headerlink" title="Certificate Authentication"></a>Certificate Authentication</h4><p>Certificate：使用SSL客户多证书进行认证</p>
<ul>
<li>所以只在SSL连接中可用</li>
<li>服务器要求客户端提供有效证书，不会向客户端传递密码prompt<ul>
<li><code>cn</code>属性（<em>common name</em>）将回和目标数据库的用户名
比较</li>
<li>可通过名称映射允许<code>cn</code>属性和数据库用户名不同</li>
</ul>
</li>
</ul>
<h5 id="涉及配置-5"><a href="#涉及配置-5" class="headerlink" title="涉及配置"></a>涉及配置</h5><ul>
<li><code>map</code>：允许系统、数据库用户名之间映射</li>
</ul>
<h4 id="PAM-Authentication"><a href="#PAM-Authentication" class="headerlink" title="PAM Authentication"></a>PAM Authentication</h4><p>PAM：类似<code>password</code>，只是使用
<em>PAM(Pluggable Anthentication Modules)</em>作为密码认证机制</p>
<h5 id="涉及配置-6"><a href="#涉及配置-6" class="headerlink" title="涉及配置"></a>涉及配置</h5><ul>
<li><code>parmservice</code>：PAM服务名<ul>
<li>默认<code>postgresql</code></li>
</ul>
</li>
</ul>
<h2 id="pg-ctl"><a href="#pg-ctl" class="headerlink" title="pg_ctl"></a><code>pg_ctl</code></h2><p><code>pg_ctl</code>：用于控制PostgreSQL服务器的工具，此工具基本需要在
postgres用户下才能使用</p>
<ul>
<li>查看状态：<code>$ pg_ctl status -D /var/lib/pgsql/data</code></li>
</ul>
<h2 id="psql"><a href="#psql" class="headerlink" title="psql"></a><code>psql</code></h2><h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><h4 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> psql [-h &lt;host&gt;] [-p &lt;port&gt;] [-U &lt;user_name&gt;] [[-d] &lt;db_name&gt;]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>-h</code>：缺省为<code>local</code>类型连接本地数据库<blockquote>
<ul>
<li><code>local</code>、<code>host</code>连接类型对应不同认证方式</li>
<li><code>-h localhost</code>和缺省对应不同<code>hba.conf</code>条目</li>
</ul>
</blockquote>
</li>
<li><code>-p</code>：缺省端口<code>5432</code></li>
<li><code>-U/--user_name=</code>：缺省linux用户名</li>
<li><code>[-d]/--database=</code>：当前linux用户名</li>
<li><code>-W</code>：密码，<code>peer</code>、<code>trust</code>模式下无价值</li>
</ul>
</blockquote>
<h4 id="Shell命令"><a href="#Shell命令" class="headerlink" title="Shell命令"></a>Shell命令</h4><ul>
<li><p>postgres不仅仅提供psql交互环境作为shell命令，还提供可以
直接在shell中运行的数据库命令</p>
<ul>
<li>当然前提是当前linux登陆用户在数据库中存在、有权限</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ createdb &lt;db_name&gt; [-O &lt;user_name&gt;]</span><br><span class="line">	# 创建数据库，设置所有权为`user_name`</span><br><span class="line">$ dropdb &lt;db_name&gt;</span><br><span class="line">	# 删除数据库</span><br></pre></td></tr></table></figure>
<h3 id="元命令"><a href="#元命令" class="headerlink" title="元命令"></a>元命令</h3><p>元命令：反斜杠命令，<code>\</code>开头，由psql自己处理</p>
<ul>
<li><p><code>\</code>后：跟命令动词、参数，其间使用空白字符分割</p>
</li>
<li><p>冒号<code>:</code>：不在引号中的冒号开头的参数会被当作psql变量</p>
</li>
<li><p>反点号：参数内容被当作命令传给shell，
输出（除去换行符）作为参数值</p>
</li>
<li><p>单引号<code>&#39;</code>：参数包含空白时需用单引号包o，其中包含的参数
的内容会进行类C的替换</p>
<ul>
<li><code>\n</code>（换行）、<code>\digits</code>（八进制）</li>
<li>包含单引号需要使用反斜杠转义</li>
</ul>
</li>
<li><p>双引号<code>\”&lt;\code&gt;</p>
<ul>
<li>遵循SQL语法规则，双引号保护字符不被强制转换为
小写，且允许其中使用空白</li>
<li>双引号内的双引号使用双双引号<code>&quot;&quot;</code>转义</li>
</ul>
</li>
</ul>
<h4 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h4><ul>
<li><p><code>\?</code></p>
<ul>
<li><code>[&lt;commands&gt;]</code>：元命令帮助</li>
<li><code>&lt;options&gt;</code>：psql命令行选项帮助</li>
<li><code>&lt;variables&gt;</code>：特殊变量帮助</li>
</ul>
</li>
<li><p><code>\h [&lt;clauses&gt;]</code>：SQL命令语法帮助（<code>*</code>表示全部）</p>
</li>
</ul>
<h4 id="展示信息"><a href="#展示信息" class="headerlink" title="展示信息"></a>展示信息</h4><ul>
<li><code>\du</code>：查看用户权限</li>
<li><code>\c &lt;db_name&gt; &lt;name&gt;</code>：以身份<code>name</code>访问数据库<code>db_name</code></li>
<li><code>\l[ist]</code>：查看数据库</li>
<li><code>\dt</code>：展示当前数据库中表</li>
</ul>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul>
<li><code>\set foo bar</code>：设置变量<ul>
<li>可以像php设置“变量 变量”：<code>\set :foo bar</code></li>
</ul>
</li>
<li><code>\unset foo</code>：重置变量</li>
</ul>
<h2 id="数据库变量"><a href="#数据库变量" class="headerlink" title="数据库变量"></a>数据库变量</h2><h3 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h3><h4 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h4><p>特殊变量：一些选项设置，在运行时可通过改变变量的值、应用的
表现状态改变其，不推荐改变这些变量的用途</p>
<ul>
<li><code>AUTOCOMMIT</code>：缺省为<code>on</code>，每个SQL命令完成后自行提交，此时
需要输出<code>BEGIN</code>、<code>START TRANSACTION</code>命令推迟提交</li>
<li><code>DBNAMW</code>：当前所连接数据库</li>
<li><code>ENCODING</code>：客户端字符集编码</li>
</ul>
<blockquote>
<ul>
<li>详情查询手册</li>
</ul>
</blockquote>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><ul>
<li><p><code>PGDATA</code>：指定数据库簇（存放数据）目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">export</span> PGDATA=/var/lib/pgsql/data</span></span><br></pre></td></tr></table></figure>
<ul>
<li>默认<code>/var/lib/pgsql/data</code></li>
<li><code>-D</code>命令行参数指定</li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-05-09T17:01:26.000Z" title="5/10/2019, 1:01:26 AM">2019-05-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-07-16T09:41:11.000Z" title="7/16/2021, 5:41:11 PM">2021-07-16</time></span><span class="level-item"><a class="link-muted" href="/categories/Tool/">Tool</a><span> / </span><a class="link-muted" href="/categories/Tool/Markup-Language/">Markup Language</a></span><span class="level-item">a minute read (About 173 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Tool/Markup-Language/binary_format.html">二进制文件格式</a></h1><div class="content"><h2 id="IDX"><a href="#IDX" class="headerlink" title="IDX"></a><em>IDX</em></h2><p><em>IDX</em>：MNIST数据集独创的数据格式</p>
<ul>
<li><p>用于存储多维数组</p>
</li>
<li><p>后可以跟数字表示存储数组的维度</p>
<ul>
<li><em>idx1</em>：存储1维数组</li>
<li><em>idx3</em>：存储3维数组</li>
</ul>
</li>
</ul>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><ul>
<li><p>2bytes：格式版本号</p>
<ul>
<li>一直是<code>0x0000</code></li>
</ul>
</li>
<li><p>1bytes：数组中每个元素的数据类型</p>
<ul>
<li><code>0x08</code>：<code>unsigned byte</code></li>
<li><code>0x09</code>：<code>signed byte</code></li>
<li><code>0x0B</code>：<code>short</code>（2bytes）</li>
<li><code>0x0C</code>：<code>int</code>（4bytes）</li>
<li><code>0x0D</code>：<code>float</code>（4bytes）</li>
<li><code>0x0E</code>：<code>double</code>（8bytes）</li>
</ul>
</li>
<li><p>1bytes：数组维度<code>d</code></p>
</li>
<li><p><code>d</code> * 4bytes(int)：数组各维度长度</p>
</li>
<li><p>数据部分</p>
<ul>
<li>数据类型已知、长度已知</li>
<li>若元素格式符合文件头要求，表明解析正确，否则文件损坏</li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-05-09T17:01:26.000Z" title="5/10/2019, 1:01:26 AM">2019-05-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-02T09:37:53.000Z" title="8/2/2021, 5:37:53 PM">2021-08-02</time></span><span class="level-item"><a class="link-muted" href="/categories/C-C/">C/C++</a></span><span class="level-item">31 minutes read (About 4691 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/C-C/class.html">类</a></h1><div class="content"><h2 id="class"><a href="#class" class="headerlink" title="class"></a><em>class</em></h2><p>类：包含值、相应操作集的模板，将相关信息片段组织成复合值，
使得可以整体对其进行操作</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><ul>
<li><p><em>object</em>：对象，属于一个类的所有值</p>
</li>
<li><p><em>instance</em>：实例，单个对象</p>
</li>
<li><p><em>field</em>/<em>instance variable</em>：域/实例变量，类的分量</p>
</li>
<li><p><em>method</em>：应用于类实例的操作</p>
<ul>
<li>C++中方法的使用和传统函数类似，新名称只是为强调其同
所属的类紧密联系</li>
<li>传统函数称为<em>free function</em>，不被约束于特定类</li>
</ul>
</li>
</ul>
<h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4><ul>
<li><p><code>private</code>：私有，声明在<em>private section</em>中的域仅对该类
本身可见（默认）</p>
</li>
<li><p><code>public</code>：公有，声明在<em>public section</em>中的域对所有用户
可见</p>
<ul>
<li>现代面向对编程不鼓励在类中声明<em>public</em>实例变量</li>
</ul>
</li>
<li><p><code>protected</code>：受限，声明在<em>protected section</em>中的成员对
所有子类都可以访问，但用户不能访问</p>
</li>
</ul>
<h4 id="类-amp-结构体"><a href="#类-amp-结构体" class="headerlink" title="类&amp;结构体"></a>类&amp;结构体</h4><p>C++中：结构类型和类基本上以同样方式实现，类是<code>struct</code>的扩展</p>
<ul>
<li>结构体：默认访问权限是<code>public</code>，类默认为<code>private</code></li>
<li>类：允许高级继承、方法，成员默认<code>private</code></li>
<li>对一般成员变量，类和结构体在内存布局上完全一致，如：
顺序、内存布局</li>
</ul>
<h3 id="消息传递模型"><a href="#消息传递模型" class="headerlink" title="消息传递模型"></a>消息传递模型</h3><p>面向对象程序设计中，对象间通过信息发送、请求实现对象间通信，
将传递的这些信息称为消息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">receiver.<span class="built_in">name</span>(arguments)</span><br></pre></td></tr></table></figure>
<ul>
<li>对象间消息发通常理解为一个对象调用另一个对象的方法</li>
<li><em>sender</em>：发送方，初始化方法的对象</li>
<li><em>receiver</em>：接收方，消息的目标对象</li>
</ul>
<h3 id="接口实现分离"><a href="#接口实现分离" class="headerlink" title="接口实现分离"></a>接口实现分离</h3><ul>
<li><p>C++中类接口、实现相分离时，类自身定义仅存在与其<code>.h</code>文件</p>
</li>
<li><p>实现放在<code>.cpp</code>中作为独立方法定义，需要以类名作为限定符、
<code>::</code>作为分隔的方式表明自己所属的类</p>
</li>
</ul>
<h3 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">subclass</span>:</span> <span class="keyword">public</span> superclass&#123;</span><br><span class="line">	...code...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>子类<code>subclass</code>继承父类<code>superclass</code>所有<code>public</code>、
<code>protected</code>成员，<code>private</code>成员仍然保持私有特性</p>
</li>
<li><p>可以继承模板类</p>
<ul>
<li>子类甚至可以不包含任何代码，仅为简化类型名<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringMap</span>:</span> <span class="keyword">public</span> Map&lt;string, string&gt;&#123;&#125;</span><br><span class="line">	<span class="comment">// 创建不包含代码的子类，简化代码</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="子类局限"><a href="#子类局限" class="headerlink" title="子类局限"></a>子类局限</h4><p>子类对象是其所属父类的实例，但是有其局限</p>
<ul>
<li><p>将子类对象赋值给父类对象会导致子类特有实例变量值被丢弃
（因为父类对象在栈中空间较小）</p>
</li>
<li><p>常用解决方法是使用指针，指针变量大小相同</p>
<ul>
<li>但使用指针会使内存管理变得复杂</li>
<li>为类定义析构函数可以管理内存，但是指针越界时，不能
保证析构函数会在合适的时间调用</li>
</ul>
</li>
<li><p>最好方法是避免使用类继承，并创建独立的类管理自身堆内存，
否则</p>
<ul>
<li>完全禁止拷贝：定义私有拷贝构造函数、重载赋值操作符，
但这会使得对象难以嵌入大型数据结构</li>
<li>执行深拷贝：用户需要承担内存管理，重载拷贝构造函数、
重载赋值操作符</li>
</ul>
</li>
</ul>
<h4 id="Multiple-Inheritance"><a href="#Multiple-Inheritance" class="headerlink" title="Multiple Inheritance"></a><em>Multiple Inheritance</em></h4><p>多重继承：类可以继承自多个父类</p>
<ul>
<li>多重继承在实际编程过程中可能导致程序复杂、模糊不清<ul>
<li>多重继承的多个父类可能拥有多个相同方法名、数据域名</li>
</ul>
</li>
<li>C++中单继承已经足够复杂，最好避免使用多重继承</li>
</ul>
<h4 id="final"><a href="#final" class="headerlink" title="final"></a><code>final</code></h4><p><code>final</code>：指定<strong>虚函数</strong>不能被派生类覆盖、类不能被继承</p>
<ul>
<li><p>语法</p>
<ul>
<li>虚函数：在声明符之后</li>
<li>类：紧跟类名后</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> <span class="keyword">final</span>&#123;</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span>:</span> B&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="override"><a href="#override" class="headerlink" title="override"></a><code>override</code></h4><p><code>override</code>：指定派生类虚方法覆盖基类虚方法</p>
<ul>
<li><p>语法：在成员函数声明之后
（其他情况下<code>override</code>甚至不是关键字）</p>
</li>
<li><p>用途：有助于防止代码出现意外继承行为</p>
<ul>
<li>即不是强制性关键字，是<strong>辅助性、可选</strong></li>
<li>非虚函数可以通过类型转换调用基类方法，不算覆盖？？？</li>
</ul>
</li>
</ul>
<h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a><em>Iterator</em></h3><p>迭代器：指向集合中一个特定元素，每次可以通过单步递进方式访问
其他元素</p>
<ul>
<li>迭代器使用<code>*</code>操作查找其指向的值</li>
</ul>
<h4 id="迭代器层次结构"><a href="#迭代器层次结构" class="headerlink" title="迭代器层次结构"></a>迭代器层次结构</h4><p><img src="/imgs/iterator_hierarchy.png" alt="iterator_hierarchy"></p>
<ul>
<li><code>InputIterator</code>：允许读值</li>
<li><code>OutputIterator</code>：允许给解析的迭代器赋新值</li>
<li><code>ForwardItertor</code>：结合<code>InputIterator</code>、<code>OutputIterator</code>
，允许读写值</li>
<li><code>BidirectionIterator</code>：在<code>ForwardIterator</code>基础上允许向后
迭代，增加<code>--</code>操作符</li>
<li><code>RandomAccessIterator</code>：在<code>BidirectionIterator</code>基础上
允许向前、向后移动任意元素，包含全部关系符</li>
</ul>
<h4 id="指针作为迭代器"><a href="#指针作为迭代器" class="headerlink" title="指针作为迭代器"></a>指针作为迭代器</h4><ul>
<li><p>指针类型已经实现了<code>RandomAccesIterator</code>提供的所有操作符
，所以可以使用指针作为迭代器</p>
</li>
<li><p>很多实现已经将<code>iterator</code>作为类中嵌套迭代器的类型，要用
<code>typedef</code>重命名指针类型为<code>iterator</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> ValueType * iterator;</span><br></pre></td></tr></table></figure>
<ul>
<li>如：编译器内部利用迭代器，将基于范围<code>for</code>展开</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>编译器内部<code>iterator</code>类型指针变量参见
  <em>cppc/basics/intro</em></li>
</ul>
</blockquote>
<h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><h3 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a><em>Constructor</em></h3><p>构造函数：创建对象</p>
<ul>
<li><p>构造函数名与类名完全一样</p>
</li>
<li><p>构造函数无法被子类继承，只能在初始化列表中调用</p>
<ul>
<li>缺省编译器调用父类默认构造函数</li>
<li>若没有构造函数，则<strong>必须显式在初始化列表中初始化</strong></li>
</ul>
</li>
</ul>
<h4 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h4><ul>
<li><p><strong>初始化阶段</strong>：初始化列表</p>
<ul>
<li><p><strong>调用父类构造函数</strong>初始化父类成员变量</p>
<ul>
<li>缺省调用默认构造函数</li>
<li>若父类没有默认构造函数，必须在初始化列表中显式
调用构造函数</li>
</ul>
</li>
<li><p>初始化<strong>类自身</strong>数据域</p>
<ul>
<li>对一般类型，缺省类似于普通<strong>未赋值初始化</strong></li>
<li>对类类型成员变量，缺省没有显式初始化则调用默认
构造函数</li>
</ul>
</li>
</ul>
</li>
<li><p>计算阶段：执行构造函数体</p>
<ul>
<li>在函数体中执行的都是赋值，不是初始化</li>
</ul>
</li>
</ul>
<h4 id="Initializer-List"><a href="#Initializer-List" class="headerlink" title="Initializer List"></a><em>Initializer List</em></h4><p>初始化列表：初始化父类、自身数据域</p>
<ul>
<li>位于的构造函数体花括号前、参数列表之后，用<code>:</code>和参数列表
分隔</li>
</ul>
<h5 id="初始化父类"><a href="#初始化父类" class="headerlink" title="初始化父类"></a>初始化父类</h5><ul>
<li><p>父类名后用括号括起来的参数列表，参数列表必须和父类
某一构造函数原型相匹配</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Foo</span>(string name, <span class="keyword">int</span> id):(name, id)&#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>父类数据域后用括号括起的该数据域的初始化值（此方法
也可以用于初始化类自身数据域）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Foo</span>(string name, <span class="keyword">int</span> id): <span class="built_in">name</span>(name), <span class="built_in">id</span>(id)&#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用父类构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Derived</span>(string name, <span class="keyword">int</span> id):<span class="built_in">Base</span>(name, id)&#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="初始化自身数据域"><a href="#初始化自身数据域" class="headerlink" title="初始化自身数据域"></a>初始化自身数据域</h5><ul>
<li><p>类类型成员变量最好使用初始化列表初始化，可以避免
<strong>构造函数初始化阶段调用成员变量默认构造函数</strong></p>
</li>
<li><p>必须放在初始化列表中成员变量</p>
<ul>
<li>常量成员：常量只能初始化，不能赋值</li>
<li>引用类型：引用必须在定义时初始化，不能重新赋值</li>
<li>没有默认构造函数的类类型</li>
</ul>
</li>
<li><p>成员变量按照其在<strong>类中声明顺序</strong>初始化，而不是在初始化
列表中的顺序</p>
<ul>
<li>为避免因成员变量初始化依赖导致的未定义，应该按照成员
变量声明的顺序初始化</li>
</ul>
</li>
</ul>
<h4 id="Default-Constructor"><a href="#Default-Constructor" class="headerlink" title="Default Constructor"></a><em>Default Constructor</em></h4><p>默认构造函数：没有参数的构造函数</p>
<ul>
<li>若类没有默认构造函数，编译器会自行定义</li>
</ul>
<h4 id="Copy-Constructor"><a href="#Copy-Constructor" class="headerlink" title="Copy Constructor"></a><em>Copy Constructor</em></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Foo</span>(<span class="keyword">const</span> Foo &amp;f)&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>拷贝构造函数：使用同类实例初始化创建新对象</p>
<ul>
<li><p>用途</p>
<ul>
<li>复制对象</li>
<li><strong>传值调用</strong>时，隐式调用拷贝构造函数构造新对象传参</li>
</ul>
</li>
<li><p>类中没有定义拷贝构造函数时，编译器会自行定义一个</p>
<ul>
<li>若类中有指针变量、并有动态内存分配，则必须定义拷贝
构造函数</li>
</ul>
</li>
</ul>
<h4 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a><code>explicit</code></h4><p><code>epxplicit</code>关键字：声明为<code>explicit</code>构造函数不能在隐式转换中
使用</p>
<ul>
<li>用途<ul>
<li>希望函数参数只能是给定类型，可以禁止隐式类型转换</li>
</ul>
</li>
</ul>
<h3 id="Destructor"><a href="#Destructor" class="headerlink" title="Destructor"></a><em>Destructor</em></h3><p>析构函数：类的对象消亡时，析构函数被自动调用</p>
<ul>
<li>析构函数可以完成各种清理操作<ul>
<li>最重要：释放对象所创建的所有堆内存</li>
<li>关闭对象打开的任何文件</li>
</ul>
</li>
<li>析构函数名称：类名前加上<code>~</code></li>
<li>析构函数特点<ul>
<li>没有返回类型</li>
<li>不能重载</li>
<li>每个类只有一个无参的析构函数</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>良好设计的C++应用中，每个类都需要堆其对内存负责</li>
</ul>
</blockquote>
<h3 id="Operator-Overloading"><a href="#Operator-Overloading" class="headerlink" title="Operator Overloading"></a><em>Operator Overloading</em></h3><p>操作符重载：扩展标准操作符以适应新的数据类型</p>
<ul>
<li><p>编译器遇到操作符时，会根据操作符<strong>操作数</strong>的类型确定其
操作语义</p>
</li>
<li><p>重载操作符函数名由关键字<code>operator</code>后跟操作符构成</p>
<ul>
<li>操作符的左右操作数类型、传值方式</li>
<li>操作符返回值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, Point pt);</span><br><span class="line">	<span class="comment">// 流对象不能拷贝，必须引用传递</span></span><br><span class="line">	<span class="comment">// 返回依然是流引用</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>有些类型根本没有定义过某些操作符，虽然实际上是扩展该类型
操作符，但是也成为重载操作符</p>
</li>
</ul>
<blockquote>
<ul>
<li><em>overload</em>：重载，使用相同名字的不同版本类方法</li>
</ul>
</blockquote>
<h4 id="重载方式"><a href="#重载方式" class="headerlink" title="重载方式"></a>重载方式</h4><p>C++提供两种机制用以重载内置操作符使得可以适用于新定义类</p>
<ul>
<li><p>类方法：在<strong>类中用方法</strong>重载操作符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line">Class Point&#123;</span><br><span class="line">Public:</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>==(Point rhs);</span><br><span class="line">	<span class="comment">// 类中声明操作符重载方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .c</span></span><br><span class="line"><span class="keyword">bool</span> Point::<span class="keyword">operator</span>==(Point rhs)&#123;</span><br><span class="line">	<span class="comment">// 实现中限定为`Point`方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>左操作数为该类型对象（声明、实现省略）</li>
<li>右操作数作为形参传递</li>
<li>编译器把左操作数视为接收者，将右操作数作为形参传递</li>
</ul>
</li>
<li><p><em>free function</em>：<strong>在类外</strong>使用自由函数重载定义操作符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(Point pt1, Point pt2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// .c</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(Point pt1, Point pt2)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>二元操作符的两个操作数都作为形参传递</li>
<li>操作符重载自由函数一般需要声明为类的友元函数，使其
能够访问类的私有实例变量</li>
</ul>
</li>
</ul>
<h4 id=""><a href="#" class="headerlink" title="++/--"></a><code>++</code>/<code>--</code></h4><p>重载<code>++</code>/<code>--</code>时，必须指明是重载前缀还是后缀形式</p>
<ul>
<li>额外传入无意义整形参数说明重载后缀形式</li>
<li>常用于枚举类型，方便遍历枚举类型</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Direction <span class="keyword">operator</span>++(Direction &amp; dir)&#123;</span><br><span class="line">	<span class="comment">// 重载前缀形式</span></span><br><span class="line">	dir = <span class="built_in">Direction</span>(dir+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> dir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Direction <span class="keyword">operator</span>++(Direction &amp; dir, <span class="keyword">int</span>)&#123;</span><br><span class="line">	<span class="comment">// 重载后缀形式</span></span><br><span class="line">	<span class="comment">// 这也说明，C++中若不需要使用形参值，可以省略形参名，</span></span><br><span class="line">		<span class="comment">// 即使是在函数实现中</span></span><br><span class="line">	Direction old = dir;</span><br><span class="line">	dir = <span class="built_in">Direction</span>(dir + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="-1"><a href="#-1" class="headerlink" title="="></a><code>=</code></h4><ul>
<li><p>赋值操作符被定义为返回其左值，所以重载赋值操作符时注意
返回值</p>
</li>
<li><p>赋值操作符开头往往检查左、右操作数地址是否一样</p>
<ul>
<li>避免不必要拷贝操作、逻辑错误</li>
</ul>
</li>
</ul>
<h4 id="-2"><a href="#-2" class="headerlink" title="()"></a><code>()</code></h4><ul>
<li>重载<strong>函数调用操作符</strong><code>()</code>将可以像函数一样调用对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddFunction</span>&#123;</span></span><br><span class="line">Public:</span><br><span class="line">	<span class="built_in">AddFunction</span>(<span class="keyword">int</span> k)&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x+k;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>重载此方法类称为<em>function class</em>（函数类），其实例称为
  <em>function object/functor</em>（函数对象、函数子）</li>
</ul>
</blockquote>
<h3 id="const方法"><a href="#const方法" class="headerlink" title="const方法"></a><code>const</code>方法</h3><p>C++允许在<strong>方法参数表后</strong>增加关键字<strong>const</strong>指定方法，声明
其不改变其对象的状态</p>
<ul>
<li>在接口原型、实现中都应该使用<code>const</code>关键字约束</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CharStack::size</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Friend"><a href="#Friend" class="headerlink" title="Friend"></a><em>Friend</em></h3><p>友元：允许访问类中私有实例变量的元素（不是类方法）</p>
<ul>
<li><p>友元函数：允许访问类中私有变量的<strong>自由函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> prototype;</span><br><span class="line">	<span class="comment">// 在类定义中声明友元函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(Point p1, Point p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>友元类：允许访问类中私有实例变量的类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">cls_name</span>;</span></span><br><span class="line">	<span class="comment">// 在类中定义中声明友元类</span></span><br></pre></td></tr></table></figure>
<ul>
<li>友元类的声明不是双向的，需要两个类都显式声明另一个类
为友元类，才能相互对方私有变量</li>
</ul>
</li>
</ul>
<h3 id="典型方法"><a href="#典型方法" class="headerlink" title="典型方法"></a>典型方法</h3><ul>
<li><p><em>Accessor</em>/<em>Getter</em>：访问器/读取器：获取实例变量值的函数</p>
<ul>
<li>为方便，读取器的命名通常以<code>get</code>为前缀</li>
</ul>
</li>
<li><p><em>Mutator</em>/<em>Setter</em>：设值方法/设值器，为特定实例变量
设置值的方法</p>
<ul>
<li>为方便，设置器的命名通常以<code>set</code>为前缀</li>
<li>将实例变量设为私有就是为了阻止用户不受限制访问变量，
所以读取器的设置更为常见</li>
<li>事实上，<em>immutable</em>设计风格将类设置为完全不可变</li>
</ul>
</li>
</ul>
<h2 id="类内存结构"><a href="#类内存结构" class="headerlink" title="类内存结构"></a>类内存结构</h2><ul>
<li>类的方法地址不会存储在实例的内存空间中</li>
</ul>
<h3 id="非虚函数"><a href="#非虚函数" class="headerlink" title="非虚函数"></a>非虚函数</h3><ul>
<li><p>编译时</p>
<ul>
<li>编译器根据<strong>变量类型</strong>（指针、引用类型）在调用函数
处写入类方法的地址</li>
<li>编译时即确定执行的函数</li>
<li>可以认为是普通函数，只是默认包含参数<code>this</code>指针</li>
</ul>
</li>
<li><p>运行时</p>
<ul>
<li>访问方法相应内存地址，传入<code>this</code>指针调用方法</li>
</ul>
</li>
</ul>
<h3 id="Pure-Virtual-Method"><a href="#Pure-Virtual-Method" class="headerlink" title="(Pure)Virtual Method"></a><em>(Pure)Virtual Method</em></h3><blockquote>
<ul>
<li>虚方法/虚函数：<code>virtual</code>修饰的方法，基类中有定义</li>
<li>纯虚方法：没有函数体的虚函数，基类中无定义，实现只能由
  其子类提供</li>
</ul>
</blockquote>
<ul>
<li>派生类中覆盖方法总为虚方法，无论是否有<code>virtual</code>关键字<ul>
<li>建议后代虚函数加上<code>virtual</code>以提升可读性</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getpay</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// `virtual`：普通虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getPay</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// `=0`：纯虚函数，没有函数体</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>编译时</p>
<ul>
<li>编译器根据类的声明创建虚表，每个类维护<strong>一张虚表</strong></li>
<li>对象被构造时，虚表地址在<strong>实例内存的首个字</strong>中</li>
<li>编译器在调用函数处不直接写入函数地址（因为不确定
调用的函数）</li>
</ul>
</li>
<li><p>执行时</p>
<ul>
<li>从对象首读取虚表，在虚表中查询需要执行方法地址</li>
<li>访问相应方法地址，传入<code>this</code>指针调用方法</li>
<li>实现多态：<em>subtyping polymorphism</em>，同一语句具体调用
方法动态决定</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>多态：参见<em>program/program_design/language_design</em></li>
<li><em>vTable</em>：虚表，存储一个类中<strong>所有虚函数地址</strong><blockquote>
<ul>
<li>虚表是依次存储当<strong>前类中所有虚方法</strong>，不是继承序列
 中同一个虚方法</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="Abstract-Class"><a href="#Abstract-Class" class="headerlink" title="Abstract Class"></a><em>Abstract Class</em></h4><p>抽象类：包含<strong>纯虚方法</strong>的类</p>
<ul>
<li><p>抽象类主要作用</p>
<ul>
<li><p>将有关类组织在继承层次结构中</p>
</li>
<li><p>刻画一组子类的操作接口的通用语义，只描述派生类共同
操作接口，完整实现留给子类</p>
</li>
</ul>
</li>
<li><p>抽象类只能作为基类派生新类使用，不能创建抽象类对象</p>
<ul>
<li><p>所以抽象类也不能做参数类型、函数返回类型、显式转换
类型</p>
</li>
<li><p>可以定义指向抽象类的指针、引用，可以指向其派生类，
进而实现多态</p>
</li>
<li><p>此特性本身就是为了解决<strong>基类生成对象不合理</strong>的问题，
抽象类就是为了抽象设计目的而建立</p>
</li>
<li><p>实际中，为了<strong>强调</strong>类是抽象类，可以将类的构造函数
放在<code>protected</code>区域</p>
</li>
<li><p>其派生类必须实现基类中所有纯虚函数，才能成为非抽象类
，否则仍然是抽象类</p>
</li>
</ul>
</li>
<li><p>构造/析构函数内不能使用纯虚函数（一般成员方法内可以）</p>
<ul>
<li><p>因为派生类构造/析构函数内会调用基类构造/析构函数</p>
</li>
<li><p>纯虚函数没有函数体，不能被调用</p>
</li>
</ul>
</li>
</ul>
<h3 id="Override"><a href="#Override" class="headerlink" title="Override"></a><em>Override</em></h3><p>覆盖/重置：在派生类中签名一样的方法会覆盖父类的方法</p>
<ul>
<li><p>非虚方法：调用方法取决于指针、引用类型</p>
<ul>
<li>将派生类对象赋给基类指针、引用后，调用方法是基类方法
，表现父类的行为</li>
</ul>
</li>
<li><p>虚方法：动态检查，调用方法取决于对象实际类型</p>
<ul>
<li>将派生类对象赋给基类指针、引用后，调用方法是派生类
方法</li>
<li>即指针（引用）根据指向值决定行为，实现<strong>多态</strong></li>
</ul>
</li>
</ul>
<h2 id="Template"><a href="#Template" class="headerlink" title="Template"></a><em>Template</em></h2><p>模板：<em>parameterized class</em>参数化类，包含<em>base type</em>规格说明
的类</p>
<ul>
<li><p>模板是C++多态的一种实现</p>
</li>
<li><p>编译器遇到函数模板调用，会自动生成相应版本函数拷贝</p>
<ul>
<li>因此模板必须能<strong>实现</strong>，即不能将模板接口、实现分开，
否则编译器无法生成相应版本函数拷贝
（当然可以通过<code>#include</code>强行将接口、实现分开）</li>
<li>模板不能节省空间</li>
</ul>
</li>
</ul>
<h3 id="模板使用"><a href="#模板使用" class="headerlink" title="模板使用"></a>模板使用</h3><p>在函数、类前添加</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ValueType&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>template</code>关键字：表示此行后整个语法单位是模板模式一部分</li>
<li><code>ValueType</code>：类型占位符，生成函数拷贝时被替换为相应类型</li>
</ul>
</blockquote>
<h4 id="模板函数"><a href="#模板函数" class="headerlink" title="模板函数"></a>模板函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line"><span class="function">ValueType <span class="title">max</span><span class="params">(ValueType x, ValueType y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (x &gt; y) ? x: y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模板类"><a href="#模板类" class="headerlink" title="模板类"></a>模板类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">	T1 d1;</span><br><span class="line">	T2 d2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line">Stack&lt;ValueType&gt;::<span class="built_in">Stack</span>()&#123;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">// 模板实现、接口在同一文件中</span></span><br></pre></td></tr></table></figure>
<h3 id="Template-Specialization"><a href="#Template-Specialization" class="headerlink" title="Template Specialization"></a><em>Template Specialization</em></h3><p>模板特化：指定一个或多个有<strong>具体模板参数</strong>的模板</p>
<blockquote>
<ul>
<li>全特化：给出所有模板参数</li>
<li>偏特化：给出部分模板参数</li>
</ul>
</blockquote>
<ul>
<li><p>模板实例化时，优先使用模板参数最匹配的模板版本</p>
</li>
<li><p>通过特化模板，可以对特定模板参数集合<strong>自定义</strong>当前模板</p>
<ul>
<li>最好特化模板的接口和普通模板一致</li>
</ul>
</li>
</ul>
<h4 id="类模板特化"><a href="#类模板特化" class="headerlink" title="类模板特化"></a>类模板特化</h4><p>类模板可以全特化、偏特化</p>
<ul>
<li>特化的模板参数从模板参数列表中移除</li>
<li>在类名后给出完整参数列表</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;</span><span class="keyword">int</span>, T2&gt;&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数模板特化"><a href="#函数模板特化" class="headerlink" title="函数模板特化"></a>函数模板特化</h4><p>函数模板只能全特化</p>
<ul>
<li>若编译器可以通过返回值类型推断模板实参类型，可以省略
函数后模板参数列表，否则引起歧义报错</li>
<li>函数模板“偏特化”可以通过函数模板重载实现</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-05-01T01:58:40.000Z" title="5/1/2019, 9:58:40 AM">2019-05-01</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-04T03:18:28.000Z" title="8/4/2021, 11:18:28 AM">2021-08-04</time></span><span class="level-item"><a class="link-muted" href="/categories/Probability/">Probability</a></span><span class="level-item">4 minutes read (About 560 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Probability/distributions.html">常见分布</a></h1><div class="content"><h2 id="离散"><a href="#离散" class="headerlink" title="离散"></a>离散</h2><h2 id="连续"><a href="#连续" class="headerlink" title="连续"></a>连续</h2><h3 id="P-stable-Distributions"><a href="#P-stable-Distributions" class="headerlink" title="P-stable Distributions"></a><em>P-stable Distributions</em></h3><p><em>p_stable distribution</em>：随机变量 $\sum_i v_i X_i$ 、随机变量 $(\sum_i |v_i|^p)^{1/p} X$ 具有相同的分布</p>
<blockquote>
<ul>
<li>$v_1, v_2, \cdots, v_n$：任意实数</li>
<li>$X_1, X_2, \cdots, X_n$：独立同分布$D$随机变量</li>
<li>$X$：服从分布$D$随机变量</li>
</ul>
</blockquote>
<ul>
<li><p>$\forall p \in (0, 2]$，稳定分布存在，但仅$p=1,2$时，有解析解</p>
<ul>
<li><p>$p=1$：柯西分布</p>
<script type="math/tex; mode=display">
c(x) = \frac 1 \pi \frac 1 {1+x^2}</script></li>
<li><p>$p=2$：高斯分布</p>
<script type="math/tex; mode=display">
g(x) = \frac 1 {\sqrt {2\pi}} e^{-\frac {x^2} 2}</script></li>
</ul>
</li>
<li><p>可以从$[0,1]$上均匀分布获得稳定分布</p>
<ul>
<li>但是概率分布、密度函数没有解析解</li>
</ul>
</li>
</ul>
<h4 id="性质、用途"><a href="#性质、用途" class="headerlink" title="性质、用途"></a>性质、用途</h4><ul>
<li>若向量 $a$ 中每个元素独立从 <em>p-stable</em> 分布中抽取，则 $|v|_p X = (\sum_i |v_i|^p)^{1/p} X$ 和 $<a,v>$ 同分布<ul>
<li>可用较好计算的内积估计 $|v|_p$</li>
<li>考虑到 $a(v_1 - v_2) = av_1 - av_2$，将内积和点之间 $L_p$ 范数距离 $|v_1 - v_2|_p$ 相联系</li>
</ul>
</li>
</ul>
<h2 id="Exponential-Family-of-Distributions"><a href="#Exponential-Family-of-Distributions" class="headerlink" title="Exponential Family of Distributions"></a><em>Exponential Family of Distributions</em></h2><p>单变量指数分布概率密度/分布</p>
<script type="math/tex; mode=display">\begin{align*}
f_X(x|\theta) &= h(x) e^{\eta(\theta) T(x) - A(\theta)} \\
&= h(x) g(\theta) e^{\eta(\theta) T(x)} \\
&= e^{\eta(\theta) T(x) - A(\theta) + B(x)}
\end{align*}</script><blockquote>
<ul>
<li>$\eta(\theta)$：<em>nutural parameter</em>，自然参数</li>
<li>$h(x)$：<em>underlying measure</em>，底层观测值</li>
<li>$T(x)$：<em>sufficient statistic</em>，随机变量X的充分统计量</li>
<li>$A(\theta)$：<em>log normalizer</em>，对数规范化</li>
</ul>
</blockquote>
<ul>
<li><p>$\eta(\theta), T(x)$：可以是向量，其内积仍为实数</p>
</li>
<li><p>$\eta(\theta) = \theta$时，称分布族为<em>canonical</em>形式</p>
<ul>
<li>总是能够定义$\eta = \eta(\theta)$转为此形式</li>
</ul>
</li>
<li><p>对数规范化$A(\theta)$使得概率密度函数满足积分为1</p>
<script type="math/tex; mode=display">\begin{align*}
f(x|\theta) e^{A(\theta)} & = h(x) e^{\eta(\theta)T(x)} \\
\int e^{A(\theta)} f(x|\theta) dx & = \int h(x) e^{\eta(\theta) T(x)} dx \\
e^{A(\theta)} \int f(x|\theta) dx & = \int h(x) e^{\eta(\theta) T(x)} dx \\
A(\theta) & = ln \int h(x) e^{\eta(\theta) T(x)} dx
\end{align*}</script></li>
</ul>
<blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/148776108">https://zhuanlan.zhihu.com/p/148776108</a></li>
</ul>
</blockquote>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul>
<li>充分统计量$T(x)$可以使用固定几个值，从大量的独立同分布
数据中获取信息<h1 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h1></li>
</ul>
<h3 id="Bernoulli分布"><a href="#Bernoulli分布" class="headerlink" title="Bernoulli分布"></a><em>Bernoulli</em>分布</h3><ul>
<li>$h(x) = 1$</li>
<li>$T(x) = x$</li>
<li>$\eta = log \frac \theta {1 - \theta}$</li>
<li>$A(\theta) = ln(1+e^{\theta})$</li>
</ul>
<h3 id="Possion"><a href="#Possion" class="headerlink" title="Possion"></a><em>Possion</em></h3><ul>
<li>$\theta = \lambda$</li>
<li>$h(x) = \frac 1 {x!}$</li>
<li>$\eta(\theta) = ln\lambda$</li>
<li>$T(x) = x$</li>
<li>$A(\theta) = \lambda$</li>
</ul>
<h3 id="Normal"><a href="#Normal" class="headerlink" title="Normal"></a><em>Normal</em></h3><ul>
<li>$h(x) = \frac 1 {\sqrt{2\pi\sigma^2}} e^{-\frac {x^2} {2\sigma^2}}$</li>
<li>$T(x) = \frac x \sigma$</li>
<li>$A(\theta) = \frac {\mu^2} {2\sigma^2}$</li>
<li>$\eta(\theta) = \frac \mu \sigma$</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-05-01T01:58:40.000Z" title="5/1/2019, 9:58:40 AM">2019-05-01</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-05-01T01:58:40.000Z" title="5/1/2019, 9:58:40 AM">2019-05-01</time></span><span class="level-item"><a class="link-muted" href="/categories/CS/">CS</a><span> / </span><a class="link-muted" href="/categories/CS/Network/">Network</a></span><span class="level-item">a minute read (About 179 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/CS/Network/rfc.html">RFC</a></h1><div class="content"><h2 id="局域网协议"><a href="#局域网协议" class="headerlink" title="局域网协议"></a>局域网协议</h2><h3 id="Identification-Protocal"><a href="#Identification-Protocal" class="headerlink" title="Identification Protocal"></a><em>Identification Protocal</em></h3><p>Ident协议</p>
<ul>
<li><p>如果客户端支持Ident协议，可以在TCP端口113上监听ident请求</p>
<ul>
<li>基本每个类Unix操作系统都带有Ident协议</li>
</ul>
</li>
<li><p>Ident在组织内部可以很好工作，但是在公共网络不能很好工作</p>
<ul>
<li>很多PC客户端没有运行Ident识别协议守护进程</li>
<li>Ident协议会使HTTP事务处理产生严重时延</li>
<li>很多防火墙不允许Ident流量进入</li>
<li>Ident协议不安全，容易被伪造</li>
<li>Ident协议不支持虚拟IP地址</li>
<li>暴露客户端用户名涉及隐私问题</li>
</ul>
</li>
<li><p>Ident协议不应用作认证、访问控制协议</p>
</li>
</ul>
<h2 id="Internet协议"><a href="#Internet协议" class="headerlink" title="Internet协议"></a>Internet协议</h2></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-05-01T01:58:40.000Z" title="5/1/2019, 9:58:40 AM">2019-05-01</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-05-01T01:58:40.000Z" title="5/1/2019, 9:58:40 AM">2019-05-01</time></span><span class="level-item"><a class="link-muted" href="/categories/Tool/">Tool</a><span> / </span><a class="link-muted" href="/categories/Tool/Windows/">Windows</a></span><span class="level-item">a few seconds read (About 13 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Tool/Windows/msys.html">MSYS配置</a></h1><div class="content"><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><h3 id="Ctags"><a href="#Ctags" class="headerlink" title="Ctags"></a>Ctags</h3><ul>
<li><a target="_blank" rel="noopener" href="https://ctag.sourceforge.net">https://ctag.sourceforge.net</a>下载<em>ctag.exe</em></li>
<li>加入<code>/path/to/mingw64/bin</code></li>
</ul>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/25/">Previous</a></div><div class="pagination-next"><a href="/page/27/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/25/">25</a></li><li><a class="pagination-link is-current" href="/page/26/">26</a></li><li><a class="pagination-link" href="/page/27/">27</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/40/">40</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">36</span></span></a><ul><li><a class="level is-mobile" href="/categories/Algorithm/Data-Structure/"><span class="level-start"><span class="level-item">Data Structure</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Heuristic/"><span class="level-start"><span class="level-item">Heuristic</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Issue/"><span class="level-start"><span class="level-item">Issue</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Problem/"><span class="level-start"><span class="level-item">Problem</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Specification/"><span class="level-start"><span class="level-item">Specification</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/C-C/"><span class="level-start"><span class="level-item">C/C++</span></span><span class="level-end"><span class="level-item tag">34</span></span></a><ul><li><a class="level is-mobile" href="/categories/C-C/Cppref/"><span class="level-start"><span class="level-item">Cppref</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/Cstd/"><span class="level-start"><span class="level-item">Cstd</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/MPI/"><span class="level-start"><span class="level-item">MPI</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/STL/"><span class="level-start"><span class="level-item">STL</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/CS/"><span class="level-start"><span class="level-item">CS</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/CS/Character/"><span class="level-start"><span class="level-item">Character</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Parallel/"><span class="level-start"><span class="level-item">Parallel</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Program-Design/"><span class="level-start"><span class="level-item">Program Design</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Storage/"><span class="level-start"><span class="level-item">Storage</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Daily-Life/"><span class="level-start"><span class="level-item">Daily Life</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/Daily-Life/Maxism/"><span class="level-start"><span class="level-item">Maxism</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Database/"><span class="level-start"><span class="level-item">Database</span></span><span class="level-end"><span class="level-item tag">27</span></span></a><ul><li><a class="level is-mobile" href="/categories/Database/Hadoop/"><span class="level-start"><span class="level-item">Hadoop</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Database/SQL-DB/"><span class="level-start"><span class="level-item">SQL DB</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Database/Spark/"><span class="level-start"><span class="level-item">Spark</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/Scala/"><span class="level-start"><span class="level-item">Scala</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">42</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Bash-Programming/"><span class="level-start"><span class="level-item">Bash Programming</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Configuration/"><span class="level-start"><span class="level-item">Configuration</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/File-System/"><span class="level-start"><span class="level-item">File System</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/IPC/"><span class="level-start"><span class="level-item">IPC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Process-Schedual/"><span class="level-start"><span class="level-item">Process Schedual</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Shell/"><span class="level-start"><span class="level-item">Shell</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Tool/"><span class="level-start"><span class="level-item">Tool</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Tool/Vi/"><span class="level-start"><span class="level-item">Vi</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Model/"><span class="level-start"><span class="level-item">ML Model</span></span><span class="level-end"><span class="level-item tag">21</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Model/Linear-Model/"><span class="level-start"><span class="level-item">Linear Model</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Model-Component/"><span class="level-start"><span class="level-item">Model Component</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Nolinear-Model/"><span class="level-start"><span class="level-item">Nolinear Model</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Unsupervised-Model/"><span class="level-start"><span class="level-item">Unsupervised Model</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/"><span class="level-start"><span class="level-item">ML Specification</span></span><span class="level-end"><span class="level-item tag">17</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/Click-Through-Rate/"><span class="level-start"><span class="level-item">Click Through Rate</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/Click-Through-Rate/Recommandation-System/"><span class="level-start"><span class="level-item">Recommandation System</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/Computer-Vision/"><span class="level-start"><span class="level-item">Computer Vision</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Specification/FinTech/"><span class="level-start"><span class="level-item">FinTech</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/FinTech/Risk-Control/"><span class="level-start"><span class="level-item">Risk Control</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/Graph-Analysis/"><span class="level-start"><span class="level-item">Graph Analysis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Specification/NLP/"><span class="level-start"><span class="level-item">NLP</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Technique/"><span class="level-start"><span class="level-item">ML Technique</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Technique/Feature-Engineering/"><span class="level-start"><span class="level-item">Feature Engineering</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Technique/Neural-Network/"><span class="level-start"><span class="level-item">Neural Network</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Theory/"><span class="level-start"><span class="level-item">ML Theory</span></span><span class="level-end"><span class="level-item tag">11</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Theory/Loss/"><span class="level-start"><span class="level-item">Loss</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Theory/Model-Enhencement/"><span class="level-start"><span class="level-item">Model Enhencement</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Theory/Optimization/"><span class="level-start"><span class="level-item">Optimization</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Algebra/"><span class="level-start"><span class="level-item">Math Algebra</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Algebra/Linear-Algebra/"><span class="level-start"><span class="level-item">Linear Algebra</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Algebra/Universal-Algebra/"><span class="level-start"><span class="level-item">Universal Algebra</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Analysis/"><span class="level-start"><span class="level-item">Math Analysis</span></span><span class="level-end"><span class="level-item tag">23</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Analysis/Fourier-Analysis/"><span class="level-start"><span class="level-item">Fourier Analysis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Functional-Analysis/"><span class="level-start"><span class="level-item">Functional Analysis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Optimization/"><span class="level-start"><span class="level-item">Optimization</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Real-Analysis/"><span class="level-start"><span class="level-item">Real Analysis</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Mixin/"><span class="level-start"><span class="level-item">Math Mixin</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Mixin/Statistics/"><span class="level-start"><span class="level-item">Statistics</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Mixin/Time-Series/"><span class="level-start"><span class="level-item">Time Series</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Probability/"><span class="level-start"><span class="level-item">Probability</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">89</span></span></a><ul><li><a class="level is-mobile" href="/categories/Python/Cookbook/"><span class="level-start"><span class="level-item">Cookbook</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Jupyter/"><span class="level-start"><span class="level-item">Jupyter</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Keras/"><span class="level-start"><span class="level-item">Keras</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Matplotlib/"><span class="level-start"><span class="level-item">Matplotlib</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Numpy/"><span class="level-start"><span class="level-item">Numpy</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Pandas/"><span class="level-start"><span class="level-item">Pandas</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Py3Ref/"><span class="level-start"><span class="level-item">Py3Ref</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Py3std/"><span class="level-start"><span class="level-item">Py3std</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Pywin32/"><span class="level-start"><span class="level-item">Pywin32</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Readme/"><span class="level-start"><span class="level-item">Readme</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/TensorFlow/"><span class="level-start"><span class="level-item">TensorFlow</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Twists/"><span class="level-start"><span class="level-item">Twists</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/RLang/"><span class="level-start"><span class="level-item">RLang</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Rust/"><span class="level-start"><span class="level-item">Rust</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Set/"><span class="level-start"><span class="level-item">Set</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/"><span class="level-start"><span class="level-item">Tool</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/Tool/Editor/"><span class="level-start"><span class="level-item">Editor</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Markup-Language/"><span class="level-start"><span class="level-item">Markup Language</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Web-Browser/"><span class="level-start"><span class="level-item">Web Browser</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Windows/"><span class="level-start"><span class="level-item">Windows</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/Web/CSS/"><span class="level-start"><span class="level-item">CSS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/NPM/"><span class="level-start"><span class="level-item">NPM</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/Proxy/"><span class="level-start"><span class="level-item">Proxy</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/Thrift/"><span class="level-start"><span class="level-item">Thrift</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://octodex.github.com/images/hula_loop_octodex03.gif" alt="UBeaRLy"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">UBeaRLy</p><p class="is-size-6 is-block">Protector of Proxy</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">392</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">93</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">522</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/xyy15926" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/xyy15926"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-04T15:07:54.896Z">2021-08-04</time></p><p class="title"><a href="/uncategorized/README.html"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-03T07:46:51.000Z">2021-08-03</time></p><p class="title"><a href="/Web/NPM/hexo_config.html">Hexo 建站</a></p><p class="categories"><a href="/categories/Web/">Web</a> / <a href="/categories/Web/NPM/">NPM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-03T02:32:45.000Z">2021-08-03</time></p><p class="title"><a href="/Web/NPM/config.html">NPM 总述</a></p><p class="categories"><a href="/categories/Web/">Web</a> / <a href="/categories/Web/NPM/">NPM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-02T08:11:11.000Z">2021-08-02</time></p><p class="title"><a href="/Python/Py3std/internet_data.html">互联网数据</a></p><p class="categories"><a href="/categories/Python/">Python</a> / <a href="/categories/Python/Py3std/">Py3std</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-29T13:55:00.000Z">2021-07-29</time></p><p class="title"><a href="/Linux/Shell/sh_apps.html">Shell 应用程序</a></p><p class="categories"><a href="/categories/Linux/">Linux</a> / <a href="/categories/Linux/Shell/">Shell</a></p></div></article></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">Advertisement</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="pub-5385776267343559" data-ad-slot="6995841235" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="https://api.follow.it/subscription-form/WWxwMVBsOUtoNTdMSlJ4Z1lWVnRISERsd2t6ek9MeVpEUWs0YldlZGxUdXlKdDNmMEZVV1hWaFZFYWFSNmFKL25penZodWx3UzRiaVkxcnREWCtOYUJhZWhNbWpzaUdyc1hPangycUh5RTVjRXFnZnFGdVdSTzZvVzJBcTJHKzl8aXpDK1ROWWl4N080YkFEK3QvbEVWNEJuQjFqdWdxODZQcGNoM1NqbERXST0=/8" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="UBeaRLy" height="28"></a><p class="is-size-7"><span>&copy; 2021 UBeaRLy</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/xyy15926/proxy"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>