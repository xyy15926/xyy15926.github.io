<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>UBeaRLy</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="UBeaRLy&#039;s Proxy"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="UBeaRLy&#039;s Proxy"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="UBeaRLy"><meta property="og:url" content="https://xyy15926.github.io/"><meta property="og:site_name" content="UBeaRLy"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://xyy15926.github.io/img/og_image.png"><meta property="article:author" content="UBeaRLy"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xyy15926.github.io"},"headline":"UBeaRLy","image":["https://xyy15926.github.io/img/og_image.png"],"author":{"@type":"Person","name":"UBeaRLy"},"publisher":{"@type":"Organization","name":"UBeaRLy","logo":{"@type":"ImageObject","url":"https://xyy15926.github.io/img/logo.svg"}},"description":""}</script><link rel="alternate" href="/atom.xml" title="UBeaRLy" type="application/atom+xml"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/darcula.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><script data-ad-client="ca-pub-5385776267343559" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><meta name="follow_it-verification-code" content="SVBypAPPHxjjr7Y4hHfn"><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="UBeaRLy" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Visit on GitHub" href="https://github.com/xyy15926/proxy"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-25T17:49:38.000Z" title="4/26/2019, 1:49:38 AM">2019-04-26</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-07-23T04:27:50.000Z" title="7/23/2021, 12:27:50 PM">2021-07-23</time></span><span class="level-item"><a class="link-muted" href="/categories/CS/">CS</a><span> / </span><a class="link-muted" href="/categories/CS/Character/">Character</a></span><span class="level-item">12 minutes read (About 1853 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/CS/Character/escape_sequences.html">转义序列</a></h1><div class="content"><h2 id="C0、C1-控制字符集"><a href="#C0、C1-控制字符集" class="headerlink" title="C0、C1 控制字符集"></a><em>C0</em>、<em>C1</em> 控制字符集</h2><ul>
<li><p><em>C0</em>、<em>C1</em> 控制字符</p>
<ul>
<li><em>ISO/IEC 2022</em> 定义的控制字符集</li>
<li><em>Unicode</em> 中控制字符码位兼容 <em>ISO/IEC 2022</em>，但<ul>
<li>仅对 <em>U+001C - U+001F</em>、<em>U+0009 - U+000D</em>、<em>U+0085</em> 限定语义</li>
<li>其余控制字符语义对 <em>Unicode</em> 透明，留给高层协议</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/C0%E4%B8%8EC1%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6">https://zh.wikipedia.org/wiki/C0%E4%B8%8EC1%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6</a></li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="C0-控制字符集"><a href="#C0-控制字符集" class="headerlink" title="C0 控制字符集"></a><em>C0</em> 控制字符集</h3><ul>
<li><p><em>CO</em> 控制字符集码位范围：<code>0x00 - 0x1F</code></p>
<ul>
<li><em>ASCII</em> 中定义控制字符标准</li>
<li>码位限定在 1byte 可以表示，避免终端机需要实现状态机处理多字节控制序列</li>
<li>现只有少数控制字符被使用</li>
</ul>
</li>
<li><p><em>C0</em> 控制字符码位范围之外，还有定义有两个具备控制符特点的字符</p>
<ul>
<li><code>0x7F</code>（<em>delete</em>）</li>
<li><code>0x20</code>（<em>space</em>）</li>
</ul>
</li>
</ul>
<h3 id="C1-控制字符集"><a href="#C1-控制字符集" class="headerlink" title="C1 控制字符集"></a><em>C1</em> 控制字符集</h3><ul>
<li><p><em>C1</em> 控制字符集码位范围：<code>0x80 - 0x9F</code></p>
<ul>
<li>8bits <em>ISO/IEC 8859 ASCII</em> 扩展提出后<ul>
<li>考虑到可打印字符的最高比特位去掉之后不应变成控制字符</li>
<li>以 <em>C0</em> 控制字符集作为低位、最高位置 1，得到 <em>C1</em> 控制字符集</li>
</ul>
</li>
<li><em>C1</em> 码位在经常被私有编码方案（<em>Windows-1252</em>、<em>Mac Os Roman</em>）用于提供额外的可打印字符</li>
</ul>
</li>
<li><p><em>ISO/IEC 8859 ASCII</em> 扩展标准中指定</p>
<ul>
<li>为兼容 7bits 传输，所有 <em>C1</em> 控制字符使用 <code>ESC</code> 开头的 7bits 字符序列表示</li>
</ul>
</li>
</ul>
<h3 id="标准-C-转义规则"><a href="#标准-C-转义规则" class="headerlink" title="标准 C 转义规则"></a>标准 <em>C</em> 转义规则</h3><ul>
<li>非打印（包括控制）字符可以通过其 <em>ASCII</em> 码位 16 进制、8 进制表示<ul>
<li><code>\0[ooo]</code>：八进制数 <code>oo</code> 码位字符</li>
<li><code>\x[hh]</code>：十六进制数 <code>hh</code> 码位字符<ul>
<li><code>\x0a</code>：同 <code>\n</code></li>
</ul>
</li>
</ul>
</li>
<li>针对常用非打印字符，有如下简写方式<ul>
<li><code>\\</code>：反斜杠 <code>\</code></li>
<li><code>\&#39;</code>：单引号 <code>&#39;</code></li>
<li><code>\&quot;</code>：双引号 <code>&quot;</code></li>
<li><code>\a</code>：<code>BEL</code> <em>ASCII</em> 响铃</li>
<li><code>\b</code>：<code>BS</code> <em>ASCII</em>退格</li>
<li><code>\f</code>：<code>FF</code> <em>ASCII</em> 进纸</li>
<li><code>\n</code>：<code>LF</code>/<code>NL</code> <em>ASCII</em> 换行，开启新行</li>
<li><code>\r</code>：<code>CR</code> <em>ASCII</em> 回车，“指针移至行首”</li>
<li><code>\t</code>：<code>TAB</code> <em>ASCII</em> 制表符</li>
<li><code>\v</code>：<code>VT</code> 垂直制表符</li>
</ul>
</li>
</ul>
<h2 id="ANSI-Escape-Sequences"><a href="#ANSI-Escape-Sequences" class="headerlink" title="ANSI Escape Sequences"></a><em>ANSI Escape Sequences</em></h2><p><em>ANSI</em>：一种 <em>In-band Signaling</em> 的转义序列标准，用于控制终端上 <strong>光标位置、颜色、其他选项</strong></p>
<ul>
<li><p>在文本中嵌入的 <em>ANSI</em> 转义序列，终端会将 <em>ANSI</em> 转义序列解释为相应指令，而不是普通字符</p>
<ul>
<li><em>ANSI</em> 转义序列使用 <em>ASCII</em> 中字符传递所有信息</li>
</ul>
</li>
<li><p><em>ANSI</em> 转义序列有不同长度，但都</p>
<ul>
<li>以 <em>ASCII</em> 字符 <code>ESC</code>（<code>0x1b</code>） 开头<ul>
<li>8 进制表示：<code>\033</code></li>
<li>16 进制表示：<code>\x1b</code></li>
</ul>
</li>
<li>第二字节则是 <code>0x45 - 0x5F</code>（<em>ASCIIi</em> <code>@A-Z[\]^_</code>）范围内的字符</li>
</ul>
</li>
<li><p>标准规定，在 8bits 环境中</p>
<ul>
<li><em>ANSI</em> 转义序列前两个字节的序列可以合并为 <code>0x80 - 0x9F</code> 范围内的单个字节（即 <em>C1</em> 控制字符）</li>
<li>但在现代设备上，<em>C1</em> 控制字符码位被用于其他目的，一般不被使用<ul>
<li><em>UTF-8</em> 编码对 <code>x80</code> 字符本就需要 2bytes</li>
<li><em>Windows-1252</em> 编码将 <em>C1</em> 控制字符码位挪作他用</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><em>C0</em> 控制字符输出有时也会产生与 <em>ANSI</em> 转义序列相近效果，如：<code>LF</code>、<code>ESC E</code>都有换行效果</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ANSI%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97">https://zh.wikipedia.org/wiki/ANSI%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97</a></li>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/screen/manual/html_node/Control-Sequences.html">https://www.gnu.org/software/screen/manual/html_node/Control-Sequences.html</a></li>
</ul>
</blockquote>
<h3 id="No-CSI-非控制序列"><a href="#No-CSI-非控制序列" class="headerlink" title="No-CSI - 非控制序列"></a><em>No-CSI</em> - 非控制序列</h3><div class="table-container">
<table>
<thead>
<tr>
<th>序列（省略 <code>ESC</code>）</th>
<th>对应 <em>C1</em></th>
<th>名称</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>N</code></td>
<td><code>0x8E</code></td>
<td><em>SS2 - Single Shift 2</em></td>
<td>从替代 <em>G2</em> 字符集中选择字符</td>
</tr>
<tr>
<td><code>O</code></td>
<td><code>0x8F</code></td>
<td><em>SS3 - Single Shift 3</em></td>
<td>从替代 <em>G3</em> 字符集中选择字符</td>
</tr>
<tr>
<td><code>P</code></td>
<td><code>0x90</code></td>
<td><em>DCS - Device Control String</em></td>
<td>控制设备</td>
</tr>
<tr>
<td><code>D</code></td>
<td></td>
<td></td>
<td>仅换行，不重置光标至行首</td>
</tr>
<tr>
<td><code>E</code></td>
<td></td>
<td></td>
<td>换行并充值光标至行首，类似<code>LF</code></td>
</tr>
<tr>
<td><code>H</code></td>
<td></td>
<td></td>
<td>制表，类似<code>TAB</code></td>
</tr>
<tr>
<td><code>M</code></td>
<td></td>
<td></td>
<td>翻转换行，回到上一行</td>
</tr>
<tr>
<td><code>X</code></td>
<td><code>0x98</code></td>
<td><em>SOS - Start of String</em></td>
<td>引用由 <em>ST</em> 终止的一串文本参数</td>
</tr>
<tr>
<td><code>^</code></td>
<td><code>0x9E</code></td>
<td><em>PM - Privacy Message</em></td>
<td>引用由 <em>ST</em> 终止的以穿文本参数</td>
</tr>
<tr>
<td><code>_</code></td>
<td><code>0x9F</code></td>
<td><em>APC - Application Program Command</em></td>
<td>引用由 <em>ST</em> 终止的一串文本参数</td>
</tr>
<tr>
<td><code>c</code></td>
<td>-</td>
<td><em>RIS - Reset to Initial State</em></td>
<td>类似<code>clear</code>命令</td>
</tr>
<tr>
<td><code>[</code></td>
<td><code>0x9B</code></td>
<td><em>CSI - Control String Sequence</em></td>
<td>控制序列导入器，某些终端中也可以使用<code>0x9D</code></td>
</tr>
<tr>
<td><code>\</code></td>
<td><code>0x9C</code></td>
<td><em>ST - String Terminator</em></td>
<td>终止其他控件得字符串</td>
</tr>
<tr>
<td><code>]</code></td>
<td><code>0x9D</code></td>
<td><em>OCS - Operating System Command</em></td>
<td>启动操作系统使用的控制字符串</td>
</tr>
<tr>
<td><code>%G</code></td>
<td></td>
<td></td>
<td>选择 <em>UTF8</em> 作为字符集</td>
</tr>
<tr>
<td><code>#8</code></td>
<td></td>
<td></td>
<td><em>DEC</em> 屏幕校准测试，使用<code>E</code>填充整个终端</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Control-Sequence-Introducer"><a href="#Control-Sequence-Introducer" class="headerlink" title="Control Sequence Introducer"></a><em>Control Sequence Introducer</em></h3><p>控制序列导入器：<code>ESC[</code> + 若干参数字节 + 若干中间字节 + 一个最终字节</p>
<ul>
<li><p>常见序列只是把参数用作一系列分号分隔的数字，如：<code>1;2;3</code></p>
<ul>
<li>缺少的数字视为 0</li>
<li>某些序列（<em>CUU</em>）把 0 视为 1，以使缺少参数情况下有意义</li>
</ul>
</li>
<li><p>一部分字符定义“私有”，方便终端制造商插入私有序列</p>
<ul>
<li>参数字节 <code>&lt;=&gt;?</code> 的使用：<code>ESC[?25h</code>、<code>ESC[?251</code> 打开、关闭光标显示</li>
<li>最终字节 <code>0x70 - 0x7F</code></li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>组成部分</th>
<th>字符范围</th>
<th>ASCII字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>参数字节</td>
<td><code>0x30~0x3F</code></td>
<td><code>0-9:;&lt;=&gt;?</code></td>
</tr>
<tr>
<td>中间字节</td>
<td><code>0x20~0x2F</code></td>
<td><code>、!&quot;#$%&amp;&#39;()*+,-./</code></td>
</tr>
<tr>
<td>最终字节</td>
<td><code>0x40~0x7E</code></td>
<td><code>@A-Z[]^_a-z&#123;&#125;~</code>, `</td>
</tr>
</tbody>
</table>
</div>
<h4 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h4><div class="table-container">
<table>
<thead>
<tr>
<th>序列内容</th>
<th>名称</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[n]A</code>/<code>[n]B</code>/<code>[n]C</code>/<code>[n]D</code></td>
<td><em>CU[UDFB] - Cursor Up/Down/Forward/Back</em></td>
<td>光标移动<code>[n]</code>格，在屏幕边缘则无效</td>
</tr>
<tr>
<td><code>[n]E</code>/<code>[n]F</code></td>
<td><em>Cursor Next Line/Previous Line</em></td>
<td>光标移动至下<code>[n]</code>行/上<code>[n]</code>行开头</td>
</tr>
<tr>
<td><code>[n]G</code></td>
<td><em>Cursor Horizontal Absolute</em></td>
<td>光标移动到第<code>[n]</code>列</td>
</tr>
<tr>
<td><code>[n;m]H</code></td>
<td><em>CUP - Cursor Position</em></td>
<td>光标绝对位置</td>
</tr>
<tr>
<td><code>[n;m]f</code></td>
<td><em>Horizontal Vertical Position</em></td>
<td>同 <em>CUP</em></td>
</tr>
<tr>
<td><code>[n]J</code></td>
<td><em>Erase in Display</em></td>
<td>清除屏幕部分区域：0 - 光标至末尾；1 - 开头至光标；2 - 整个屏幕</td>
</tr>
<tr>
<td><code>[n]K</code></td>
<td><em>Erase in Line</em></td>
<td>清除行内部分区域</td>
</tr>
<tr>
<td><code>[n]S</code></td>
<td><em>Scroll Up</em></td>
<td>整页向上滚动 <code>[n]</code> 行</td>
</tr>
<tr>
<td><code>[n]T</code></td>
<td><em>Scroll Down</em></td>
<td>整页向下滚动 <code>[n]</code> 行</td>
</tr>
<tr>
<td><code>s</code></td>
<td><em>Save Cursor Position</em></td>
<td>保存光标当前位置</td>
</tr>
<tr>
<td><code>u</code></td>
<td><em>Restore Cursor Position</em></td>
<td>恢复光标位置</td>
</tr>
</tbody>
</table>
</div>
<h4 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h4><div class="table-container">
<table>
<thead>
<tr>
<th>序列内容</th>
<th>名称</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>5i</code></td>
<td>-</td>
<td>打开辅助端口，通常用于本地串行打印机</td>
</tr>
<tr>
<td><code>4i</code></td>
<td>-</td>
<td>关闭辅助端口，通常用于本地串行打印机</td>
</tr>
<tr>
<td><code>6n</code></td>
<td><em>Device Status Report</em></td>
<td>以 <code>ESC[n;m]R</code> 报告光标位置</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Select-Graphic-Rendition"><a href="#Select-Graphic-Rendition" class="headerlink" title="Select Graphic Rendition"></a><em>Select Graphic Rendition</em></h4><ul>
<li><em>SGR</em> 选择图形再现：<code>ESC[[n]m</code><ul>
<li><code>[n]</code>：多个参数用 <code>;</code> 分隔，缺省为 0</li>
<li><code>m</code>：结束字节</li>
</ul>
</li>
</ul>
<h5 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h5><div class="table-container">
<table>
<thead>
<tr>
<th>设置值</th>
<th>显示效果</th>
<th>取消值</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>所有属性值重置为默认值，用于取消对后续输出影响</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>高亮或粗体</td>
<td>22</td>
</tr>
<tr>
<td>2</td>
<td>半亮</td>
<td>22</td>
</tr>
<tr>
<td>4</td>
<td>下划线</td>
<td>24</td>
</tr>
<tr>
<td>5</td>
<td>闪烁</td>
<td>25</td>
</tr>
<tr>
<td>7</td>
<td>反显，前景、背景色交换</td>
<td>27</td>
</tr>
<tr>
<td>8</td>
<td>隐藏，前景、背景色相同，可能不支持</td>
<td>28</td>
</tr>
<tr>
<td>9</td>
<td>删除线</td>
<td>29</td>
</tr>
<tr>
<td>53</td>
<td>上划线</td>
<td>55</td>
</tr>
<tr>
<td>11-19</td>
<td>选择替代字体</td>
</tr>
</tbody>
</table>
</div>
<h5 id="3-4位色"><a href="#3-4位色" class="headerlink" title="3/4位色"></a>3/4位色</h5><div class="table-container">
<table>
<thead>
<tr>
<th>前景色值</th>
<th>背景色值</th>
<th>颜色</th>
<th>高亮前景色值</th>
<th>高亮背景色值</th>
</tr>
</thead>
<tbody>
<tr>
<td>30</td>
<td>40</td>
<td>黑色</td>
<td>90</td>
<td>100</td>
</tr>
<tr>
<td>31</td>
<td>41</td>
<td>红色</td>
<td>91</td>
<td>101</td>
</tr>
<tr>
<td>32</td>
<td>42</td>
<td>绿色</td>
<td>92</td>
<td>102</td>
</tr>
<tr>
<td>33</td>
<td>43</td>
<td>黄色</td>
<td>93</td>
<td>103</td>
</tr>
<tr>
<td>34</td>
<td>44</td>
<td>蓝色</td>
<td>94</td>
<td>104</td>
</tr>
<tr>
<td>35</td>
<td>45</td>
<td>紫红色</td>
<td>95</td>
<td>105</td>
</tr>
<tr>
<td>36</td>
<td>46</td>
<td>青蓝色</td>
<td>96</td>
<td>106</td>
</tr>
<tr>
<td>37</td>
<td>47</td>
<td>白色</td>
<td>97</td>
<td>107</td>
</tr>
<tr>
<td>38</td>
<td>48</td>
<td>控制使用256位、RGB色</td>
<td></td>
<td></td>
</tr>
<tr>
<td>39</td>
<td>49</td>
<td>默认颜色</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p><img src="/imgs/ansi_sgr_colors_16.png" alt="ansi_sgr_colors_16"></p>
<blockquote>
<ul>
<li>可通过反显 <code>7</code> 实现背景色、高亮 <code>1</code> 实现多高亮色</li>
</ul>
</blockquote>
<h5 id="8bits-色"><a href="#8bits-色" class="headerlink" title="8bits 色"></a>8bits 色</h5><ul>
<li>8bits 色设置格式<ul>
<li><code>ESC[38;5;37m</code>：设置256位前景色</li>
<li><code>ESC[48;5;37m</code>：设置256位背景色</li>
</ul>
</li>
<li>预定义 8bits 色情况<ul>
<li><em>0-7</em>：标准颜色，同 <code>ESC[30-37m</code></li>
<li><em>8-15</em>：高强度颜色，同 <code>ESC[90-97m</code></li>
<li><em>16-231</em>：<code>16 + 36*r + 6*g + b</code>（$0 leq r,g,b leq 5$ 得到 6 <em> 6 </em> 6 立方）</li>
<li><em>232-255</em>：24阶灰阶</li>
</ul>
</li>
</ul>
<p><img src="/imgs/ansi_sgr_colors_256.png" alt="ansi_sgr_colors_256"></p>
<h5 id="24bits-色"><a href="#24bits-色" class="headerlink" title="24bits 色"></a>24bits 色</h5><ul>
<li><p>24bits 色设置格式</p>
<ul>
<li><code>ESC[38;2;&lt;r&gt;;&lt;g&gt;;&lt;b&gt;m</code>：选择 <em>RGB</em> 前景色</li>
<li><code>ESC[48;2;&lt;r&gt;;&lt;g&gt;;&lt;b&gt;m</code>：选择 <em>RGB</em> 辈景色</li>
</ul>
</li>
<li><p>字符内容体系结构有一个不太受支持的替代版本</p>
<ul>
<li><code>ESC[38:2:&lt;Color-Space-ID&gt;:&lt;r&gt;:&lt;g&gt;:&lt;b&gt;:&lt;unused&gt;:&lt;CS tolerance&gt;:&lt;Color-Space: 0=&quot;CIELUV&quot;;1=&quot;CIELAB&quot;&gt;m</code>：选择 <em>RGB</em> 前景色</li>
<li><code>ESC[48:2:&lt;Color-Space-ID&gt;:&lt;r&gt;:&lt;g&gt;:&lt;b&gt;:&lt;unused&gt;:&lt;CS tolerance&gt;:&lt;Color-Space: 0=&quot;CIELUV&quot;;1=&quot;CIELAB&quot;&gt;m</code>：选择 <em>RGB</em> 背景色</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>支持 <code>libvte</code> 的终端上支持 <em>ISO-8613-3</em> 的 24bits 前景色、背景色设置，如 <em>Xterm</em>、<em>Konsole</em></li>
<li>24bits 色的替代版本是 <em>ISO/IEC 8613-6</em> 采用的 <em>ITU</em> 的 <em>T.416</em> 信息技术</li>
</ul>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-22T17:32:09.000Z" title="4/23/2019, 1:32:09 AM">2019-04-23</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-04-22T17:32:09.000Z" title="4/23/2019, 1:32:09 AM">2019-04-23</time></span><span class="level-item"><a class="link-muted" href="/categories/Math-Analysis/">Math Analysis</a><span> / </span><a class="link-muted" href="/categories/Math-Analysis/Optimization/">Optimization</a></span><span class="level-item">12 minutes read (About 1864 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Math-Analysis/Optimization/quasi_newtons.html">Quasi-Newton Method/Variable Metric Method</a></h1><div class="content"><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>拟Newton法/变度量法：不需要求解Hesse矩阵，使用一阶导构造
二阶信息的近似矩阵</p>
<ul>
<li><p>使用迭代过程中信息，创建近似矩阵$B^{(k)}$代替Hesse矩阵</p>
</li>
<li><p>用以下方程组替代Newton方程，其解$d^{(k)}$作为搜索方向</p>
<script type="math/tex; mode=display">
B^{(k)} d = - \triangledown f(x^{(k)})</script></li>
</ul>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><ul>
<li><p>考虑$\triangledown f(x)$在$x^{(k+1)}$处泰勒展开</p>
<script type="math/tex; mode=display">
\triangledown f(x) \approx \triangledown f(x^{(k+1)})
   + \triangledown^2 f(x^{(k+1)})(x - x^{(k+1)})</script></li>
<li><p>取$x = x^{(k)}$，有</p>
<script type="math/tex; mode=display">\begin{align*}
\triangledown f(x^{(k+1)}) - \triangledown f(x^{(k)})
   & \approx \triangledown^2 f(x^{(x+1)})
   (x^{(k+1) } - x^{(k)}) \\
\triangledown^2 f(x^{k+1}) s^{(k)} & \approx y^{(k)}
\end{align*}</script><blockquote>
<ul>
<li>$s^{(k)} = x^{(k+1)} - x^{(k)}$</li>
<li>$y^{(k)} = \triangledown f(x^{(k+1)}) - \triangledown f(x^{(k)})$</li>
</ul>
</blockquote>
</li>
<li><p>要求$B^{(k)}$近似$\triangledown^2 f(x^{(k)})$，带入并将
$\approx$改为$=$，得到拟Newton方程</p>
<script type="math/tex; mode=display">
B^{(k+1)} s^{(k)} = y^{(k)}</script><p>并假设$B^{(k)}$对称</p>
</li>
<li><p>拟Newton方程不能唯一确定$B^{(k+1)}$，需要附加条件，自然
的想法就是$B^{(k+1)}$可由$B^{(k)}$修正得到，即</p>
<script type="math/tex; mode=display">
B^{(k+1)} = B^{(k)} + \Delta B^{(k)}</script><p>且修正项$\Delta B^{(k)}$具有“简单形式”</p>
</li>
</ul>
<h2 id="Hesse矩阵修正"><a href="#Hesse矩阵修正" class="headerlink" title="Hesse矩阵修正"></a>Hesse矩阵修正</h2><h3 id="对称秩1修正"><a href="#对称秩1修正" class="headerlink" title="对称秩1修正"></a>对称秩1修正</h3><p>认为简单指矩阵秩小：即认为$\Delta B^{(k)}$秩为最小值1</p>
<ul>
<li><p>设$\Delta B^{(k)} = u v^T$，带入有</p>
<script type="math/tex; mode=display">\begin{align*}
y^{(k)} & = B^{(k+1)} s^{(k)} \\
& = B^{(k)} s^{(k)} + (v^T s^{(k)}) u \\
y^{(k)} - B^{(k)} s^{(k)} & = (v^T s^{(k)}) u
\end{align*}</script><ul>
<li>这里有的书会设$\Delta B^{(k)} = \alpha u v^T$，
其实对向量没有必要</li>
<li>$v^T s^{(k)}$是数，所以$u$必然与共线，同理也没有必要
考虑系数，直接取相等即可</li>
<li>而且系数不会影响最终结果</li>
</ul>
</li>
<li><p><strong>可取</strong>$u = y^{(k)} - B^{(k)} s{(k)}$，取$v$满足
$v^T s^{(k)}  = 1$</p>
</li>
<li><p>由$B^{(k)}$的对称性、并希望$B^{(k+1)}$保持对称，需要
$u, v$共线，则有</p>
<script type="math/tex; mode=display">\begin{align*}
v & = \lambda u = \lambda (y^{(k)} - B^{(k)} s^{(k)}) \\
1 & = \lambda (y^{(k)} - B^{(k)} s^{(k)})^T s^{(k)}
\end{align*}</script></li>
<li><p>得到$B^{(k)}$的对称秩1修正公式</p>
<script type="math/tex; mode=display">
B^{(k+1)} = B^{(k)} + \frac {(y^{(k) - B^{(k)} s^{(k)}})
   (y^{(k)} - B^{(k)} s^{(k)})^T}
   {(y^{(k)} - B^{(k)} s^{(k)})^T s^{(k)}}</script></li>
</ul>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ol>
<li><p>初始点$x^{(1)}$、初始矩阵$B^{(1)} = I$、精度要求
$\epsilon$、置$k=1$</p>
</li>
<li><p>若$|\triangledown f(x^{(k)})| \leq \epsilon$，停止计算
，得到解$x^{(k)}$，否则求解以下方程得到$d^{(k)}$</p>
<script type="math/tex; mode=display">
B^{(k)} d = -\triangle f(x^{(k)})</script></li>
<li><p>一维搜索，求解</p>
<script type="math/tex; mode=display">
\arg\min_{\alpha} \phi(\alpha)=f(x^{(k)} + \alpha d^{(k)})</script><p>得到$\alpha_k$，置$x^{(k+1)}=x^{(k)} + \alpha_k d^{(k)}$</p>
</li>
<li><p>修正$B^{(k)}$</p>
<script type="math/tex; mode=display">\begin{align*}
s^{(k)} & = x^{(k+1)} - x^{(k)} \\
y^{(k)} & = \triangledown f(x^{(k+1)}) -
  \triangledown f(x^{(k)}) \\
B^{(k+1)} & = B^{(k)} + \frac {(y^{(k) - B^{(k)} s^{(k)}})
  (y^{(k)} - B^{(k)} s^{(k)})^T}
  {(y^{(k)} - B^{(k)} s^{(k)})^T s^{(k)}}
\end{align*}</script></li>
<li><p>置$k = k+1$，转2</p>
</li>
</ol>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>缺点</p>
<ul>
<li><p>要求$(y^{(k)} - B^{(k)} s^{(k)})^T s^{(k)} \neq 0$，
否则无法继续计算</p>
</li>
<li><p>不能保证正定性传递，只有
$(y^{(k)} - B^{(k)} s^{(k)})^T s^{(k)} &gt; 0$才能保证
$B^{(k+1)}$也正定</p>
</li>
<li><p>即使$(y^{(k)} - B^{(k)} s^{(k)})^T s^{(k)} &gt; 0$，
也可能很小，容易产生较大的舍入误差</p>
</li>
</ul>
</li>
</ul>
<h3 id="对称秩2修正"><a href="#对称秩2修正" class="headerlink" title="对称秩2修正"></a>对称秩2修正</h3><ul>
<li><p>为克服秩1修正公式缺点，考虑$\Delta B^{(k)}$秩为2，设</p>
<script type="math/tex; mode=display">
\Delta B^{(k)} = u^{(1)} (v^{(1)})^T
   + u^{(2)} (v^{(2)})^T</script></li>
<li><p>带入拟Newton方程有</p>
<script type="math/tex; mode=display">
B^{(k)} s^{(k)} + ((v^{(1)})^T s^{(k)}) u^{(1)} +
   ((v^{(2)})^T s^{(k)}) u^{(2)} = y^{(k)}</script></li>
<li><p>类似的取</p>
<script type="math/tex; mode=display">\left \{ \begin{array}{l}
u^{(1)} = y^{(k)} \\
(v^{(1)})^T s^{(k)} = 1
\end{array} \right.</script><script type="math/tex; mode=display">\left \{ \begin{array}{l}
u^{(2)} = -B^{(k)} s^{(k)} \\
(v^{(2)})^T s^{(k)} = 1
\end{array} \right.</script></li>
<li><p>同秩1公式保持对称性推导，得到对称秩2修正公式/BFGS公式</p>
<script type="math/tex; mode=display">
B^{(k+1)} = B^{(k)} - \frac {B^{(k)} s^{(k)}
   (s^{(k)})^T B^{(k)}} {(s^{(k)})^T B^{(k)} s^{(k)}}
   + \frac {y^{(k)} (y^{(k)})^T} {(y^{(k)})^T s^{(k)}}</script></li>
</ul>
<h3 id="BFGS算法"><a href="#BFGS算法" class="headerlink" title="BFGS算法"></a>BFGS算法</h3><p>类似同秩1修正算法，仅第4步使用对称秩2修正公式</p>
<h2 id="Hesse逆修正"><a href="#Hesse逆修正" class="headerlink" title="Hesse逆修正"></a>Hesse逆修正</h2><h3 id="对称秩2修正-1"><a href="#对称秩2修正-1" class="headerlink" title="对称秩2修正"></a>对称秩2修正</h3><ul>
<li><p>考虑直接构造近似于$(\triangledown^2 f(x^{(k)}))^{-1}$的
矩阵$H^{(k)}$</p>
</li>
<li><p>这样无需求解线性方程组，直接计算</p>
<script type="math/tex; mode=display">
d^{(k)} = -H^{(k)} \triangledown f(x^{(k)})</script></li>
<li><p>相应拟Newton方程为</p>
<script type="math/tex; mode=display">
H^{(k+1)} y^{(k)} = s^{(k)}</script></li>
<li><p>可得$H^{(k)}$的对称秩1修正公式</p>
<script type="math/tex; mode=display">
H^{(k+1)} = H^{(k)} + \frac {(s^{(k)} - H^{(k)} y^{(k)})
   (s^{(k)} - H^{(k)} y^{(k)})T}
   {(s^{(k)} - H^{(k)} y^{(k)})^T y^{(k)}}</script></li>
<li><p>可得$H^{(k)}$的对称秩2修正公式/DFP公式</p>
<script type="math/tex; mode=display">
H^{(k+1)} = H^{(k)} - \frac {H^{(k)} y^{(k)} (y^{(k)})^T
   H^{(k)}} {(y^{(k)})^T H^{(k)} y^{(k)}} +
   \frac {s^{(k)} (s^{(k)})^T} {(s^{(k)})^T y^{(k)}}</script></li>
</ul>
<h4 id="DFP算法"><a href="#DFP算法" class="headerlink" title="DFP算法"></a>DFP算法</h4><p>类似BFGS算法，只是</p>
<ul>
<li>使用$H^{(k)}$计算更新方向</li>
<li>使用$H^{(k)}$的对称秩2修正公式修正</li>
</ul>
<blockquote>
<ul>
<li>对正定二次函数，BFGS算法和DFP算法效果相同</li>
<li>对一般可微（非正定二次函数），一般认为BFGS算法在收敛性质
  、数值计算方面均由于DFP算法</li>
</ul>
</blockquote>
<h3 id="Hesse逆的BFGS算法"><a href="#Hesse逆的BFGS算法" class="headerlink" title="Hesse逆的BFGS算法"></a>Hesse逆的BFGS算法</h3><ul>
<li><p>考虑</p>
<script type="math/tex; mode=display">\begin{align*}
B^{(k+1)} & = B^{(k)} + u^{(1)} (v^{(1)})^T +
   u^{(2)} (v^{(2)})^T \\
H^{(k+1)} & = (B^{(k+1)})^{-1} \\
& = (B^{(k)} + u^{(1)} (v^{(1)})^T + u^{(2)}
   (v^{(2)})^T)^{-1} \\
\end{align*}</script></li>
<li><p>两次利用<em>Sherman-Morrison</em>公式，可得</p>
<script type="math/tex; mode=display">
H^{(k+1)} = (I - \frac {s^{(k)} (y^{(k)})^T} 
   {(y^{(k)})^T s^{(k)}})
   H^{(k)}
   (I - \frac {s^{(k)} (y^{(k)})^T}
       {(y^{(k)})^T s^{(k)}})^T
   + \frac {s^{(k)} (s^{(k)})^T} {(y^{(k)})^T s^{(k)}}</script></li>
</ul>
<h1 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h1><ul>
<li><p>还可以进一步展开</p>
<script type="math/tex; mode=display">
H^{(k+1)} = H^{(k)} + (\frac 1 {(s^{(k)})^T y^{(k)}} +
   \frac {(y^{(k)})^T H^{(k)} y^{(k)}}
   {((s^{(k)})^T y^{(k)})^2}) s^{(k)} (s^{(k)})^T
   - \frac 1 {(s^{(k)})^T y^{(k)}}
   (H^{(k)} y^{(k)} (s^{(k)})^T +
   s^{(k)} (y^{(k)})^T H^{(k)})</script></li>
</ul>
<h2 id="变度量法的基本性质"><a href="#变度量法的基本性质" class="headerlink" title="变度量法的基本性质"></a>变度量法的基本性质</h2><h3 id="算法的下降性"><a href="#算法的下降性" class="headerlink" title="算法的下降性"></a>算法的下降性</h3><h4 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h4><blockquote>
<ul>
<li>设$B^{(k)}$（$H^{(k)}$）是正定对称矩阵，且有
  $(s^{(k)})^T y^{(k)} &gt; 0$，则由BFGS（DFS）公式构造的
  $B^{(k+1)}$（$H^{(k+1)}$）是正定对称的</li>
</ul>
</blockquote>
<ul>
<li><p>考虑$B^{(k)}$对称正定，有
$B^{(k)} = (B^{(k)})^{1/2} (B^{(k)})^{1/2}$</p>
</li>
<li><p>带入利用柯西不等式即可证</p>
</li>
</ul>
<blockquote>
<ul>
<li>中间插入正定矩阵的向量内积不等式也称为广义柯西不等式</li>
</ul>
</blockquote>
<h4 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h4><blockquote>
<ul>
<li>若$d^{(k)}$v是下降方向，且<strong>一维搜索是精确的</strong>，设
  $B^{(k)}$（$H^{(k)}$）是正定对称矩阵，则有BFGS（DFP）
  公式构造的$B^{(k+1)}$（$H^{(k+1)}$）是正定对称的</li>
</ul>
</blockquote>
<ul>
<li>精确一维搜索$(d^{(k)})^T \triangledown f(x^{(k+1)}) = 0$</li>
<li>则有$(s^{(k)})^T y^{(k)} &gt; 0$</li>
</ul>
<h4 id="定理3"><a href="#定理3" class="headerlink" title="定理3"></a>定理3</h4><blockquote>
<ul>
<li>若用BFGS算法（DFP算法）求解无约束问题，设初始矩阵
  $B^{(1)}$（$H^{(1)}$）是正定对称矩阵，且一维搜索是精确的
  ，若$\triangledown f(x^{(k)}) \neq 0$，则产生搜索方向
  $d^{(k)}$是下降方向</li>
</ul>
</blockquote>
<ul>
<li>结合上2个结论，数学归纳法即可</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>若每步迭代一维搜索精确，或满足$(s^{(k)})^T y^{(k)} &gt; 0$</p>
<ul>
<li>停止在某一稳定点</li>
<li>或产生严格递减的序列${f(x^{(k)})}$</li>
</ul>
</li>
<li><p>若目标函数满足一定条件我，可以证明变度量法产生的点列
${x^{(k)}}$收敛到极小点，且收敛速率超线性</p>
</li>
</ul>
<h3 id="搜索方向共轭性"><a href="#搜索方向共轭性" class="headerlink" title="搜索方向共轭性"></a>搜索方向共轭性</h3><blockquote>
<ul>
<li>用变度量法BFGS（DFP）算法求解正定二次函数</li>
</ul>
</blockquote>
<pre><code>$$
min f(x) = \frac 1 2 x^T G x + r^T x + \sigma
$$

若一维搜索是精确的，假设已经进行了m次迭代，则
</code></pre><blockquote>
<ul>
<li><p>搜索方向$d^{(1)}, \cdots, d^{(m)}$是m个非零的G共轭方向</p>
</li>
<li><p>对于$j = 1, 2, \cdots, m$，有</p>
</li>
</ul>
</blockquote>
<pre><code>$$
B^&#123;(m+1)&#125; s^&#123;(j)&#125; = y^&#123;(j)&#125;
(H^&#123;(m+1)&#125; y^&#123;(j)&#125; = s^&#123;(j)&#125;)
$$

且$m = n$时有吧

$$
B^&#123;(n+1)&#125; = G(H^&#123;(n+1)&#125; = G^&#123;-1&#125;)
$$
</code></pre><h3 id="变度量法二次终止"><a href="#变度量法二次终止" class="headerlink" title="变度量法二次终止"></a>变度量法二次终止</h3><blockquote>
<ul>
<li>若一维搜索是精确的，则变度量法（BFGS、DFP）具有二次终止</li>
</ul>
</blockquote>
<ul>
<li><p>若$\triangle f(x^{(k)}) = 0, k \leq n$，则得到最优解
$x^{(k)}$</p>
</li>
<li><p>否则得到的搜索方向是共轭的，由扩展空间子定理，
$x^{(n+1)}$是最优解</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-21T16:33:40.000Z" title="4/22/2019, 12:33:40 AM">2019-04-22</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-02T03:34:11.000Z" title="8/2/2021, 11:34:11 AM">2021-08-02</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Cookbook/">Cookbook</a></span><span class="level-item">a minute read (About 150 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Cookbook/funcs.html">Python 函数式编程</a></h1><div class="content"><h2 id="functools"><a href="#functools" class="headerlink" title="functools"></a><code>functools</code></h2><h3 id="total-ordering"><a href="#total-ordering" class="headerlink" title="total_ordering"></a><code>total_ordering</code></h3><p><code>total_ordering</code>：允许类只定义<code>__eq__</code>和其他中的一个，其他
富比较方法由装饰器自动填充</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> total_ordering</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Room</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, length, width</span>):</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.length = length</span><br><span class="line">		self.width = width</span><br><span class="line">		self.square_feet = self.length * self.width</span><br><span class="line"></span><br><span class="line"><span class="meta">@total_ordering</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, style</span>):</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.style = style</span><br><span class="line">		self.rooms = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line"><span class="meta">	@property</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">living_space_footage</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">sum</span>(r.square_feet <span class="keyword">for</span> r <span class="keyword">in</span> self.rooms)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">add_room</span>(<span class="params">self, room</span>):</span></span><br><span class="line">		self.rooms.append(room)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&#123;&#125;: &#123;&#125; squre foot &#123;&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">			self.name,</span><br><span class="line">			self.living_space_footage,</span><br><span class="line">			self.style)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__eq__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">		<span class="keyword">return</span> self.living_space_footage == other.living_space_footage</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__lt__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">		<span class="keyword">return</span> self.living_space_footage &lt; other.living_space_footage</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-20T07:39:09.000Z" title="4/20/2019, 3:39:09 PM">2019-04-20</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-04-20T07:39:09.000Z" title="4/20/2019, 3:39:09 PM">2019-04-20</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Py3std/">Py3std</a></span><span class="level-item">5 minutes read (About 739 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Py3std/README.html">Py3std Readme</a></h1><div class="content"><h2 id="常用参数说明"><a href="#常用参数说明" class="headerlink" title="常用参数说明"></a>常用参数说明</h2><ul>
<li>函数书写声明同Python全局说明</li>
<li>以下常用参数如不特殊注明，按照此解释</li>
</ul>
<h3 id="Common"><a href="#Common" class="headerlink" title="Common"></a>Common</h3><h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><ul>
<li><p><code>mode=&quot;r&quot;/&quot;w&quot;/&quot;a&quot;/&quot;+&quot;/&quot;t&quot;/&quot;b&quot;</code></p>
<ul>
<li>含义：文件/管道打开模式<ul>
<li><code>t</code>：文本，可省略</li>
<li><code>b</code>：二进制</li>
<li><code>r</code>：读，默认</li>
<li><code>w</code>：写</li>
<li><code>a</code>：追加，大部分支持</li>
<li><code>+</code>：更新模式，同时允许读写<ul>
<li><code>r+</code>：文件已存在，读、写</li>
<li><code>w+</code>：清除之前内容，读、写</li>
<li><code>a+</code>：读、追加写</li>
</ul>
</li>
</ul>
</li>
<li>默认：<code>rt</code>/<code>r</code></li>
</ul>
</li>
<li><p><code>buffering/bufsize = -1/0/1/int</code></p>
<ul>
<li>含义：缓冲模式<ul>
<li><code>0</code>：不缓冲，只在二进制模式中被运行</li>
<li><code>1</code>：逐行缓冲，只在文本模式中有效</li>
<li>其他正整数：指定固定大小chunk缓冲的大小</li>
<li><code>-1</code>：全缓冲<ul>
<li>普通二进制、文本，缓冲chunks大小启发式确定，
<code>io.DEFAULT_BUFFER_SIZE</code>查询</li>
<li>终端交互流（<code>.isatty()</code>），逐行缓冲</li>
</ul>
</li>
</ul>
</li>
<li>默认：<code>-1</code></li>
</ul>
</li>
<li><p><code>encoding(str)</code></p>
<ul>
<li>含义：文件编码<ul>
<li><code>utf-8</code></li>
<li><code>utf-16</code></li>
<li><code>utf-16-le</code></li>
<li><code>utf-16-be</code></li>
<li><code>utf-32</code></li>
<li><code>gbxxxx</code></li>
<li>待续</li>
</ul>
</li>
<li>缺省：使用<code>locale.getpreferedencoding()</code>返回值</li>
</ul>
</li>
</ul>
<h3 id="Threading-Processing"><a href="#Threading-Processing" class="headerlink" title="Threading/Processing"></a>Threading/Processing</h3><ul>
<li><p><code>block/blocking = True/False</code></p>
<ul>
<li>含义：是否阻塞</li>
<li>默认：大部分为<code>True</code>（阻塞）</li>
<li>其他<ul>
<li>对返回值不是bool类型的函数，非阻塞时若无法进行
操作，往往会<code>raise Exception</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>timeout = None/num</code></p>
<ul>
<li>含义：延迟时间，单位一般是秒</li>
<li>默认：None，无限时间</li>
<li>其他<ul>
<li><code>block=False</code>时，一般<code>timeout</code>参数设置无效</li>
</ul>
</li>
</ul>
</li>
<li><p><code>fn/func/callable(callable)</code></p>
<ul>
<li>含义：可调用对象</li>
<li>默认：一般默认值</li>
<li>其他<ul>
<li>实参可以是任何可调用对象<ul>
<li>函数</li>
<li>方法</li>
<li>可调用对象</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>args = ()/None/tuple/list</code>/<code>*args(arg_1, ...)</code></p>
<ul>
<li>含义：函数位置参数</li>
<li>默认：<code>()/None</code>，无参数</li>
</ul>
</li>
<li><p><code>kwrags/kwds = &#123;&#125;/None/dict</code>/<code>**kwargs(kwarg_1=v1, ...)</code></p>
<ul>
<li>含义：函数关键字参数</li>
<li>默认：<code>&#123;&#125;/None</code>，无参数</li>
</ul>
</li>
<li><p><code>callback=callable</code></p>
<ul>
<li>含义：回调函数<ul>
<li>异步线程、进程调用才会有该参数</li>
<li>回调函数接收进程/线程返回值作为参数</li>
<li>回调函数最好有返回值，否则会阻塞进程、线程池</li>
</ul>
</li>
<li>默认：<code>None</code>，无参数</li>
</ul>
</li>
<li><p><code>chunksize=None/1/int</code></p>
<ul>
<li>含义：一次传递给<strong>子进程</strong>的迭代器元素数量<ul>
<li>常在进程池迭代调度函数中，较大的<code>chunksize</code>
能减少进程间通信消耗，但会降低灵活性</li>
<li>线程调度相关函数该参数被忽略</li>
</ul>
</li>
<li>默认：<code>None</code>/<code>1</code>，一次传递一个元素</li>
</ul>
</li>
<li><p><code>daemon=False/None/True</code></p>
<ul>
<li>含义：是否为守护进程/线程<ul>
<li>默认情况下，主进程（线程）会等待子进程、线程退出
后退出</li>
<li>主进程（线程）不等待守护进程、线程退出后再退出</li>
<li>注意：主进程退出之前，守护进程、线程会自动终止</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Python命令行参数"><a href="#Python命令行参数" class="headerlink" title="Python命令行参数"></a>Python命令行参数</h2><ul>
<li><code>-c</code>：解释执行语句</li>
<li><code>-u</code>：强制输入、输出流无缓冲，直接输入，默认全缓冲</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-18T05:32:24.000Z" title="4/18/2019, 1:32:24 PM">2019-04-18</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-04-18T05:32:24.000Z" title="4/18/2019, 1:32:24 PM">2019-04-18</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Problem/">Problem</a></span><span class="level-item">23 minutes read (About 3521 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Problem/sorting.html">排序</a></h1><div class="content"><h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><ul>
<li>按照升序重新排列给定列表中的数据项</li>
<li>为了让问题有意义，列表中的数据项应该能够排序（数据之间
有一种全序关系）</li>
<li>键：在对记录排序时，需要选取的、作为排序的依据的一段信息</li>
</ul>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ul>
<li>排序可能是所求解的问题输出要求</li>
<li>排序能够更方便的求解和列表相关的问题<ul>
<li>查找问题</li>
</ul>
</li>
<li>在其他领域的重要算法中，排序也被作为辅助步骤</li>
</ul>
<h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><ul>
<li><p>排序领域已经有很多不错的算法，只需要做$nlog_{x}^{n}$次
比较就能完成长度为$n$的任意数组排序，且没有一种基于
<strong>键</strong>值比较（相较于比较键值部分内容而言）的排序算法能
在本质上操作其，</p>
</li>
<li><p>但是还是需要不断探寻新的算法虽然有些算法比其他的要好，
但是没有任何算法在任何情况下是最优的</p>
<ul>
<li>有些算法比较简单，但速度较慢</li>
<li>有些算法适合随机排列的输入，而有些适合基本有序的列表</li>
<li>有些算法适合驻留在快速存储器中的列表，而有些适合存储
在磁盘上的大型文件排序</li>
</ul>
</li>
</ul>
<h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><ul>
<li>稳定性：排序算法保留等值元素在输入中的相对顺序<ul>
<li>一般来说，将相隔很远的键交换位置的算法虽然不稳定，
但往往很快</li>
</ul>
</li>
<li>在位性：排序算法不需要额外的存储空间，除极个别存储单元外</li>
</ul>
<h2 id="线性表排序"><a href="#线性表排序" class="headerlink" title="线性表排序"></a>线性表排序</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul>
<li>每轮<strong>选择出</strong>剩余元素中最小值，放在对于位置上</li>
</ul>
<h4 id="顺序表算法"><a href="#顺序表算法" class="headerlink" title="顺序表算法"></a>顺序表算法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SelectionSort(A[<span class="number">0.</span>.n-<span class="number">1</span>]):</span><br><span class="line">	// 选择排序排序数组</span><br><span class="line">	// 输入：可排序数组A[<span class="number">0.</span>.n-<span class="number">1</span>]</span><br><span class="line">	// 输出：升序排序数组A[<span class="number">0.</span>.n-<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span> to n-<span class="number">1</span> do</span><br><span class="line">		<span class="built_in">min</span> = i</span><br><span class="line">		<span class="keyword">for</span> j = i to n-<span class="number">1</span> do</span><br><span class="line">			<span class="keyword">if</span> A[j] &lt; A[<span class="built_in">min</span>]</span><br><span class="line">				<span class="built_in">min</span> = j</span><br><span class="line">		swap A[i] <span class="keyword">and</span> A[<span class="built_in">min</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>扫描整个列表找到最小元素，然后和首个元素交换，将其放在
最终位置上</li>
<li>从第2个元素开始寻找之后最小元素，和第2个元素交换，将其
放在最终位置上</li>
<li>重复n-1次，列表有序</li>
</ul>
<h4 id="链表算法"><a href="#链表算法" class="headerlink" title="链表算法"></a>链表算法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">SelectionSort(linked):</span><br><span class="line">	// 选择排序排序链表</span><br><span class="line">	// 输入：可排序链表linked头</span><br><span class="line">	// 输出：排序后链表头</span><br><span class="line">	<span class="keyword">if</span> linked == NULL:</span><br><span class="line">		<span class="keyword">return</span> NULL</span><br><span class="line">	linked_head = ListNode()</span><br><span class="line">		// 为方便附设头结点</span><br><span class="line">	linked_head.<span class="built_in">next</span> = linked</span><br><span class="line">	unsorted_head = linked_head</span><br><span class="line">		// 未排序头结点</span><br><span class="line">		// 后续过程中是链表中元素</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> unsorted_head.<span class="built_in">next</span> != NULL:</span><br><span class="line">		cur_node = unsorted_head</span><br><span class="line">		min_node = unsorted_head</span><br><span class="line">			// 全是链表中元素</span><br><span class="line">		<span class="keyword">while</span> cur_node.<span class="built_in">next</span> != NULL:</span><br><span class="line">			<span class="keyword">if</span> cur_node.<span class="built_in">next</span>.val &lt; min_node.<span class="built_in">next</span>.val:</span><br><span class="line">				min_node = cur_node</span><br><span class="line">			cur_node = cur_node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">		// 若`min_node.<span class="built_in">next</span>`就是`unsorted_start.<span class="built_in">next</span>`，以下</span><br><span class="line">			// 代码中的断开、重组链表操作会出现环</span><br><span class="line">		// 完全切开再重组链表，则需要判断`unsorted_start`</span><br><span class="line">			// 是否为空</span><br><span class="line">		<span class="keyword">if</span> unsorted_start.<span class="built_in">next</span> != min_node.<span class="built_in">next</span>:</span><br><span class="line">			_tmp_node = unsorted_head.<span class="built_in">next</span></span><br><span class="line">				// 记录原`unsorted_head.<span class="built_in">next</span>`</span><br><span class="line"></span><br><span class="line">			unsorted_head.<span class="built_in">next</span> = min_node.<span class="built_in">next</span></span><br><span class="line">				// `unsorted_head.<span class="built_in">next</span>`断开、连接`min_node`</span><br><span class="line"></span><br><span class="line">			min_node.<span class="built_in">next</span> = min_node.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">				// `min_node.<span class="built_in">next</span>`断开、跳过`min_node`重连</span><br><span class="line">				// 若`min_node.<span class="built_in">next</span>`是`unsorted_start.<span class="built_in">next</span>`</span><br><span class="line">					// 会断开`unsorted_start`和`min_node`</span><br><span class="line"></span><br><span class="line">			unsorted_head.<span class="built_in">next</span>.<span class="built_in">next</span> = _tmp_node</span><br><span class="line">				// 原`min_node`重连原`unsorted_head.<span class="built_in">next</span>`</span><br><span class="line"></span><br><span class="line">		unsorted_start = unsorted_start.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> linked_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>对任何输入，选择排序键值比较都是$\Theta(n^2)$</li>
<li>键交换次数仅为$\Theta(n)$<ul>
<li>选择排序此特性优于许多其他排序算法</li>
</ul>
</li>
</ul>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul>
<li>比较表中相邻元素，如果逆序就交换位置</li>
<li>重复多次则最大元素被“沉到”列表最后位置</li>
<li>第2轮比较将第2大元素“沉到”其最终位置</li>
<li>重复比较n-1轮，列表有序</li>
</ul>
<h4 id="顺序表算法-1"><a href="#顺序表算法-1" class="headerlink" title="顺序表算法"></a>顺序表算法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BubbleSort(A[<span class="number">0.</span>.n-<span class="number">1</span>]):</span><br><span class="line">	// 冒泡排序排序数组</span><br><span class="line">	// 输入：可排序数组A[<span class="number">0.</span>.n-<span class="number">1</span>]</span><br><span class="line">	// 输出：升序排序数组A[<span class="number">0.</span>.n-<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span> to n-<span class="number">2</span> do</span><br><span class="line">		<span class="keyword">for</span> j = <span class="number">0</span> to n-<span class="number">2</span>-i do</span><br><span class="line">			<span class="keyword">if</span> A[j+i] &lt; A[j]</span><br><span class="line">				swap A[j] <span class="keyword">and</span> A[j+<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="链表算法-1"><a href="#链表算法-1" class="headerlink" title="链表算法"></a>链表算法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BublleSort(head):</span><br><span class="line">	// 冒泡排序排序链表</span><br><span class="line">	// 输入：可排序链表首个元素</span><br><span class="line">	// 输出：排序后列表首个元素</span><br></pre></td></tr></table></figure>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>对任何输入，冒泡排序键值比较都是$\Theta(n^2)$</li>
<li>其交换次数取决于特定输入<ul>
<li>最坏情况是遇到降序排列数组，此时键交换次数同比较次数</li>
</ul>
</li>
<li>冒泡排序看起来就像是选择排序的<strong>一直交换+最大优先</strong>版本</li>
</ul>
<h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><ul>
<li>如果对列表比较一轮后没有交换任何元素，说明列表有序，可以
结束算法</li>
</ul>
<h3 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h3><p>插入排序：利用减一技术对数组$A[0..n-1]$进行排序</p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ul>
<li>假设对较小数组$A[0..i-2]$排序已经解决</li>
<li>从右至左（方便将将元素右移）扫描有序子数组，直到遇到首个
小于等于$A[i-1]$元素，将$A[i-1]$插入其后</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">InsertionSort(A[<span class="number">0.</span>.n-<span class="number">1</span>])</span><br><span class="line">	// 用插入排序对给定数组排序</span><br><span class="line">	// 输入：n个可排序元素构成数组</span><br><span class="line">	// 输出：非降序排序数组</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span> to n-<span class="number">1</span> do</span><br><span class="line">		v = A[i]</span><br><span class="line">		j = i - <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> A[j] &gt; v do</span><br><span class="line">			A[j+<span class="number">1</span>] = A[j]</span><br><span class="line">			j = j - <span class="number">1</span></span><br><span class="line">		A[j+<span class="number">1</span>] = v</span><br><span class="line">		// 上一步比较元素已经赋值给其后，所以应该覆盖其值</span><br></pre></td></tr></table></figure>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>插入排序是自顶向下基于递归思想，但是自底向上使用迭代实现
算法效率更高</p>
</li>
<li><p>算法时间效率</p>
<ul>
<li>算法基本操作是键值比较，比较次数依赖于特定输入</li>
<li>最坏情况（递减数组）下：每轮比较次数都到达最大，此时
键值比较次数$\in \Theta(n^2)$</li>
<li>最优情况（递增数组）下：每轮比较次数仅为1，此时键值
比较次数$\in \Theta(n)$</li>
<li>对随机序列：比较次数$\in \Theta(n^2)$</li>
<li>许多应用中都会遇到基本有序的文件，插入排序能保证良好
性能</li>
</ul>
</li>
<li><p>减常量法</p>
</li>
</ul>
<h3 id="Shell-Sort"><a href="#Shell-Sort" class="headerlink" title="Shell Sort"></a>Shell Sort</h3><p>插入排序的扩展，Shell排序基于<em>h有序</em></p>
<h4 id="H有序"><a href="#H有序" class="headerlink" title="H有序"></a>H有序</h4><p>数组中任意间隔为h的元素都是有序的，对应的数组称为<em>h有序数组</em></p>
<ul>
<li><em>h有序数组</em>：就是h个互相独立的有序数组<strong>编织</strong>在一起数组</li>
<li><em>h有序数组</em>具有分离、局部有序的特点</li>
</ul>
<h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><ul>
<li>使用插入排序对<em>h子数组</em>独立排序，每次交换相隔h的元素</li>
<li>h逐渐减小到1，shell排序退化（最后一轮）为插入排序</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ShellSort(A[<span class="number">0.</span>.n-<span class="number">1</span>])</span><br><span class="line">	// 用插入排序对给定数组排序</span><br><span class="line">	// 输入：n个可排序元素构成数组</span><br><span class="line">	// 输出：非降序排序数组</span><br><span class="line">	h = <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> h &lt; n/<span class="number">3</span></span><br><span class="line">		h = h*<span class="number">3</span> + <span class="number">1</span></span><br><span class="line">		// 获取初始h值，之后每轮h变为<span class="number">1</span>/<span class="number">3</span></span><br><span class="line">	<span class="keyword">while</span> h &gt;= <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">for</span> i = h to n-<span class="number">1</span>:</span><br><span class="line">			v = A[i]</span><br><span class="line">			j = i - h</span><br><span class="line">			<span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> A[j] &gt; v do</span><br><span class="line">				A[j] = A[j-h]</span><br><span class="line">				j = j - h</span><br><span class="line">			A[j+h] = v</span><br><span class="line">		h = h/<span class="number">3</span></span><br></pre></td></tr></table></figure>
<h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>Shell排序全衡量子数组规模、有序性，更加高效</p>
</li>
<li><p>h递增序列</p>
<ul>
<li>子数组部分有序程度取决于h递增序列的选择</li>
<li>不同的h递增序列对算法效率有常数倍的变动，但是在实际
应用中效果不明显</li>
</ul>
</li>
<li><p>Shell排序是唯一无法准确描述其对于乱序数组性能特征的排序
方法</p>
</li>
<li><p>减常量法</p>
</li>
</ul>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="Mergesort"><a href="#Mergesort" class="headerlink" title="Mergesort"></a>Mergesort</h4><ul>
<li>将需要排序的数组A[0..n-1]均分的</li>
<li>对两个子数组<strong>递归排序</strong>，然后把排序后的子数组合并为有序
数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Mergesort(A[<span class="number">0.</span>.n-<span class="number">1</span>]):</span><br><span class="line">	// 递归调用MergeSort对数组排序</span><br><span class="line">	// 输入：可排序数组A[<span class="number">0.</span>.n-<span class="number">1</span>]</span><br><span class="line">	// 输出：非降序排列数组A[<span class="number">0.</span>.n-<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">if</span> n &gt; <span class="number">1</span>:</span><br><span class="line">		copy A[<span class="number">0.</span>.floor(n/<span class="number">2</span>)-<span class="number">1</span>] to B[<span class="number">0.</span>.floor(n/<span class="number">2</span>)-<span class="number">1</span>]</span><br><span class="line">		copy A[floor(n/<span class="number">2</span>)..n-<span class="number">1</span>] to C[<span class="number">0.</span>.ceiling(n/<span class="number">2</span>)-<span class="number">1</span>]</span><br><span class="line">		Mergesort(B[<span class="number">0.</span>.floor(n/<span class="number">2</span>)-<span class="number">1</span>])</span><br><span class="line">		Mergesort(C[<span class="number">0.</span>.ceiling(n/<span class="number">2</span>)-<span class="number">11</span>])</span><br><span class="line">		Merge(B, C, A)</span><br></pre></td></tr></table></figure>
<h4 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h4><ul>
<li>初始两只指针指向待合并数组首个元素</li>
<li>比较两个元素大小，将较小元素添加到新数组中，被复制元素
的数组指针右移</li>
<li>重复直到某一数组处理完毕，将未处理完数组复制到新数组尾部</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Merge(B[<span class="number">0.</span>.p-<span class="number">1</span>], C[<span class="number">0.</span>.q-<span class="number">1</span>], A[<span class="number">0.</span>.p+q-<span class="number">1</span>]):</span><br><span class="line">	// 将两个有序数组合并为新的有序数组</span><br><span class="line">	// 输入：有序数组B[<span class="number">0.</span>.p-<span class="number">1</span>]、C[<span class="number">0.</span>.q-<span class="number">1</span>]</span><br><span class="line">	// 输出：存放有B、C中元素的有序数组A[<span class="number">0.</span>.p+q-<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">while</span> i &lt; p <span class="keyword">and</span> j &lt; q:</span><br><span class="line">		<span class="keyword">if</span> B[i] &lt;= C[j]</span><br><span class="line">			A[k] = B[i]</span><br><span class="line">			i = i + <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			A[k] = C[j]</span><br><span class="line">			j = j + <span class="number">1</span></span><br><span class="line">		k = k + <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> i == p:</span><br><span class="line">		copy C[j..q-<span class="number">1</span>] to A[k..p+q-<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		copy B[i..p-<span class="number">1</span>] to A[k..p+q-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>算法时间效率</p>
<ul>
<li>最坏情况下比较次数$\in \Theta(nlogn)$，为
$nlog_2n-n+1$，十分接近基于比较的排序算法理论上能够
达到的最少次数</li>
</ul>
</li>
<li><p>相较于快排、堆排序</p>
<ul>
<li>合并排序比较稳定，缺点在于需要线性额外空间</li>
<li>虽然能做到在位，但是算法过于复杂，只具有理论上意义</li>
</ul>
</li>
<li><p>算法可以自底向上合并数组的元素对，再合并有序对</p>
<ul>
<li>这可以避免使用堆栈递归调用时时空开销</li>
</ul>
</li>
<li><p>可以把数组划分为待排序的多个部分，再对其递归排序，最后
合并在一起</p>
<ul>
<li>这尤其适合对存在二级存储空间的文件进行排序</li>
<li>也称为<em>Multiway Mergesort</em></li>
</ul>
</li>
<li><p>分治算法</p>
</li>
</ul>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>相较于合并排序按照元素在数组中的位置进行划分，快速排序按照
元素值对其进行划分</p>
<h4 id="Quicksort"><a href="#Quicksort" class="headerlink" title="Quicksort"></a>Quicksort</h4><ul>
<li>对数组中元素重新排列，使得A[s]左边元素均小于A[s]，A[s]
右边元素都大于等于A[s]<ul>
<li>此时A[s]已经位于它在有序数组中的最终位置</li>
</ul>
</li>
<li>接下来对A[s]左右子数组进行排序</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Quicksort(A[l..]r)</span><br><span class="line">	// 对给定可比较数组进行排序</span><br><span class="line">	// 输入：可比较数组A[<span class="number">0.</span>.n-<span class="number">1</span>]子数组A[l..r]</span><br><span class="line">	// 输出：非降序排序的子数组A[l..r]</span><br><span class="line">	<span class="keyword">if</span> l&lt;r</span><br><span class="line">		s = partition(A[l..r])</span><br><span class="line">		Quicksort(A[l..s-<span class="number">1</span>])</span><br><span class="line">		Quicksort(A[s+<span class="number">1.</span>.r])</span><br></pre></td></tr></table></figure>
<h4 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>需要选择合适的划分算法J</p>
<ul>
<li><em>LomutoPartition</em></li>
<li><em>HoarePartition</em></li>
</ul>
</li>
<li><p>算法效率</p>
<ul>
<li>最优情况：分裂点都位于数组中点，算法比较次数为
$nlog_2n$</li>
<li>最差情况：分裂点都趋于极端（逆序输入），算法比较
次数$\in \Theta(n^2)$</li>
<li>平均：比较次数为$2nlnn \approx 1.39nlog_2n$</li>
<li>且算法内层循环效率非常高，在处理随机排列数组时，速度
比合并排序快</li>
</ul>
</li>
<li><p>快速排序缺点</p>
<ul>
<li>不稳定</li>
<li>需要堆栈存储未被排序的子数组参数，尽管可以先对较短
子数组排序使得堆栈大小降低到$O(logn)$，但是还是比
堆排序的$O(1)$差</li>
<li>仍然存在最差情况出现的可能性，即使有很多巧妙地中轴
选择办法</li>
<li>对随机数组排序性能的好坏，不仅与算法具体实现有关，
还和计算机系统结构、数据类型有关</li>
</ul>
</li>
<li><p>分治算法</p>
</li>
</ul>
<h4 id="算法改良"><a href="#算法改良" class="headerlink" title="算法改良"></a>算法改良</h4><ul>
<li><p>更好的中轴选择方法</p>
<ul>
<li>randomized quicksort：随机快速排序，使用随机元素作为
中轴</li>
<li>median-of-three method：三平均划分法，以数组最左边、
最右边、最中间的中位数作为中轴</li>
</ul>
</li>
<li><p>子数组足够小时（5~15），改用插入排序；或者直接不对小数组
排序，而是在快速排序结束后使用插入排序对整个近似有序的
数组进行排序</p>
</li>
<li><p>改进划分方法</p>
<ul>
<li>三路划分：将数组划分为3段，小于、等于、大于中轴元素</li>
</ul>
</li>
</ul>
<h3 id="比较计数排序"><a href="#比较计数排序" class="headerlink" title="比较计数排序"></a>比较计数排序</h3><h4 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h4><ul>
<li>遍历待排序列表中每个元素</li>
<li>计算、记录列表中小于该元素的元素个数</li>
<li>更新大于其的元素的小于元素的元素个数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ComparisonCountingSort(A[<span class="number">0.</span>.n-<span class="number">1</span>])</span><br><span class="line">	// 用比较计数法排序</span><br><span class="line">	// 输入：可排序数组A[<span class="number">0.</span>.n-<span class="number">1</span>]</span><br><span class="line">	// 输出：将A中可排序数组按照升序排列数组</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span> to n-<span class="number">1</span> do</span><br><span class="line">		count[i] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span> to n-<span class="number">2</span> do</span><br><span class="line">		<span class="keyword">for</span> j = i+<span class="number">1</span> to n-<span class="number">1</span> do</span><br><span class="line">			<span class="keyword">if</span> A[i] &lt; A[j]</span><br><span class="line">				count[j] += <span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				count[i] += <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span> to n-<span class="number">1</span> do</span><br><span class="line">		S[count[i]] = A[i]</span><br></pre></td></tr></table></figure>
<h4 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>算法效率</p>
<ul>
<li>算法比较次数为$n(n-1)/2$</li>
<li>占用了线性数量的额外空间</li>
</ul>
</li>
<li><p>算法使得键值的可能移动次数最小化，能够直接将键值放在在
有序数组最终位置</p>
</li>
<li><p>输入增强</p>
</li>
</ul>
<h3 id="分布计数排序"><a href="#分布计数排序" class="headerlink" title="分布计数排序"></a>分布计数排序</h3><ul>
<li>待排序元素来自于某个已知小集合$[l..u]$</li>
</ul>
<h4 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h4><ul>
<li>扫描列表，计算、存储列表中元素出现频率于数组$F[l..u]$中</li>
<li>再次扫描列表，根据值填入相应位置</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DistributionCountingSort(A[<span class="number">0.</span>.n-<span class="number">1</span>], l, u):</span><br><span class="line">	// 分布计数法排序，对元素来自有限范围整数的数组排序</span><br><span class="line">	// 输入：数组[<span class="number">0.</span>.n-<span class="number">1</span>]，数组中整数位于l、u间</span><br><span class="line">	// 输出：A中元素构成非降序数组S[<span class="number">0.</span>.n-<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">for</span> j = <span class="number">0</span> to u-l do</span><br><span class="line">		D[j] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span> to n=<span class="number">1</span> do</span><br><span class="line">		D[A[i]-l] += <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> j = <span class="number">1</span> to u-l do</span><br><span class="line">		D[j] += D[j-<span class="number">1</span>]</span><br><span class="line">		// 存储各元素最后出现索引+<span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i = n-<span class="number">1</span> downto <span class="number">0</span> do</span><br><span class="line">		j = A[i] - l</span><br><span class="line">		S[D[j]-<span class="number">1</span>] = A[i]</span><br><span class="line">		D[j] -= <span class="number">1</span></span><br><span class="line">		// 更新应该存储的位置，类似于压栈</span><br><span class="line">	<span class="keyword">return</span> S</span><br></pre></td></tr></table></figure>
<h4 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>算法效率</p>
<ul>
<li>如果元素值范围固定，效率为线性（不是基于比较的排序，
$nlogn$没有限制）</li>
<li>用空间换时间，其实可以看作是hash</li>
<li>利用了输入列表独特自然属性</li>
</ul>
</li>
<li><p>变治法（输入增强）</p>
</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li>判断线性表元素是否唯一</li>
<li>寻找线性表众数</li>
<li>快速查找</li>
</ul>
<h2 id="线性表顺序统计量"><a href="#线性表顺序统计量" class="headerlink" title="线性表顺序统计量"></a>线性表顺序统计量</h2><p>寻找列表中第k小的元素</p>
<ul>
<li><p>也即：求出给定列表中k个最小元素问题</p>
</li>
<li><p>采用partitioning的思路，需要将给定列表根据某个值先行划分</p>
<ul>
<li><em>Lumuto</em>划分算法</li>
</ul>
</li>
</ul>
<h3 id="QuickSelect算法"><a href="#QuickSelect算法" class="headerlink" title="QuickSelect算法"></a>QuickSelect算法</h3><h4 id="算法-4"><a href="#算法-4" class="headerlink" title="算法"></a>算法</h4><ul>
<li>对划分完后出数组，s为分割位置<ul>
<li>若：s == k-1，则中轴p就是第k小元素</li>
<li>若：s &lt; k-1，则应该是数组右边划分第k-s小元素</li>
<li>若：s &gt; k-1，则应该是数组左边划分第k小元素</li>
</ul>
</li>
<li>这样就得到规模更小的问题实例</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QuickSelect(A[l..r], k)</span><br><span class="line">	// 用基于划分递归算法解决选择问题</span><br><span class="line">	// 输入：可排序数组A[<span class="number">0.</span>.n-<span class="number">1</span>]的子数组A[l..r]、整数k</span><br><span class="line">	// 输出：A[l..r]中第k小元素</span><br><span class="line">	s = Partition(A[l..r])</span><br><span class="line">	<span class="keyword">if</span> s = l+k-<span class="number">1</span></span><br><span class="line">		<span class="keyword">return</span> A[s]</span><br><span class="line">	<span class="keyword">elif</span> s &gt; l+k-<span class="number">1</span></span><br><span class="line">		QuickSelect(A[l..s-<span class="number">1</span>], k)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		QuickSelect(A[s+<span class="number">1.</span>.r], l+k-<span class="number">1</span>-s)</span><br></pre></td></tr></table></figure>
<h4 id="特点-8"><a href="#特点-8" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>时间效率：和划分算法有关（对<em>Lomuto</em>算法）</p>
<ul>
<li>最好情况下只需要划分一次即找到，需要比较$n-1$次</li>
<li>最坏情况下需要比较$n(n-1)/2$次，这比直接基于排序更差</li>
<li>数学分析表明，基于划分的算法平均情况下效率是线性的</li>
</ul>
</li>
<li><p>已经找到复杂算法替代<em>Lomuto</em>算法用于在快速选择中选出
中轴，在最坏情况下仍保持线性时间效率</p>
</li>
<li><p>QuickSelect算法可以不用递归实现，且非递归版本中甚至
不需要调整参数k值，只需要最后<code>s == k-1</code>即可</p>
</li>
<li><p>减可变规模：<em>Lomuto</em>算法性质</p>
</li>
</ul>
<h2 id="线性表有序划分"><a href="#线性表有序划分" class="headerlink" title="线性表有序划分"></a>线性表有序划分</h2><h3 id="LomutoPartition"><a href="#LomutoPartition" class="headerlink" title="LomutoPartition"></a>LomutoPartition</h3><h4 id="算法-5"><a href="#算法-5" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>考虑子数组A[l..r]分为三段，按顺序排在中轴p之后</p>
<ul>
<li>小于p的元素，最后元素索引记为s</li>
<li>大于等于p的元素，最后元素索引记为i</li>
<li>未同p比较过元素</li>
</ul>
</li>
<li><p>从左至右扫描A[l..r]，比较其中元素和p大小</p>
<ul>
<li>若<code>A[i] &gt;= p</code>，扩大大于等于p元素段</li>
<li>若<code>A[i] &lt; p</code>，需要扩大小于等于p元素段</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LomutoPartition(A[l..r])</span><br><span class="line">	// 采用Lomuto算法，用首个元素作中轴划分数组</span><br><span class="line">	// 输入：可排序数组A[<span class="number">0.</span>.n-<span class="number">1</span>]的子数组A[l..r]</span><br><span class="line">	// 输出：A[l..r]的划分、中轴位置</span><br><span class="line">	p = A[l]</span><br><span class="line">	s = l</span><br><span class="line">	<span class="keyword">for</span> i = l+<span class="number">1</span> to r</span><br><span class="line">		<span class="keyword">if</span> A[i] &lt; p</span><br><span class="line">			s = s+<span class="number">1</span></span><br><span class="line">			swap(A[s], A[i])</span><br><span class="line">	swap(A[l], A[s])</span><br><span class="line">	<span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<h3 id="HoarePartition"><a href="#HoarePartition" class="headerlink" title="HoarePartition"></a>HoarePartition</h3><h4 id="算法-6"><a href="#算法-6" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>选择一个元素p作为中轴（最简单的，首个元素p=A[l]）</p>
</li>
<li><p>从数组A[l..r]两端进行扫描，将扫描到的元素同中轴比较</p>
<ul>
<li>从左至右的扫描忽略小于中轴元素，直到遇到大于等于中轴
元素停止（从第二个元素开始i=l+1）</li>
<li>从右至左的扫描忽略大于中轴元素，直到遇到小于等于中轴
元素停止(j=r-1)</li>
</ul>
</li>
<li><p>若扫描停止后</p>
<ul>
<li>两指针不相交i &lt; j，交换A[i]、A[j]，i=i+1、j=j-1，
继续扫描</li>
<li>若指针相交i &gt; j，把中轴和A[j]交换即得到数组一个划分
，分裂点为s=j</li>
<li>如果指针重合i==j，此元素一定等于p，也得到数组的一个
划分，分裂点为s==i==j</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">HoarePartition(A[l..r])</span><br><span class="line">	// 以首元素为中轴，对数组进行划分</span><br><span class="line">	// 输入：可排序数组A[<span class="number">1.</span>.n]的子数组A[l..r]</span><br><span class="line">	// 输出：A[l..r]的一个划分，返回分裂点位置</span><br><span class="line">	p = A[l]</span><br><span class="line">	i = l</span><br><span class="line">	j = r+<span class="number">1</span></span><br><span class="line">	repeat</span><br><span class="line">		repeat i = i+<span class="number">1</span> until A[i] &gt;= p</span><br><span class="line">			// 这里i有可能越界，可以添加一个限位器</span><br><span class="line">		repeat j = j-<span class="number">1</span> until j[i] &lt;= p</span><br><span class="line">			// 从左右两端都是遇到等于p的元素就停止扫描</span><br><span class="line">			// 这样可以保证即使数组中有许多和p相等的元素</span><br><span class="line">			// 也能够将数组划分得比较均匀</span><br><span class="line">		swap(A[i], A[j])</span><br><span class="line">			// 这样写没有关系，不需要在这里给调整i、j</span><br><span class="line">			// 因为循环下一步就是调整i、j</span><br><span class="line">	until i &gt;= j</span><br><span class="line">	swap(A[i], A[j])</span><br><span class="line">		// 撤销算法最后一次交换</span><br><span class="line">	swap(A[l], A[j])</span><br><span class="line">	<span class="keyword">return</span> j</span><br></pre></td></tr></table></figure>
<h3 id="三路划分"><a href="#三路划分" class="headerlink" title="三路划分"></a>三路划分</h3><h4 id="算法-7"><a href="#算法-7" class="headerlink" title="算法"></a>算法</h4></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-18T05:32:00.000Z" title="4/18/2019, 1:32:00 PM">2019-04-18</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-04-18T05:32:00.000Z" title="4/18/2019, 1:32:00 PM">2019-04-18</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Data-Structure/">Data Structure</a></span><span class="level-item">10 minutes read (About 1479 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Data-Structure/linear_list.html">Linear List</a></h1><div class="content"><h2 id="线性表综述"><a href="#线性表综述" class="headerlink" title="线性表综述"></a>线性表综述</h2><p>线性表：n个数据元素的有限序列</p>
<ul>
<li>元素个数n定义为线性表长度，n=0时称为空表</li>
<li>非空表中每个元素都有确定的位置</li>
</ul>
<h2 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h2><p>顺序存储结构/映像：使用一组地址连续的存储单元依次存储数据
元素</p>
<blockquote>
<ul>
<li>具体参见<em>algorithm/data_structure_intro</em></li>
</ul>
</blockquote>
<h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>顺序表：顺序存储结构的线性表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	ElemType *elem;</span><br><span class="line">	<span class="keyword">int</span> length;</span><br><span class="line">	<span class="keyword">int</span> listsize;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>以元素在计算机内<strong>物理位置相邻</strong>表示线性表中数据元素之间
的逻辑关系</p>
</li>
<li><p>每个数据元素存储位置和线性表起始位置，相差和其在线性表中
位序成正比常数，所以顺序表时一种<strong>随机存取</strong>存储结构</p>
<ul>
<li>高级程序语言中<strong>数组类型</strong>也有随机存取特点，因此通常
用数组描述</li>
</ul>
</li>
</ul>
<h4 id="时间效率"><a href="#时间效率" class="headerlink" title="时间效率"></a>时间效率</h4><ul>
<li>插入/删除：$O(n)$<ul>
<li>主要时间耗费在移动元素上</li>
</ul>
</li>
<li>求表长：$O(1)$</li>
<li>取第n个元素：$O(1)$</li>
</ul>
<h2 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h2><p>链式/非顺序存储结构/映像：用一组<strong>任意</strong>存储单元存储线性表
中数据元素，还需存储一个指示其直接后继的信息</p>
<blockquote>
<ul>
<li>具体参见<em>algorithm/data_structure_intro</em></li>
</ul>
</blockquote>
<h3 id="（线性-单）链表"><a href="#（线性-单）链表" class="headerlink" title="（线性/单）链表"></a>（线性/单）链表</h3><p>线性链表：n个节点链接而成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure>
<ul>
<li>链表中每个节点只包含一个指针域<ul>
<li>数据元素之间的逻辑关系由节点中指针指示，即指针为数据
元素之间的逻辑关系映像</li>
</ul>
</li>
<li>整个链表存取必须从头指针开始</li>
<li>单链表中任何两个元素存储位置之间没有固定联系，是非随机
存取存储结构</li>
</ul>
<blockquote>
<ul>
<li>头指针：指示链表中第一个节点的存储位置</li>
<li>头节点：在单链表第一个节点之前附设的节点，其数据域可以
  不存储信息，也可以存储线性表长度、尾指针等附加信息</li>
</ul>
</blockquote>
<h4 id="时间效率-1"><a href="#时间效率-1" class="headerlink" title="时间效率"></a>时间效率</h4><ul>
<li>插入、删除：$O(n)$<ul>
<li>已知插入、删除元素确切位置的情况下，仅需修改指针，
而不需要移动元素</li>
</ul>
</li>
<li>取第n个元素：$O(n)$<ul>
<li>访问时间依赖元素在列表中位置</li>
</ul>
</li>
</ul>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul>
<li><p>在很多场合下，链表是线性表的首选结构</p>
<ul>
<li>链表不需要事先分配任何存储空间，空间利用合理</li>
<li>插入、删除效率高，只需要重连相关指针</li>
</ul>
</li>
<li><p>但是存在一些实现问题</p>
<ul>
<li>求线性表长不如顺序存储结构</li>
</ul>
</li>
<li><p>链表中结点关系使用指针表示，数据元素在线性表中“位序”
概念淡化，被“位置”代替</p>
</li>
</ul>
<p>因此重新定义带头结点的线性链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;*Link, * Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Link head, tail;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单链表注意事项"><a href="#单链表注意事项" class="headerlink" title="单链表注意事项"></a>单链表注意事项</h4><ul>
<li><p>头结点/头指针：处理链表非常方便的技巧</p>
<ul>
<li>头指针指向链表首个结点：便于调整首个节点位置时，仍然
<strong>记住链表</strong></li>
<li>头指针不包含链表信息，本质不属于链表：有些情况下方便
统一代码，不需要特殊考虑链表首个节点</li>
</ul>
</li>
<li><p>对链表进行<strong>可能改变链表的遍历</strong>操作：一般使用两个标记
结点/指针</p>
<ul>
<li>头结点/指针<code>lstart</code>：记住链表</li>
<li>遍历标记指针<code>cur</code>：标记处理结点</li>
</ul>
</li>
<li><p>交换节点：标记指针需要指向<strong>当前处理节点的前一个结点</strong></p>
<ul>
<li>单链表中只有指向下个节点的指针，若标记指针指向当前
节点，则无法方便将链表同当前节点断开、重连</li>
<li>注意<strong>待交换两个节点为同一节点</strong>的情况：不同于值交换
，这种情况可能导致链表<strong>错误连接成环</strong></li>
</ul>
</li>
<li><p>无指针、纯引用对象语言（<code>python</code>）中：只能使用节点对象
遍历链表</p>
<ul>
<li>变量为<strong>链表中节点引用</strong>：使用类似普通指针，需要注意
别修改引用节点数据</li>
<li>变量为<strong>额外节点引用</strong>：内存类似普通指针，使用时注意
解析引用次数</li>
</ul>
</li>
</ul>
<h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>静态链表：使用数组描述的链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">int</span> cur;</span><br><span class="line">&#125;component, SLinkList[MAXSIZE];</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>数组分量表示节点</li>
<li>使用游标<code>cur</code>作为指针域指示节点在链表中的逻辑位置</li>
<li>第0个分量表示头节点，其指针域<code>cur</code>指向链表第一个节点</li>
</ul>
</blockquote>
<ul>
<li>方便在无指针高级语言中使用链式结构</li>
<li>为确定未使用的数组分量，可以将未被使用的、删除的分量用
游标链成备用边表</li>
</ul>
<h3 id="Circular-Linked-List"><a href="#Circular-Linked-List" class="headerlink" title="Circular Linked List"></a><em>Circular Linked List</em></h3><p>循环链表：表中最后一个节点指针域指向头节点，整个链表形成环</p>
<ul>
<li>循环链表和线性链表操作基本一致<ul>
<li>仅循环条件不再是指针域为空，而是是否等于头指针</li>
</ul>
</li>
</ul>
<h3 id="Double-Linked-List"><a href="#Double-Linked-List" class="headerlink" title="Double Linked List"></a><em>Double Linked List</em></h3><p>双向链表：链表中有两个指针域，分别指向直接后继、直接前驱</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	Struct DulNode * prior;</span><br><span class="line">	Struct DulNode * next;</span><br><span class="line">&#125;DuLNode, * DuLinkList;</span><br></pre></td></tr></table></figure>
<ul>
<li>双向链表克服线性链表寻找直接前驱时间$O(n)$的缺点</li>
<li>双向链表大部分操作和线性链表相同，指示有些操作需要同时
修改两个指针</li>
</ul>
<ul>
<li>字符串：数组实现的一种数据结构<ul>
<li>字符串常见操作不同于其他数组<ul>
<li>计算字符串长度</li>
<li>按照字典序确定字符串排序时位置</li>
<li>连接字符串构</li>
</ul>
</li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-12T08:01:20.000Z" title="4/12/2019, 4:01:20 PM">2019-04-12</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-04-12T08:01:20.000Z" title="4/12/2019, 4:01:20 PM">2019-04-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Problem/">Problem</a></span><span class="level-item">an hour read (About 9286 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Problem/graph.html">图算法</a></h1><div class="content"><h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><ul>
<li>图的遍历算法：如何一次访问到网络中所有节点</li>
<li>最短路线算法：两个城市间最佳路线</li>
<li>有向图拓扑排序：课程、预备课程是否有矛盾</li>
<li>All-Pairs Shortest-Paths Problem：完全最短路径问题，找到
每个顶点到其他所有顶点的距离</li>
</ul>
<h2 id="遍历算法"><a href="#遍历算法" class="headerlink" title="遍历算法"></a>遍历算法</h2><h3 id="Depth-First-Search"><a href="#Depth-First-Search" class="headerlink" title="Depth-First Search"></a>Depth-First Search</h3><p>深度优先查找（DFS）</p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>从<strong>任意顶点</strong>开始访问图顶点，然后标记为已访问</p>
</li>
<li><p>每次迭代时，紧接着处理与当前顶点<strong>邻接的未访问顶点</strong>，
直到遇到终点，该顶点所有邻接顶点均已访问过</p>
</li>
<li><p>在终点上，算法<strong>沿着来路</strong>后退一条边，继续从那里访问未
访问顶点</p>
</li>
<li><p>后退到<strong>起始点</strong>，且起始点也是终点时，算法停止，这样
起始点所在的连通分量的所有顶点均已访问过</p>
</li>
<li><p>若存在未访问顶点，则必须从其中任一顶点开始重复上述</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line">	<span class="comment">// 全局变量：访问次序（次数）</span></span><br><span class="line">DFS(G)</span><br><span class="line">	<span class="comment">// 对给定图的深度优先查找遍历</span></span><br><span class="line">	<span class="comment">// 输入：图G=&lt;V, E&gt;</span></span><br><span class="line">	<span class="comment">// 输出：图G顶点按照DFS遍历第一次访问到的先后次序，</span></span><br><span class="line">	<span class="comment">//       未访问到标记未0</span></span><br><span class="line">	<span class="keyword">for</span> each vertex v in V <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span> v is marked with <span class="number">0</span></span><br><span class="line">			dfs(v)</span><br><span class="line">dfs(v)</span><br><span class="line">	<span class="comment">// 递归访问所有和v相连接的未访问顶点，赋予count值</span></span><br><span class="line">	count = count+<span class="number">1</span></span><br><span class="line">	mark v with count</span><br><span class="line">	<span class="keyword">for</span> each vertex w in V adjecnt to v <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span> w is marked with <span class="number">0</span></span><br><span class="line">			dfs(w)</span><br></pre></td></tr></table></figure>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>算法效率非常高效，消耗时间和表示图的数据结构规模成正比</p>
<ul>
<li>邻接矩阵：遍历时间效率$\in \Theta(|V|^2)$</li>
<li>邻接链表：遍历时间效率$\in \Theta(|V|+|E|)$</li>
</ul>
</li>
<li><p>可以方便地用栈跟踪深度优先查找</p>
<ul>
<li>首次访问顶点，将顶点入栈</li>
<li>当顶点成为终点时，将其出栈</li>
<li>运行时就是实际上就是栈，所以深度优先可以直接利用递归
实现</li>
</ul>
</li>
<li><p><em>Depth-First Search Foreat</em>：参见
<em>algorithm/data_structure/graph</em></p>
</li>
<li><p>DFS产生两种节点排列顺序性质不同，有不同应用</p>
<ul>
<li>入栈（首次访问顶点）次序</li>
<li>出栈（顶点成为终点）次序</li>
</ul>
</li>
</ul>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul>
<li>检查图连通性：算法第一次停止后，是否所有顶点已经访问</li>
<li>检查图无环性：DFS是否包含回边</li>
<li>拓扑排序：见<em>键值法</em><ul>
<li>DFS节点出栈逆序就是拓扑排序的一个解（图中无回边，
即为有向无环图）</li>
<li>DAG中顶点v出栈前，不存在顶点u拥有到v的边，否则存在
回边，图不是DAG</li>
</ul>
</li>
</ul>
<h3 id="Broad-First-Search"><a href="#Broad-First-Search" class="headerlink" title="Broad-First Search"></a>Broad-First Search</h3><p>广度优先查找（BFS）</p>
<h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>首先访问所有和初始顶点邻接的顶点</p>
</li>
<li><p>然后是离它两条边的所有未访问顶点</p>
</li>
<li><p>以此类推，直到所有与初始顶点在同一连通分类顶点均已访问</p>
</li>
<li><p>若存在未访问顶点，从图其他连通分量任意顶点开始</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line">	<span class="comment">// 全局变量：访问次序（次数）</span></span><br><span class="line">BFS(G)</span><br><span class="line">	<span class="comment">// 给定图广度优先查找变量</span></span><br><span class="line">	<span class="comment">// 输入：图G=&lt;V, E&gt;</span></span><br><span class="line">	<span class="comment">// 输出：图G的顶点按照被BFS遍历第一次访问到次序，</span></span><br><span class="line">	<span class="comment">//       未访问顶点标记未0</span></span><br><span class="line">	<span class="keyword">for</span> each vertax v in V <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span> v is marked with <span class="number">0</span></span><br><span class="line">			bfs(v)</span><br><span class="line">bfs(v)</span><br><span class="line">	<span class="comment">// 访问所有和v相连接的顶点，赋count值</span></span><br><span class="line">	count = count+<span class="number">1</span></span><br><span class="line">	whilte <span class="built_in">queue</span> is <span class="keyword">not</span> empty <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">for</span> each vertex w in V adjcent to the front vertex <span class="keyword">do</span></span><br><span class="line">			<span class="keyword">if</span> w is marked with <span class="number">0</span></span><br><span class="line">				count = count+<span class="number">1</span></span><br><span class="line">				mark w with count</span><br><span class="line">				add w to the <span class="built_in">queue</span></span><br><span class="line">		remove the front vertex from the <span class="built_in">queue</span></span><br></pre></td></tr></table></figure>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>算法效率同DFS</p>
<ul>
<li>邻接矩阵：遍历时间效率$\in \Theta(|V|^2)$</li>
<li>邻接链表：遍历时间效率$\in \Theta(|V|+|E|)$</li>
</ul>
</li>
<li><p>使用队列可以方便地跟踪广度优先查找操作</p>
<ul>
<li>从遍历初始顶点开始，标记、入队</li>
<li>每次迭代时，算法查找所有和队头顶点邻接未访问，标记
、入队、将队头顶点出队</li>
</ul>
</li>
<li><p><em>Breadth-First Search Forest</em>：参见
<em>algorithm/data_struture/graph</em></p>
</li>
<li><p>BFS只产生顶点的一种排序，因为队列时FIFO结构，顶点入队、
出队次序相同</p>
</li>
</ul>
<h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><ul>
<li><p>和DFS一样可以检查图的连通性、无环性，但是无法用于比较
复杂的应用</p>
</li>
<li><p>求给定两个顶点间最短路径：从一顶点开始BFS遍历，访问到
另一节点结束（难以证明？）</p>
</li>
</ul>
<h2 id="有向图强连通分量"><a href="#有向图强连通分量" class="headerlink" title="有向图强连通分量"></a>有向图强连通分量</h2><h3 id="Kosaraju算法"><a href="#Kosaraju算法" class="headerlink" title="Kosaraju算法"></a>Kosaraju算法</h3><p>考虑有向图中强连通分量之间不连通的情况</p>
<ul>
<li><p>强连通分量之间没有边</p>
<ul>
<li><p>在任意连通分量中任意结点开始深度优先遍历</p>
</li>
<li><p>访问完所有结点需要DFS次数就是强连通分量数量，每轮
DFS访问的点就是强连通分量中的顶点</p>
</li>
</ul>
</li>
<li><p>强连通分量之间只有单向边</p>
<ul>
<li><p>将强连通分量视为<strong>单个结点</strong>，则整个图可以视为一个
靠连通分量间单向边连接的有向无环图</p>
</li>
<li><p>从最底层强连通分量中任选结点开始进行DFS，则此轮DFS
只能访问当前连通分量中结点</p>
</li>
<li><p>逆序依次在各强连通分量中选择结点进行DFS，则每轮DFS只
访问当前连通分量中结点（其下层连通分量已访问）</p>
</li>
<li><p>直至所有结点访问完毕，则得到所有强连通分量，即每轮
进行DFS访问的结点</p>
</li>
<li><p>以下图为例，从图中连通分量B中任意结点开始进行DFS，
则经过两轮DFS即能找所有强连通分量</p>
<p><img src="/imgs/strongly_connected_two_components.png" alt="strongly_connected_two_components"></p>
</li>
</ul>
</li>
</ul>
<p>由以上分析</p>
<ul>
<li><p>只需要保证<strong>底层强连通分量进行DFS优先搜索</strong></p>
</li>
<li><p>也即在结点搜索优先级中，底层强连通分量中至少有一个结点
在其上层连通分量所有结点之前</p>
</li>
<li><p>可以利用<strong>原图的反向</strong>的DFS<strong>逆后序排列</strong>得到满足条件
的结点优先级序列</p>
<p><img src="/imgs/strongly_connected_two_components_reversed.png" alt="strongly_connected_two_components_reversed"></p>
<ul>
<li><p>若从反向图中最底层强连通分量某结点开始，则只能遍历
自身，反向图中其余连通分量位于其所有结点之前</p>
</li>
<li><p>若从反向图中非最底层强连通分量某结点开始，则能依次
遍历其底层所有强连通分量中结点，且至少该结点位于其余
连通分量所有结点之前</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>逆后序排列参见<em>algorithm/data_structure/graph</em></li>
</ul>
</blockquote>
<h4 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h4><ul>
<li>对原图G每条路径求反，得到反向图$G^R$</li>
<li>对反向图$G^R$求解逆后序序列</li>
<li>按照逆序序列优先级，对原图G进行DFS，每棵DFS生成树就是
一个强连通分量</li>
</ul>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul>
<li>算法效率<ul>
<li>时间效率$\in O(|V| + |E|)$</li>
<li>算法需要对图进行两次DFS，速度较Tanjar算法更慢</li>
</ul>
</li>
</ul>
<h3 id="Tarjan算法"><a href="#Tarjan算法" class="headerlink" title="Tarjan算法"></a>Tarjan算法</h3><p>Tarjan算法：基于图深度优先搜索的算法</p>
<ul>
<li><p>为每个结点维护两个标记，通过此标记确定是否存在回路</p>
<ul>
<li><code>DFN</code>：深度优先搜索中搜索到次序</li>
<li><code>Low</code>：通过回边能访问到的前驱被搜索到的次序</li>
</ul>
<blockquote>
<ul>
<li>还可以维护一个<code>Flag</code>，判断结点是否仍在DFS栈中</li>
</ul>
</blockquote>
</li>
<li><p>对图进行深度优先搜索</p>
<ul>
<li><p>未处理结点入栈，设置其<code>DFN</code>、<code>Low</code>被搜索到的次序</p>
</li>
<li><p>对已处理结点，考虑到深度优先的搜索、退栈方式</p>
<ul>
<li><p>仍然在栈中，则肯定是栈顶元素前驱，连接边为回边，
存在<strong>栈顶节点到该前驱结点的回路</strong></p>
</li>
<li><p>不在栈中，该节点不是祖先结点，连接边为交叉边，
该结点已经在其他连通分量中出栈</p>
</li>
</ul>
</li>
<li><p>使用栈中前驱结点<code>Low/DFN</code>次序更新当前（栈顶）结点，
并递归更新，即使用<strong>子节点访问先驱次序更新父节点</strong></p>
</li>
</ul>
</li>
<li><p>DFS回溯、退栈，考虑栈中每个结点<code>DFN</code>、<code>Low</code></p>
<ul>
<li><p>若<code>DFN[u] &gt; Low[u]</code>：结点<code>u</code>和其<strong>前驱</strong>之间有回路，
即其属于同一个强连通分量</p>
</li>
<li><p>若<code>DFN[u] ==  Low[u]</code>：结点<code>u</code>和其前驱之间没有通路，
没有更多结点属于其所属强连通分量，以结点<code>u</code>为根子树
是一个强连通分量</p>
<ul>
<li>则从栈顶元素开始退栈直至结点<code>u</code>退栈，退栈的所有
元素构成强连通分量</li>
</ul>
</li>
</ul>
</li>
<li><p>每个强连通分量为深度优先搜索树中一个子树</p>
</li>
</ul>
<script type="math/tex; mode=display">
Low[v] = \min\{DFN[v], Low[w], DFN[k]\}</script><blockquote>
<ul>
<li>$w, (w, v) \in E$：顶点v的直接前驱</li>
<li>$k, (v, k) \in E$：顶点v的祖先（即栈中结点）</li>
</ul>
</blockquote>
<h4 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">S = initStack()</span><br><span class="line">DFN[MAX_VERTAX], Low[MAX_VERTEX]</span><br><span class="line">index = <span class="number">0</span></span><br><span class="line">QList = InitList(Queue())</span><br><span class="line"></span><br><span class="line">tarjan(u, E):</span><br><span class="line">	<span class="comment">// 比较DFS搜索次序、回边到达次序判断强连通分量</span></span><br><span class="line">	<span class="comment">// 输入：结点u，边集合E</span></span><br><span class="line">	<span class="comment">// 输出：强连通分量队列列表</span></span><br><span class="line">	DFN[u] = Low[u] = ++ index</span><br><span class="line">	S.push(u)</span><br><span class="line">	<span class="keyword">for</span> each (u, v) in E:</span><br><span class="line">		<span class="keyword">if</span> (v is <span class="keyword">not</span> visited):</span><br><span class="line">			tarjan(v)</span><br><span class="line">			Low[u] = min(Low[u], Low[v])</span><br><span class="line">			<span class="comment">// 使用v找到的前驱更新u能找到前驱，递归更新</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (v in S):</span><br><span class="line">			<span class="comment">// 判断边是否为回边</span></span><br><span class="line">			Low[u] = min(Low[u], DFN[v])</span><br><span class="line">			<span class="comment">// Low[u] = min(Low[u], Low[v])</span></span><br><span class="line">				<span class="comment">// 应该也行</span></span><br><span class="line">	<span class="keyword">if</span>(DFN[u] == Low[u]):</span><br><span class="line">		Q = QList.next()</span><br><span class="line">		repeat</span><br><span class="line">			v = S.pop()</span><br><span class="line">			Q.push(v)</span><br><span class="line">		until (u == v)</span><br></pre></td></tr></table></figure>
<h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><ul>
<li>算法效率<ul>
<li>时间效率$\in O(|V|+|E|)$</li>
</ul>
</li>
</ul>
<h2 id="关节点"><a href="#关节点" class="headerlink" title="关节点"></a>关节点</h2><h3 id="类Tarjan算法"><a href="#类Tarjan算法" class="headerlink" title="类Tarjan算法"></a>类Tarjan算法</h3><ul>
<li>类似Tarjan算法为每个节点维护<code>DFN</code>、<code>Low</code>两个次序<ul>
<li>对非根结点v，<strong>存在</strong>其直接后继w有<code>Low[w] &gt;= DFN[v]</code>
，则v为关节点</li>
<li>对根节点，有两棵以上子树则为关节点</li>
</ul>
</li>
</ul>
<h4 id="算法-4"><a href="#算法-4" class="headerlink" title="算法"></a>算法</h4><p>此算法具体实现和Tarjan算法细节有差异</p>
<ul>
<li>此算法中不需要使用栈保存访问过顶点中是前驱者<ul>
<li>连通无向图DFS只会有回边，已访问点必然是前驱结点</li>
</ul>
</li>
<li>需要对根结点额外判断是否为关节点</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">DFN[MAX_VERTAX], Low[MAX_VERTEX]</span><br><span class="line">index = <span class="number">0</span></span><br><span class="line">Q = InitQueue()</span><br><span class="line"></span><br><span class="line">FindArticul(G):</span><br><span class="line">	<span class="comment">// 输入：无向连通图G</span></span><br><span class="line">	<span class="comment">// 输出：关节点队列</span></span><br><span class="line">	vroot = G.V.pop()</span><br><span class="line">	TarjanArticul(vroot, G)</span><br><span class="line">	<span class="keyword">for</span>(v in G.V <span class="keyword">if</span> v <span class="keyword">not</span> visited)</span><br><span class="line">		<span class="comment">// 根节点有两棵及以上子树</span></span><br><span class="line">		TarjanAricul(vroot, G)</span><br><span class="line">		Q.push(vroot)</span><br><span class="line">		<span class="comment">// 根节点也是关节点</span></span><br><span class="line">	<span class="keyword">return</span> Q</span><br><span class="line"></span><br><span class="line">TarjanArticul(u, G):</span><br><span class="line">	<span class="comment">// 比较DFS搜索次序、回边到达次序判断关节点</span></span><br><span class="line">	<span class="comment">// 输入：结点u，无向连通图G</span></span><br><span class="line">	<span class="comment">// 输出：关节点队列</span></span><br><span class="line">	DFN[u] = Low[u] = ++ index</span><br><span class="line">	<span class="keyword">for</span> each (u, v) in G.E:</span><br><span class="line">		<span class="keyword">if</span> (v is <span class="keyword">not</span> visited):</span><br><span class="line">			tarjan(v)</span><br><span class="line">			Low[u] = min(Low[u], Low[v])</span><br><span class="line">			<span class="comment">// 使用v找到的前驱更新u能找到前驱，递归更新</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			Low[u] = min(Low[u], DFN[v])</span><br><span class="line">			<span class="comment">// Low[u] = min(Low[u], Low[v])</span></span><br><span class="line">				<span class="comment">// 应该也行</span></span><br><span class="line">	<span class="keyword">for</span>(v connected by u)</span><br><span class="line">		<span class="keyword">if</span>(Low[v] &lt;= DFN[u])</span><br><span class="line">			Q.push(u)</span><br><span class="line">	<span class="keyword">return</span> Q</span><br></pre></td></tr></table></figure>
<h2 id="无权路径"><a href="#无权路径" class="headerlink" title="无权路径"></a>无权路径</h2><h3 id="路径数量"><a href="#路径数量" class="headerlink" title="路径数量"></a>路径数量</h3><p>图中顶点i到顶点j之间长度为k的不同路径数量为$A^k[i, j]$</p>
<ul>
<li>A为图的邻接矩阵</li>
<li>可以使用数学归纳法证明</li>
<li>对无向、有向图均适用</li>
</ul>
<h3 id="Warshall算法"><a href="#Warshall算法" class="headerlink" title="Warshall算法"></a>Warshall算法</h3><p>Warshall算法：生成有向图传递闭包</p>
<ul>
<li><p>构造n+1个n阶布尔矩阵$R^{(k)}, k=0,1,\cdots, n$</p>
<ul>
<li><p>$R^{(k)}_{ij}=1$：顶点i、j直接存在中间顶点<strong>编号</strong>
不大于k的有效路径</p>
</li>
<li><p>$R^{(0)}$：邻接矩阵，顶点直接连接</p>
</li>
<li><p>$R^{(k)}, 0&lt;k&lt;n$：路径中间顶点编号最大为<code>k</code></p>
</li>
<li><p>$R^{(n)}$：传递闭包，允许所有类型路径</p>
</li>
<li><p>后继矩阵相对前趋，允许作为路径上顶点增加，可能包含
1数量更多</p>
</li>
</ul>
</li>
<li><p>考虑$R^{(k)}$通过直接前趋$R^{(k-1)}$计算得到</p>
<ul>
<li><p>$R^{(k-1)}$中已有路径在$R^{(k)}$保留</p>
</li>
<li><p>考虑$R^{(k)}$相较于$R^{(k-1)}$新增$r_{ij}=1$</p>
<ul>
<li><p>表示顶点i、j之间存在包含k的路径</p>
</li>
<li><p>若k在路径中出现多次，则将删除回路，得到新路径</p>
</li>
<li><p>则存在ik和kj之间路径满足中间顶点编号小于k，即在
$R^{(k-1)}$中有$r<em>{ik}=1, r</em>{kj}=1$</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="算法-5"><a href="#算法-5" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>若元素$r_{ij}$在$R^{(k-1)}$中为1，则在$R^{(k)}$也是1</p>
</li>
<li><p>若元素$r<em>{ij}$在$R^{(k-1)}$中为0，当且仅当存在v使得
$R^{(k-1)}$中$r</em>{iv}=1, r_{vj}=1$</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Warshall(A[<span class="number">1.</span>.n, <span class="number">1.</span>.n])</span><br><span class="line">	<span class="comment">// 计算传递闭包的Warshall算法</span></span><br><span class="line">	<span class="comment">// 输入：A[1..n, 1..n]包含n个顶点的有向图的邻接矩阵</span></span><br><span class="line">	<span class="comment">// 输出：A的传递闭包</span></span><br><span class="line">	R^<span class="number">0</span> = A</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">for</span> i = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">			<span class="keyword">for</span> j = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">				<span class="keyword">if</span> R^(k<span class="number">-1</span>)[i, j] == <span class="number">1</span> <span class="keyword">or</span></span><br><span class="line">					(R^(k<span class="number">-1</span>)[i, k] == <span class="number">0</span> <span class="keyword">and</span> R^(k<span class="number">-1</span>)[k, j] == <span class="number">0</span>)</span><br><span class="line">					R^k[i, j] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> R^n</span><br></pre></td></tr></table></figure>
<h4 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>算法效率</p>
<ul>
<li>时间效率$\in \Theta(n^3)$<ul>
<li>重新构造最内层循环，可以提高对某些输入的处理速度</li>
<li>将矩阵行视为位串，使用或运算也可以加速</li>
</ul>
</li>
<li>空间效率取决于如何处理布尔矩阵</li>
</ul>
</li>
<li><p>蛮力法：所有点分别作为起点作一次搜索，记录能够访问的顶点</p>
<ul>
<li>对有向图遍历多次</li>
<li>使用邻接链表表示稀疏图，蛮力法渐进效率好于Warshall算法</li>
</ul>
</li>
</ul>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><p>Prim算法：求解最小图最小生成树算法</p>
<ul>
<li>每次添加距离当前树距离最近顶点进树</li>
<li>不断迭代构造最小生成树</li>
</ul>
<h4 id="算法-6"><a href="#算法-6" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>从图顶点集V中任选单顶点作为序列中初始子树</p>
</li>
<li><p>对图中顶点维护两个标记：树中最近顶点、相应距离</p>
<ul>
<li>与树不直接相连顶点置：<code>NULL</code>、$\infty$</li>
<li>每次添加新节点更新两个标记</li>
<li>可使用优先队列维护提高效率</li>
</ul>
</li>
<li><p>以贪婪的方式扩张当前生成树，添加不在树中的<strong>最近顶点</strong></p>
</li>
<li><p>更新顶点和树距离最近的顶点、相应距离</p>
<ul>
<li>只需考察与新添加顶点直接相连顶点即可</li>
</ul>
</li>
<li><p>不断迭代直到所有点都在树中</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Prim(G):</span><br><span class="line">	<span class="comment">// 构造最小生成树Prim算法</span></span><br><span class="line">	<span class="comment">// 输入：加权连通图G=&lt;V, E&gt;</span></span><br><span class="line">	<span class="comment">// 输出：E_T, 组成G最小生成树的边集合</span></span><br><span class="line">	V_T = &#123;v_0&#125;</span><br><span class="line">		<span class="comment">// 使用任意顶点初始化树顶点集合</span></span><br><span class="line">	E_T = <span class="literal">NULL</span></span><br><span class="line">		<span class="comment">// 初始化生成树边为空集</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span> to |V|</span><br><span class="line">		<span class="keyword">if</span> i connect V_T</span><br><span class="line">			connect_V[i] = <span class="number">0</span></span><br><span class="line">			connect_D[i] = e(<span class="number">0</span>, i)</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			connect_V[i] = <span class="literal">NULL</span></span><br><span class="line">			connect_D[i] = \infty</span><br><span class="line">	<span class="comment">// 初始化节点和树最近节点列表、节点与树距离列表</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span> to |V|<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">		<span class="comment">// 重复n-1次，直到树包含所有顶点</span></span><br><span class="line">		edge = min(connect_D)</span><br><span class="line">			<span class="comment">// 寻找距离树最近的点</span></span><br><span class="line">		v = vertex(edge)</span><br><span class="line"></span><br><span class="line">		V_T = V_T <span class="keyword">union</span> &#123;v&#125;</span><br><span class="line">		E_T = E_T <span class="keyword">union</span> &#123;edge&#125;</span><br><span class="line"></span><br><span class="line">		connect_V[v] = <span class="literal">NULL</span></span><br><span class="line">		connect_D[v] = \infty</span><br><span class="line">		更新和v相连的顶点两个标记值</span><br><span class="line">	<span class="keyword">return</span> E_T</span><br></pre></td></tr></table></figure>
<h4 id="算法特点-1"><a href="#算法特点-1" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>算法时间效率依赖实现优先队列、存储图数据结构</p>
<ul>
<li>图权重矩阵、优先队列无序数组$\in \Theta(|V|^2)$</li>
<li>图邻接链表、二叉最小堆$\in O(|E|log|V|)$</li>
<li>图邻接链表、Fibonacci Heap $\in O(|E| + |V|log|V|)$</li>
</ul>
</li>
<li><p>对树进行扩展时用到的边的集合表示算法生成树</p>
</li>
<li><p>穷举查找构造生成树，生成树数量呈指数增长，且构造生成树
不容易</p>
</li>
</ul>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>Kruskal算法：把最小生成树看作是具有$|V|-1$条边、且边权重最小
的无环子图，通过对子图不断扩展构造最小生成树</p>
<h4 id="算法-7"><a href="#算法-7" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>按照权重非递减顺序对图中边排序</p>
</li>
<li><p>从空子图开始扫描有序列表，试图把列表中下条边加到当前子图
中，如果添加边导致回路则跳过</p>
</li>
<li><p>不断添加边直到达到$|V|-1$</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Kruskal(G)</span><br><span class="line">	<span class="comment">// 构造最小生成树的Kruskal算法</span></span><br><span class="line">	<span class="comment">// 输入：G=&lt;V, E&gt;加权连通图</span></span><br><span class="line">	<span class="comment">// 输出：E_T，组成G的最小生成树边集</span></span><br><span class="line">	reverse_sort([w(e_i)])</span><br><span class="line">		<span class="comment">// 按照边权非递减顺序对边集排序</span></span><br><span class="line">	E_T = <span class="literal">NULL</span></span><br><span class="line">	ecounter = <span class="number">0</span></span><br><span class="line">	k = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> ecounter &lt; |V|<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">		k += <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> E_T <span class="keyword">union</span> &#123;e_k&#125; 无回路</span><br><span class="line">			<span class="comment">// 常用并查算法检查`e_k`连接的两个顶点是否在</span></span><br><span class="line">			<span class="comment">// 同一棵树（并查集）中</span></span><br><span class="line">			E_T = E_T <span class="keyword">union</span> &#123;e_k&#125;</span><br><span class="line">			ecounter += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span>  E_T</span><br></pre></td></tr></table></figure>
<h4 id="算法特点-2"><a href="#算法特点-2" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>Kruskal每次迭代都需要检查添加新边是否会导致回路，其实
效率不一定比Prim算法高</p>
</li>
<li><p>Kruskal算法中间阶段会生成一系列无环子图（树）</p>
<ul>
<li>子图不总是联通的</li>
<li>可以看作是对包含给定图所有顶点、部分边的森林所作的
连续动作</li>
<li>初始森林由|V|棵普通树构成，包含单独顶点</li>
<li>最终森林为单棵树，包含图中所有顶点</li>
<li>每次迭代从图的边有序列表中取出下条边，找到包含其端点
的树，若不是同一棵树，则加入边生成一棵更大的树</li>
</ul>
</li>
<li><p>算法效率</p>
<ul>
<li>如果检查顶点是否位于同一棵树算法高效，则算法运行时间
取决于排序算法，时间效率$\in O(|E|log|E|)$</li>
</ul>
</li>
</ul>
<h3 id="Sollin算法"><a href="#Sollin算法" class="headerlink" title="Sollin算法"></a>Sollin算法</h3><p>Sollin算法：Prim算法、Kruskal算法的结合，将图每个顶点视为
子树，每次添加多条边合并子树直至得到最小生成树</p>
<h4 id="算法-8"><a href="#算法-8" class="headerlink" title="算法"></a>算法</h4><ul>
<li>将图中每个顶点视为一棵树，整个图表示森林$F^{(0)}$</li>
<li>为森林$F$中每棵树选择最小代价边<strong>合并</strong>两棵树</li>
<li>重复以上，直至所有树合并为一棵树</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Sollin(G):</span><br><span class="line">	<span class="comment">// 无向图最小生成树Sollin算法</span></span><br><span class="line">	<span class="comment">// 输入：无向图G</span></span><br><span class="line">	<span class="comment">// 输出：最小生成树边集</span></span><br><span class="line">	MST_E = <span class="literal">NULL</span></span><br><span class="line">	Forest = G.V</span><br><span class="line">	<span class="keyword">while</span> |MST_E| &lt; |G.V|:</span><br><span class="line">		<span class="keyword">for</span> tree in Forest:</span><br><span class="line">			e = find_min(G.E)</span><br><span class="line">			tree_b = get_tree(e)</span><br><span class="line">			MET_E.add(e)</span><br><span class="line">			tree.<span class="keyword">union</span>(tree_b)</span><br></pre></td></tr></table></figure>
<h1 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h1><h4 id="算法特点-3"><a href="#算法特点-3" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li>算法效率<ul>
<li>每轮子树数量减少一半，则最多重复<code>log|V|</code>轮算法终止</li>
<li>时间效率$\in O(|E|log|V|)$</li>
</ul>
</li>
</ul>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p>Dijkstra算法：求解单起点、<strong>权值非负</strong>最短路径算法</p>
<ul>
<li><p>按照从给定起点到图中各顶点的距离，<strong>顺序</strong>求出离起始点
最近的顶点、相应最短路径</p>
</li>
<li><p>第i次迭代前，算法已经确定了i-1条连接起点、离起点前i-1近
顶点的最短路径</p>
<ul>
<li>这些构成了给定图的一棵子树$T_i$</li>
<li>可以在同$T_i$顶点邻接的顶点中找到和起点最接近的顶点
（边权非负）</li>
</ul>
</li>
<li><p>算法类似于Prim算法，两个对代价评价标准不同</p>
<ul>
<li>Dijkstra算法是各条路径长度：有重复边，考虑整个路径</li>
<li>Prim算法是评价各边总和：无重复边，只考虑一条边</li>
</ul>
</li>
</ul>
<h4 id="算法-9"><a href="#算法-9" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>对顶点维护两个标记：起点到该顶点最短路径长度<code>d</code>、路径上
前个顶点<code>pre_v</code></p>
<ul>
<li>一般使用优先队列维护最短路径长度</li>
<li>对所有顶点维护：$\infty$、<code>NULL</code>标记不在树中、不与树
邻接顶点</li>
<li>仅对生成树中顶点、邻接顶点维护：每次迭代更新列表</li>
</ul>
</li>
<li><p>根据标记选择邻接顶点中和起始点距离<code>d</code>最小顶点，添加进树</p>
</li>
<li><p>更新顶点标记</p>
<ul>
<li>因为生成树只新添加一个顶点，只需要考虑与新添加顶点
直接相连、未在树中顶点</li>
<li>比较与起始点距离是否改变</li>
</ul>
</li>
<li><p>不断迭代直至所有点均在树中</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Dijkstra(G, s)</span><br><span class="line">	<span class="comment">// 单起点最短路径Dijkstra算法</span></span><br><span class="line">	<span class="comment">// 输入：G=&lt;V, E&gt;非负权重加权连通图，顶点s起始点</span></span><br><span class="line">	<span class="comment">// 输出：对V中每个顶点，从s到v的最短路径长度d_v</span></span><br><span class="line">	Initialize(Q)</span><br><span class="line">		<span class="comment">// 将顶点优先队列初始化为空</span></span><br><span class="line">	<span class="keyword">for</span> v in V</span><br><span class="line">		d_v = \infty</span><br><span class="line">		p_v = <span class="literal">NULL</span></span><br><span class="line">		Insert(Q, s, d_s)</span><br><span class="line">			<span class="comment">// 初始化有限队列中顶点优先级</span></span><br><span class="line">	d_s = <span class="number">0</span></span><br><span class="line">	Decrease(Q, s, d_s)</span><br><span class="line">		<span class="comment">// 更新s优先级为d_s</span></span><br><span class="line">	V_T = <span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span> to |V|<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">		u* = DeleteMin(Q)</span><br><span class="line">			<span class="comment">// 删除优先级最小元素</span></span><br><span class="line">		V_T = V_T \<span class="keyword">union</span> &#123;u*&#125;</span><br><span class="line">		<span class="keyword">for</span> v in V-V_T 中与u*邻接顶点 <span class="keyword">do</span></span><br><span class="line">			<span class="keyword">if</span> d_u* + w(u*, u) &lt; d_u</span><br><span class="line">				d_u = d_u* + w(u*, u)</span><br><span class="line">				p_u = u*</span><br><span class="line">				Decrease(Q, u, d_u)</span><br></pre></td></tr></table></figure>
<h4 id="算法特点-4"><a href="#算法特点-4" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li>算法时间效率同Prim算法</li>
</ul>
<h3 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h3><p>Bellman-Ford算法：求解单节点、权值正负无限制最短距离</p>
<ul>
<li>权值正负无限制意味着贪心策略不再有效</li>
<li>要求路径中不存在负权值回路</li>
<li>对n个顶点图，路径最长为n-1，否则删除回路路径长度不增加</li>
</ul>
<h4 id="算法-10"><a href="#算法-10" class="headerlink" title="算法"></a>算法</h4><p>考虑使用动态规划算法</p>
<ul>
<li><p>令$dist^{(l)}[u]$表示从起点v到节点u边数不超过l的最短
路径长度</p>
<ul>
<li><p>在不允许出现负权值回路的前提下，构造最短路算法过程
最多只需要考虑n-1条边</p>
</li>
<li><p>即$dist^{(n-1)}$是从v到u不限制路径中边数目的最短路径
长度</p>
</li>
</ul>
</li>
<li></li>
</ul>
<h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><p>Floyd算法：求解完全最短路径问题，有向、无向、加权图均适用
（边距离不为负，否则距离可以任意小）</p>
<ul>
<li><p>构造n+1个距离矩阵$D^{(k)}, k=0,1,\cdots,n$</p>
<ul>
<li><p>$D^{(k)}$中元素$d_{ij}$表示顶点i、j之间由编号小于k的
顶点作为中间顶点的距离</p>
</li>
<li><p>$D^{(0)}$：初始权重矩阵</p>
</li>
<li><p>$D^{(k)}, 0&lt;i&lt;n$：路径中顶点编号最大为<code>k</code></p>
</li>
<li><p>$D^{(n)}$：目标距离矩阵</p>
</li>
<li><p>后继矩阵相对前趋，允许作为路径上顶点增加，各顶点间
距离可能缩短</p>
</li>
</ul>
</li>
<li><p>考虑$D^{(k)}$通过直接前趋$D^{(k-1)}$计算得到，其中距离
（路径）分为两类</p>
<ul>
<li><p>$d^{(k)}<em>{ij} = d^{(k-1)}</em>{ij}$：不包含顶点k作为中间
节点的路径</p>
</li>
<li><p>$d^{(k)}<em>{ij} = d^{(k-1)}</em>{ik} + d^{(k-1)}<em>{kj} &lt; d^{(k-1)}</em>{ij}$：
包含顶点k作为中间节点的路径</p>
</li>
</ul>
</li>
</ul>
<h4 id="算法-11"><a href="#算法-11" class="headerlink" title="算法"></a>算法</h4><script type="math/tex; mode=display">
d^{(k)}_{ij} = \min \{ d^{(k-1)}_{ik} + d^{(k-1)}_{kj},
    d^{(k-1)}_{ij}, d^{(k-1)}_{ij} \}</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Floyd(W[<span class="number">1.</span>.n, <span class="number">1.</span>.n])</span><br><span class="line">	<span class="comment">// 计算完全最短路径的Floyd算法</span></span><br><span class="line">	<span class="comment">// 输入：W不包含负距离的距离矩阵</span></span><br><span class="line">	<span class="comment">// 输出：包含最短距离的距离矩阵</span></span><br><span class="line">	D^<span class="number">0</span> = W</span><br><span class="line">	<span class="keyword">for</span> k = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">for</span> i = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">			<span class="keyword">for</span> j = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">				D[i, j] = min(D[i, j], D[i, k] + D[k, j])</span><br><span class="line">	<span class="keyword">return</span> D</span><br></pre></td></tr></table></figure>
<h4 id="算法特点-5"><a href="#算法特点-5" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>算法效率</p>
<ul>
<li>时间效率同Warshall算法为立方级</li>
<li>如上伪码的空间效率为平方级（没有创建n+1距离矩阵）</li>
</ul>
</li>
<li><p>Floyd算法类似于Warshall算法</p>
</li>
<li><p>Floyd算法利用最优性原理，即最短路径中子路径也是最短</p>
</li>
</ul>
<h2 id="最大流量问题"><a href="#最大流量问题" class="headerlink" title="最大流量问题"></a>最大流量问题</h2><h3 id="Augmenting-Path-Method"><a href="#Augmenting-Path-Method" class="headerlink" title="Augmenting-Path Method"></a>Augmenting-Path Method</h3><h4 id="Shortest-Augmented-Path算法"><a href="#Shortest-Augmented-Path算法" class="headerlink" title="Shortest-Augmented-Path算法"></a>Shortest-Augmented-Path算法</h4><p>最短增益路径法（<em>first-labeled first-scanned algorithm</em>）</p>
<ul>
<li><p>对网络中顶点维护两个标记</p>
<ul>
<li>从源点到被标记顶点能增加流量数</li>
<li>路径中前个顶点名称<ul>
<li><code>+</code>：从前向边访问到当前顶点</li>
<li><code>-</code>：从后向边访问到当前顶点</li>
</ul>
</li>
</ul>
</li>
<li><p>对网络的每条边$(i, j)$，初始化流量为$x_{ij}=0$</p>
</li>
<li><p>从源点开始同时沿着前向边、后向边进行广度优先搜索</p>
<ul>
<li>先更新前向边</li>
<li>只有有增益空间边（顶点）才能被访问</li>
<li>更新搜索到顶点标记</li>
</ul>
</li>
<li><p>源点被标记表明得到一条增量路径，沿着标记反向更新边流量</p>
</li>
<li><p>若广度优先搜索无法达到源点，表明不存在流量增益路径，当前
流量值作为最大值返回</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">ShortestAugmentingPath(G)</span><br><span class="line">	<span class="comment">// 最短增量路径算法</span></span><br><span class="line">	<span class="comment">// 输入：流量网络G</span></span><br><span class="line">	<span class="comment">// 输出：最大流量x</span></span><br><span class="line">	对网络中每条边，设置x[i, j] = <span class="number">0</span></span><br><span class="line">	把源点标记为(\infty, -)，加入空队列Q中</span><br><span class="line">		<span class="comment">// 使用队列实现广度优先搜索</span></span><br><span class="line">	<span class="keyword">while</span> <span class="keyword">not</span> Empty(Q) <span class="keyword">do</span></span><br><span class="line">		i = Front(Q)</span><br><span class="line">		Dequeue(Q)</span><br><span class="line">		<span class="keyword">for</span> 从i到j的每条边 <span class="keyword">do</span></span><br><span class="line">			<span class="comment">// 遍历从i出发的边，前向边</span></span><br><span class="line">			<span class="keyword">if</span> j未被标记</span><br><span class="line">				r[i, j] = = u[i, j] - x[i, j]</span><br><span class="line">				<span class="keyword">if</span> r[i, j] &gt; <span class="number">0</span></span><br><span class="line">					l[j] = min&#123;l[i], r[i, j]&#125;</span><br><span class="line">					<span class="comment">/// 更新从源点到顶点j能增加的流量数</span></span><br><span class="line">					用l[j], i+标记j</span><br><span class="line">					Enqueue(Q, j)</span><br><span class="line">		<span class="keyword">for</span> 从j到i的每条边 <span class="keyword">do</span></span><br><span class="line">			<span class="comment">// 遍历到达i的边，后向边</span></span><br><span class="line">			<span class="keyword">if</span> j未被标记</span><br><span class="line">				<span class="keyword">if</span> x[j, i] &gt; <span class="number">0</span></span><br><span class="line">					l[j] = min&#123;l[i], x[j, i]&#125;</span><br><span class="line">					<span class="comment">// 更新源点到顶点j能增加的流量数</span></span><br><span class="line">					用l[j], i-标记j</span><br><span class="line">					Enqueue(Q, j)</span><br><span class="line">		<span class="keyword">if</span> 汇点被标记</span><br><span class="line">			<span class="comment">// 沿着找的增益路径进行增益</span></span><br><span class="line">			j = n</span><br><span class="line">			<span class="keyword">while</span> j != <span class="number">1</span></span><br><span class="line">				<span class="comment">// 反向更新到源点为止</span></span><br><span class="line">				<span class="keyword">if</span> 顶点j前个节点为i+</span><br><span class="line">					<span class="comment">// 通过前向边访问到顶点j</span></span><br><span class="line">					x[i, j] = x[i, j] + l[n]</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					x[j, i] -= l[n]</span><br><span class="line">				j = i</span><br><span class="line">		去除除源点外所有顶点标记</span><br><span class="line">		重新初始化化队列Q</span><br></pre></td></tr></table></figure>
<h4 id="算法特点-6"><a href="#算法特点-6" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>算法正确性可以（联合）最大流-最小割定理证明</p>
</li>
<li><p>算法时间效率</p>
<ul>
<li>可以证明最短增益路径算法用到的增益路径数量不超过
$|V||E|/2$</li>
<li>对使用邻接列表表示的网络，用广度优先查找找到一条增益
路径的时间$\int O(|V|+|E|)$</li>
<li>所有算法时间效率$\in O(|V||E|^2)$</li>
</ul>
</li>
<li><p>迭代算法</p>
</li>
</ul>
<h3 id="Preflow推进算法"><a href="#Preflow推进算法" class="headerlink" title="Preflow推进算法"></a>Preflow推进算法</h3><p>预流：满足容量约束，但是不满足流量守恒约束</p>
<ul>
<li>把过剩流量向汇点处移动，直到网络所有中间顶点都满足流量
守恒约束为止</li>
</ul>
<h4 id="算法特点-7"><a href="#算法特点-7" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li>算法时间效率<ul>
<li>这类算法中较快者最差效率可以接近$O(|V||E|)$</li>
</ul>
</li>
</ul>
<h3 id="Dinitz算法"><a href="#Dinitz算法" class="headerlink" title="Dinitz算法"></a>Dinitz算法</h3><h3 id="Karzanov算法"><a href="#Karzanov算法" class="headerlink" title="Karzanov算法"></a>Karzanov算法</h3><h3 id="Malhotra-Kamar-Maheshweari算法"><a href="#Malhotra-Kamar-Maheshweari算法" class="headerlink" title="Malhotra-Kamar-Maheshweari算法"></a>Malhotra-Kamar-Maheshweari算法</h3><h3 id="Goldberg-Tarjan算法"><a href="#Goldberg-Tarjan算法" class="headerlink" title="Goldberg-Tarjan算法"></a>Goldberg-Tarjan算法</h3><h3 id="单纯形法"><a href="#单纯形法" class="headerlink" title="单纯形法"></a>单纯形法</h3><p>此问题仍然是线性规划问题，可以使用单纯形法等通用解法求解</p>
<h2 id="最大匹配（二分图）"><a href="#最大匹配（二分图）" class="headerlink" title="最大匹配（二分图）"></a>最大匹配（二分图）</h2><h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><h4 id="算法-12"><a href="#算法-12" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>对U中每个顶点维护一个标记：与其匹配的对偶顶点</p>
</li>
<li><p>从V中的一个自由顶点v出发，按<strong>广度优先搜索</strong>找到U中自由
顶点u，寻找增益路径，搜索过程中</p>
<ul>
<li><p>V中顶点：按照广度优先搜索，得到不在匹配M中的边</p>
<ul>
<li>搜索到U中自由顶点，则停止<strong>得到增益路径</strong></li>
<li>搜索到U中被标记顶点，则连接上已有匹配</li>
</ul>
</li>
<li><p>U中顶点：直接找到其在V中的对偶顶点，得到在M中边</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>得到一个增益路径，沿着增益路径<strong>回溯</strong>，奇数边加入匹配</p>
</li>
<li><p>未找到自由顶点时，则无法得到增益路径</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">MaximumBipartiteMatching(G)</span><br><span class="line">	<span class="comment">// 用类似广度优先算法遍历求二分图的一个最大匹配</span></span><br><span class="line">	<span class="comment">// 输入：二分图G=&lt;V, U, E&gt;</span></span><br><span class="line">	<span class="comment">// 输出：输入图中一个最大基数匹配</span></span><br><span class="line">	初始边集合M包含某些合法的匹配（例如空集合）</span><br><span class="line">	初始队列Q包含V的所有自由顶点（任意序）</span><br><span class="line">	<span class="function"><span class="keyword">while</span> <span class="keyword">not</span> <span class="title">Empty</span><span class="params">(Q)</span> <span class="keyword">do</span></span></span><br><span class="line"><span class="function">		w </span>= Front(Q)</span><br><span class="line">		Dequeue(Q)</span><br><span class="line">		<span class="keyword">if</span> w \in V</span><br><span class="line">			<span class="keyword">for</span> 邻接w的每个顶点u <span class="keyword">do</span></span><br><span class="line">				<span class="comment">// 二分图性质保证u一定在U中</span></span><br><span class="line">				<span class="keyword">if</span> u是自由顶点</span><br><span class="line">					<span class="comment">// 增益</span></span><br><span class="line">					M = M \<span class="keyword">union</span> (w, u)</span><br><span class="line">						<span class="comment">// 首边进匹配</span></span><br><span class="line">					v = w</span><br><span class="line">					<span class="keyword">while</span> v已经被标记 <span class="keyword">do</span></span><br><span class="line">						<span class="comment">// 从增益路径回溯生成匹配</span></span><br><span class="line">						u = 以v标记的点</span><br><span class="line">						M -= (v, u)</span><br><span class="line">							<span class="comment">// 偶数边出匹配</span></span><br><span class="line">						v = 以u标记的点</span><br><span class="line">						M += (v, u)</span><br><span class="line">							<span class="comment">// 奇数边进匹配</span></span><br><span class="line">					删除所以顶点标记</span><br><span class="line">					用V中所有自由顶点重新初始化Q</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">						<span class="comment">// 增益后，重新搜索</span></span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="comment">// u已经匹配</span></span><br><span class="line">					<span class="keyword">if</span> (w, u) <span class="keyword">not</span> \in M <span class="keyword">and</span> u未标记</span><br><span class="line">						用w标记u</span><br><span class="line">						Enqueue(Q, u)</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="comment">// w \in U，此时w必然已经匹配</span></span><br><span class="line">			用w标记w的对偶v</span><br><span class="line">				<span class="comment">// 将已有匹配添加进增益路径中</span></span><br><span class="line">			Enqueue(Q, v)</span><br><span class="line">	<span class="keyword">return</span> M</span><br><span class="line">		<span class="comment">// 当前匹配已经是最大匹配</span></span><br></pre></td></tr></table></figure>
<h4 id="算法特点-8"><a href="#算法特点-8" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>注意：从自由顶点开始寻求匹配时，无论是否找到增益路径，
路径中中U中节点标记已经更新，匹配仅在得到增益路径才更新</p>
</li>
<li><p>算法时间效率</p>
<ul>
<li>每次迭代花费时间$\in O(|E|+|V|)$，迭代次数
$\in O(|V|/2 + 1)$</li>
<li>若每个顶点的信息（自由、匹配、对偶）能在常数时间内
得到（如存储在数组中）</li>
<li>则算法时间效率$\in O(|V|(|V| + |E|))$</li>
</ul>
</li>
<li><p>算法正确性参见图<em>graph_undirected</em>关于增益路径-最大匹配</p>
</li>
<li><p>迭代算法</p>
</li>
</ul>
<h3 id="霍普克罗夫-卡普算法"><a href="#霍普克罗夫-卡普算法" class="headerlink" title="霍普克罗夫-卡普算法"></a>霍普克罗夫-卡普算法</h3><h4 id="算法特点-9"><a href="#算法特点-9" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>对匈牙利算法的改进，把多次迭代在一个阶段完成，然后用一次
查找把最大数量边添加到匹配中</p>
</li>
<li><p>算法时间效率：$\in O(\sqrt {|V|}(|V| + |E|))$</p>
</li>
</ul>
<h2 id="稳定婚姻问题"><a href="#稳定婚姻问题" class="headerlink" title="稳定婚姻问题"></a>稳定婚姻问题</h2><h3 id="婚姻稳定算法"><a href="#婚姻稳定算法" class="headerlink" title="婚姻稳定算法"></a>婚姻稳定算法</h3><p>存在自由男士，任选<em>求婚</em>、<em>回应</em>之一执行，直至不存在自由男士</p>
<ul>
<li><p>求婚：自由男士m向女士w求婚，w为其优先级最大、之前未拒绝
过其女士（可以是已匹配）</p>
</li>
<li><p>回应：若女士w自由则接受男士m求婚，与之配对；女士w不自由
则把m同当前配偶匹配，选择其中优先级较高者</p>
</li>
</ul>
<h4 id="算法-13"><a href="#算法-13" class="headerlink" title="算法"></a>算法</h4><h4 id="算法特点-10"><a href="#算法特点-10" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>算法会在$n^2$次迭代内终止：至多每位男士向所有女士求婚</p>
</li>
<li><p><em>性别倾向</em>：总是生成<em>man-optimal</em>的稳定匹配，优先满足
男士偏好</p>
<ul>
<li>在任何稳定婚姻中，总是尽可能把优先级最高的女士分配给
男性</li>
<li>使用女士进行求婚也只会把性别偏见反向，而不能消除</li>
</ul>
</li>
<li><p>对给定的参与者优先选择集合而言，男士（女士）最优匹配唯一</p>
<ul>
<li>由性别性别倾向容易证明</li>
<li>所以算法的输出不取决于自由男士（女士）求婚顺序，可以
使用任何数据结构表示参与者集合而不影响结果</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>算法最终输出匹配M为稳定婚姻匹配证明参见<em>graph</em></li>
</ul>
</blockquote>
<h2 id="分配问题（二分图）"><a href="#分配问题（二分图）" class="headerlink" title="分配问题（二分图）"></a>分配问题（二分图）</h2><p>n个任务分配给n个人执行（一人一个），将任务j分配个人i的成本为
$C_{ijd}$，求最小成本分配方案</p>
<blockquote>
<ul>
<li>类似问题：最大权重匹配问题</li>
</ul>
</blockquote>
<h3 id="蛮力算法"><a href="#蛮力算法" class="headerlink" title="蛮力算法"></a>蛮力算法</h3><h4 id="算法-14"><a href="#算法-14" class="headerlink" title="算法"></a>算法</h4><ul>
<li>生成整数n的全部排列</li>
<li>根据成本矩阵计算每个分配方案总成本</li>
<li>选择和最小的方案</li>
</ul>
<h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><ul>
<li>算法排列次数为$n!$</li>
</ul>
<h3 id="分支界限法"><a href="#分支界限法" class="headerlink" title="分支界限法"></a>分支界限法</h3><ul>
<li><p>第i层节点下界可取：$lb = c + \sum_{k=i+1}^n min{c_k}$</p>
<ul>
<li>$c$：当前成本</li>
<li>$min{c_k}$：成本矩阵第k行最小值</li>
</ul>
</li>
</ul>
<h4 id="算法-15"><a href="#算法-15" class="headerlink" title="算法"></a>算法</h4><h4 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h4><h3 id="匈牙利算法-1"><a href="#匈牙利算法-1" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><h4 id="算法-16"><a href="#算法-16" class="headerlink" title="算法"></a>算法</h4><h4 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h4><h2 id="Topological-Sorting"><a href="#Topological-Sorting" class="headerlink" title="Topological Sorting"></a>Topological Sorting</h2><p>拓扑排序：按照次序列出有向图的顶点，使得对图中每条边，其
起始顶点总在结束顶点之前</p>
<h3 id="删点法"><a href="#删点法" class="headerlink" title="删点法"></a>删点法</h3><h4 id="算法-17"><a href="#算法-17" class="headerlink" title="算法"></a>算法</h4><ul>
<li>在有向图中求出源（没有输出边的顶点），然后把删除其和所有
从它出发的边</li>
<li>不断重复，直到不存在源，如果此时图中还有顶点，则图中存在
环，无解</li>
<li>则删除节点顺序即为拓扑排序可行解</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">TopologicalSort(G):</span><br><span class="line">	<span class="comment">// 从有向图中不断删除入度为0的点、入栈，判断有向图G是否</span></span><br><span class="line">		<span class="comment">// 为DAG，并给出拓扑排序栈</span></span><br><span class="line">	<span class="comment">// 输入：有向图G</span></span><br><span class="line">	<span class="comment">// 输出：拓扑排序栈T</span></span><br><span class="line">	InitStack(S)</span><br><span class="line">	indgree = [v.indegree <span class="keyword">for</span> v in G]</span><br><span class="line">	<span class="keyword">for</span> v in G:</span><br><span class="line">		<span class="keyword">if</span> v.indgree == <span class="number">0</span></span><br><span class="line">			S.push(v)</span><br><span class="line">		<span class="comment">// 存储0入度结点栈</span></span><br><span class="line">	count = <span class="number">0</span></span><br><span class="line">		<span class="comment">// 删除结点计数</span></span><br><span class="line">	<span class="keyword">while</span>(!S.empty())</span><br><span class="line">		v = S.pop()</span><br><span class="line">		T.push(v)</span><br><span class="line">		count++</span><br><span class="line">		<span class="keyword">for</span>(u connected to v)</span><br><span class="line">			<span class="keyword">if</span> --indgree.u == <span class="number">0</span></span><br><span class="line">				S.push(u)</span><br><span class="line">	<span class="keyword">if</span> count &lt; |G.V|</span><br><span class="line">		<span class="comment">// 结点未删除完毕，但无0入度结点</span></span><br><span class="line">		<span class="comment">// G中有回路，报错</span></span><br><span class="line">		<span class="keyword">return</span> ERROR</span><br><span class="line">	<span class="keyword">return</span> T</span><br></pre></td></tr></table></figure>
<h4 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a>特点</h4><ul>
<li>算法效率<ul>
<li>时间效率$\in O(|V|+|E|)$</li>
</ul>
</li>
<li>减常数法</li>
</ul>
<h3 id="DFS逆后序遍历"><a href="#DFS逆后序遍历" class="headerlink" title="DFS逆后序遍历"></a>DFS逆后序遍历</h3><p>图中<strong>无环</strong>时，由某点出发进行DFS</p>
<ul>
<li><p>最先退出DFS的为出度为0的点，即拓扑有序序列中最后顶点</p>
</li>
<li><p>按照DFS退出先后次序得到序列即为逆向拓扑有序序列</p>
<ul>
<li>使用逆后序方式存储DFS访问顶点，判断是否有环、出栈
次序即为正向拓扑有序序列</li>
</ul>
</li>
</ul>
<h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><ul>
<li>判断庞大项目中相互关联任务不矛盾，然后才能合理安排，使得
项目整体完成时间最短（需要CPM、PERT算法支持）</li>
</ul>
<h2 id="Cirtical-Path问题"><a href="#Cirtical-Path问题" class="headerlink" title="Cirtical Path问题"></a><em>Cirtical Path</em>问题</h2><p>找出使用AOE网表示的工程的中关键路径</p>
<ul>
<li>关键路径由关键活动构成</li>
<li>即耗费时间变动对工程整体完成时间有影响的活动</li>
</ul>
<h3 id="拓扑排序求解"><a href="#拓扑排序求解" class="headerlink" title="拓扑排序求解"></a>拓扑排序求解</h3><ul>
<li>最早、最晚开始时间检查是否为关键活动</li>
<li>建立活动（边）、事件（顶点）发生事时间关系</li>
<li>拓扑排序求解事件发生最早、最晚时间</li>
</ul>
<blockquote>
<ul>
<li>具体参见<em>algorithm/data_structure/graphdi_specials</em></li>
</ul>
</blockquote>
<h4 id="算法-18"><a href="#算法-18" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">TopologicalOrder(G):</span><br><span class="line">	<span class="comment">// 从有向图中不断删除入度为0的点、入栈，判断有向图G是否</span></span><br><span class="line">		<span class="comment">// 为DAG，并给出拓扑排序栈</span></span><br><span class="line">	<span class="comment">// 输入：有向图G</span></span><br><span class="line">	<span class="comment">// 输出：拓扑排序栈T、顶点事件最早发生事件ve</span></span><br><span class="line">	InitStack(S)</span><br><span class="line">	indgree = [v.indegree <span class="keyword">for</span> v in G]</span><br><span class="line">	ve[<span class="number">0.</span>.|G.V|] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> v in G:</span><br><span class="line">		<span class="keyword">if</span> v.indgree == <span class="number">0</span></span><br><span class="line">			S.push(v)</span><br><span class="line">		<span class="comment">// 存储0入度结点栈</span></span><br><span class="line">	count = <span class="number">0</span></span><br><span class="line">		<span class="comment">// 删除结点计数</span></span><br><span class="line">	<span class="keyword">while</span>(!S.empty())</span><br><span class="line">		v = S.pop()</span><br><span class="line">		T.push(v)</span><br><span class="line">		count++</span><br><span class="line">		<span class="keyword">for</span>(u connected by v)</span><br><span class="line">			ve[u] = max&#123;ve[u], ve[v] + len(v, u)&#125;</span><br><span class="line">				<span class="comment">// 若有更长路径，更新</span></span><br><span class="line">			<span class="keyword">if</span> --indgree[u] == <span class="number">0</span></span><br><span class="line">				S.push(u)</span><br><span class="line">	<span class="keyword">if</span> count &lt; |G.V|</span><br><span class="line">		<span class="comment">// 结点未删除完毕，但无0入度结点</span></span><br><span class="line">		<span class="comment">// G中有回路，报错</span></span><br><span class="line">		<span class="keyword">return</span> ERROR</span><br><span class="line">	<span class="keyword">return</span> T, ve</span><br><span class="line"></span><br><span class="line">CriticalPath(G, T, ve):</span><br><span class="line">	<span class="comment">// 逆序求顶点事件最晚发生时间，求出关键活动</span></span><br><span class="line">	<span class="comment">// 输入：有向无环图G，G拓扑排序</span></span><br><span class="line">	<span class="comment">// 输出：关键活动队列Q</span></span><br><span class="line">	vl[<span class="number">0.</span>.|G.V|] = ve</span><br><span class="line">	Q = InitQueue()</span><br><span class="line">	<span class="keyword">while</span>(!T.empty())</span><br><span class="line">		v = T.pop()</span><br><span class="line">		<span class="keyword">for</span> (u connect to v)</span><br><span class="line">			vl[u] = min&#123;vl[u], vl[v] - len(u, v)&#125;</span><br><span class="line">	<span class="keyword">for</span>(v in G.V)</span><br><span class="line">		<span class="keyword">for</span> (u connected by v)</span><br><span class="line">			ee = ve[v]</span><br><span class="line">			el = vl[u] - len(v)</span><br><span class="line">			<span class="keyword">if</span>(el == ee)</span><br><span class="line">				Q.push(G.edge(v, u))</span><br><span class="line">	<span class="keyword">return</span> Q</span><br></pre></td></tr></table></figure>
<ul>
<li><p>以上算法中在生成拓扑排序栈时同时得到各顶点事件最早发生
时间</p>
</li>
<li><p>可以只获取拓扑排序栈，然后处理其获得顶点事件最早发生时间
，将两个功能分离，只是处理一遍顶点而已</p>
</li>
<li><p>也可以使用其他算法获得拓扑排序栈</p>
<ul>
<li>DFS遍历甚至可以遍历顶点一遍，同时获得顶点事件最早、
最晚发生时间</li>
</ul>
</li>
</ul>
<h4 id="特点-8"><a href="#特点-8" class="headerlink" title="特点"></a>特点</h4><ul>
<li>算法效率<ul>
<li>时间效率$\in O(|V|+|E|)$</li>
</ul>
</li>
</ul>
<h2 id="哈密顿回路问题"><a href="#哈密顿回路问题" class="headerlink" title="哈密顿回路问题"></a>哈密顿回路问题</h2><p>确定给定图中是否在包含一条哈密顿回路</p>
<h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><h4 id="算法-19"><a href="#算法-19" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>对所有节点维护标记：是否位于当前路径中</p>
</li>
<li><p>选择某节点<em>a</em>作为哈密顿回路起点顶点，即回溯状态空间树根</p>
</li>
<li><p>从根节点开始处理</p>
<ul>
<li>若节点周围还有未标记节点，选择下个加入路径、标记</li>
<li>若节点周围没有未标记节点，回溯到之前节点重新处理</li>
</ul>
</li>
<li><p>直到所有节点都被标记，且当前节点和根节点相邻</p>
</li>
</ul>
<h4 id="特点-9"><a href="#特点-9" class="headerlink" title="特点"></a>特点</h4><h2 id="旅商问题"><a href="#旅商问题" class="headerlink" title="旅商问题"></a>旅商问题</h2><p>Traveling Salesman Problem：对相互之间距离已知为正整数的n座
城市，求最短漫游路径，使得在回到出发城市之前，对每个城市只
访问一次</p>
<ul>
<li>即：对权重为正整数的无向完全图寻找最短哈密顿回路</li>
</ul>
<h3 id="蛮力算法-1"><a href="#蛮力算法-1" class="headerlink" title="蛮力算法"></a>蛮力算法</h3><h4 id="算法-20"><a href="#算法-20" class="headerlink" title="算法"></a>算法</h4><ul>
<li>生成n-1个中间城市的组合得到所有旅行线路</li>
<li>计算线路长度，求得最短路径</li>
</ul>
<h4 id="特点-10"><a href="#特点-10" class="headerlink" title="特点"></a>特点</h4><ul>
<li>算法排序次数为$(n-1)!/2$</li>
</ul>
<h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><ul>
<li>线路成对出现，只是方向相反，可考虑任意两个相邻顶点，只
考虑包含其某个排序的线路</li>
</ul>
<h3 id="分支界限法-1"><a href="#分支界限法-1" class="headerlink" title="分支界限法"></a>分支界限法</h3><ul>
<li><p>第i层下界可取$lb = \sum<em>{k=i+1}^n d</em>{k1}$</p>
</li>
<li><p>更紧密、也不复杂的下界
$lb = \lceil \frac {\sum<em>{k=i+1}^n (d</em>{k1} + d_{k2})} 2 \rceil$</p>
<ul>
<li><p>$d<em>{k1}, d</em>{k2}$：城市$i+1$到最近的两个城市距离</p>
</li>
<li><p>最短路径为两个端点共享，至多只能有一个端点能够成为
该边起点</p>
</li>
<li><p>若要求所有哈密顿回路中必须包括某些边，则在考虑相应
边端点城市时，使用必须边（若不是节点最短边）替换其中
次短边</p>
</li>
</ul>
</li>
<li><p>只需要生成某对节点有序的路径：可以消去状态空间树中部分
分支</p>
</li>
</ul>
<h4 id="算法-21"><a href="#算法-21" class="headerlink" title="算法"></a>算法</h4><h4 id="特点-11"><a href="#特点-11" class="headerlink" title="特点"></a>特点</h4><h2 id="旅商问题非精确算法"><a href="#旅商问题非精确算法" class="headerlink" title="旅商问题非精确算法"></a>旅商问题非精确算法</h2><p>以下均是讨论TSP问题的欧几里得实例，不对称实例等已经证明更难
解决，对精确算法、启发式算法都是如此</p>
<h3 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h3><h4 id="Nearest-Neighbor算法"><a href="#Nearest-Neighbor算法" class="headerlink" title="Nearest-Neighbor算法"></a>Nearest-Neighbor算法</h4><ul>
<li>任意选择城市开始</li>
<li>每次访问和当前城市k最接近的城市，直到访问完所有城市</li>
<li>回到开始城市</li>
</ul>
<h4 id="Multifregment-Heuristic算法"><a href="#Multifregment-Heuristic算法" class="headerlink" title="Multifregment-Heuristic算法"></a>Multifregment-Heuristic算法</h4><p>求给定加权完全图的最小权重边集合，且每个顶点连通度均为2</p>
<ul>
<li><p>将边按权重升序排列，将要构造的旅途边集合开始时空集合</p>
</li>
<li><p>不断尝试将排序列表中下条边加入旅途边集合</p>
<ul>
<li>边加入不会使得某节点连通度大于2</li>
<li>不会产生长度小于n的回路</li>
<li>否则忽略这条边</li>
</ul>
</li>
<li><p>返回旅途集合</p>
</li>
</ul>
<h4 id="算法特点-11"><a href="#算法特点-11" class="headerlink" title="算法特点"></a>算法特点</h4><p>对属于<strong>欧几里得类型</strong>的旅商问题实例（大部分）</p>
<ul>
<li>此时虽然两个算法的精确性能比无法界定，但是满足
$\frac {f(s_a)} {f(s^{*})} \leqslant \frac 1 2 (\lceil log_2 n \rceil + 1)$</li>
</ul>
<h3 id="Minimum-Spaning-Tree-Based-Algorithm"><a href="#Minimum-Spaning-Tree-Based-Algorithm" class="headerlink" title="Minimum-Spaning-Tree-Based Algorithm"></a>Minimum-Spaning-Tree-Based Algorithm</h3><p>基于最小生成树的算法</p>
<ul>
<li>哈密顿回路中去掉一条边就能得到一棵生成树$T_h$</li>
<li>可以先构造一棵最小生成数$T^{*}$，然后在其基础上构造近似
最短路径</li>
</ul>
<h4 id="Twice-Around-The-Tree算法"><a href="#Twice-Around-The-Tree算法" class="headerlink" title="Twice-Around-The-Tree算法"></a>Twice-Around-The-Tree算法</h4><ul>
<li>对给定实例构造最小生成树$T^{<em>}$（</em>Prim, Kruskal*）</li>
<li>从任意顶点开始，（利用深度优先遍历）绕树散步一周，记录
经过顶点</li>
<li>扫描顶点列表，消去重复出现顶点（走捷径，直接去新城市），
除列表尾部重复起点，得到一条哈密顿回路</li>
</ul>
<blockquote>
<ul>
<li>可能是考虑到最小生成树能够选出部分最短路径？？？</li>
</ul>
</blockquote>
<h4 id="特点-12"><a href="#特点-12" class="headerlink" title="特点"></a>特点</h4><p>对属于<strong>欧几里得类型</strong>的旅商问题</p>
<ul>
<li><p>绕树两周算法是2近似算法：$2f(s^{*}) &gt; f(s_a)$</p>
<ul>
<li>$f(s^{<em>} &gt; w(T_h) \geqslant w(T^{</em>})$：最优哈密顿
回路去掉一条边后长度大于等于最小生成树长度</li>
<li>$f(s^{<em>}) &lt; 2w(T^{</em>})$：第二次扫描走捷径距离小于绕树
一周距离</li>
<li>这里限定了特点类型实例，并没有找到对所有旅商问题的
优先近似算法</li>
</ul>
</li>
</ul>
<h3 id="Christofides算法"><a href="#Christofides算法" class="headerlink" title="Christofides算法"></a>Christofides算法</h3><p>同样利用问题与最小生成树的出关系，但更复杂</p>
<h4 id="算法-22"><a href="#算法-22" class="headerlink" title="算法"></a>算法</h4><ul>
<li>对给定实例构造最小生成树$T^{*}$</li>
<li>构造包含包含$T^{*}$的欧拉回路<ul>
<li>找出最小生成树中所有连通度为奇数的顶点</li>
<li>求出这些顶点的最小权重匹配（匈牙利算法）</li>
<li>将最小权重匹配边加入树中得到多重图欧拉回路</li>
</ul>
</li>
<li>使用走捷径方法将欧拉回路转换为哈密顿回路</li>
</ul>
<h4 id="特点-13"><a href="#特点-13" class="headerlink" title="特点"></a>特点</h4><p>对属于<strong>欧几里得类型</strong>的旅商问题</p>
<ul>
<li><p>绕最小生成树一周得到的路径是多重图的一条欧拉回路，其中
多重图为将当前图每条边重复一遍得到</p>
<ul>
<li>绕树两周算法：直接原始欧拉回路上走捷径</li>
<li>Christofides算法：重新构建更短的欧拉回路，在此基础
上走捷径</li>
</ul>
</li>
<li><p>Christofides算法是1.5近似算法</p>
<ul>
<li>实际应用中，Christofides算法近似解明显好于绕树两周</li>
<li>可以对连通度大于2顶点尝试不同访问次序，即将<strong>回路</strong>
中邻接顶点分别<strong>两两组合</strong>，找到访问其的最佳路径</li>
</ul>
</li>
</ul>
<h3 id="迭代改进算法"><a href="#迭代改进算法" class="headerlink" title="迭代改进算法"></a>迭代改进算法</h3><p>Local Search Heuristics：本地查找启发法</p>
<ul>
<li><p>这类算法从某个初始旅途（随机或简单近似算法生成）开始</p>
</li>
<li><p>每次迭代把当前旅途一些边用其他边代替，试图得到和当前旅途
稍有差别的旅途</p>
<ul>
<li>若能得到优于当前旅途的新旅途，则替换当前旅途，继续
寻找</li>
<li>否则，返回当前旅途，停止</li>
</ul>
</li>
</ul>
<h4 id="2选算法"><a href="#2选算法" class="headerlink" title="2选算法"></a>2选算法</h4><p>删除旅途中2条非临边，把两条边端点用另一对边重新连接</p>
<ul>
<li>此操作称为<em>2改变</em></li>
<li>为保证重连后得到合法哈密顿回路，重连方法只有一种</li>
</ul>
<h4 id="3选算法"><a href="#3选算法" class="headerlink" title="3选算法"></a>3选算法</h4><p>删除3条非临边后重连</p>
<ul>
<li>重连方法有3种</li>
<li>事实上可以推广到k选，但是只有3改变被证明有意义</li>
</ul>
<h4 id="Lin-Kernighan算法"><a href="#Lin-Kernighan算法" class="headerlink" title="Lin-Kernighan算法"></a>Lin-Kernighan算法</h4><p>变选算法算法的一种</p>
<ul>
<li>可以视为在3选操作后进行一系列2选操作</li>
</ul>
<h4 id="算法特点-12"><a href="#算法特点-12" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li>迭代改进算法求得的近似解效果质量非常好</li>
<li>Lin-Kernighan算法是公认的求解高质量近似解的最佳算法</li>
</ul>
<h3 id="Held-Karp-Bound"><a href="#Held-Karp-Bound" class="headerlink" title="Held-Karp Bound"></a>Held-Karp Bound</h3><p>Held-Karp下界</p>
<ul>
<li>将TSP描述为线性规划问题求解（忽略整数约束）得到，计算
速度快</li>
<li>一般和最优旅途长度非常接近，误差不超过1%</li>
<li>可使用其代替最短旅途估计近似算法的精确度</li>
</ul>
<h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><ul>
<li>10000个随机点：坐标、距离取整</li>
<li>Comqaq ES40：500MHz的Alpha处理器、2GB内存</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>启发式算法</th>
<th>超过Held-Karp下界的%</th>
<th>运行时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>最近邻居</td>
<td>24.79</td>
<td>0.28</td>
</tr>
<tr>
<td>多片段</td>
<td>16.42</td>
<td>0.20</td>
</tr>
<tr>
<td>Christofides</td>
<td>9.81</td>
<td>1.04</td>
</tr>
<tr>
<td>2选</td>
<td>4.70</td>
<td>1.41</td>
</tr>
<tr>
<td>3选</td>
<td>2.88</td>
<td>1.50</td>
</tr>
<tr>
<td>Lin-Kernighan</td>
<td>2.00</td>
<td>2.06</td>
</tr>
</tbody>
</table>
</div>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-11T04:25:59.000Z" title="4/11/2019, 12:25:59 PM">2019-04-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-02T10:07:33.000Z" title="8/2/2021, 6:07:33 PM">2021-08-02</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Data-Structure/">Data Structure</a></span><span class="level-item">22 minutes read (About 3269 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Data-Structure/graph.html">图</a></h1><div class="content"><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>图$G=<V, E>$：由一些称为顶点的点构成的集合，其中某些顶点由
称为边的线段相连</p>
<ul>
<li>有限集合V：元素为顶点<em>vertex</em></li>
<li>有限集合E：元素为<strong>顶点二元组</strong>，称为边<em>edge</em>/弧<em>arc</em></li>
</ul>
<h3 id="边方向"><a href="#边方向" class="headerlink" title="边方向"></a>边方向</h3><h4 id="Undigraph-Undirected-Graph"><a href="#Undigraph-Undirected-Graph" class="headerlink" title="Undigraph/Undirected Graph"></a><em>Undigraph</em>/<em>Undirected Graph</em></h4><blockquote>
<ul>
<li>无向图：所有边都是无向边的图</li>
<li>无向边：若有序对$(u, v) \in E$，必有$(v, u) \in E$，
  即E是对称的，顶点对$(u, v)$等同于$(v, u)$，没有顺序</li>
</ul>
</blockquote>
<p>对无向边$(u, v)$</p>
<ul>
<li>则顶点u、v相互<em>adjcent</em></li>
<li>其通过<em>undirected edge</em>$(u, v)$相连接</li>
<li>顶点u、v称为边$(u, v)$的<em>endpoint</em></li>
<li>u、v和该边<em>incident</em>（相依附）</li>
</ul>
<h4 id="Digraph"><a href="#Digraph" class="headerlink" title="Digraph"></a><em>Digraph</em></h4><blockquote>
<ul>
<li>有向图：所有边都是有向边的图</li>
<li>有向边：若有序对对$(u, v) \in E$无法得到$(v, u) \in E$，
  即两者不等同，有顺序</li>
</ul>
</blockquote>
<p>对有向边$(u, v)$</p>
<ul>
<li>边$(u, v)$的方向是从顶点u到顶点v</li>
<li>u称为tail，v称为head</li>
</ul>
<h3 id="边权重"><a href="#边权重" class="headerlink" title="边权重"></a>边权重</h3><h4 id="Ordered-Graph"><a href="#Ordered-Graph" class="headerlink" title="Ordered Graph"></a><em>Ordered Graph</em></h4><p>有序图：各边地位有序</p>
<h4 id="Weighted-Graph-Network"><a href="#Weighted-Graph-Network" class="headerlink" title="Weighted Graph/Network"></a><em>Weighted Graph</em>/<em>Network</em></h4><p>加权图/网络：给边赋值的图</p>
<ul>
<li>值称为<em>weight</em>或<em>cost</em></li>
<li>有大量的现实应用</li>
</ul>
<h3 id="边数量"><a href="#边数量" class="headerlink" title="边数量"></a>边数量</h3><ul>
<li><em>complete graph</em>：任意两个顶点直接都有的边相连的图<ul>
<li>使用$K_{|v|}$表示有|V|个顶点的完全图</li>
</ul>
</li>
<li><em>dense graph</em>：图中所缺的边数量相对较少</li>
<li><em>sparse</em>：图中边相对顶点数量较少</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>不考虑<strong>loop</strong>（顶点连接自身边），则含有|V|个顶点无向图
包含边的数量|E|满足：
$ 0 \leq |E| \leq \frac {|V|(|V| - 1)} {2} $</p>
</li>
<li><p>对于稀疏图、稠密图可能会影响图的表示方法，影响设计、使用
算法的运行时间</p>
</li>
</ul>
<h2 id="图表示方法（存储结构）"><a href="#图表示方法（存储结构）" class="headerlink" title="图表示方法（存储结构）"></a>图表示方法（存储结构）</h2><h3 id="Adjacency-Matrix"><a href="#Adjacency-Matrix" class="headerlink" title="Adjacency Matrix"></a><em>Adjacency Matrix</em></h3><p>邻接矩阵：两个数组分别存储数据元素（顶点）信息、数据元素之间
关系（边）的信息</p>
<ul>
<li>n个顶点的图对应n * n的bool矩阵<ul>
<li>图中每个顶点使用一行和一列表示</li>
<li>i、j节点间有边，则矩阵第i行、j列元素为1，否则为0</li>
</ul>
</li>
<li>无向图邻接矩阵一定是对称的，有向图邻接矩阵不一定</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span>DG, DN&lt; UDG, UDN&#125; GraphKind;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcCell</span>&#123;</span></span><br><span class="line">	VRType adj;</span><br><span class="line">		<span class="comment">// 顶点关系类型：无权图0、1是否相邻，加权图权值类型</span></span><br><span class="line">	InfoType * info;</span><br><span class="line">		<span class="comment">// 弧相关信息</span></span><br><span class="line">&#125;ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	VertexType vexs[MAX_VERTEX_NUM];</span><br><span class="line">		<span class="comment">// 顶点向量</span></span><br><span class="line">	AdjMatrix arcs;</span><br><span class="line">	<span class="keyword">int</span> vexnum, arcnum;</span><br><span class="line">		<span class="comment">// 图当前顶点弧数</span></span><br><span class="line">	GraphKind kind;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Adjacency-List"><a href="#Adjacency-List" class="headerlink" title="Adjacency List"></a><em>Adjacency List</em></h3><p>邻接表：n条单链表代替邻接矩阵的n行，对应图G的n个顶点</p>
<ul>
<li><p>每个顶点用一个邻接表表示</p>
<ul>
<li>线性表的<em>header</em>表示对应的顶点</li>
<li>链表中结点表示依附于顶点的边</li>
</ul>
</li>
<li><p>无向图一条边在邻接链表中对应两条链，有向图对应一条</p>
<ul>
<li>有向图出度计算简单</li>
<li>计算入度则比较复杂，如果需要频繁计算入度，可以再存储
一个反向邻接表</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> adjvex;</span><br><span class="line">		<span class="comment">// 弧指向顶点信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span></span><br><span class="line">		<span class="comment">// 指向下条弧指针</span></span><br><span class="line">	InfoType * info;</span><br><span class="line">		<span class="comment">// 弧相关信息</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">	VertexType data;</span><br><span class="line">		<span class="comment">// 顶点信息</span></span><br><span class="line">	ArcNode * firstarc;</span><br><span class="line">		<span class="comment">// 首条依附该顶点的弧指针</span></span><br><span class="line">&#125;VNode, AdjList[MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	AdjList vertices;</span><br><span class="line">	<span class="keyword">int</span> vexnum, arcnum;</span><br><span class="line">	<span class="keyword">int</span> kind;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Orthogonal-List"><a href="#Orthogonal-List" class="headerlink" title="Orthogonal List"></a><em>Orthogonal List</em></h3><p>十字链表：将<strong>有向图</strong>的邻接表、逆邻接表结合起来</p>
<ul>
<li>有向图中每条弧、每个顶点对应一个结点</li>
<li>弧结点所在链表为非循环链表，<ul>
<li>结点之间相对位置自然形成，不一定按照顶点序号有序</li>
</ul>
</li>
<li>表头结点即顶点结点，顺序存储</li>
</ul>
<p><img src="/imgs/orthogonal_list_structure.png" alt="orthogonal_list_structure"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcBox</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> tailvex, headvex;</span><br><span class="line">		<span class="comment">// 头、尾顶点链域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ArcBox</span> *<span class="title">hlink</span>, *<span class="title">tlink</span>;</span></span><br><span class="line">		<span class="comment">// 头相同、尾相同弧链域</span></span><br><span class="line">	InfoType *info;</span><br><span class="line">		<span class="comment">// 弧相关信息</span></span><br><span class="line">&#125;ArcBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VexNode</span>&#123;</span></span><br><span class="line">	VertexType data;</span><br><span class="line">		<span class="comment">// 顶点信息</span></span><br><span class="line">	ArcBox *firstin, *firstout;</span><br><span class="line">		<span class="comment">// 顶点第一条出、入弧</span></span><br><span class="line">&#125;VexNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	VexNode xlist[MAX_VERTEX _NUM];</span><br><span class="line">		<span class="comment">// 表头</span></span><br><span class="line">	<span class="keyword">int</span> vexnum, arcnum;</span><br><span class="line">&#125;OLGraph;</span><br></pre></td></tr></table></figure>
<h3 id="Adjacency-Multilist"><a href="#Adjacency-Multilist" class="headerlink" title="Adjacency Multilist"></a><em>Adjacency Multilist</em></h3><p>邻接多重表：<strong>无向图</strong>的另一种存储形式</p>
<ul>
<li>一条边对应<strong>唯一结点</strong><ul>
<li>所有依附于同一顶点的串联在同一链表中</li>
<li>每个边界点同时链接在两个链表中</li>
<li>避免无向图邻接表中一条边两次出现</li>
</ul>
</li>
<li>类似十字链表，仅无需区分头尾结点</li>
</ul>
<p><img src="/imgs/adjacency_multilist_structure.png" alt="adjacency_multilist_structure"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EBox</span>&#123;</span></span><br><span class="line">	VisitIf mark;</span><br><span class="line">		<span class="comment">// 访问标记</span></span><br><span class="line">	<span class="keyword">int</span> ivex, jvex;</span><br><span class="line">		<span class="comment">// 边依附的两个顶点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">EBox</span> *<span class="title">ilink</span>, *<span class="title">jlink</span>;</span></span><br><span class="line">		<span class="comment">// 依附两个顶点的下条边</span></span><br><span class="line">	InfoType *info;</span><br><span class="line">		<span class="comment">// 边信息指针</span></span><br><span class="line">&#125;EBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VexBox</span>&#123;</span></span><br><span class="line">	VertexType data;</span><br><span class="line">	EBox *firstedge;</span><br><span class="line">		<span class="comment">// 第一条依附该顶点的边</span></span><br><span class="line">&#125;VexBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	VexBox adjmulist[MAX_VERTEX_NUM];</span><br><span class="line">	<span class="keyword">int</span> vexnum, edgenum;</span><br><span class="line">&#125;AMLGraph;</span><br></pre></td></tr></table></figure>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li><p>稀疏图：尽管链表指针会占用额外存储器，但是相对于邻接矩阵
占用空间依然较少</p>
</li>
<li><p>稠密图：邻接矩阵占用空间较少</p>
</li>
<li><p>邻接矩阵、邻接链表都可以方便的表示加权图</p>
<ul>
<li>邻接矩阵元素A[i, j]设置为有限值表示存在的边的权重，
设置为$\infty$表示不存在边，此时矩阵也称
<strong>weighted matrix</strong>或<strong>cost matrix</strong></li>
<li>邻接链表在节点中型跨同时包含节点名称和相应边权重</li>
</ul>
</li>
<li><p>任何可以存储顶点、边的数据结构（如集合）都可以表示图，
只是存储效率低、无法高效操作</p>
</li>
</ul>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><h4 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h4><ul>
<li><p><em>directed path</em>：有向图中顶点的一个序列，序列中每对连续
顶点都被边连接，边方向为一个顶点指向下一个顶点</p>
</li>
<li><p><em>directed cycle</em>：有向图中节点序列，起点、终点相同，每个
节点和其直接前趋之间，都有一条从前趋指向后继的边</p>
</li>
<li><p><em>directed acyclic graph</em>：DAG，有向无环图</p>
</li>
</ul>
<h4 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h4><ul>
<li><p><em>path</em>：（无向）图G中始于u而止于v的邻接顶点序列，即为顶点u
到顶点v的路径</p>
</li>
<li><p><em>simple path</em>：路径上所有点互不相同</p>
</li>
<li><p><em>cycle</em>：特殊的path</p>
<ul>
<li>起点、终点都是同一顶点</li>
<li>长度大于0</li>
<li>不包含同一条边两次</li>
</ul>
</li>
<li><p><em>acyclic</em>：不包含回路的图</p>
</li>
</ul>
<h4 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h4><ul>
<li><em>length</em>：路径中代表顶点序列中的顶点数目减1，等于路径中
包含的边数目</li>
<li><em>distance</em>：顶点间距离，顶点之间最短路径长度</li>
</ul>
<h3 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h3><h4 id="无向图-1"><a href="#无向图-1" class="headerlink" title="无向图"></a>无向图</h4><ul>
<li><p><em>connected</em>：顶点u、v连通，当且仅当存在u到v的路径</p>
</li>
<li><p><em>connected graph</em>：连通图，对图中的每对顶点$(u, v)$，
都有从u到v的路径</p>
</li>
<li><p><em>connected component</em>：连通分量，给定图的极大连通子图，
即没有可以添加的连通子图用于扩充</p>
<ul>
<li>非连通图中包含的几个自我连通的部分</li>
</ul>
</li>
<li><p><em>articulation point</em>：关节点，如果从连通图$G$中删除顶点
$v$、极其邻接边各点之后的的图$G^{‘}$至少有两个连通分量，
则称顶点$v$为关节点</p>
</li>
<li><p><em>biconnected graph</em>：重连通图，没有关节点的连通图</p>
</li>
<li><p><em>biconnected component</em>：重连通分量，连通图的最大重连通
子图，即不是其他重连通分量的真子图</p>
<ul>
<li>两个重连通分量不可能共享一个以上节点，即图的一条边
不可能同时出现在两个重连通分量中
（否则两个“重连通分量”可以合并）</li>
<li>所以可以说重连通分量是对原图的<strong>边的划分</strong></li>
</ul>
</li>
</ul>
<h4 id="有向图-1"><a href="#有向图-1" class="headerlink" title="有向图"></a>有向图</h4><ul>
<li>强连通图：对所有不同顶点u、v，都存在u到v、v到u的路径</li>
<li><em>strongly connected component</em>：强连通分量，有向图的
极大连通子图</li>
</ul>
<h5 id="源点、汇点"><a href="#源点、汇点" class="headerlink" title="源点、汇点"></a>源点、汇点</h5><ul>
<li><em>soruce</em>：源，没有输入边的顶点</li>
<li><em>sink</em>：汇点，没有输出边顶点</li>
</ul>
<h2 id="图遍历"><a href="#图遍历" class="headerlink" title="图遍历"></a>图遍历</h2><p>遍历图：实质是对每个顶点查找其邻接顶点的过程</p>
<blockquote>
<ul>
<li>具体算法参见<em>algorithm/problem/graph</em></li>
</ul>
</blockquote>
<h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><blockquote>
<ul>
<li>BFS：<em>Breadth First Search</em>：广度优先搜索，类似树的先序
  遍历</li>
<li><p>DFS：<em>Depth First Search</em>：深度优先搜索，类似树的按层次
  遍历</p>
</li>
<li><p>具体算法参见<em>algorithm/problem/graph</em></p>
</li>
</ul>
</blockquote>
<h3 id="结点处理顺序"><a href="#结点处理顺序" class="headerlink" title="结点处理顺序"></a>结点处理顺序</h3><blockquote>
<ul>
<li><em>post-order</em>：后序，先处理子节点，再处理当前结点</li>
<li><em>pre-order</em>：前序，先处理当前结点，再处理子节点</li>
</ul>
</blockquote>
<ul>
<li><p>搜索森林中<strong>仅有一棵树</strong>时</p>
<ul>
<li>前序、后序均满足处理顺序（后序为逆处理顺序）</li>
<li>前序、后序处理仅是处理顺序刚好相反</li>
</ul>
</li>
<li><p>搜索森林中<strong>有多棵树</strong>时，将每棵树视为一个结点考虑</p>
<ul>
<li>每个树内前序、后序顶点处理顺序相反</li>
<li><strong>不同树整体</strong>前序、后序处理顺序相反</li>
<li>此时前序不再满足处理顺序，后序仍为逆处理顺序，所以
前序不常用</li>
</ul>
</li>
<li><p>节点处理记录方式</p>
<ul>
<li>栈：出栈顺序同记录反向</li>
<li>队列：出队列顺序同记录顺序</li>
</ul>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p><em>Pre-Order</em>：正前序，先当前顶点、后子顶点，队列存储</p>
</li>
<li><p><em>Reverse Pre-Order</em>：逆前序，先子顶点、后当前顶点，
栈存储</p>
</li>
<li><p><em>Post-Order</em>：正后序，先当前顶点、后子顶点，队列存储</p>
</li>
<li><p><em>Reversed Post-Order</em>：逆后序，先子顶点、后当前顶点，
栈存储，也称为<strong>伪拓扑排序</strong></p>
<ul>
<li>可以用于得到DAG的拓扑有序序列</li>
<li>也可以用于得到有环有向图的<strong>伪拓扑序列</strong><ul>
<li>强连通分量整体看作结点，组成DAG</li>
<li>各强连通分量必然可以选出某个顶点，满足在伪拓扑
序列中次序<strong>先于DAG中先驱强连通分量所有顶点</strong></li>
</ul>
</li>
<li>用途最广<ul>
<li>有向图拓扑排序</li>
<li>Kosaraju算法中用到</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="BFS、DFS森林"><a href="#BFS、DFS森林" class="headerlink" title="BFS、DFS森林"></a>BFS、DFS森林</h3><p>广度优先、深度优先生成森林</p>
<ul>
<li>遍历的初始顶点可以作为森林中树的根</li>
<li>遇到新未访问的顶点，将其附加为<strong>直接前趋</strong>子女</li>
<li>其实<strong>仅有树向边</strong>才是符合森林定义（其他边都只是搜索过程
中遇到）</li>
</ul>
<blockquote>
<ul>
<li>DFS森林中边是<strong>从左到右</strong>逐渐生成</li>
<li>BFS森林中边是<strong>从上到下</strong>逐渐生成</li>
</ul>
</blockquote>
<h4 id="边类型"><a href="#边类型" class="headerlink" title="边类型"></a>边类型</h4><ul>
<li><em>tree edge</em>：树向边，连接父母、子女的边</li>
<li><em>back edge</em>：回边，连接非直接前驱的边<ul>
<li>对有向图包括连接父母的边</li>
<li>对无向图不存在连接父母边</li>
</ul>
</li>
<li><em>cross edge</em>：交叉边，连接非前驱、后继的边</li>
<li><em>forward edge</em>：前向边，连接非直接后代的边</li>
</ul>
<h4 id="边存在性"><a href="#边存在性" class="headerlink" title="边存在性"></a>边存在性</h4><ul>
<li>无向图<ul>
<li>DFS森林：只可能有回边</li>
<li>BFS森林：只可能有交叉边</li>
</ul>
</li>
<li>有向图<ul>
<li>DFS森林：可以都有</li>
<li>BFS森林：只可能有回边、交叉边</li>
</ul>
</li>
</ul>
<h3 id="Spanning-Tree"><a href="#Spanning-Tree" class="headerlink" title="Spanning Tree"></a><em>Spanning Tree</em></h3><p>生成树/极小连通子图：包含图中所有顶点的连通无环子图（树）</p>
<ul>
<li><p>n个顶点的生成树有且仅有n-1条边，反之不成立</p>
</li>
<li><p>在生成树添加一条边必定构成一个环，因为其实使得其依附的
两个顶点之间生成了第二条路径</p>
</li>
</ul>
<h4 id="Minimum-Cost-Spanning-Tree"><a href="#Minimum-Cost-Spanning-Tree" class="headerlink" title="Minimum Cost Spanning Tree"></a><em>Minimum Cost Spanning Tree</em></h4><p>最小生成树：图的一棵权重最小的生成树（权重指所有边权重之和）</p>
<h5 id="MST性质"><a href="#MST性质" class="headerlink" title="MST性质"></a>MST性质</h5><blockquote>
<ul>
<li>若$N=(V, {E})$是连通网，U是顶点集V的非空子集，若
  $(u, v), u \in U, v \in V-U$是一条具有最小权值（代价）边
  ，则图中<strong>存在</strong>最小生成树包含该边</li>
</ul>
</blockquote>
<ul>
<li><p>假设网N中最小生成树T不包含边$(u, v)$，将其加入T中</p>
</li>
<li><p>因为T为生成树，所以必存在边
$(u^{‘}, v^{‘}), u^{‘} \in U, v^{‘} \in V-U$，且
$u, u^{‘}$、$v, v^{‘}$之间均有路径连通</p>
</li>
<li><p>则删除$(u^{‘}, v^{‘})$可以消去上述回路，得到新生成树
$T^{‘}$，且代价不大于$T$，矛盾</p>
</li>
</ul>
<blockquote>
<ul>
<li><strong>存在</strong>是考虑到存在其他同权值边，若权值严格最小，则所有
  最小生成树必然包含</li>
<li>依此性质生成算法参见<em>algorithm/problems/graph</em></li>
</ul>
</blockquote>
<h3 id="连通性-1"><a href="#连通性-1" class="headerlink" title="连通性"></a>连通性</h3><ul>
<li>对图进行遍历是判断图连通性、求解连通分量的好方法</li>
</ul>
<h4 id="有向图-2"><a href="#有向图-2" class="headerlink" title="有向图"></a>有向图</h4><ul>
<li><p>连通图：从图中任意顶点出发，进行深度、广度优先搜索即可
访问到图中所有顶点</p>
<ul>
<li>利用DFS生成树可以找出图的重连通分量</li>
</ul>
</li>
<li><p>非连通图：需要从多个顶点起始进行搜索</p>
<ul>
<li>每次<strong>从新的起始点出发</strong>进行搜索过程中得到顶点访问
序列就是各个连通分量的顶点集</li>
</ul>
</li>
</ul>
<h4 id="无向图-2"><a href="#无向图-2" class="headerlink" title="无向图"></a>无向图</h4><ul>
<li>深度优先搜索是求有向图<strong>强连通分量</strong>的有效方法</li>
</ul>
<blockquote>
<ul>
<li>具体算法参见<em>algorithm/problem/graph</em></li>
</ul>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-11T01:47:57.000Z" title="4/11/2019, 9:47:57 AM">2019-04-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-04-11T01:47:57.000Z" title="4/11/2019, 9:47:57 AM">2019-04-11</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Data-Structure/">Data Structure</a></span><span class="level-item">14 minutes read (About 2063 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Data-Structure/graphdi_specials.html">有向图衍生</a></h1><div class="content"><h2 id="Directed-Acycline-Graph"><a href="#Directed-Acycline-Graph" class="headerlink" title="Directed Acycline Graph"></a><em>Directed Acycline Graph</em></h2><p>DAG：有向无环图</p>
<ul>
<li>描述含有公共子式的表达式的有效工具<ul>
<li>可以实现对相同子式的共享，节省存储空间</li>
</ul>
</li>
<li>描述一项工程、系统进行过程的有效工具<ul>
<li>拓扑排序：工程能否顺利进行</li>
<li>关键活动：整个工程完成必须的最短时间</li>
</ul>
</li>
</ul>
<h3 id="Dependence-Analysis"><a href="#Dependence-Analysis" class="headerlink" title="Dependence Analysis"></a><em>Dependence Analysis</em></h3><p>依赖性分析：由有向图判断、构造可行任务执行序列</p>
<h4 id="Topological-Sort"><a href="#Topological-Sort" class="headerlink" title="Topological Sort"></a><em>Topological Sort</em></h4><blockquote>
<ul>
<li>拓扑有序：由偏序得到的全序</li>
<li>拓扑排序：由偏序定义得到拓扑有序的操作</li>
</ul>
</blockquote>
<ul>
<li><p>构造有向图中顶点的拓扑有序序列</p>
<ul>
<li>得到可行任务执行顺序</li>
</ul>
</li>
<li><p>判断有向图AOV-网中是否存在环，即是否为DAG</p>
<ul>
<li>若图中所有顶点都在拓扑有序序列中，则有向图中不存在环</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>参见<em>algorithm/problems/graph</em></li>
<li>AOV网：<em>activity on vertex network</em>，顶点表示活动，弧
  表示活动间优先关系的有向图</li>
</ul>
</blockquote>
<h3 id="关键活动优化"><a href="#关键活动优化" class="headerlink" title="关键活动优化"></a>关键活动优化</h3><h4 id="Critical-Path"><a href="#Critical-Path" class="headerlink" title="Critical Path"></a><em>Critical Path</em></h4><p>关键路径：路径长度最长的路径</p>
<ul>
<li><p>对整个AOE网，开始点到结束点的关键路径长度即为完成工程
的最短时间</p>
</li>
<li><p>对事件$v_i$，从起始点$v_1$到其的关键路径长度即为，以
$v_i$为尾的活动的最早开始时间</p>
</li>
<li><p>关键路径上的所有活动均为关键活动</p>
<ul>
<li>分析关键路径目的就是找出关键活动</li>
<li>提高关键活动工效缩短工期</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>AOE网：<em>activity on edge network</em>，顶点表示事件，边表示
  活动持续事件的带权有向无环图<blockquote>
<ul>
<li>一般网络中只有一个源点、汇点，表示工程开始、完成</li>
<li>以上假设AOE网中活动可以并行进行</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="关键活动"><a href="#关键活动" class="headerlink" title="关键活动"></a>关键活动</h4><blockquote>
<ul>
<li>关键活动：记$ee<em>{ij}$为活动$a</em>{ij}$最早开始时间、
  $el<em>{ij}$为不推迟整个工程完成前提下$a</em>{ij}$最迟开始时间
  ，称$ee<em>{ij} = el</em>{ij}$称为关键活动</li>
</ul>
</blockquote>
<ul>
<li><p>$el<em>{ij} - ee</em>{ij}$表示完成活动$a_{ij}$的时间余量</p>
<ul>
<li>提前完成非关键活动不能加快工程进度</li>
<li>关键活动耗时一定范围变化影响工程整体完成时间</li>
</ul>
</li>
<li><p>考虑如下事件和活动发生关系有</p>
<script type="math/tex; mode=display">
\left \{ \begin{array}{l}
ee_{ij} & = ve_{i} \\
el_{ij} & = vl_{j} - a_{ij}
\end{array} \right.</script><blockquote>
<ul>
<li>$ve_i, vl_i$：事件（顶点）i最早、最晚发生的时间</li>
<li>$a<em>{ij}$：活动$a</em>{ij}$需要持续时间</li>
</ul>
</blockquote>
</li>
<li><p>对$ve_i, vl_i$，存在如下递推关系</p>
<script type="math/tex; mode=display">\left \{ \begin{array}{l}
ve_i = \max\{ve_m + a_{mi} \}, & \forall a_{mi} \in E \\
vl_i = \max\{vl_n - a_{in} \}, & \forall a_{in} \in E
\end{array} \right.</script><p>则依拓扑排序可计算得$ve_i$，逆拓扑排序可计算得$vl_i$</p>
</li>
</ul>
<blockquote>
<ul>
<li>参见<em>algorithm/problems/graph</em></li>
<li>为求解AOE网中活动$e<em>{ij}, l</em>{ij}$，应该首先求出事件</li>
</ul>
</blockquote>
<h2 id="Flow-Network"><a href="#Flow-Network" class="headerlink" title="Flow Network"></a>Flow Network</h2><p>流量网络</p>
<ul>
<li>包含一个源点：物质流唯一出发点</li>
<li>包含一个汇点：物质流唯一汇聚点</li>
<li>每条有向边权重为边capacity的正整数$u_{ij}$<ul>
<li>事实上，有理数总可以通过变换变为整数，所以只要容量为
有理数就可以</li>
<li>计算机无法真正处理无理数，无理数边权只具有理论意义</li>
</ul>
</li>
</ul>
<h3 id="流量约束"><a href="#流量约束" class="headerlink" title="流量约束"></a>流量约束</h3><h4 id="Capacity-Constraits"><a href="#Capacity-Constraits" class="headerlink" title="Capacity Constraits"></a>Capacity Constraits</h4><p>容量约束：通过边的流量不大于边容量$x<em>{ij} \leqslant u</em>{ij}$</p>
<h4 id="Flow-Conservation-Requirement"><a href="#Flow-Conservation-Requirement" class="headerlink" title="Flow-Conservation Requirement"></a>Flow-Conservation Requirement</h4><p>流量守恒要求：除源点、汇点外其余顶点只能改变流方向，进入、
流出物质总量不变，不能消耗、添加物质</p>
<script type="math/tex; mode=display">
\sum_{i:(i,j) \in E} x_{ij} = \sum_{k:(j,k) \in E} x_{jk}</script><ul>
<li>其中$x_{ij}$表示通过边$(i,j)$的流量（传输量）</li>
<li>等式左右为进入、离开顶点i的输入、输出流总和</li>
</ul>
<p>并且</p>
<script type="math/tex; mode=display">
\sum_{j:(1,j) \in E} x_{1j} = \sum_{i:(i,n) \in E} x_{in}</script><ul>
<li>流的值 = 源点输出流 = 汇点输入流</li>
<li>可通过流量守恒要求推出</li>
</ul>
<h3 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h3><p>最大流：分配流量网络中边权（实际流量），使得网络在满足流量
守恒、容量束情况下，最大的流的值（边容量都为正整数）</p>
<script type="math/tex; mode=display">
\max = \sum_{j:(1,j)} x_{i,j} \\
s.t. 0 \leqslant x_{ij} \leqslant u_{ij} \\
\sum_{j:(j,i) \in E) x_{ji} - \sum_{j:(i,j) \in E} x_{ij} = 0</script><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a><em>cut</em></h3><p>割：$C(X,\bar X)$=所有头在$X$、尾在$\bar X$边集合</p>
<ul>
<li>$X$；包含源点、不包含汇点的顶点V的子集</li>
<li>$\bar X$：$X$的补集，包含汇点</li>
<li>删除割中所有边，则不存在从源点的汇点的路径</li>
</ul>
<h3 id="Augmenting-Path-Method"><a href="#Augmenting-Path-Method" class="headerlink" title="Augmenting-Path Method"></a>Augmenting-Path Method</h3><h4 id="Augmenting-Path"><a href="#Augmenting-Path" class="headerlink" title="Augmenting-Path"></a>Augmenting-Path</h4><p><strong>流量增益</strong>路径：当前流情况下，可以传输更多流量、从源点到
汇点路径，考虑路径$i \rightarrow j \leftarrow k$中顶点j边</p>
<ul>
<li><p><em>forward edge</em>：前向边$(i, j)$，同流量网络中边$(i, j)$
方向相同</p>
<ul>
<li>具有正的未使用容量$r<em>{ij} = u</em>{ij} - x_{ij}$</li>
<li>可以把该边流量增加最多$r_{ij}$</li>
</ul>
</li>
<li><p><em>backward edge</em>：后向边$(j, k)$，同流量网络中边$(k, j)$
方向相反</p>
<ul>
<li>具有正流量$x_{kj}$</li>
<li>可以把该边流量减少最多$x_{kj}$</li>
</ul>
</li>
</ul>
<h4 id="增益路径法"><a href="#增益路径法" class="headerlink" title="增益路径法"></a>增益路径法</h4><ul>
<li><p>寻找网络中增益路径，设$r$为路径中各前向边未使用容量
$r<em>{ij}$、后向边流量$x</em>{jk}$最小值</p>
</li>
<li><p>每条前向边流量加r、后向边流量减r，可以得到新的可行流量，
且流量值增加r，不断迭代</p>
</li>
<li><p>基于边容量、流量都为正整数假设</p>
<ul>
<li><p>r也为正整数，每次迭代流量值至少增加1</p>
</li>
<li><p>流量最大值有上界为源点为起点边容量和，则增益路径法
在<strong>有限步迭代后会停止</strong></p>
</li>
</ul>
</li>
<li><p>联合最大流-最小割定律可以证明</p>
<ul>
<li>最终流量一定是最大化的，等于最小割容量</li>
<li>和增量路径选择无关</li>
</ul>
</li>
<li><p>最后一步迭代中</p>
<ul>
<li>所有已标记顶点和未标记顶点之间边就构成最小割</li>
<li>这样边流量要么满（标记到未标记）、要么空（反）</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>增益路径法具体实现参见<em>graph</em></li>
<li>算法主要问题在于如何寻找增益路径，生成路径的顺序对算法
  有巨大影响</li>
</ul>
</blockquote>
<h3 id="Max-Flow-Min-Cut-Theorem"><a href="#Max-Flow-Min-Cut-Theorem" class="headerlink" title="Max-Flow Min-Cut Theorem"></a>Max-Flow Min-Cut Theorem</h3><p>最大流-最小割定理：网络中最大流量值等于其最小割容量</p>
<h4 id="Theorem1"><a href="#Theorem1" class="headerlink" title="Theorem1"></a>Theorem1</h4><p>网络中最大流量值小于任意割容量</p>
<ul>
<li><p>设可行流量x值为v，割$C(X, \bar_X)$容量为c</p>
</li>
<li><p>通过该割的流量为：<em>$X$到$\bar_X$的流量之和</em>与
<em>$\bar_X$到$X$的流量之和</em>的差值（可由流量守恒推导）</p>
<script type="math/tex; mode=display">
v = \sum_{i \in X, j \in \bar_X} x_{ij} -
   \sum{j \in \bar_X, i \in X} x_{ji}</script></li>
<li><p>由流量非负可得</p>
<script type="math/tex; mode=display">
v \leqslant \sum_{i \in X, j \in \bar_X} x_{ij}
   \leqslant \sum_{i \in X, j \in \bar_x} u_{ij}</script><p>即网络上任何可行流值不能超过网络上任意割容量</p>
<script type="math/tex; mode=display">v \leqslant c</script></li>
</ul>
<h4 id="Theorem2"><a href="#Theorem2" class="headerlink" title="Theorem2"></a>Theorem2</h4><p>网络中最大流量等于最小割容量，可以使用增益路径法证明</p>
<ul>
<li><p>设$v^{<em>}$为通过路径增益法得到的最终流$x^{</em>}$的值</p>
</li>
<li><p>对增益路径法最终流量情况下，考虑顶点集合$X^{*}$</p>
<ul>
<li>包含源点</li>
<li>其他顶点可由源点出发，经未使用的容量大于0的前向边、
流量大于0的后向边组成路径到达</li>
</ul>
</li>
<li><p>则汇点不属于$X^{*}$，否则存在一条流量增益路径，不是流量
增益法最终流情况</p>
</li>
<li><p>考虑割$C(X^{<em>}, \bar_{X^{</em>}})$</p>
<ul>
<li><p>$X^{<em>}, \bar_{X^{</em>}}$之间任意边$(i,j)$：
$x<em>{ij} = u</em>{ij}$，没有未使用容量</p>
</li>
<li><p>$\bar<em>{X^{<em>}}, X^{</em>}$之间任意边$(j,i)$：$x</em>{ji}=0$，
没有流量</p>
</li>
<li><p>否则顶点j$\in X^{*}$</p>
</li>
</ul>
</li>
<li><p>则有</p>
<script type="math/tex; mode=display">\begin{align}{c}
v* & = \sum_{i \in X^{*}, j \in \bar_{X^{*}} x_{ij} -
   \sum{j \in \bar_{X^{*}, i \in X^{*}} x_{ji} \\

& = \sum_{i \in X^{*}, j \in \bar_{X^{*}}} u_{ij} - 0 \\

& = C(X^{*}, \bar_{X^{*}})
\end{align}</script><p>即存在某个割容量等于流量增益法得到最终流量值</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-09T18:35:42.000Z" title="4/10/2019, 2:35:42 AM">2019-04-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-02T09:30:55.000Z" title="8/2/2021, 5:30:55 PM">2021-08-02</time></span><span class="level-item"><a class="link-muted" href="/categories/Database/">Database</a><span> / </span><a class="link-muted" href="/categories/Database/Spark/">Spark</a></span><span class="level-item">15 minutes read (About 2177 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Database/Spark/spark_joinreorder.html">SparkSQL2.4中启用CBO时JoinReorder分析</a></h1><div class="content"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="Spark-Join方式"><a href="#Spark-Join方式" class="headerlink" title="Spark Join方式"></a>Spark Join方式</h3><p>SparkSQL目前支持三种join方式</p>
<ul>
<li><p><em>broadcast hash join</em>：将小表广播分发到大表所在的结点上
，并行在各节点上进行hash join</p>
<ul>
<li>仅适合内表非常小的场合</li>
</ul>
</li>
<li><p><em>shuffle hash join</em>：按照join key分区，每个结点独立并行
进行hash join</p>
<ul>
<li>类似分布式GHJ，不同块位于不同结点</li>
</ul>
</li>
<li><p><em>sort merge join</em>：按照join key分区，在各节点独立并行<em>SMJ</em></p>
<ul>
<li>spark当前shuffle算法使用<em>sort-based shuffle</em>算法</li>
<li>理论上shuffle过后各分区数据已经排序完毕，无需再次
sort，效率很高</li>
</ul>
</li>
</ul>
<h3 id="Join类型"><a href="#Join类型" class="headerlink" title="Join类型"></a>Join类型</h3><p>SparkSQL支持的Join类型可以分为以下两类</p>
<ul>
<li><p>顺序结果无关Join</p>
<ul>
<li><em>inner join</em></li>
<li><em>(full)outer join</em></li>
</ul>
</li>
<li><p>顺序结果相关Join</p>
<ul>
<li><em>left(outer) join</em></li>
<li><em>right(outer) join</em></li>
<li><em>left semi join</em></li>
<li><em>right semi join</em></li>
</ul>
</li>
</ul>
<p>考虑到JoinReorder的结果</p>
<ul>
<li><p>仅支持连接重排序的连接类型只可能是<em>inner join</em>
<em>outer join</em></p>
</li>
<li><p>而<em>outer join</em>重排序虽然不影响结果，但是处理不方便，所以
联接重排序一般仅限于<em>inner join</em>？？？</p>
<ul>
<li>有些情况下RBO可以将外联接等价转换为内联接</li>
<li>SparkSQL2.4中支持的连接重排序仅限于内连接</li>
</ul>
</li>
</ul>
<h3 id="Cost-Based-Opitimization-Optimizer"><a href="#Cost-Based-Opitimization-Optimizer" class="headerlink" title="Cost-Based Opitimization/Optimizer"></a><em>Cost-Based Opitimization/Optimizer</em></h3><p><em>CBO</em>：基于成本的优化（器）</p>
<ul>
<li><p>根据SQL的执行成本制定、优化查询作业执行计划，生成可能
的执行计划中代价最小的计划</p>
<ul>
<li>数据表统计数据<ul>
<li>基/势</li>
<li>唯一值数量</li>
<li>空值数量</li>
<li>平均、最大长度</li>
</ul>
</li>
<li>SQL执行路径I/O</li>
<li>网络资源</li>
<li>CPU使用情况</li>
</ul>
</li>
<li><p>在SparkSQL Hash Join中可以用于</p>
<ul>
<li>选择正确hash建表方</li>
<li>选择正确join类型：广播hash、全洗牌hash</li>
<li>join reorder：调整多路join顺序</li>
</ul>
</li>
<li><p>CBO本身需要耗费一定资源，需要平衡CBO和查询计划优化程度</p>
<ul>
<li>数据表的数据统计资源耗费</li>
<li>优化查询计划即时资源耗费</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>CBO是相较于<em>Rule-Based Optimization</em>的概念</li>
</ul>
</blockquote>
<h4 id="CBO中的独特概念"><a href="#CBO中的独特概念" class="headerlink" title="CBO中的独特概念"></a>CBO中的独特概念</h4><ul>
<li><p><em>cardinality</em>：集的势，结果集的行数</p>
<ul>
<li>表示SQL执行成本值</li>
<li>SQL执行返回的结果集包含的行数越多，成本越大</li>
</ul>
</li>
<li><p><em>selectivity</em>：可选择率，施加指定谓语条件后返回结果集的
记录数占未施加任何谓语条件的原始结果记录数的比率</p>
<ul>
<li>值越小，说明可选择性越好</li>
<li>值越大，说明可选择性越差，成本值越大</li>
</ul>
</li>
</ul>
<h2 id="Join-Reorder"><a href="#Join-Reorder" class="headerlink" title="Join Reorder"></a><em>Join Reorder</em></h2><p>Join Reorder：基于CBO的多表连接顺序重排</p>
<ul>
<li><p>用统计信息预估的基修正join顺序</p>
</li>
<li><p>主要涉及到以下两个方面</p>
<ul>
<li>查询代价估算</li>
<li>多表连接顺序搜索算法</li>
</ul>
</li>
</ul>
<h3 id="查询代价估计"><a href="#查询代价估计" class="headerlink" title="查询代价估计"></a>查询代价估计</h3><h4 id="代价模型"><a href="#代价模型" class="headerlink" title="代价模型"></a>代价模型</h4><ul>
<li><p>单个join操作成本</p>
<script type="math/tex; mode=display">
cost = weight * cardinality + (1 - weight)*size</script><blockquote>
<ul>
<li>carinality：对应CPU成本</li>
<li>size：对应IO成本</li>
</ul>
</blockquote>
</li>
<li><p>join树的成本是所有中间join成本总和</p>
</li>
</ul>
<h4 id="Filter-Selectivity估计"><a href="#Filter-Selectivity估计" class="headerlink" title="Filter Selectivity估计"></a><em>Filter Selectivity</em>估计</h4><p>过滤选择率：估计应用谓词表达式过滤的选择率</p>
<h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><ul>
<li><p><code>AND</code>：左侧过滤条件选择率、右侧过滤条件选择率之积</p>
<script type="math/tex; mode=display">
fs(a AND b) = fs(a) * fs(b)</script></li>
<li><p><code>OR</code>：左侧、右侧过滤条件选择率之和，减去其乘积</p>
<script type="math/tex; mode=display">
fs(a OR b) = fs(a) + fs(b) - fs(a) * fs(b)</script></li>
<li><p><code>NOT</code>：1减去原始过滤条件选择率</p>
<script type="math/tex; mode=display">
fs(NOT a) = 1.0 - fs(a)</script></li>
</ul>
<h5 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h5><ul>
<li><p><code>=</code>：等于条件</p>
<ul>
<li>若常数取值在当前列取值范围之外，则过滤选择率为0</li>
<li>否则根据柱状图、均匀分布得到过滤选择率</li>
</ul>
</li>
<li><p><code>&lt;</code>：小于条件</p>
<ul>
<li>若常数取值小于当前列最小值，则过滤选择率为0</li>
<li>否则根据柱状图、均匀分数得到过滤选择率</li>
</ul>
</li>
</ul>
<h4 id="Join-Carinality估计"><a href="#Join-Carinality估计" class="headerlink" title="Join Carinality估计"></a><em>Join Carinality</em>估计</h4><p>联接基：估计联接操作结果的基</p>
<ul>
<li><p><em>inner</em>：其他基估计值可由inner join计算</p>
<script type="math/tex; mode=display">
num(A IJ B) = \frac {num(A) * num(B)}
   {max(distinct(A.k), distinct(B.k))}</script><blockquote>
<ul>
<li><code>num(A)</code>：join操作前表A的有效记录数</li>
<li><code>distinct(A.k)</code>：表A中列k唯一值数量</li>
</ul>
</blockquote>
</li>
<li><p><em>left-outer</em>：取inner join、左表中基较大者</p>
<script type="math/tex; mode=display">
num(A LOJ B) = max(num(A IJ B), num(A))</script></li>
<li><p><em>right-outer</em>：取inner join、右表中基较大者</p>
<script type="math/tex; mode=display">
num(A ROJ B) = max(num(A IJ B), num(B))</script></li>
<li><p><em>full-outer</em></p>
<script type="math/tex; mode=display">
num(A FOJ B) = num(A ROJ B) + num(A ROJ B) - num(A IJ B)</script></li>
</ul>
<h3 id="多表连接顺序搜索算法"><a href="#多表连接顺序搜索算法" class="headerlink" title="多表连接顺序搜索算法"></a>多表连接顺序搜索算法</h3><p>SparkSQL2.4中使用动态规划算法对可能联接顺序进行搜索，从中
选择最优的联接顺序作为执行计划</p>
<ul>
<li><p>最优子结构：一旦前k个表联接顺序确定，则联接前中间表和
第k+1个表方案和前k个表的联接顺序无关</p>
</li>
<li><p>动态规划表：从单表代价开始，逐层向上计算各层多表联接代价
，直到求得所有表联接最小代价</p>
</li>
<li><p>减少搜索空间启发式想法：尽可能优先有谓词限制的内连接、
中间表</p>
</li>
</ul>
<h4 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h4><ul>
<li>优势：动态规划算法能够求得整个搜索空间中最优解</li>
<li>缺陷：当联接表数量增加时，算法需要搜索的空间增加的非常快
，计算最优联接顺序代价很高</li>
</ul>
<h2 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h2><h3 id="代价模型-1"><a href="#代价模型-1" class="headerlink" title="代价模型"></a>代价模型</h3><p>Postgres的查询代价估计模型基于CPU开销、IO开销，另外还增加
了<strong>启动代价</strong></p>
<script type="math/tex; mode=display">
总代价 = 启动代价 + IO代价 + CPU代价</script><h3 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h3><p>类似SparkSQL2.4多表连接算法（假设联接n个表）</p>
<ol>
<li><p>构造第一层关系：每个关系的最优路径就是关系的最优单表扫描
方式</p>
</li>
<li><p>迭代依次构造之后n-1层关系联接最优解</p>
<ul>
<li>左深联接树方式：将第k-1层每个关系同第1层关系联接</li>
<li>紧密树联接方式：将第m(m &gt; 2)层每个关系同第k-m层关系
联接</li>
</ul>
<p><img src="/imgs/left_deep_tree_bushy_tree.png" alt="left_deep_tree_bushy_tree"></p>
</li>
</ol>
<h3 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h3><p>遗传算法：模拟自然界生物进化过程，采用人工进化的方式对目标
空间进行搜索</p>
<ul>
<li>本质是高效、并行、全局搜索方法</li>
<li>能在搜索过程中自动获取、积累有关搜索空间的知识，并自适应
的控制搜索过程以求的最佳解</li>
</ul>
<h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><ul>
<li>将问题域中可能解看作是染色体，将其编码为符号串的形式</li>
<li>对染色体群体反复进行基于遗传学的操作：选择、交叉、变异</li>
<li>根据预定目标适应度函数对每个个体进行评价，不断得到更优
群体，从中全局并行搜索得到优化群体中最优个体</li>
</ul>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="代价模型-2"><a href="#代价模型-2" class="headerlink" title="代价模型"></a>代价模型</h3><script type="math/tex; mode=display">
总代价 = IO代价 + CPU代价</script><ul>
<li>因为多表联接顺序采用贪心算法，多个表已经按照一定规则排序
（可访问元组数量升序排序）</li>
<li>所以MySQL认为，找到每个表的最小花费就是最终联接最小代价</li>
</ul>
<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>贪心算法：认为每次连接表的连接方式都是最优的，即从未联接表中
选择使得下次联接代价最小者</p>
<ul>
<li><p>多表排序一般为</p>
<ul>
<li>常量表最前</li>
<li>其他表按可访问元组数量升序排序</li>
</ul>
</li>
<li><p>贪心算法得到的联接方式都是最优的</p>
<ul>
<li>则每次联接主要求解要联接表对象的最佳访问方式</li>
<li>即每次代价估计的重点在于单表扫描的代价</li>
</ul>
</li>
<li><p>求解结束后，局部最优查询计划生成</p>
<ul>
<li>得到左深树</li>
<li>最初始表位于最左下端叶子节点处</li>
</ul>
</li>
</ul>
<h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><p>以下分别从查询代价估计、多表连接顺序搜索算法给出方案</p>
<h3 id="查询代价估计-1"><a href="#查询代价估计-1" class="headerlink" title="查询代价估计"></a>查询代价估计</h3><ul>
<li><p>考虑在现有代价模型上增加网络通信开销</p>
<script type="math/tex; mode=display">
cost = \alpha * cardinality + \beta * size + \gamma netcost</script></li>
<li><p>在现有直方图估计选择率基础上，增加选择率估计方法</p>
<ul>
<li><p><em>Parametric Method</em>：参数方法，使用预先估计分布函数
逼近真实分布</p>
</li>
<li><p><em>Curve Fitting</em>：曲线拟合法，使用多项式函数、最小
标准差逼近属性值分布</p>
</li>
</ul>
</li>
</ul>
<h3 id="多表连接顺序搜索算法-1"><a href="#多表连接顺序搜索算法-1" class="headerlink" title="多表连接顺序搜索算法"></a>多表连接顺序搜索算法</h3><p>考虑到动态规划算法随着联接表数量增加时，计算代价过于庞大，
可以考虑引入其他算法优化多表连接顺序</p>
<ul>
<li>遗传算法</li>
<li>退火算法</li>
<li>贪心算法</li>
</ul>
<ul>
<li>遗传算法</li>
<li>退火算法</li>
<li>贪心算法</li>
</ul>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/26/">Previous</a></div><div class="pagination-next"><a href="/page/28/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/26/">26</a></li><li><a class="pagination-link is-current" href="/page/27/">27</a></li><li><a class="pagination-link" href="/page/28/">28</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/40/">40</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">36</span></span></a><ul><li><a class="level is-mobile" href="/categories/Algorithm/Data-Structure/"><span class="level-start"><span class="level-item">Data Structure</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Heuristic/"><span class="level-start"><span class="level-item">Heuristic</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Issue/"><span class="level-start"><span class="level-item">Issue</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Problem/"><span class="level-start"><span class="level-item">Problem</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Specification/"><span class="level-start"><span class="level-item">Specification</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/C-C/"><span class="level-start"><span class="level-item">C/C++</span></span><span class="level-end"><span class="level-item tag">34</span></span></a><ul><li><a class="level is-mobile" href="/categories/C-C/Cppref/"><span class="level-start"><span class="level-item">Cppref</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/Cstd/"><span class="level-start"><span class="level-item">Cstd</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/MPI/"><span class="level-start"><span class="level-item">MPI</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/STL/"><span class="level-start"><span class="level-item">STL</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/CS/"><span class="level-start"><span class="level-item">CS</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/CS/Character/"><span class="level-start"><span class="level-item">Character</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Parallel/"><span class="level-start"><span class="level-item">Parallel</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Program-Design/"><span class="level-start"><span class="level-item">Program Design</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Storage/"><span class="level-start"><span class="level-item">Storage</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Daily-Life/"><span class="level-start"><span class="level-item">Daily Life</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/Daily-Life/Maxism/"><span class="level-start"><span class="level-item">Maxism</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Database/"><span class="level-start"><span class="level-item">Database</span></span><span class="level-end"><span class="level-item tag">27</span></span></a><ul><li><a class="level is-mobile" href="/categories/Database/Hadoop/"><span class="level-start"><span class="level-item">Hadoop</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Database/SQL-DB/"><span class="level-start"><span class="level-item">SQL DB</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Database/Spark/"><span class="level-start"><span class="level-item">Spark</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/Scala/"><span class="level-start"><span class="level-item">Scala</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">42</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Bash-Programming/"><span class="level-start"><span class="level-item">Bash Programming</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Configuration/"><span class="level-start"><span class="level-item">Configuration</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/File-System/"><span class="level-start"><span class="level-item">File System</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/IPC/"><span class="level-start"><span class="level-item">IPC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Process-Schedual/"><span class="level-start"><span class="level-item">Process Schedual</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Shell/"><span class="level-start"><span class="level-item">Shell</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Tool/"><span class="level-start"><span class="level-item">Tool</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Tool/Vi/"><span class="level-start"><span class="level-item">Vi</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Model/"><span class="level-start"><span class="level-item">ML Model</span></span><span class="level-end"><span class="level-item tag">21</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Model/Linear-Model/"><span class="level-start"><span class="level-item">Linear Model</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Model-Component/"><span class="level-start"><span class="level-item">Model Component</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Nolinear-Model/"><span class="level-start"><span class="level-item">Nolinear Model</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Unsupervised-Model/"><span class="level-start"><span class="level-item">Unsupervised Model</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/"><span class="level-start"><span class="level-item">ML Specification</span></span><span class="level-end"><span class="level-item tag">17</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/Click-Through-Rate/"><span class="level-start"><span class="level-item">Click Through Rate</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/Click-Through-Rate/Recommandation-System/"><span class="level-start"><span class="level-item">Recommandation System</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/Computer-Vision/"><span class="level-start"><span class="level-item">Computer Vision</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Specification/FinTech/"><span class="level-start"><span class="level-item">FinTech</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/FinTech/Risk-Control/"><span class="level-start"><span class="level-item">Risk Control</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/Graph-Analysis/"><span class="level-start"><span class="level-item">Graph Analysis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Specification/NLP/"><span class="level-start"><span class="level-item">NLP</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Technique/"><span class="level-start"><span class="level-item">ML Technique</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Technique/Feature-Engineering/"><span class="level-start"><span class="level-item">Feature Engineering</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Technique/Neural-Network/"><span class="level-start"><span class="level-item">Neural Network</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Theory/"><span class="level-start"><span class="level-item">ML Theory</span></span><span class="level-end"><span class="level-item tag">11</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Theory/Loss/"><span class="level-start"><span class="level-item">Loss</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Theory/Model-Enhencement/"><span class="level-start"><span class="level-item">Model Enhencement</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Theory/Optimization/"><span class="level-start"><span class="level-item">Optimization</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Algebra/"><span class="level-start"><span class="level-item">Math Algebra</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Algebra/Linear-Algebra/"><span class="level-start"><span class="level-item">Linear Algebra</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Algebra/Universal-Algebra/"><span class="level-start"><span class="level-item">Universal Algebra</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Analysis/"><span class="level-start"><span class="level-item">Math Analysis</span></span><span class="level-end"><span class="level-item tag">23</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Analysis/Fourier-Analysis/"><span class="level-start"><span class="level-item">Fourier Analysis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Functional-Analysis/"><span class="level-start"><span class="level-item">Functional Analysis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Optimization/"><span class="level-start"><span class="level-item">Optimization</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Real-Analysis/"><span class="level-start"><span class="level-item">Real Analysis</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Mixin/"><span class="level-start"><span class="level-item">Math Mixin</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Mixin/Statistics/"><span class="level-start"><span class="level-item">Statistics</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Mixin/Time-Series/"><span class="level-start"><span class="level-item">Time Series</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Probability/"><span class="level-start"><span class="level-item">Probability</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">89</span></span></a><ul><li><a class="level is-mobile" href="/categories/Python/Cookbook/"><span class="level-start"><span class="level-item">Cookbook</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Jupyter/"><span class="level-start"><span class="level-item">Jupyter</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Keras/"><span class="level-start"><span class="level-item">Keras</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Matplotlib/"><span class="level-start"><span class="level-item">Matplotlib</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Numpy/"><span class="level-start"><span class="level-item">Numpy</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Pandas/"><span class="level-start"><span class="level-item">Pandas</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Py3Ref/"><span class="level-start"><span class="level-item">Py3Ref</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Py3std/"><span class="level-start"><span class="level-item">Py3std</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Pywin32/"><span class="level-start"><span class="level-item">Pywin32</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Readme/"><span class="level-start"><span class="level-item">Readme</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/TensorFlow/"><span class="level-start"><span class="level-item">TensorFlow</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Twists/"><span class="level-start"><span class="level-item">Twists</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/RLang/"><span class="level-start"><span class="level-item">RLang</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Rust/"><span class="level-start"><span class="level-item">Rust</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Set/"><span class="level-start"><span class="level-item">Set</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/"><span class="level-start"><span class="level-item">Tool</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/Tool/Editor/"><span class="level-start"><span class="level-item">Editor</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Markup-Language/"><span class="level-start"><span class="level-item">Markup Language</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Web-Browser/"><span class="level-start"><span class="level-item">Web Browser</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Windows/"><span class="level-start"><span class="level-item">Windows</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/Web/CSS/"><span class="level-start"><span class="level-item">CSS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/NPM/"><span class="level-start"><span class="level-item">NPM</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/Proxy/"><span class="level-start"><span class="level-item">Proxy</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/Thrift/"><span class="level-start"><span class="level-item">Thrift</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://octodex.github.com/images/hula_loop_octodex03.gif" alt="UBeaRLy"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">UBeaRLy</p><p class="is-size-6 is-block">Protector of Proxy</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">392</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">93</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">522</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/xyy15926" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/xyy15926"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-04T15:07:54.896Z">2021-08-04</time></p><p class="title"><a href="/uncategorized/README.html"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-03T07:46:51.000Z">2021-08-03</time></p><p class="title"><a href="/Web/NPM/hexo_config.html">Hexo 建站</a></p><p class="categories"><a href="/categories/Web/">Web</a> / <a href="/categories/Web/NPM/">NPM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-03T02:32:45.000Z">2021-08-03</time></p><p class="title"><a href="/Web/NPM/config.html">NPM 总述</a></p><p class="categories"><a href="/categories/Web/">Web</a> / <a href="/categories/Web/NPM/">NPM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-02T08:11:11.000Z">2021-08-02</time></p><p class="title"><a href="/Python/Py3std/internet_data.html">互联网数据</a></p><p class="categories"><a href="/categories/Python/">Python</a> / <a href="/categories/Python/Py3std/">Py3std</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-29T13:55:00.000Z">2021-07-29</time></p><p class="title"><a href="/Linux/Shell/sh_apps.html">Shell 应用程序</a></p><p class="categories"><a href="/categories/Linux/">Linux</a> / <a href="/categories/Linux/Shell/">Shell</a></p></div></article></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">Advertisement</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5385776267343559" data-ad-slot="6995841235" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="https://api.follow.it/subscription-form/WWxwMVBsOUtoNTdMSlJ4Z1lWVnRISERsd2t6ek9MeVpEUWs0YldlZGxUdXlKdDNmMEZVV1hWaFZFYWFSNmFKL25penZodWx3UzRiaVkxcnREWCtOYUJhZWhNbWpzaUdyc1hPangycUh5RTVjRXFnZnFGdVdSTzZvVzJBcTJHKzl8aXpDK1ROWWl4N080YkFEK3QvbEVWNEJuQjFqdWdxODZQcGNoM1NqbERXST0=/8" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="UBeaRLy" height="28"></a><p class="is-size-7"><span>&copy; 2021 UBeaRLy</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/xyy15926/proxy"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>