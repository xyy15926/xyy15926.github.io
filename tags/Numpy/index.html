<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Tag: Numpy - Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="UBeaRLy&#039;s Proxy"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="UBeaRLy&#039;s Proxy"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Hexo"><meta property="og:url" content="https://xyy15926.github.io/"><meta property="og:site_name" content="Hexo"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://xyy15926.github.io/img/og_image.png"><meta property="article:author" content="UBeaRLy"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xyy15926.github.io"},"headline":"Hexo","image":["https://xyy15926.github.io/img/og_image.png"],"author":{"@type":"Person","name":"UBeaRLy"},"publisher":{"@type":"Organization","name":"Hexo","logo":{"@type":"ImageObject","url":"https://xyy15926.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/darcula.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><script data-ad-client="ca-pub-5385776267343559" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Visit on GitHub" href="https://github.com/xyy15926/proxy"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">Tags</a></li><li class="is-active"><a href="#" aria-current="page">Numpy</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-03-14T09:52:56.000Z" title="3/14/2021, 5:52:56 PM">2021-03-14</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-03-14T09:52:56.000Z" title="3/14/2021, 5:52:56 PM">2021-03-14</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Numpy/">Numpy</a></span><span class="level-item">6 minutes read (About 907 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Numpy/ndarray_sci.html">NDArray 科学计算</a></h1><div class="content"><h2 id="NumPy-Numeric"><a href="#NumPy-Numeric" class="headerlink" title="NumPy Numeric"></a>NumPy Numeric</h2><h3 id="矩阵、向量乘积"><a href="#矩阵、向量乘积" class="headerlink" title="矩阵、向量乘积"></a>矩阵、向量乘积</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dot(a,b[,out])</code></td>
<td><code>a</code>最后轴与<code>b</code>倒数第二轴的点积，即shape满足线代要求</td>
</tr>
<tr>
<td><code>inner(a,b[,out])</code></td>
<td><code>a</code>最后轴与<code>b</code>最后轴的点积</td>
</tr>
<tr>
<td><code>vdot(a,b)</code></td>
<td>向量点积，多维将被展平</td>
</tr>
<tr>
<td><code>outer(a,b[,out])</code></td>
<td>向量外积，多维将被展平</td>
</tr>
<tr>
<td><code>matmul(x1,x2,/[,out,casting,order,...])</code></td>
<td>矩阵乘积</td>
</tr>
<tr>
<td><code>tensordot(a,b[,axes])</code></td>
<td>沿指定轴计算张量积</td>
</tr>
<tr>
<td><code>einsum(subscripts,*operands[,out,dtype,...])</code></td>
<td>Einstein求和约定</td>
</tr>
<tr>
<td><code>einsum_path(subscripts,*operands[,optimize])</code></td>
<td>考虑中间数组情况下评估计算表达式最小代价</td>
</tr>
<tr>
<td><code>linalg.matrix_power(a,n)</code></td>
<td>方阵幂</td>
</tr>
<tr>
<td><code>kron(a,b)</code></td>
<td>Kronecker积（矩阵外积，分块）</td>
</tr>
<tr>
<td><code>trace(a[,offset,axis1,axis2,dtype,out])</code></td>
<td>迹</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>Einstein求和约定：简化求和式中的求和符号</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">15</span>).reshape(<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">b = np.arange(<span class="number">1</span>,<span class="number">16</span>).reshape(<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment"># Transpose</span></span><br><span class="line">np.einsum(<span class="string">&quot;ij-&gt;ji&quot;</span>, a)</span><br><span class="line"><span class="comment"># Sum all</span></span><br><span class="line">np.einsum(<span class="string">&quot;ij-&gt;&quot;</span>, a)</span><br><span class="line"><span class="comment"># Sum along given axis</span></span><br><span class="line">np.einsum(<span class="string">&quot;ij-&gt;i&quot;</span>, a)</span><br><span class="line">np.einsum(<span class="string">&quot;ij-&gt;j&quot;</span>, a)</span><br><span class="line"><span class="comment"># Multiply</span></span><br><span class="line">np.einsum(<span class="string">&quot;ij,ij-&gt;&quot;</span>,a,b)</span><br><span class="line"><span class="comment"># Inner product</span></span><br><span class="line">np.einsum(<span class="string">&quot;ik,jk-&gt;&quot;</span>,a,b)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>np.tensordot</code>：张量积，类似普通内积，仅有结构</p>
<ul>
<li><code>axes</code>为整形<ul>
<li><code>axes&gt;0</code>：<code>a</code>末尾<code>axes</code>维度、<code>b</code>开头<code>axes</code>维度
内积</li>
<li><code>axes=0</code>：Kronecker积</li>
</ul>
</li>
<li><code>axes</code>为2-Tuple：分别指定<code>a</code>、<code>b</code>内积的轴</li>
</ul>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>|Function|Desc|
|<code>np.i0(X)</code>|第1类修改的Bessel函数，0阶|</p>
<h2 id="np-linalg"><a href="#np-linalg" class="headerlink" title="np.linalg"></a><code>np.linalg</code></h2><ul>
<li>NumPy的线代基于<em>BLAS</em>、<em>LAPACK</em>提供高效的标准底层实现<ul>
<li>依赖库可以是NumPy提供的C版本子集</li>
<li>也可是针对特定平台优化的库（更好）<ul>
<li><em>OpenBLAS</em></li>
<li><em>MKL</em></li>
<li><em>ATLAS</em></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="np-linalg-1"><a href="#np-linalg-1" class="headerlink" title="np.linalg"></a><code>np.linalg</code></h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>multi_dot(arrays)</code></td>
<td>自动选择最快的计算顺序计算内积</td>
</tr>
<tr>
<td><code>cholesky(a)</code></td>
<td>cholesky分解</td>
</tr>
<tr>
<td><code>det(a)</code></td>
<td>行列式</td>
</tr>
<tr>
<td><code>eig(a)</code></td>
<td>特征值、特征向量（右乘）</td>
</tr>
<tr>
<td><code>eigh(a[,UPLO])</code></td>
<td>Hermitian（共轭对称）或实对称矩阵特征值、特征向量</td>
</tr>
<tr>
<td><code>eigvals(a)</code></td>
<td>特征值</td>
</tr>
<tr>
<td><code>eigvalsh(a[,UPLO])</code></td>
<td>Hermitian（共轭对称）或实对称矩阵特征值</td>
</tr>
<tr>
<td><code>inv(a)</code></td>
<td>矩阵逆</td>
</tr>
<tr>
<td><code>lstsq(a,b[,rcond])</code></td>
<td>最小二乘解</td>
</tr>
<tr>
<td><code>norm(x[,ord,axis,keepdims])</code></td>
<td>矩阵、向量范数</td>
</tr>
<tr>
<td><code>pinv(a[,rcond,hermitian])</code></td>
<td>Moore-Penrose伪逆</td>
</tr>
<tr>
<td><code>solve(a,b)</code></td>
<td>线程方程组求解</td>
</tr>
<tr>
<td><code>tensorsolve(a,b[,axes])</code></td>
<td>张量方程组求解</td>
</tr>
<tr>
<td><code>tensorrinv(a[,ind])</code></td>
<td>张量逆</td>
</tr>
<tr>
<td><code>svd(a[,full_matrices,compute_uv,hermitian])</code></td>
<td>奇异值分解</td>
</tr>
<tr>
<td><code>qr(a[,mode])</code></td>
<td>QR分解</td>
</tr>
<tr>
<td><code>matrix_rank(M[,tol,hermitian])</code></td>
<td>使用SVD方法计算矩阵秩</td>
</tr>
<tr>
<td><code>slogdet(a)</code></td>
<td>行列式的符号、自然对数</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>部分线代函数支持传入高维数组、数组序列，同时计算结果<ul>
<li>对高维数组，要求数组最后2、1维度满足计算要求</li>
</ul>
</li>
</ul>
<h2 id="（快速）傅里叶变换np-fft"><a href="#（快速）傅里叶变换np-fft" class="headerlink" title="（快速）傅里叶变换np.fft"></a>（快速）傅里叶变换<code>np.fft</code></h2><h3 id="Standard-FFTs"><a href="#Standard-FFTs" class="headerlink" title="Standard FFTs"></a>Standard FFTs</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>fft(a[,n,axis,norm])</code></td>
<td>1维离散傅里叶变换</td>
</tr>
<tr>
<td><code>fft2(a[,n,axes,norm])</code></td>
<td>2维离散FFT</td>
</tr>
<tr>
<td><code>fftn(a[,n,axes,norm])</code></td>
<td>N维离散FFT</td>
</tr>
<tr>
<td><code>ifft(a[,n,axis,norm])</code></td>
<td>1维离散逆FFT</td>
</tr>
<tr>
<td><code>ifft2(a[,n,axes,norm])</code></td>
<td>2维离散逆FFT</td>
</tr>
<tr>
<td><code>ifftn(a[,n,axes,norm])</code></td>
<td>N维离散逆FFT</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Real-FFTs"><a href="#Real-FFTs" class="headerlink" title="Real FFTs"></a>Real FFTs</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>rfft(a[,n,axis,norm])</code></td>
<td>1维离散傅里叶变换</td>
</tr>
<tr>
<td><code>rfft2(a[,n,axes,norm])</code></td>
<td>2维离散FFT</td>
</tr>
<tr>
<td><code>rfftn(a[,n,axes,norm])</code></td>
<td>N维离散FFT</td>
</tr>
<tr>
<td><code>irfft(a[,n,axis,norm])</code></td>
<td>1维逆离散FFT</td>
</tr>
<tr>
<td><code>irfft2(a[,n,axes,norm])</code></td>
<td>2维离散逆FFT</td>
</tr>
<tr>
<td><code>irfftn(a[,n,axes,norm])</code></td>
<td>N维离散逆FFT</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Hermitian-FFTs"><a href="#Hermitian-FFTs" class="headerlink" title="Hermitian FFTs"></a>Hermitian FFTs</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>hfft(a[,n,axis,norm])</code></td>
<td>Hermitian对称（实谱）的信号的FFT</td>
</tr>
<tr>
<td><code>ihfft(a[,n,axis,norm])</code></td>
<td>Hermitian对称（实谱）的信号的逆FFT</td>
</tr>
</tbody>
</table>
</div>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>fftfreq(n[,d])</code></td>
<td>离散FFT样本频率</td>
</tr>
<tr>
<td><code>rfftfreq(n[,d])</code></td>
<td></td>
</tr>
<tr>
<td><code>fftshift(x[,axes])</code></td>
<td>平移0频成分到频谱中间</td>
</tr>
<tr>
<td><code>ifftshift(x[,axes])</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="np-lib-scimath"><a href="#np-lib-scimath" class="headerlink" title="np.lib.scimath"></a><code>np.lib.scimath</code></h2><ul>
<li><p><code>np.lib.scimath</code>中包含一些顶层命名空间的同名函数</p>
<ul>
<li><p>相较于顶层空间，其定义域被扩展，相应其值域也扩展到
复数域</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.emath.log(-np.e) == <span class="number">1</span> + np.pi * <span class="number">1j</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><code>np.emath</code>是<code>np.lib.scimath</code>模块的推荐别名</li>
</ul>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-03-11T02:12:42.000Z" title="3/11/2021, 10:12:42 AM">2021-03-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-03-11T02:12:42.000Z" title="3/11/2021, 10:12:42 AM">2021-03-11</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Numpy/">Numpy</a></span><span class="level-item">35 minutes read (About 5293 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Numpy/ndarray_routines.html">NDArray Routine</a></h1><div class="content"><h2 id="Array-Manipulation"><a href="#Array-Manipulation" class="headerlink" title="Array Manipulation"></a>Array Manipulation</h2><h3 id="Shape-Only"><a href="#Shape-Only" class="headerlink" title="Shape Only"></a>Shape Only</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>reshape(a,newshape[,order])</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>resize(a,new_shape)</code></td>
<td>大小可不同，重复<code>a</code>补不足</td>
<td><code>0</code>补不足</td>
</tr>
<tr>
<td><code>ravel(a[,order])</code></td>
<td>展平视图</td>
<td></td>
</tr>
<tr>
<td><code>.flatten([order])</code></td>
<td>无</td>
<td>展平副本</td>
</tr>
<tr>
<td><code>shape(a)</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>size(a)</code></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Order-Alteration"><a href="#Order-Alteration" class="headerlink" title="Order Alteration"></a>Order Alteration</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>transpose(a[,axes])</code></td>
<td>调整轴顺序，缺省逆序即转置</td>
<td></td>
</tr>
<tr>
<td><code>moveaxis(a,source,destination)</code></td>
<td>移动数组轴到新位置</td>
<td>无</td>
</tr>
<tr>
<td><code>rollaxis(a,axis[,start])</code></td>
<td>将指定后向插入至指定位置（缺省0）</td>
<td>无</td>
</tr>
<tr>
<td><code>swapaxes(a,axis1,axis2)</code></td>
<td>交换轴</td>
<td></td>
</tr>
<tr>
<td><code>flip(m[,axis])</code></td>
<td>沿指定轴反向，缺省所有轴</td>
<td>无</td>
</tr>
<tr>
<td><code>fliplr(m)</code></td>
<td>左右反向（沿第2轴）</td>
<td>无</td>
</tr>
<tr>
<td><code>flipud(m)</code></td>
<td>上下反向（沿第1轴）</td>
<td>无</td>
</tr>
<tr>
<td><code>roll(a,shift[,axis])</code></td>
<td>沿轴滚动<code>shift</code></td>
<td>无</td>
</tr>
<tr>
<td><code>rot90(m[,k,axes])</code></td>
<td>在<code>axes</code>指定的平面中旋转<code>k</code>次90度</td>
<td>无</td>
</tr>
<tr>
<td><code>lib.stride_tricks.as_strided(x[,shape,...])</code></td>
<td>利用给定shape、stride在<code>x</code>上创建视图</td>
</tr>
</tbody>
</table>
</div>
<h3 id="维数改变"><a href="#维数改变" class="headerlink" title="维数改变"></a>维数改变</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>atleast_1d(*arys)</code></td>
<td>prepend维度直至维度至少维数至少1</td>
<td>无</td>
</tr>
<tr>
<td><code>atleast_2d(*arys)</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>atleatt_3d(*arys)</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>broadcast(*arys)</code></td>
<td>广播、打包输入对应元素的元组迭代器，类似<code>zip</code></td>
<td>无</td>
</tr>
<tr>
<td><code>broadcast_to(array,shape[,subok])</code></td>
<td>广播为指定shape</td>
<td>无</td>
</tr>
<tr>
<td><code>boradcast_arrays(*args,**kwargs)</code></td>
<td>输入的广播结果列表</td>
<td>无</td>
</tr>
<tr>
<td><code>expand_dims(a,axis)</code></td>
<td>在指定位置插入新轴</td>
<td>无</td>
</tr>
<tr>
<td><code>squeeze(a[,axis])</code></td>
<td>删除大小为1维度</td>
</tr>
</tbody>
</table>
</div>
<h3 id="插入、删除元素"><a href="#插入、删除元素" class="headerlink" title="插入、删除元素"></a>插入、删除元素</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>delete(arr,obj[,axis])</code></td>
<td>删除<code>obj</code>指定部分，缺省按展平数组删除</td>
</tr>
<tr>
<td><code>insert(arr,obj,values[,axis])</code></td>
<td>缺省按展平数组插入</td>
</tr>
<tr>
<td><code>append(arr,values[,axis])</code></td>
<td>缺省<code>arr</code>、<code>values</code>展平再添加</td>
</tr>
<tr>
<td><code>trim_zeros(filt[,trim])</code></td>
<td>trim前导、尾随0，缺省两边</td>
</tr>
</tbody>
</table>
</div>
<h3 id="改变类型"><a href="#改变类型" class="headerlink" title="改变类型"></a>改变类型</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>asarray(a[,dtype,order])</code></td>
<td>转换为数组</td>
<td>无</td>
</tr>
<tr>
<td><code>asarray_chkfinite(a[,dtype,order])</code></td>
<td>检查<code>NaN</code>、<code>inf</code></td>
<td>无</td>
</tr>
<tr>
<td><code>asanyarray(a[,dtype,order])</code></td>
<td>转换为数组，数组子类则不变</td>
<td>无</td>
</tr>
<tr>
<td><code>ascalar(a)</code></td>
<td>将大小为1的数组转换为等效标量</td>
</tr>
<tr>
<td><code>require(a[,dtype,requirements])</code></td>
<td>创建满足要求<code>ndarray.flags</code>数组</td>
<td>无</td>
</tr>
<tr>
<td><code>asfortranarray(a[,dtype])</code></td>
<td>转换为Fortran-contiguous风格内存布局</td>
<td>无</td>
</tr>
<tr>
<td><code>ascontiguousarray(a[,dtype])</code></td>
<td>转换为C-contiguous风格内存布局</td>
<td>无</td>
</tr>
<tr>
<td><code>asmatrix(data[,dtype])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>asfarray(a[,dtype])</code></td>
<td>转换为浮点类型</td>
<td>无</td>
</tr>
<tr>
<td><code>.astype(dtype[,order,casting,...])</code></td>
<td>无</td>
<td>转换为指定类型</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<ul>
<li>numpy中数组不是仅有C、Fortran风格内存布局，对数组的形态
  变换会导致内存布局不为任何风格内存布局</li>
</ul>
</blockquote>
<h3 id="组合数组"><a href="#组合数组" class="headerlink" title="组合数组"></a>组合数组</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>concatenate((a1,a2,...)[,axis,out])</code></td>
<td>沿现有轴连接数组</td>
</tr>
<tr>
<td><code>stack(arrays[,axis,out])</code></td>
<td>创建给定（新）轴堆叠数组</td>
</tr>
<tr>
<td><code>row_stack(tup)/vstack(tup)</code></td>
<td>沿第1（竖直）轴堆叠</td>
</tr>
<tr>
<td><code>column_stack(tup)/hstack(tup)</code></td>
<td>沿第2（水平）轴堆叠</td>
</tr>
<tr>
<td><code>dstack(tup)</code></td>
<td>沿第3轴堆叠</td>
</tr>
<tr>
<td><code>block(arrays)</code></td>
<td>按照<code>arrays</code>中给定数组块、位置组装</td>
</tr>
</tbody>
</table>
</div>
<h3 id="拆分数组"><a href="#拆分数组" class="headerlink" title="拆分数组"></a>拆分数组</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>split(ary,indices_or_sections[,axis])</code></td>
<td>沿轴拆分成视图</td>
</tr>
<tr>
<td><code>array_split(ary,indices_or_sections[,axis])</code></td>
<td>同<code>split</code>，但可处理不整除拆分</td>
</tr>
<tr>
<td><code>vsplit(ary,indices_or_sections)</code></td>
<td>沿第1（竖直）轴拆分</td>
</tr>
<tr>
<td><code>hsplit(ary,indices_or_sections)</code></td>
<td>沿第2（水平）轴拆分</td>
</tr>
<tr>
<td><code>dsplit(ary,indices_or_sections)</code></td>
<td>沿第3轴拆分</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pad(array,pad_width[,mode])</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="Index-Routine"><a href="#Index-Routine" class="headerlink" title="Index Routine"></a>Index Routine</h2><ul>
<li><p>结果数组shape考虑逻辑链</p>
<ul>
<li>确定输出数组的维数<code>ndim</code></li>
<li>确定参数数组原维度轴位置、补1轴位置，参数维度轴对齐</li>
<li>修正各维度大小<ul>
<li>沿轴操作：保持不变</li>
<li>沿轴采样：采样数目</li>
<li>沿轴concate：维度相加</li>
<li>沿轴聚集：删除维度</li>
<li>沿轴切片聚集：删除其余维度</li>
</ul>
</li>
</ul>
</li>
<li><p>numpy中（多维）索引往往使用整数高级索引的方式返回</p>
<ul>
<li><code>np.ndarray</code>数组：首维度各分量分别表示各维度的高级
索引</li>
<li>list、tuple：各元素分别为各维度的高级索引</li>
</ul>
</li>
</ul>
<h3 id="数组无关切片、高级索引"><a href="#数组无关切片、高级索引" class="headerlink" title="数组无关切片、高级索引"></a>数组无关切片、高级索引</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>返回值类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s_[]</code></td>
<td>支持多维切片生成，类<code>slice()</code></td>
<td>切片、元组</td>
</tr>
<tr>
<td><code>index_exp[]</code></td>
<td>同<code>s_</code>，但总返回元组</td>
<td>元组</td>
</tr>
<tr>
<td><code>r_[]</code></td>
<td>沿第1轴concate切片、数组、标量</td>
<td>数组</td>
</tr>
<tr>
<td><code>c_[]</code></td>
<td>沿第-1轴concate切片、数组、标量（1维则被视为列向量）</td>
<td>数组</td>
</tr>
<tr>
<td><code>ravel_multi_index(multi_index,dims[,mode,order])</code></td>
<td>计算高级索引<code>multi_index</code>在<code>dims</code>数组展平后的位置</td>
<td>数组</td>
</tr>
<tr>
<td><code>unravel_index(indices,shape[,order])</code></td>
<td><code>ravel_multi_index</code>逆向</td>
<td>元组</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p><code>np.r_[]</code>、<code>np.c_[]</code>除可concate切片方便生成数组，还可以
传递两个参数修改行为</p>
<ul>
<li><p><code>r</code>/<code>c</code>字符被设置时，返回矩阵</p>
<ul>
<li>1维数组，<code>r</code>被设置时返回1 <em> N矩阵，<code>c</code>被设置时
返回N </em> 1矩阵</li>
<li>2维数组，<code>r</code>、<code>c</code>被设置时，结果矩阵相同</li>
</ul>
</li>
<li><p><code>&lt;axis&gt;[,&lt;ndim&gt;,&lt;ori_pos&gt;]</code>三个整形，决定shape</p>
<p>|参数|说明|<code>np.r_[]</code>缺省值|<code>np.c_[]</code>缺省值|
|——-|——-|——-|——-|
|<code>&lt;axis&gt;</code>|concate执行轴|<code>0</code>|<code>-1</code>|
|<code>&lt;ndim&gt;</code>|目标维数，仅在其大于结果维数时才生效|<code>1</code>|<code>2</code>|
|<code>&lt;ori_pos&gt;</code>|原数据轴所在的位置|<code>-1</code>，即prepend全<code>1</code>轴|<code>0</code>，即postpend全<code>1</code>轴|</p>
</li>
<li><p>相同参数时，两者结果相同，可根据不同数组设置合适的
参数相互实现</p>
<ul>
<li><code>np.r_[]</code>可视为参数缺省为<code>0,1,-1</code></li>
<li><code>np.c_[]</code>可视为参数缺省为<code>-1,2,0</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><code>np.r_</code>、<code>np.c_</code>分别是<code>np.lib.index_tricks.RClass</code>、
  <code>np.lib.index_tricks.CClass</code>实例</li>
<li><code>np.s_</code>、<code>np.index_exp</code>均是
  <code>np.lib.index_tricks.IndexExpression</code>实例，仅初始化参数
  不同</li>
</ul>
</blockquote>
<h3 id="网格"><a href="#网格" class="headerlink" title="网格"></a>网格</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>返回值类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ix_(*args)</code></td>
<td>以<code>args</code>为基点创建开网格（仅设置基点、维度）</td>
<td>元组</td>
</tr>
<tr>
<td><code>meshgrid(*xi,**kwargs)</code></td>
<td>以<code>xi</code>作为基点创建稠密网格（所有网格点高级索引）</td>
<td>列表</td>
</tr>
<tr>
<td><code>mgrid[]</code></td>
<td>根据切片创建稠密网格</td>
<td>数组</td>
</tr>
<tr>
<td><code>ogrid[]</code></td>
<td>根据切片创建开网格</td>
<td>列表</td>
</tr>
<tr>
<td><code>indices(dimensions[,dtype,sparse])</code></td>
<td>以<code>dimensions</code>作为各维度长创建网格</td>
<td>数组、元组</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>开网格广播即可得到稠密网格</li>
</ul>
<h3 id="值相关索引"><a href="#值相关索引" class="headerlink" title="值相关索引"></a>值相关索引</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>nonzero(a)</code></td>
<td>非0元素整形高级索引</td>
<td></td>
</tr>
<tr>
<td><code>where(condition,[x,y])</code></td>
<td><code>condition</code>对应整形高级索引，给出<code>x,y</code>时则从中抽取元素</td>
<td>无</td>
</tr>
<tr>
<td><code>flatnonzero(a)</code></td>
<td>展平非0位置</td>
<td>无</td>
</tr>
</tbody>
</table>
</div>
<h3 id="特殊位置索引"><a href="#特殊位置索引" class="headerlink" title="特殊位置索引"></a>特殊位置索引</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>diag_indices(n[,ndim])</code></td>
<td><code>ndim</code>维长为<code>n</code>数组对角索引</td>
</tr>
<tr>
<td><code>diag_indices_from(arr)</code></td>
<td>获取<code>arr</code>对角索引</td>
</tr>
<tr>
<td><code>mask_indices(n,mask_func[,k])</code></td>
<td>根据<code>mask_func</code>获取n * n数组索引</td>
</tr>
<tr>
<td><code>tril_indices(n[,k,m])</code></td>
<td>n * m的下三角索引</td>
</tr>
<tr>
<td><code>triu_indices(n[,k,m])</code></td>
<td>n * m的上三角索引</td>
</tr>
<tr>
<td><code>tril_indices_from(arr[,k])</code></td>
<td><code>arr</code>的下三角索引</td>
</tr>
<tr>
<td><code>triu_indices_from(arr[,k])</code></td>
<td><code>arr</code>的下三角索引</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>np.ndindex(*args) == np.broadcast(*np.indices(*args))</code></li>
</ul>
<h3 id="Searching-索引"><a href="#Searching-索引" class="headerlink" title="Searching 索引"></a>Searching 索引</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>argwhere(a)</code></td>
<td>非0点坐标数组</td>
<td>无</td>
</tr>
<tr>
<td><code>argmax(a[,axis,out])</code></td>
<td>展平后位置，存在<code>NaN</code>则返回<code>0</code></td>
<td></td>
</tr>
<tr>
<td><code>argmin(a[,axis])</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>nanargmax(a[,axis])</code></td>
<td>忽略<code>NaN</code></td>
</tr>
<tr>
<td><code>nanargmin(a[,axis])</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>searchsorted(a,v[,side,sorter])</code></td>
<td>应插入（保持有序）位置</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Value-Manipulation"><a href="#Value-Manipulation" class="headerlink" title="Value Manipulation"></a>Value Manipulation</h2><h3 id="Value-Extraction"><a href="#Value-Extraction" class="headerlink" title="Value Extraction"></a>Value Extraction</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>take(a,indices[,axis,out,mode])</code></td>
<td>按<code>indices</code>沿给定轴获取超平面（缺省将数组展平）</td>
<td></td>
</tr>
<tr>
<td><code>take_along_axis(arr,indices,axis)</code></td>
<td>将<code>arr</code>、<code>indices</code>沿<code>axis</code>匹配，选取元素</td>
<td>无</td>
</tr>
<tr>
<td><code>compress(condition,a[,axis,out])</code></td>
<td>按bool数组<code>condition</code>沿给定轴<code>axis</code>选取超平面（缺省将数组展平）</td>
<td></td>
</tr>
<tr>
<td><code>extract(condition,arr)</code></td>
<td>在展平数组上抽取元素</td>
<td>无</td>
</tr>
<tr>
<td><code>choose(a,choices[,out,mode])</code></td>
<td>根据<code>a</code>广播后元素值选择<code>choices</code>中数组填充对应位置</td>
<td></td>
</tr>
<tr>
<td><code>select(condlist,choicelist[,default])</code></td>
<td><code>condlist</code>中首个真值对应的<code>choicelist</code>数组填充对应位置</td>
<td>无</td>
</tr>
<tr>
<td><code>diag(v[,k])</code></td>
<td>从2维<code>v</code>抽取对角、或以1维<code>v</code>作为对角</td>
<td>无</td>
</tr>
<tr>
<td><code>diagonal(a[,offset,axis1,axis2])</code></td>
<td>返回给定对象</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p><code>take</code>：沿给定轴从数组中获取元素</p>
<ul>
<li><code>axis</code>为<code>None</code>时，按展平后获取<code>indices</code>指定元素，
非<code>None</code>时<ul>
<li>函数行为同高级索引</li>
<li>指定<code>axis</code>可以简化通过高级索引获取指定轴的元素</li>
</ul>
</li>
<li>基本元素为数组在该轴的切片</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ni, Nk = a.shape[:axis], a.shape[axis+<span class="number">1</span>:]</span><br><span class="line">Nj = indices.shape</span><br><span class="line"><span class="keyword">for</span> ii <span class="keyword">in</span> np.ndindex(Ni):</span><br><span class="line">	<span class="keyword">for</span> jj <span class="keyword">in</span> np.ndindex(Nj):</span><br><span class="line">		<span class="keyword">for</span> kk <span class="keyword">in</span> np.ndindex(Nk):</span><br><span class="line">			out[ii+jj+kk] = a[ii+(indices[jj],)+kk]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>take_along_axis</code>：匹配给定轴方向的1维索引、数据切片，
获取元素</p>
<ul>
<li>基本元素为单个元素<ul>
<li>将<code>indices</code>和<code>arr</code>对齐，除给定维度外，其余维度
大小均须相同</li>
<li>其余维度给定下，按照<code>indices</code>在超平面上给出的
位置获取对应的元素</li>
<li>即<code>take</code>以超平面为单位获取整个超平面的元素，而
<code>take_along_axis</code>按元素为单位，沿给定轴方向调整
元素顺序</li>
</ul>
</li>
<li><code>np.argsort</code>、<code>np.argpartition</code>等函数能够返回适合此
函数的索引</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">N1, M, Nk = arr.shape[:axis], arr.shape[axis], arr.shape[axis+<span class="number">1</span>:]</span><br><span class="line">J = indices.shape[axis]</span><br><span class="line">out = np.empty(Ni + (J,) + Nk)</span><br><span class="line"><span class="keyword">for</span> ii <span class="keyword">in</span> np.ndindex(Ni):</span><br><span class="line">	<span class="keyword">for</span> kk <span class="keyword">in</span> np.ndindex(Nk):</span><br><span class="line">		a_1d = arr[ii + np.s_[:,] + kk]</span><br><span class="line">		indices_1d = indices[ii + np.s_[:,] +kk]</span><br><span class="line">		out_1d = out[ii + np.s_[:,] + kk]</span><br><span class="line">		out_1d = a_1d[indices_1d[j]]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>np.choose</code></p>
<ul>
<li><code>choices</code>：数组序列，其中数组和<code>a</code>需广播兼容<ul>
<li>若本身为数组，则其最外层被视为序列</li>
</ul>
</li>
<li>逻辑<ul>
<li><code>a</code>、<code>choices</code>中数组共同广播</li>
<li>广播结果的shape即为结果shape，其中<code>a</code>取值为<code>n</code>
处用数组<code>choices[n]</code>填充</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.choose(a,choices) == np.array([choices[a[I]][I] <span class="keyword">for</span> I <span class="keyword">in</span> np.ndindex(a.shape)])</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>np.select</code></p>
<ul>
<li>使用各位置<code>condlist</code>首个真值出现的位序值构建<code>a</code>，则
等价于<code>np.choose(a,choicelist)</code>
（不考虑缺省值）</li>
</ul>
</li>
<li><p><code>np.extract</code></p>
<ul>
<li>等价于<code>np.compress(np.ravel(condition), np.ravel(arr))</code></li>
<li>若<code>condition</code>为bool数组，也等价于<code>arr[condition]</code></li>
</ul>
</li>
</ul>
<h3 id="Value-Modification"><a href="#Value-Modification" class="headerlink" title="Value Modification"></a>Value Modification</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>place(arr,mask,vals)</code></td>
<td>按照<code>mask</code>循环使用<code>vals</code>中值替换<code>arr</code>中元素</td>
<td>无</td>
</tr>
<tr>
<td><code>put(a,ind,v[,mode])</code></td>
<td>同<code>place</code>，但根据展平索引<code>ind</code>替换</td>
<td></td>
</tr>
<tr>
<td><code>put_along_axis(arr,indices,values,axis)</code></td>
<td>匹配<code>indices</code>和<code>arr</code>沿<code>axis</code>分量，替换值</td>
<td>无</td>
</tr>
<tr>
<td><code>copyto(dst,src[,casting,where])</code></td>
<td>根据bool数组<code>where</code>替换<code>dst</code>中元素</td>
<td>无</td>
</tr>
<tr>
<td><code>putmask(a,mask,values)</code></td>
<td>同<code>copyto</code></td>
<td>无</td>
</tr>
<tr>
<td><code>fill_diagonal(a,val[,wrap])</code></td>
<td>用<code>val</code>填充<code>a</code>的主对角</td>
<td>无</td>
</tr>
<tr>
<td><code>clip(a,a_min,a_max[,out=None,**kwargs])</code></td>
<td>裁剪值</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<ul>
<li><code>where</code>、<code>mask</code>、<code>condition</code>缺省为、等价为bool数组</li>
<li><code>np.clip</code>是<em>ufunc</em></li>
</ul>
</blockquote>
<h3 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sort(a[,axis,kind,order,])</code></td>
<td></td>
<td>在位排序</td>
</tr>
<tr>
<td><code>lexsort(keys[,axis])</code></td>
<td>根据<code>keys</code>中多组键沿<code>axis</code>轴排序（靠后优先级高）</td>
<td>无</td>
</tr>
<tr>
<td><code>msort(a)</code></td>
<td>沿第1轴排序</td>
<td>无</td>
</tr>
<tr>
<td><code>argsort(a[,axis,kind,order])</code></td>
<td>沿<code>axis</code>方向间接排序</td>
<td></td>
</tr>
<tr>
<td><code>sort_complex(a)</code></td>
<td>先实、后虚排序</td>
<td></td>
</tr>
<tr>
<td><code>partition(a,kth[,axis,kind,order])</code></td>
<td>以第<code>kth</code>大小数划分</td>
</tr>
<tr>
<td><code>argpartition(a,kth[,axis,kind,order])</code></td>
<td>间接分段</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>lexsort</code>：按照<code>axis</code>方向、以<code>keys</code>中数组顺序作为权重
进行间接排序<ul>
<li><code>keys</code>：数组序列或2维以上数组<ul>
<li>数组最高维视为序列</li>
<li><code>keys</code>为数组时，最高维被省略</li>
<li>多个数组视为权重不同的排序依据，靠后优先级高</li>
</ul>
</li>
<li><code>axis</code>：排序所沿轴方向，缺省为<code>-1</code>，沿最低维轴排序<ul>
<li>可视为按<code>keys</code>中数组逆序优先级，取用各数组沿轴
方向的间接排序结果</li>
<li>即对每个第1轴、<code>axis</code>构成平面，优先考虑第1轴末尾
<code>axis</code>方向数组进行排序，再依次考虑前序</li>
</ul>
</li>
<li><code>lexsort</code>、<code>argsort</code>排序方向相同时，<code>lexsort</code>结果中
最后子数组和<code>argsort</code>结果应差别不大
（排序方向相同而不是<code>axis</code>参数取值相同）</li>
</ul>
</li>
</ul>
<h2 id="Logical-Test"><a href="#Logical-Test" class="headerlink" title="Logical Test"></a>Logical Test</h2><h3 id="真值测试"><a href="#真值测试" class="headerlink" title="真值测试"></a>真值测试</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>all(a[,axis,out,keepdims])</code></td>
<td>给定轴方向所有元素为真</td>
<td></td>
</tr>
<tr>
<td><code>any(a[,axis,out,keepdims])</code></td>
<td>给定轴方向存在元素为真</td>
</tr>
</tbody>
</table>
</div>
<h3 id="数组内容"><a href="#数组内容" class="headerlink" title="数组内容"></a>数组内容</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>isfinite(x,/[,out,where,casting,order,...])</code></td>
<td>逐元素是否有限</td>
</tr>
<tr>
<td><code>isinf(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>isnan(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>isnat(x,/[,out,where,casting,order,...])</code></td>
<td>逐元素是否<code>NaT</code></td>
</tr>
<tr>
<td><code>isneginf(x,/[,out])</code></td>
<td></td>
</tr>
<tr>
<td><code>isposinf(x,/[,out])</code></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<ul>
<li><code>isneginf</code>、<code>isposinf</code>行为类似<em>ufunc</em>，但不是</li>
</ul>
</blockquote>
<h3 id="类型测试"><a href="#类型测试" class="headerlink" title="类型测试"></a>类型测试</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>iscomplex(x)</code></td>
<td></td>
</tr>
<tr>
<td><code>iscomplexobj(x)</code></td>
<td>复数类型或复数值</td>
</tr>
<tr>
<td><code>isfortran(a)</code></td>
<td>Fortran contiguous</td>
</tr>
<tr>
<td><code>isreal(x)</code></td>
<td></td>
</tr>
<tr>
<td><code>isrealobj(x)</code></td>
<td>实数类型或实数值</td>
</tr>
<tr>
<td><code>isscalar(x)</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="Mathmatics"><a href="#Mathmatics" class="headerlink" title="Mathmatics"></a>Mathmatics</h2><blockquote>
<ul>
<li>部分数学函数为<em>ufunc</em></li>
</ul>
</blockquote>
<h3 id="UFunc初等运算"><a href="#UFunc初等运算" class="headerlink" title="UFunc初等运算"></a>UFunc初等运算</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>add(x1,x2,/[out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>subtract(x1,x2,/[,out,where,casting,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>multiply(x1,x2,/[,out,where,casting,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>divide(x1,x2,/[,out,where,casting,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>true_devide(x1,x2,/[,out,where,casting,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>floor_devide(x1,x2,/[,out,where,casting,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>logaddexp(x1,x2,/[,out,where,casting,...])</code></td>
<td><code>ln(x1+x2)</code></td>
</tr>
<tr>
<td><code>logaddexp2(x1,x2,/[,out,where,casting,...])</code></td>
<td><code>log_2 (x1+x2)</code></td>
</tr>
<tr>
<td><code>negative(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>positive(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>power(x1,x2,/[,out,where,casting,order,...])</code></td>
<td><code>x1^x2</code></td>
</tr>
<tr>
<td><code>float_power(x1,x2,/[,out,where,casting,...])</code></td>
<td><code>x1^x2</code></td>
</tr>
<tr>
<td><code>remainder(x1,x2,/[,out,where,casting,...])</code></td>
<td>求余/取模</td>
</tr>
<tr>
<td><code>mod(x1,x2,/[,out,where,casting,order,...])</code></td>
<td>求余/取模</td>
</tr>
<tr>
<td><code>fmod(x1,x2,/[,out,where,casting,order,...])</code></td>
<td>求余/取模</td>
</tr>
<tr>
<td><code>divmod(x1,x2,/[,out1,out2],/[out,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>absolute(x,/[,out,where,casting,order,...])</code>/<code>abs</code></td>
<td></td>
</tr>
<tr>
<td><code>rint(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>sign(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>heaviside(x1,x2,/[,out,where,casting,...])</code></td>
<td>阶跃函数</td>
</tr>
<tr>
<td><code>conj(x,/[,out,where,casting,...])</code></td>
<td>对偶</td>
</tr>
<tr>
<td><code>exp(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>exp2(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>log(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>log2(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>log10(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>expm1(x,/[,out,where,casting,order,...])</code></td>
<td>计算<code>exp(x)-1</code></td>
</tr>
<tr>
<td><code>log1p(x,/[,out,where,casting,order,...])</code></td>
<td>计算<code>ln(x+1)</code></td>
</tr>
<tr>
<td><code>sqrt(x,/[,out,where,casting,order,...])</code></td>
<td>非负平方根</td>
</tr>
<tr>
<td><code>square(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>cbrt(x,/[,out,where,casting,order,...])</code></td>
<td>立方根</td>
</tr>
<tr>
<td><code>reciprocal(x,/[,out,where,casting,order,...])</code></td>
<td>倒数</td>
</tr>
<tr>
<td><code>gcd(x,/[,out,where,casting,order,...])</code></td>
<td>最大公约数</td>
</tr>
<tr>
<td><code>lcm(x,/[,out,where,casting,order,...])</code></td>
<td>最小公倍数</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>out</code>参数可用于节省内存，如：<code>G=A*B+C</code><ul>
<li>等价于：<code>t1=A*B; G=t1+C; del t1;</code></li>
<li>可利用<code>out</code>节省中间过程内存：<code>G=A*B; np.add(G,C,G)</code></li>
</ul>
</li>
</ul>
<h3 id="UFunc-Floating函数"><a href="#UFunc-Floating函数" class="headerlink" title="UFunc Floating函数"></a>UFunc Floating函数</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>fabs(x,/[,out,where,casting,order,...])</code></td>
<td>不可用于复数</td>
</tr>
<tr>
<td><code>signbit(x,/[,out,where,casting,order,...])</code></td>
<td><em>signbit</em>是否设置，即<code>&lt;0</code></td>
</tr>
<tr>
<td><code>copysign(x1,x2,/[,out,where,casting,order,...])</code></td>
<td>根据<code>x1</code>设置<code>x2</code>的<em>signbit</em></td>
</tr>
<tr>
<td><code>nextafter(x1,x2,/[,out,where,casting,order,...])</code></td>
<td><code>x1</code>朝向<code>x2</code>的下个浮点数，即变动最小精度</td>
</tr>
<tr>
<td><code>spacing(x,/[,out,where,casting,order,...])</code></td>
<td><code>x</code>和最近浮点数距离，即取值的最小精度</td>
</tr>
<tr>
<td><code>modf(x[,out1,out2],/[,out,where],...)</code></td>
<td>返回取值的整数、小数部分</td>
</tr>
<tr>
<td><code>ldexp(x1,x2,/[,out,where,casting,...])</code></td>
<td>计算<code>x1*2**x2</code>，即还原2为底的科学计数</td>
</tr>
<tr>
<td><code>frexp(x[,out1,out2],/[,out,where],...)</code></td>
<td>返回2为底的科学计数的假数、指数</td>
</tr>
<tr>
<td><code>floor(x,/,out,*,where,...)</code></td>
<td></td>
</tr>
<tr>
<td><code>ceil(x,/,out,*,where,...)</code></td>
<td></td>
</tr>
<tr>
<td><code>trunc(x,/,out,*,where,...)</code></td>
<td></td>
</tr>
<tr>
<td><code>rint(x,/[,out,where,casting,order,...])</code></td>
<td>最近整数</td>
</tr>
<tr>
<td><code>around(a[,decimals,out])</code>/<code>round</code>/<code>round_</code></td>
<td></td>
</tr>
<tr>
<td><code>fix(x[,out])</code></td>
<td>向零点取整</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<ul>
<li><code>np.fix</code>不是<em>ufunc</em>，但行为类似</li>
</ul>
</blockquote>
<h3 id="比较函数"><a href="#比较函数" class="headerlink" title="比较函数"></a>比较函数</h3><ul>
<li><p>数值比较</p>
<ul>
<li><code>np.equal()</code>更多应用于整形比较，比较浮点使用
<code>np.isclose()</code>更合适</li>
<li><code>np.allclose()</code>则是判断数组整体是否相同</li>
<li><code>array_equal(a1,a2)</code>数组<code>a1</code>、<code>a2</code>相同</li>
<li><code>array_equiv(a1,a2)</code>数组<code>a1</code>、<code>a2</code>广播后相同</li>
</ul>
</li>
<li><p>逻辑运算符</p>
<ul>
<li><code>&amp;</code>、<code>|</code>、<code>~</code>：逐元素逻辑运算<ul>
<li>优先级高于比较运算符</li>
</ul>
</li>
<li><code>and</code>、<code>or</code>、<code>not</code>：整个数组的逻辑运算</li>
</ul>
</li>
<li><p><code>np.maximum()</code>、<code>np.minimum()</code>函数</p>
<ul>
<li><code>max()</code>寻找最大值效率比<code>np.maximum.reduce()</code>低，同样
<code>min()</code>效率也较低</li>
</ul>
</li>
</ul>
<h4 id="UFunc比较函数"><a href="#UFunc比较函数" class="headerlink" title="UFunc比较函数"></a>UFunc比较函数</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>greater(x1,x2,/[,out,where,casting,...])</code></td>
<td></td>
<td><code>&gt;</code></td>
</tr>
<tr>
<td><code>greater_equal(x1,x2,/[,out,where,casting,...])</code></td>
<td><code>&gt;=</code></td>
</tr>
<tr>
<td><code>less(x1,x2,/[,out,where,casting,...])</code></td>
<td></td>
<td><code>&lt;</code></td>
</tr>
<tr>
<td><code>less_equal(x1,x2,/[,out,where,casting,...])</code></td>
<td></td>
<td><code>&lt;=</code></td>
</tr>
<tr>
<td><code>not_equal(x1,x2,/[,out,where,casting,...])</code></td>
<td></td>
<td><code>!=</code></td>
</tr>
<tr>
<td><code>equal(x1,x2,/[,out,where,casting,...])</code></td>
<td></td>
<td><code>==</code></td>
</tr>
<tr>
<td><code>logical_and(x1,x2,/[,out,where,casting,...])</code></td>
<td>逐元素<code>and</code></td>
<td><code>and</code></td>
</tr>
<tr>
<td><code>logical_or(x1,x2,/[,out,where,casting,...])</code></td>
<td></td>
<td><code>or</code></td>
</tr>
<tr>
<td><code>logical_xor(x1,x2,/[,out,where,casting,...])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>logical_not(x1,x2,/[,out,where,casting,...])</code></td>
<td></td>
<td><code>not</code></td>
</tr>
<tr>
<td><code>maximum(x1,x2,/[,out,where,casting,...])</code></td>
<td>逐元素选择较大者</td>
<td></td>
</tr>
<tr>
<td><code>minimum(x1,x2,/[,out,where,casting,...])</code></td>
<td>逐元素选择较小者</td>
<td></td>
</tr>
<tr>
<td><code>fmax(x1,x2,/[,out,where,casting,...])</code></td>
<td>逐元素选择较大者，忽略<code>NaN</code></td>
<td></td>
</tr>
<tr>
<td><code>fmin(x1,x2,/[,out,where,casting,...])</code></td>
<td>逐元素选择较小者，忽略<code>NaN</code></td>
</tr>
</tbody>
</table>
</div>
<h4 id="非UFunc"><a href="#非UFunc" class="headerlink" title="非UFunc"></a>非UFunc</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>isclose(a,b[,rtol,atol,equal_nan])</code></td>
<td>逐元素容忍度范围内相等</td>
</tr>
<tr>
<td><code>allclose(a,b[,rtol,atol,equal_nan])</code></td>
<td><code>all(isclose())</code></td>
</tr>
<tr>
<td><code>array_equal(a1,a2[,equal_nan])</code></td>
<td>数组整体</td>
</tr>
<tr>
<td><code>array_equiv(a1,a2)</code></td>
<td>广播后相等</td>
</tr>
</tbody>
</table>
</div>
<h3 id="UFunc-Bit-twiddling函数"><a href="#UFunc-Bit-twiddling函数" class="headerlink" title="UFunc Bit-twiddling函数"></a>UFunc Bit-twiddling函数</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bitwise_and(x1,x2,/[,out,where,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>bitwise_or(x1,x2,/[,out,where,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>bitwise_xor(x1,x2,/[,out,where,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>invert(x,/[,out,where,casting,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>left_shift(x1,x2,/[,out,where,casting...])</code></td>
<td></td>
</tr>
<tr>
<td><code>left_shift(x1,x2,/[,out,where,casting...])</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="UFunc-三角函数"><a href="#UFunc-三角函数" class="headerlink" title="UFunc 三角函数"></a>UFunc 三角函数</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sin(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>cos(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>tan(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>arcsin(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>arccos(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>arctan(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>arctan2(x1,x2,/[,out,where,casting,order,...])</code></td>
<td>考虑象限下，<code>arctan(x1/x2)</code></td>
</tr>
<tr>
<td><code>hypot(x1,x2,/[,out,where,casting,order,...])</code></td>
<td>计算斜边</td>
</tr>
<tr>
<td><code>sinh(x,/[,out,where,casting,order,...])</code></td>
<td>双曲正弦</td>
</tr>
<tr>
<td><code>cosh(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>tanh(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>arcsinh(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>arccosh(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>arctanh(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>deg2rad(x,/[,out,where,casting,order,...])</code></td>
<td>角度转换为弧度</td>
</tr>
<tr>
<td><code>rad2deg/degrees(x,/[,out,where,casting,order,...])</code></td>
<td>弧度转换为角度</td>
</tr>
</tbody>
</table>
</div>
<h3 id="基本数学"><a href="#基本数学" class="headerlink" title="基本数学"></a>基本数学</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>prod(a[,axis,dtype,out,keepdims,...])</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>nanprod(a[,axis,dtype,out,keepdims,...])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>sum(a[,axis,dtype,out,keepdims,...])</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>nansum(a[,axis,dtype,out,keepdims,...])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>cumprod(a[,axis,dtype,out,keepdims,...])</code></td>
<td>累乘（也可用<em>ufunc.accumulate</em>）</td>
<td></td>
</tr>
<tr>
<td><code>cumsum(a[,axis,dtype,out,keepdims,...])</code></td>
<td>累加</td>
<td></td>
</tr>
<tr>
<td><code>nancumprod(a[,axis,dtype,out,keepdims,...])</code></td>
<td><code>NaN</code>视为<code>1</code></td>
<td>无</td>
</tr>
<tr>
<td><code>nancumsum(a[,axis,dtype,out,keepdims,...])</code></td>
<td><code>NaN</code>视为<code>0</code></td>
<td>无</td>
</tr>
<tr>
<td><code>diff(a[,n,axis,prepend,append,...])</code></td>
<td>沿给定轴1阶差分（保持类型不变，注意溢出）</td>
<td>无</td>
</tr>
<tr>
<td><code>ediff1d(ary[,to_end,to_begin]</code></td>
<td>沿展平顺序1阶差分</td>
<td>无</td>
</tr>
<tr>
<td><code>gradient(f,*varargs,**kwargs)</code></td>
<td>梯度</td>
<td>无</td>
</tr>
<tr>
<td><code>cross(a,b[,axisa,axisb,axisc,axis])</code></td>
<td>向量叉积</td>
<td>无</td>
</tr>
<tr>
<td><code>trapz(y[,x,dx,axis])</code></td>
<td>梯形法则定积分</td>
<td>无</td>
</tr>
</tbody>
</table>
</div>
<h3 id="复数运算"><a href="#复数运算" class="headerlink" title="复数运算"></a>复数运算</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>angle(z[,deg])</code></td>
<td>角度</td>
<td>无</td>
</tr>
<tr>
<td><code>real(val)</code></td>
<td>实部</td>
<td></td>
</tr>
<tr>
<td><code>imag(val)</code></td>
<td>虚部</td>
<td></td>
</tr>
<tr>
<td><code>conj/conjugate(x,/[,out,where,casting,order,...])</code></td>
<td>复共轭</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>nan_to_num(x[,copy,nan,posinf,neginf])</code></td>
<td>替换<code>NaN</code>、<code>inf</code>为数值</td>
</tr>
<tr>
<td><code>real_if_close(a[,to])</code></td>
<td>虚部接近0则省略</td>
</tr>
<tr>
<td><code>interp(x,xp,fp[,left,right,period])</code></td>
<td>1维线性插值</td>
</tr>
<tr>
<td><code>polyfit(x,y,deg[,rcond,full,w,cov])</code></td>
<td>最小二乘多项式拟合</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Statistics"><a href="#Statistics" class="headerlink" title="Statistics"></a>Statistics</h2><blockquote>
<ul>
<li><code>axis=None</code>：默认值<code>None</code>，表示在整个数组上执行操作</li>
</ul>
</blockquote>
<h3 id="Count"><a href="#Count" class="headerlink" title="Count"></a>Count</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>count_nonzero(a[,axis])</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>amin/min(a[,axis,out,keepdims,initial,where])</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>amax/max(a[,axis,out,keepdims,initial,where])</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>nanmin(a[,axis,out,keepdims,initial,where])</code></td>
<td>忽略<code>NaN</code></td>
</tr>
<tr>
<td><code>nanmax(a[,axis,out,keepdims,initial,where])</code></td>
<td></td>
</tr>
<tr>
<td><code>ptp(a[,axis,out,keepdims])</code></td>
<td>极差</td>
<td></td>
</tr>
<tr>
<td><code>percentile(a,q[,axis,out,...])</code></td>
<td><code>q</code>取值<code>[0-100]</code></td>
<td>无</td>
</tr>
<tr>
<td><code>nanpercentile(a,q[,axis,out,...])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>quantile(a,q[,axis,out,overwrite_input,...])</code></td>
<td><code>q</code>取值<code>[0,1]</code></td>
<td>无</td>
</tr>
<tr>
<td><code>nanquantile(a,q[,axis,out,...])</code></td>
<td></td>
<td>无</td>
</tr>
</tbody>
</table>
</div>
<h3 id="均值、方差"><a href="#均值、方差" class="headerlink" title="均值、方差"></a>均值、方差</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>median(a[,axis,out,overwrite_input,keepdims])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>average(a[,axis,weights,returned])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>mean(a[,axis,dtype,out,keepdims])</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>std(a[,axis,dtype,out,ddof,keepdims])</code></td>
<td>标准差</td>
<td></td>
</tr>
<tr>
<td><code>var(a[,axis,dtype,out,ddof,keepdims])</code></td>
<td>方查</td>
<td></td>
</tr>
<tr>
<td><code>nanmedian(a[,axis,out,overwrite_input,...])</code></td>
<td>无</td>
</tr>
<tr>
<td><code>nanmean(a[,axis,dtype,out,keepdims])</code></td>
<td>无</td>
</tr>
<tr>
<td><code>nanstd(a[,axis,dtype,out,ddof,keepdims])</code></td>
<td>无</td>
</tr>
<tr>
<td><code>nanvar(a[,axis,dtype,out,ddof,keepdims])</code></td>
<td>无</td>
</tr>
</tbody>
</table>
</div>
<h3 id="相关系数"><a href="#相关系数" class="headerlink" title="相关系数"></a>相关系数</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>corrcoef(x[,y,rowvar,bias,ddof])</code></td>
<td>Pearson积差相关系数</td>
</tr>
<tr>
<td><code>correlate(a,v[,mode])</code></td>
<td>卷积</td>
</tr>
<tr>
<td><code>convolve(a,v[,mode])</code></td>
<td>离散、线性卷积</td>
</tr>
<tr>
<td><code>cov(m[,y,rowvar,bias,ddof,fweights,...])</code></td>
<td>方差</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Array-Creation"><a href="#Array-Creation" class="headerlink" title="Array Creation"></a>Array Creation</h2><h3 id="Ones-and-Zeros"><a href="#Ones-and-Zeros" class="headerlink" title="Ones and Zeros"></a>Ones and Zeros</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>empty(shape[,dtype,order])</code></td>
<td>无初始化</td>
</tr>
<tr>
<td><code>empty_like(prototype[,dtype,order,subok,...])</code></td>
<td>shape、类型同<code>prototype</code></td>
</tr>
<tr>
<td><code>eye(N[,M,k,dtype,order])</code></td>
<td>对角为1的2D数组</td>
</tr>
<tr>
<td><code>identity(n[,dtype])</code></td>
<td>单位矩阵数组</td>
</tr>
<tr>
<td><code>ones(shape[,dtype,order])</code></td>
<td></td>
</tr>
<tr>
<td><code>ones_like(a[,dtype,order,subok,shape])</code></td>
<td></td>
</tr>
<tr>
<td><code>zeros(shape[,dtype,order])</code></td>
<td></td>
</tr>
<tr>
<td><code>zeros_like(a[,dtype,order,subok,shape])</code></td>
<td></td>
</tr>
<tr>
<td><code>full(shape,fill_value[,dtype,order])</code></td>
<td>全<code>full_value</code>数组</td>
</tr>
<tr>
<td><code>full_like(a,fill_value[,dtype,order,...])</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Numerical-Ranges"><a href="#Numerical-Ranges" class="headerlink" title="Numerical Ranges"></a>Numerical Ranges</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>arange([start,]stop[,step][,dtpye])</code></td>
<td>给定间距</td>
</tr>
<tr>
<td><code>linspace(start,stop[,num,endpoint])</code></td>
<td>给定数量，等差均分</td>
</tr>
<tr>
<td><code>geomspace(start,stop[,num,endpoint,base,...])</code></td>
<td>等比均分</td>
</tr>
<tr>
<td><code>logspace(start,stop[,num,endpoint,base,...])</code></td>
<td>在<em>log10</em>尺度上均分，同<code>np.power(10, np.linspace(start,stop))</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Repetition"><a href="#Repetition" class="headerlink" title="Repetition"></a>Repetition</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tile(A,reps)</code></td>
<td>重复<code>A</code>（可是数组）创建一维数组</td>
<td>无</td>
</tr>
<tr>
<td><code>repeat(a,repeats[,axis])</code></td>
<td>沿已有轴重复<code>a</code>创建</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Matrix-Relative"><a href="#Matrix-Relative" class="headerlink" title="Matrix-Relative"></a>Matrix-Relative</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>diag(v[,k])</code></td>
<td>从2维<code>v</code>抽取对角、或以1维<code>v</code>作为对角</td>
</tr>
<tr>
<td><code>diagflat(v[,k])</code></td>
<td></td>
</tr>
<tr>
<td><code>tri(N[,M,k,dtype])</code></td>
<td>对角线及以下为1、其余为0矩阵</td>
</tr>
<tr>
<td><code>tril(m[,k])</code></td>
<td>下三角</td>
</tr>
<tr>
<td><code>triu(m[,k])</code></td>
<td>上三角</td>
</tr>
<tr>
<td><code>vander(x[,N,increasing])</code></td>
<td>Vandermonde矩阵</td>
</tr>
</tbody>
</table>
</div>
<h3 id="From-Existing-Data"><a href="#From-Existing-Data" class="headerlink" title="From Existing Data"></a>From Existing Data</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>array(object[,dtype,copy,order,subok,ndmin])</code></td>
<td></td>
</tr>
<tr>
<td><code>copy(a[,order])</code></td>
<td></td>
</tr>
<tr>
<td><code>frombuffer(buffer[,dtype,count,offset]</code></td>
<td>从缓冲（如字节串）创建数组</td>
</tr>
<tr>
<td><code>fromfunction(function,shape,**kwargs)</code></td>
<td>以坐标为参数，从函数创建数组</td>
</tr>
<tr>
<td><code>fromiter(iterable,dtype[,count])</code></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<ul>
<li>改变数组数据类型也可以视为是创建新数组</li>
</ul>
</blockquote>
<h2 id="转入、转出"><a href="#转入、转出" class="headerlink" title="转入、转出"></a>转入、转出</h2><h3 id="类型转出"><a href="#类型转出" class="headerlink" title="类型转出"></a>类型转出</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.item(*args)</code></td>
<td>根据<code>args</code>选择元素复制至标准python标量</td>
</tr>
<tr>
<td><code>.tolist()</code></td>
<td>转换为<code>.ndim</code>层嵌套python标量列表</td>
</tr>
<tr>
<td><code>.itemset(*args)</code></td>
<td>插入元素（尝试转换类型）</td>
</tr>
<tr>
<td><code>.byteswap([inplace])</code></td>
<td>反转字节序</td>
</tr>
<tr>
<td><code>.view([dtype,type])</code></td>
<td>创建新视图</td>
</tr>
<tr>
<td><code>.getfield(dtype[,offset])</code></td>
<td>设置数据类型为指定类型</td>
</tr>
<tr>
<td><code>.setflags([write,align,uic])</code></td>
<td>设置标志</td>
</tr>
<tr>
<td><code>.fill(value)</code></td>
<td>使用标量填充</td>
</tr>
</tbody>
</table>
</div>
<h3 id="打包二进制"><a href="#打包二进制" class="headerlink" title="打包二进制"></a>打包二进制</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>packbits(a[,axis,bitorder])</code></td>
<td>元素打包为标志位，<code>0</code>补足，返回<code>uint8</code>数组</td>
</tr>
<tr>
<td><code>upackbits(a[,axis,bitorder])</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="输入、输出"><a href="#输入、输出" class="headerlink" title="输入、输出"></a>输入、输出</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>格式</th>
<th>输入</th>
<th>输出</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dump(file)</code></td>
<td>pickle</td>
<td>无</td>
<td>文件</td>
</tr>
<tr>
<td><code>tofile(fid[,sep,format])</code></td>
<td>内存内容（<code>sep=&quot;&quot;</code>）、分割符串</td>
<td>无</td>
<td>文件</td>
</tr>
<tr>
<td><code>fromfile(file[,dtype,count,sep,offset])</code></td>
<td>字节串、分割符串</td>
<td>文件</td>
<td>数组</td>
</tr>
<tr>
<td><code>save(file,arr[,allow_pickle,fix_imports])</code></td>
<td><code>.npy</code></td>
<td>数组</td>
<td>文件</td>
</tr>
<tr>
<td><code>savez(file,*args,**kwds)</code></td>
<td>非压缩的<code>.npz</code></td>
<td>（多个）数组</td>
<td>文件</td>
</tr>
<tr>
<td><code>savez_compressed(file,*args,**kwds)</code></td>
<td>压缩的<code>.npz</code></td>
<td>（多个）数组</td>
<td>无</td>
</tr>
<tr>
<td><code>load(file[,mmap_mode,allow_pickle,...])</code></td>
<td><code>.npy</code>、<code>.npz</code>、pickle</td>
<td>文件</td>
<td>数组</td>
</tr>
<tr>
<td><code>savetxt(fname,X[,fmt,delimiter,newline,...])</code></td>
<td>分割符串</td>
<td>二维以下数组</td>
<td>文件</td>
</tr>
<tr>
<td><code>loadtxt(fname[,dtype,comments,delimiter,...])</code></td>
<td>分割符串</td>
<td>文件</td>
<td>数组</td>
</tr>
<tr>
<td><code>genfromtxt(fname[,dtype,comments,...])</code></td>
<td>分割符串</td>
<td>文件</td>
<td>数组</td>
</tr>
<tr>
<td><code>fromregex(file,regexp,dtype[,encoding])</code></td>
<td>正则表达式结构</td>
<td>文件</td>
<td>数组</td>
</tr>
</tbody>
</table>
</div>
<h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>array2string(a[,max_line_width,precision,...])</code></td>
<td></td>
<td><code>__str__</code></td>
</tr>
<tr>
<td><code>array_repr(arr[,max_line_width,precision,...])</code></td>
<td></td>
<td><code>__repr__</code></td>
</tr>
<tr>
<td><code>array_str(arr[,max_line_width,precision,...])</code></td>
<td></td>
<td><code>__str__</code></td>
</tr>
<tr>
<td><code>dumps()</code></td>
<td>无</td>
<td>pickle序列化</td>
</tr>
<tr>
<td><code>loads(*args,**kwargs)</code></td>
<td>pickle</td>
<td>字节串</td>
<td>数组</td>
</tr>
<tr>
<td><code>tobytes([order])</code>/<code>tostring</code></td>
<td>内存内容字节串</td>
</tr>
<tr>
<td><code>fromstring(string[,dtype,count,sep])</code></td>
<td>从字符串、字节串（<code>sep=&quot;&quot;</code>，且缺省）创建1维数组</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>np.loads</code>即<code>pickle.loads</code>，不建议使用</li>
<li><code>np.fromstring</code><ul>
<li><code>sep=&quot;&quot;</code>：从二进制字节串中创建数组，类<code>frombuffer</code></li>
<li><code>sep</code>置为分割符时，只能指定一种元素分隔符，也只能
解析1维数组的字符串</li>
</ul>
</li>
</ul>
<h3 id="字符串输出格式"><a href="#字符串输出格式" class="headerlink" title="字符串输出格式"></a>字符串输出格式</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>format_float_positional(x[,precision,...])</code></td>
<td>格式化位置计数</td>
</tr>
<tr>
<td><code>format_float_scientific(x[,precision,...])</code></td>
<td>格式化科学计数</td>
</tr>
<tr>
<td><code>set_printoptions([precision,threshold,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>get_printoptions()</code></td>
<td></td>
</tr>
<tr>
<td><code>set_string_function(f[,repr])</code></td>
<td></td>
</tr>
<tr>
<td><code>printoptions(*args,**kwargs)</code></td>
<td>设置打印选项的上下文管理器</td>
</tr>
<tr>
<td><code>binary_repr(num[,width])</code></td>
<td>二进制字符串</td>
</tr>
<tr>
<td><code>base_repr(number[,base,padding])</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Data-Source"><a href="#Data-Source" class="headerlink" title="Data Source"></a>Data Source</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>DataSource([destpath])</code></td>
<td>通用数据源文件（file，http，ftp等）</td>
</tr>
</tbody>
</table>
</div>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-03-11T01:47:45.000Z" title="3/11/2021, 9:47:45 AM">2021-03-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-03-11T01:47:45.000Z" title="3/11/2021, 9:47:45 AM">2021-03-11</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Numpy/">Numpy</a></span><span class="level-item">2 minutes read (About 290 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Numpy/numpy_efficience.html">Numpy 性能</a></h1><div class="content"><h2 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h2><h3 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>setbufsize(size)</code></td>
<td>设置<em>ufunc</em>使用的缓冲区大小</td>
</tr>
<tr>
<td><code>getbufsize()</code></td>
<td></td>
</tr>
<tr>
<td><code>shares_memory(a,b[,max_work])</code></td>
<td></td>
</tr>
<tr>
<td><code>may_share_memory(a,b[,max_work])</code></td>
<td></td>
</tr>
<tr>
<td><code>byte_bounds(a)</code></td>
<td>返回指向数组结尾的指针</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Array-Mixin"><a href="#Array-Mixin" class="headerlink" title="Array Mixin"></a>Array Mixin</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lib.mixins.NDArrayOperatorsMixin</code></td>
<td>定义了所有使用<code>array_ufunc</code>特殊方法</td>
</tr>
<tr>
<td><code>lib.NumpyVersion(vstring)</code></td>
<td>解析、比较NumPy版本</td>
</tr>
<tr>
<td><code>get_include()</code></td>
<td>返回头文件目录</td>
</tr>
<tr>
<td><code>deprecate(*args,**kwargs)</code></td>
<td>废弃警告</td>
</tr>
<tr>
<td><code>deprecate_with_doc(msg)</code></td>
<td></td>
</tr>
<tr>
<td><code>who([vardict])</code></td>
<td>在指定字典中打印数组</td>
</tr>
<tr>
<td><code>disp(mesg[,device,linefee])</code></td>
<td>展示信息</td>
</tr>
</tbody>
</table>
</div>
<h2 id="浮点错误处理"><a href="#浮点错误处理" class="headerlink" title="浮点错误处理"></a>浮点错误处理</h2><ul>
<li>错误处理<ul>
<li>设置硬件平台上注册的错误处理，如：除零错误</li>
<li>基于线程设置</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>seterr([all,divide,over,under,invalid])</code></td>
<td>设置浮点错误处理</td>
</tr>
<tr>
<td><code>seterrcall(func)</code></td>
<td>设置浮点错误回调或log</td>
</tr>
<tr>
<td><code>geterr()</code></td>
<td>获取当前处理浮点错误的方法</td>
</tr>
<tr>
<td><code>geterrcall()</code></td>
<td>获取当前处理浮点错误回调函数</td>
</tr>
<tr>
<td><code>errstate(**kwargs)</code></td>
<td>浮点错误处理上下文</td>
</tr>
<tr>
<td><code>seterrobj(errobj)</code></td>
<td>设置定义浮点错误处理的对象</td>
</tr>
<tr>
<td><code>geterrobj()</code></td>
<td>获取定义浮点错误处理的对象</td>
</tr>
</tbody>
</table>
</div>
<h2 id="NumPy帮助"><a href="#NumPy帮助" class="headerlink" title="NumPy帮助"></a>NumPy帮助</h2><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lookfor(what[,module,import_modules])</code></td>
<td>在文档中搜索关键词</td>
</tr>
<tr>
<td><code>info([object,maxwidth,output,toplevel])</code></td>
<td>获取帮助信息</td>
</tr>
<tr>
<td><code>source(object[,output])</code></td>
<td>获取源码</td>
</tr>
</tbody>
</table>
</div>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-03-11T01:36:49.000Z" title="3/11/2021, 9:36:49 AM">2021-03-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-03-11T01:36:49.000Z" title="3/11/2021, 9:36:49 AM">2021-03-11</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Numpy/">Numpy</a></span><span class="level-item">2 minutes read (About 327 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Numpy/numpy_libs.html">Numpy 附加库</a></h1><div class="content"><h2 id="财金"><a href="#财金" class="headerlink" title="财金"></a>财金</h2><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>fv(rate,nper,pmt,pv[,when])</code></td>
<td>未来值</td>
</tr>
<tr>
<td><code>pv(rate,nper,pmt[,fv,when])</code></td>
<td>现值</td>
</tr>
<tr>
<td><code>npv(rate,values)</code></td>
<td>净现值</td>
</tr>
<tr>
<td><code>pmt(rate,nper,pv[,fv,when])</code></td>
<td>等额本息，每期付款</td>
</tr>
<tr>
<td><code>ppmt(rate,per,nper,pv[,fv,when])</code></td>
<td>等额本息中第<code>per</code>期本金</td>
</tr>
<tr>
<td><code>ipmt(rate,per,nper,pv[,fv,when])</code></td>
<td>等额本息中第<code>per</code>期利息</td>
</tr>
<tr>
<td><code>irr(values)</code></td>
<td>内部收益率</td>
</tr>
<tr>
<td><code>mirr(values,finance_rate,reinvest_rate)</code></td>
<td>考虑期内再融资成本<code>finance_rate</code>、收益再投资收益<code>reinvest_rate</code></td>
</tr>
<tr>
<td><code>nper(rate,pmt,pv[,fv,when])</code></td>
<td>每期付款</td>
</tr>
<tr>
<td><code>rate(nper,pmt,pv,fv[,when,guess,tol,...])</code></td>
<td>每期间的利率</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>参数说明</p>
<ul>
<li><code>pv</code>：现值</li>
<li><code>fv</code>：未来值</li>
<li><code>when</code>：期初或期末付款<ul>
<li><code>0</code>/<code>end</code></li>
<li><code>1</code>/<code>begin</code></li>
</ul>
</li>
<li><code>pmt</code>：<em>Payment</em>，每期付款</li>
<li><code>ppmt</code>：<em>Principle of Payment</em>，每期付款中本金</li>
<li><code>ipmt</code>：<em>Interest of Payment</em>，每期付款中利息</li>
</ul>
</li>
<li><p>值说明</p>
<ul>
<li>正值：收入</li>
<li>负值：支出</li>
</ul>
</li>
</ul>
<h2 id="Histogram"><a href="#Histogram" class="headerlink" title="Histogram"></a>Histogram</h2><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>histogram(a[,bins,range,normed,weights,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>histogram2d(x,y[,bins,range,normed,weights,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>histogramdd(sample[,bins,range,normed,weights,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>bincount(x[,weights,minlength])</code></td>
<td></td>
</tr>
<tr>
<td><code>histogram_bin_edges(a[,bin,range,weights])</code></td>
<td></td>
</tr>
<tr>
<td><code>digitize(x,bins[,right])</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="Operation"><a href="#Operation" class="headerlink" title="Operation"></a>Operation</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>in1d(ar1,ar2[,assume_unique,invert])</code></td>
<td>是否包含，始终返回1维数组</td>
</tr>
<tr>
<td><code>isin(element,test_element[,...])</code></td>
<td>保持<code>element</code>shape返回</td>
</tr>
<tr>
<td><code>intersect1d(ar1,ar2[,assume_unique,...])</code></td>
<td>交集</td>
</tr>
<tr>
<td><code>union1d(ar1,ar2[,assume_unique,...])</code></td>
<td>并集</td>
</tr>
<tr>
<td><code>setdiff1d(ar1,ar2[,assume_unique,...])</code></td>
<td><code>ar1</code>-<code>ar2</code></td>
</tr>
<tr>
<td><code>setxor1d(ar1,ar2[,assume_unique,...])</code></td>
<td>差集</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Unique"><a href="#Unique" class="headerlink" title="Unique"></a>Unique</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>unique(ar[,return_index,return_inverse,return_counts,axis])</code></td>
<td>返回唯一值</td>
</tr>
</tbody>
</table>
</div>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-03-11T01:34:47.000Z" title="3/11/2021, 9:34:47 AM">2021-03-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-03-11T01:34:47.000Z" title="3/11/2021, 9:34:47 AM">2021-03-11</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Numpy/">Numpy</a></span><span class="level-item">8 minutes read (About 1151 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Numpy/ndarray_index.html">Numpy 索引</a></h1><div class="content"><h2 id="索引、切片"><a href="#索引、切片" class="headerlink" title="索引、切片"></a>索引、切片</h2><h3 id="基本切片、索引"><a href="#基本切片、索引" class="headerlink" title="基本切片、索引"></a>基本切片、索引</h3><ul>
<li><p>基本切片<code>[Slice]start:stop:step</code>（基本同原生类型切片）</p>
<ul>
<li><code>start</code>、<code>stop</code>负值时，按维度长取正模</li>
<li><code>step&gt;0</code>时，<code>start</code>缺省为<code>0</code>、<code>stop</code>缺省为维度长<code>N</code></li>
<li><code>step&lt;0</code>时，<code>start</code>缺省为<code>N-1</code>、<code>stop</code>缺省为<code>-N-1</code></li>
<li><code>stop</code>、<code>start</code>可以超过维度长<code>N</code></li>
</ul>
</li>
<li><p><code>Ellipsis</code>/<code>...</code>：放在切片中表示选择所有</p>
<ul>
<li><code>...</code>存在的场合，结果总是数组而不是数组标量，即使其
没有大小</li>
</ul>
</li>
<li><p><code>np.newaxis</code>/<code>None</code>：为切片生成数组在所在位置添加长度为
<code>1</code>的维度</p>
</li>
<li><p>切片可以用于设置数组中的值</p>
</li>
</ul>
<blockquote>
<ul>
<li>基本切片可认为是依次对各维度切片，若靠前维度为索引，则
  可以把靠前维度独立出来</li>
<li>基本切片生成的所有数组始终是原始数组的视图，也因此存在
  切片引用的数组内存不会被释放</li>
<li>注意：基本索引可用于改变数组的值，但是返回值不是对数组
  中对应值的引用</li>
</ul>
</blockquote>
<h3 id="高级索引"><a href="#高级索引" class="headerlink" title="高级索引"></a>高级索引</h3><ul>
<li><p>选择对象为以下类型时会触发高级索引</p>
<ul>
<li>非元组序列</li>
<li><code>ndarray</code>（整形或boolean类型）</li>
<li>包含至少一个序列、<code>ndarray</code>（整型或boolean类型）的
元组</li>
</ul>
</li>
<li><p>高级索引总是返回数据的<strong>副本</strong></p>
<ul>
<li>高级索引结果不能保证任何内存布局</li>
</ul>
</li>
</ul>
<h4 id="整数索引"><a href="#整数索引" class="headerlink" title="整数索引"></a>整数索引</h4><ul>
<li><p>整数索引<code>X[obj]</code>允许根据其各维度索引选择数组<code>X</code>任意元素</p>
<ul>
<li>各整数索引（数组）表示对应维度的索引</li>
<li>各维度索引迭代、连接得到各元素位置：<code>zip(obj*)</code></li>
<li>索引维数小于数组维数时，以子数组作为元素
（可以理解为索引和数组高维对齐后广播）</li>
</ul>
</li>
<li><p>整数索引结果shape由<code>obj</code>中各维度索引shape决定</p>
<ul>
<li>整数索引<code>obj</code>中各维度索引数组会被广播<ul>
<li>各维度索引shape可能不同</li>
<li>为保证各维度索引能正常迭代选取元素，各维度索引
shape需要能被广播、符合广播要求</li>
</ul>
</li>
<li>则高级索引出现场合<ul>
<li>“普通索引（标量值）”不存在，必然被广播</li>
<li>切片能够共存</li>
</ul>
</li>
</ul>
</li>
<li><p>切片（包括<code>np.newaxis</code>）和高级索引共存时</p>
<ul>
<li>高级索引特点导致其结果维度不可割<ul>
<li>“标量索引”本应削减该维度</li>
<li>而高级索引整体（广播后）决定唯一shape</li>
</ul>
</li>
<li>高级索引结果维度应整体参与结果构建<ul>
<li>高级索引被切片分割：高级索引结果维度整体提前</li>
<li>高级索引相邻：高级索引结果维度填充至该处</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>高级索引操作结果中无元素，但单个维度索引越界的错误未定义</li>
<li>高级索引结果内存布局对每个索引操作有优化，不能假设特定
  内存顺序</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">X = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]])</span><br><span class="line">rows = [<span class="number">0</span>, <span class="number">3</span>]</span><br><span class="line">cols = [<span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line"> <span class="comment"># 整数索引</span></span><br><span class="line">X[np.ix_(rows, cols)]</span><br><span class="line"> <span class="comment"># 整数索引数组</span></span><br><span class="line">X[[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>]],:]</span><br><span class="line">X.take([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>]], axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Boolean索引"><a href="#Boolean索引" class="headerlink" title="Boolean索引"></a>Boolean索引</h4><ul>
<li><p>Boolean索引<code>obj</code>选择其中<code>True</code>处位置对应元素</p>
<ul>
<li>索引<code>obj</code>维数较数组<code>X</code>小，直接抽取子数组作为元素
（可以理解为索引和数组高维对齐后广播）</li>
<li>索引<code>obj</code>在超出数组<code>X.shape</code>范围处有<code>True</code>值，会引发
索引错误</li>
<li>索引<code>obj</code>在<code>X.shape</code>内未填充处等同于填充<code>False</code></li>
</ul>
</li>
<li><p>Boolean索引通过<code>.nonezero</code>方法转换为高级整数索引实现</p>
<ul>
<li>Boolean索引等价于<code>True</code>数量长的1维整数索引<ul>
<li><code>X[..,bool_obj,..]</code>等价于
<code>X[..,bool_obj.nonzero(),..]</code></li>
<li>Boolean索引总是削减对应索引，展开为1维</li>
</ul>
</li>
<li>Boolean索引、高级整数索引共同存在场合行为诡异<ul>
<li>Boolean索引转换为等价的整数索引</li>
<li>整数索引需要广播兼容转换后整数索引</li>
<li>整数索引、转换后整数索引整体得到结果</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>索引<code>obj</code>和数组<code>X</code>形状相同计算速度更快</li>
</ul>
</blockquote>
<h3 id="字段名称形式访问"><a href="#字段名称形式访问" class="headerlink" title="字段名称形式访问"></a>字段名称形式访问</h3><ul>
<li><code>ndarray</code>中元素为结构化数据类型时，可以使用字符串索引
访问<ul>
<li>字段元素非子数组时<ul>
<li>其shape同原数组</li>
<li>仅包含该字段数据</li>
<li>数据类型为该字段数据类型</li>
</ul>
</li>
<li>字段元素为子数组时<ul>
<li>子数组shape会同原数组shape合并</li>
</ul>
</li>
<li>支持字符串列表形式访问<ul>
<li>返回数组视图而不是副本（Numpy1.6后）</li>
</ul>
</li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-02-20T00:40:31.000Z" title="2/20/2021, 8:40:31 AM">2021-02-20</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-02-20T00:40:31.000Z" title="2/20/2021, 8:40:31 AM">2021-02-20</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Numpy/">Numpy</a></span><span class="level-item">8 minutes read (About 1242 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Numpy/numpy_ufunc.html">Universal Functions</a></h1><div class="content"><h2 id="Universal-Functions"><a href="#Universal-Functions" class="headerlink" title="Universal Functions"></a>Universal Functions</h2><ul>
<li><p><em>UFunc</em>：在数组上执行逐元素运算函数</p>
<ul>
<li>支持广播、类型映射等</li>
<li>可视为是函数的向量化包装</li>
<li>基本<em>ufunc</em>在标量上执行操作，更泛化的<em>ufunc</em>也可以
在以子数组为基本元素进行操作</li>
</ul>
</li>
<li><p>numpy中的<em>ufunc</em>是<code>np.ufunc</code>的实例</p>
<ul>
<li>许多内建的<em>ufunc</em>是通过C编译实现的</li>
<li>可以通过<code>np.frompyfunc</code>工厂方法自定义<em>ufunc</em>实例</li>
<li>numpy中包含超过60种<em>ufunc</em><ul>
<li>部分<em>ufunc</em>在相关运算标记调用时，会被自动调用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="内部缓冲"><a href="#内部缓冲" class="headerlink" title="内部缓冲"></a>内部缓冲</h3><ul>
<li>Internal Buffers<ul>
<li>用于数据非对齐、数据交换、数据类型转换场合</li>
<li><code>.setbufsize(size)</code>：基于线程设置内部缓冲，缺省为
<code>10,000</code>元素</li>
</ul>
</li>
</ul>
<h3 id="类型转换规则"><a href="#类型转换规则" class="headerlink" title="类型转换规则"></a>类型转换规则</h3><ul>
<li><p>各<em>ufunc</em>内部维护列表，给出适用的输入类型（组合）、
相应的输出类型
（可通过<code>.types</code>属性查看）</p>
</li>
<li><p>当<em>ufunc</em>内部列表中没有给定的输入类型组合时，则需要
进行safely类型转换
（可通过<code>np.can_cast</code>函数判断）</p>
<ul>
<li><code>&quot;S&quot;, &quot;U&quot;, &quot;V&quot;</code>类型不能支持<em>ufunc</em>运算</li>
<li>标量-数组操作使用不同类型转换规则确保标量不会降低
数组精度，除非标量和数组属于同一类型体系</li>
</ul>
</li>
</ul>
<h3 id="UFunc维度说明"><a href="#UFunc维度说明" class="headerlink" title="UFunc维度说明"></a>UFunc维度说明</h3><ul>
<li><p><em>core dimension</em>：核心维度，<em>ufunc</em>执行操作所在的维度</p>
<ul>
<li>核心维度一般使用元组表示<ul>
<li>对一般<em>ufunc</em>：核心维度为空元组</li>
<li>对广义<em>ufunc</em>：核心维度为非空元组、空元组</li>
</ul>
</li>
<li><em>signature</em>：签名，包含<em>ufunc</em>涉及的输出操作数和输出
操作数的核心维度字符串，如：<code>(i,),(j,)-&gt;()</code></li>
<li>签名中各输入操作数的对应核心维度大小必须相同，移除后
剩余的循环维度共同广播，加上输出操作数的核心维度得到
输出结果shape</li>
</ul>
</li>
<li><p><em>loop dimension</em>：循环维度，除核心维度之外的维度</p>
</li>
</ul>
<blockquote>
<ul>
<li>这些术语来自<em>Perl Vector Library</em></li>
<li><a target="_blank" rel="noopener" href="https://numpy.org/doc/1.17/reference/c-api.generalized-ufuncs.html">https://numpy.org/doc/1.17/reference/c-api.generalized-ufuncs.html</a></li>
</ul>
</blockquote>
<h3 id="UFunc原型"><a href="#UFunc原型" class="headerlink" title="UFunc原型"></a>UFunc原型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NDA = <span class="function"><span class="keyword">def</span> <span class="title">numpy</span>.&lt;<span class="title">ufunc</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">	x1 [,x2], /,</span></span></span><br><span class="line"><span class="params"><span class="function">	[out1, out2,], out, *,</span></span></span><br><span class="line"><span class="params"><span class="function">	where=<span class="literal">True</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	casting=<span class="string">&quot;same_kind&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	order=<span class="string">&quot;K&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	dtype=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	subok=<span class="literal">True</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	[signature, extobj]</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>where=True/False/Array[bool]</code></p>
<ul>
<li>此参数不用于对子数组做操作的广义<em>ufunc</em></li>
</ul>
</li>
<li><p><code>keepdims=False/True</code></p>
<ul>
<li>对广义<em>ufunc</em>，只在输入操作数上有相同数量核心维度、
输出操作数没有核心维度（即返回标量）时使用</li>
</ul>
</li>
<li><p><code>axes=tuple/int</code></p>
<ul>
<li>含义：广义<em>ufunc</em>执行操作、存储结果所在的轴序号<ul>
<li><code>[tuple]</code>：各元组为各输入操作数应被执行操作、
输出操作数存储结果的轴的序号</li>
<li><code>[int]</code>：广义<em>ufunc</em>在1维向量上执行操作时，可以
直接使用整形</li>
</ul>
</li>
<li>若广义<em>ufunc</em>的输出操作数均为标量，可省略其对应元组</li>
</ul>
</li>
<li><p><code>axis=int</code></p>
<ul>
<li>含义：广义<em>ufunc</em>执行操作所在的single轴序号<ul>
<li><code>int</code>：广义<em>ufunc</em>在相同的轴<code>axis</code>上执行操作，
等价于<code>axes=[(axis,),(axis,),...]</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>signature=np.dtype/tuple[np.dtype]/str</code></p>
<ul>
<li>含义：指示<em>ufunc</em>的输入、输出的数据类型，</li>
<li>对于底层计算1维loop，是通过比较输入的数据类型，找到
让所有输入都能安全转换的数据类型<ul>
<li>此参数允许绕过查找，直接指定loop</li>
</ul>
</li>
<li>可通过<code>ufunc.types</code>属性查看可用的signature列表</li>
</ul>
</li>
<li><p><code>extobj=list</code></p>
<ul>
<li>含义：指定<em>ufunc</em>的缓冲大小、错误模式整数、错误处理
回调函数<ul>
<li><code>list</code>：长度为1、或2、或3的列表</li>
</ul>
</li>
<li>默认这些值会在对应线程字典中查找，此参数可以通过更
底层的控制<ul>
<li>可优化在小数组上大量<em>ufunc</em>的调用</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>部分参数含义通用，参见<em>README</em></li>
</ul>
</blockquote>
<h3 id="UFunc属性"><a href="#UFunc属性" class="headerlink" title="UFunc属性"></a>UFunc属性</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Attr</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ufunc.nin</code></td>
<td>输入数量</td>
</tr>
<tr>
<td><code>ufunc.nout</code></td>
<td>输出数量</td>
</tr>
<tr>
<td><code>ufunc.nargs</code></td>
<td>参数数量</td>
</tr>
<tr>
<td><code>ufunc.ntypes</code></td>
<td>类型数量</td>
</tr>
<tr>
<td><code>ufunc.types</code></td>
<td><em>input-&gt;output</em>列表</td>
</tr>
<tr>
<td><code>ufunc.identity</code></td>
<td>标志值</td>
</tr>
<tr>
<td><code>ufunc.signature</code></td>
<td>广义<em>ufunc</em>执行操作所在的核心元素的定义</td>
</tr>
</tbody>
</table>
</div>
<h3 id="UFunc方法"><a href="#UFunc方法" class="headerlink" title="UFunc方法"></a>UFunc方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Method</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ufunc.reduce(a[,axis,dtype,out,...])</code></td>
<td>通过沿轴应用<em>ufunc</em>缩减维度</td>
</tr>
<tr>
<td><code>ufunc.accumulate(array[,axis,dtype,out])</code></td>
<td>累加所有元素的计算结果</td>
</tr>
<tr>
<td><code>ufunc.reduceat(a,indice[,axis,dtype,out])</code></td>
<td>在single轴指定切片上执行reduce</td>
</tr>
<tr>
<td><code>ufunc.outer(A,B,**kwargs)</code></td>
<td>在分属<code>A,B</code>的元素对上应用<em>ufunc</em></td>
</tr>
<tr>
<td><code>ufunc.at(a,indices[,b])</code></td>
<td>在<code>indices</code>处在位无缓冲执行操作</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>所有<em>ufunc</em>都有4个方法，但是这些方法只在标量<em>ufunc</em>、
包含2输入参数、1输出参数里有价值，否则导致<code>ValueError</code></li>
</ul>
<h2 id="UFunc相关函数"><a href="#UFunc相关函数" class="headerlink" title="UFunc相关函数"></a><em>UFunc</em>相关函数</h2><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>apply_along_axis(func1d,axis,arr,*args,...)</code></td>
<td>沿给定轴应用函数</td>
</tr>
<tr>
<td><code>apply_over_axes(func,a,axes)</code></td>
<td>依次沿给定轴应用函数<code>func(a,axis)</code></td>
</tr>
<tr>
<td><code>frompyfunc(func,nin,nout[,identity])</code></td>
<td>创建ufunc，指定输入、输出数量</td>
</tr>
<tr>
<td><code>vertorize(pyfunc[,otypes,doc,excluded,cache,signature])</code></td>
<td>创建ufunc，较<code>frompyfunc</code>提供更多特性</td>
</tr>
<tr>
<td><code>piecewise(x,condlist,funclist,*args,**kw)</code></td>
<td>按照<code>condlist</code>中索引，对应应用<code>funclist</code>中函数</td>
</tr>
</tbody>
</table>
</div>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-02-19T01:02:01.000Z" title="2/19/2021, 9:02:01 AM">2021-02-19</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-02-19T01:02:01.000Z" title="2/19/2021, 9:02:01 AM">2021-02-19</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Numpy/">Numpy</a></span><span class="level-item">5 minutes read (About 801 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Numpy/ndarray_interface.html">NDArray开发</a></h1><div class="content"><h2 id="NDArray-Interface-Protocol"><a href="#NDArray-Interface-Protocol" class="headerlink" title="NDArray Interface/Protocol"></a>NDArray Interface/Protocol</h2><ul>
<li>数组接口（规范）：为重用数据缓冲区设计的规范<ul>
<li>接口描述内容<ul>
<li>获取<code>ndarray</code>内容的方式</li>
<li>数组需为同质数组，即其中各元素数据类型相同</li>
</ul>
</li>
<li>接口包含C和Python两个部分<ul>
<li>Python-API：对象应包含属性<code>__array_interface__</code>字典</li>
<li>C-API：结构体<code>__array_struct__</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.numpy.org.cn/en/reference/arrays/interface.html#python-side">https://www.numpy.org.cn/en/reference/arrays/interface.html#python-side</a></p>
<h3 id="Python-API"><a href="#Python-API" class="headerlink" title="Python API"></a>Python API</h3><blockquote>
<ul>
<li><code>__array_interface__</code>：由3个必须字段和5个可选字段构成</li>
</ul>
</blockquote>
<ul>
<li><p><code>shape</code>：各维度长度（使用时注意取值范围）</p>
</li>
<li><p><code>typestr</code>：指明同质数组数据类型的字符串</p>
<ul>
<li>格式、含义基本同<em>Array-Protocol</em>，但有部分字符
含义不同</li>
<li>但不同于自定义数据类型字符串，不指定结构化数据、
shape，非基本类型就是<code>void</code>，具体含义由<code>descr</code>
给出</li>
</ul>
<p>|代码|类型|
|——-|——-|
|<code>&#39;t&#39;</code>|bit|
|<code>&#39;b&#39;</code>|boolean|
|<code>&#39;B&#39;</code>|unsigned byte|
|<code>&#39;i&#39;</code>|(signed) integer|
|<code>&#39;u&#39;</code>|unsigned integer|
|<code>&#39;f&#39;</code>|floating-point|
|<code>&#39;c&#39;</code>|complex-floating point|
|<code>&#39;m&#39;</code>|timedelta|
|<code>&#39;M&#39;</code>|datetime|
|<code>&#39;O&#39;</code>|(Python) objects|
|<code>&#39;S&#39;</code>/<code>&#39;a&#39;</code>|zero-terminated bytes (not recommended)|
|<code>&#39;U&#39;</code>|Unicode string|
|<code>&#39;V&#39;</code>|raw data (void)|</p>
</li>
<li><p><code>descr</code>：给出同质数组中各元素中内存布局的详细描述的
列表</p>
<ul>
<li>各元素为包含2、3个元素的元组<ul>
<li>名称：字符串、或<code>(&lt;fullname&gt;,&lt;basicname&gt;)</code>
形式的元组</li>
<li>类型：描述基础类型字符串、或嵌套列表</li>
<li>shape：该结构的重复次数，若没有给出则表示无
重复</li>
</ul>
</li>
<li>一般此属性在<code>typestr</code>为取值为<code>V[0-9]+</code>时使用，
要求表示的内存字节数相同</li>
<li>缺省为<code>[(&#39;&#39;), typestr]</code></li>
</ul>
</li>
<li><p><code>data</code>：给出数据位置的2元素元组或暴露有缓冲接口
的对象</p>
<ul>
<li>元组首个元素：表示存储数组内容的数据区域，指向
数据中首个元素（即<code>offset</code>被忽略）</li>
<li>元素第二个元素：只读标记</li>
<li>缺省为<code>None</code>，表示内存共享通过缓冲接口自身实现，
此时<code>offset</code>用于指示缓冲的开始</li>
</ul>
</li>
<li><p><code>strides</code>：存储各维度跃迁的strides的元组</p>
<ul>
<li>元组各元素为各维度跃迁字节数整形值，注意取值范围</li>
<li>缺省为<code>None</code>，C-contiguous风格</li>
</ul>
</li>
<li><p><code>mask</code>：指示数据是否有效的暴露有缓冲接口的对象</p>
<ul>
<li>其shape需要同原始数据shape广播兼容</li>
<li>缺省为<code>None</code>，表示所有数据均有效</li>
</ul>
</li>
<li><p><code>offset</code>：指示数组数据区域offset的整形值</p>
<ul>
<li>仅在数据为<code>None</code>或为<code>buffer</code>对象时使用</li>
<li>缺省为<code>0</code></li>
</ul>
</li>
<li><p><code>version</code>：指示接口版本</p>
</li>
</ul>
<h3 id="C-API"><a href="#C-API" class="headerlink" title="C API"></a>C API</h3><ul>
<li><p><code>__array_struct__</code>：ctype的<code>PyCObject</code>，其中<code>voidptr</code>
指向<code>PyArrayInterface</code></p>
<ul>
<li><code>PyCObject</code>内存空间动态分配</li>
<li><code>PyArrayInterface</code>有相应的析构，访问其之后需要在其上
调用<code>Py_DECREF</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> two;				<span class="comment">// 值为2，sanity check</span></span><br><span class="line">	<span class="keyword">int</span> nd;					<span class="comment">// 维数</span></span><br><span class="line">	<span class="keyword">char</span> typekind;			<span class="comment">// 数组中数据类型</span></span><br><span class="line">	<span class="keyword">int</span> itemsize;			<span class="comment">// 数据类型size</span></span><br><span class="line">	<span class="keyword">int</span> flags;				<span class="comment">// 指示如何解释数据的标志</span></span><br><span class="line">							<span class="comment">// 5bits指示数据解释的5个标志位</span></span><br><span class="line">								<span class="comment">// `CONTIGUOUS`	0x01</span></span><br><span class="line">								<span class="comment">// `FROTRAN`	0x02</span></span><br><span class="line">								<span class="comment">// `ALIGNED`	0x100</span></span><br><span class="line">								<span class="comment">// `NOTSWAPPED` 0x200</span></span><br><span class="line">								<span class="comment">// `WRITABLE`	0X400</span></span><br><span class="line">							<span class="comment">// 1bit指示接口解释（是否包含有效`descr`字段）</span></span><br><span class="line">								<span class="comment">// `ARR_HAS_DESCR` 0x800</span></span><br><span class="line">	Py_intptr_t *shape;		<span class="comment">// shape</span></span><br><span class="line">	Py_intptr_t *strides;	<span class="comment">// strides</span></span><br><span class="line">	<span class="keyword">void</span> *data;				<span class="comment">// 指向数组中首个元素</span></span><br><span class="line">	PyObject *descr;		<span class="comment">// NULL或数据描述（需设置`flags`中的`ARR_HAS_DESCR`，否则被忽略）</span></span><br><span class="line">&#125; PyArrayInterface;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-02-18T09:10:18.000Z" title="2/18/2021, 5:10:18 PM">2021-02-18</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-02-18T09:10:18.000Z" title="2/18/2021, 5:10:18 PM">2021-02-18</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Numpy/">Numpy</a></span><span class="level-item">21 minutes read (About 3088 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Numpy/ndarray_derived.html">NDArray子类</a></h1><div class="content"><h2 id="子类相关钩子属性、方法"><a href="#子类相关钩子属性、方法" class="headerlink" title="子类相关钩子属性、方法"></a>子类相关钩子属性、方法</h2><h3 id="array-方法"><a href="#array-方法" class="headerlink" title="__array__方法"></a><code>__array__</code>方法</h3><ul>
<li><p><code>class.__array_ufunc__(ufunc, method, *inputs, **kwargs)</code></p>
<ul>
<li>功能：供自定义以覆盖numpy中ufunc行为<ul>
<li>返回操作结果，或<code>NotImplemented</code>
（将此方法置<code>None</code>）</li>
</ul>
</li>
<li>参数<ul>
<li><code>ufunc</code>：被调用的ufunc对象</li>
<li><code>method</code>：字符串，指示调用的<code>ufunc</code>对象的方法</li>
<li><code>inputs</code>：<code>ufunc</code>顺序参数元组</li>
<li><code>kwargs</code>：<code>ufunc</code>关键字参数字典</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><em>Ufunc</em>、与<code>__array_ufunc__</code>关系参见ufunc部分</li>
</ul>
</blockquote>
</li>
<li><p><code>class.__array_function__(func,types,args,kwargs)</code></p>
<ul>
<li>参数<ul>
<li><code>func</code>：任意callable，以<code>func(*args, **kwargs)</code>
形式调用</li>
<li><code>types</code>：来自实现`</li>
<li><code>args</code>、<code>kwargs</code>：原始调用的参数</li>
</ul>
</li>
</ul>
</li>
<li><p><code>class.__array__finalize(obj)</code></p>
<ul>
<li>功能：构造之后更改<code>self</code>的属性<ul>
<li>在为<code>obj</code>类型数组分配空间时调用</li>
</ul>
</li>
<li>参数<ul>
<li><code>obj</code>：<code>ndarray</code>子类</li>
</ul>
</li>
</ul>
</li>
<li><p><code>class.__array_prepare__(array,context=None)</code></p>
<ul>
<li>功能：在ufunc计算前，将ouput数组转换为子类实例、
更新元数据<ul>
<li>调用任何ufunc前，在最高优先级的input数组，或指定
的output数组上调用，返回结果传递给ufunc</li>
<li>默认实现：保持原样</li>
</ul>
</li>
</ul>
</li>
<li><p><code>class.__array_wrap__(array,context=None)</code></p>
<ul>
<li>功能：在将结果返回给用户前，将output数组转换为子类
实例、更新元信息<ul>
<li>ufunc计算结果返回给用户前，在最高优先级的output
数组、或指定output对象上调用</li>
<li>默认实现：将数组转换为新</li>
</ul>
</li>
</ul>
</li>
<li><p><code>class.__array__([dtype])</code></p>
<ul>
<li>功能：若output对象有该方法，ufunc结果将被写入其
返回值中</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>若ufunc中所有<code>__array_ufunc__</code>返回<code>NotImplemented</code>，那么
  <code>raise TypeError</code></li>
</ul>
</blockquote>
<h3 id="array-属性"><a href="#array-属性" class="headerlink" title="__array__属性"></a><code>__array__</code>属性</h3><ul>
<li><code>class.__array_priority__</code><ul>
<li>功能：决定返回对象的数据类型（有多种可能性时）<ul>
<li>默认值：<code>0.0</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Matrix"><a href="#Matrix" class="headerlink" title="Matrix"></a>Matrix</h2><h3 id="np-matrix"><a href="#np-matrix" class="headerlink" title="np.matrix"></a><code>np.matrix</code></h3><p>Matrix对象：继承自<code>ndarray</code>，具有<code>ndarray</code>的属性、方法</p>
<ul>
<li>Matrix对象的特殊行为<ul>
<li>维数始终为2<ul>
<li><code>.ravel()</code>仍然二维</li>
<li><em>item selection</em>返回二维对象</li>
</ul>
</li>
<li>数学操作<ul>
<li>覆盖乘法为矩阵乘法</li>
<li>覆盖幂次为矩阵幂次</li>
</ul>
</li>
<li>属性<ul>
<li>默认<code>__array_priority__</code>为<code>10.0</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>Matrix类被设计用于与<code>scipy.sparse</code>交互，建议不使用</li>
<li><code>np.mat</code>是<code>np.matrix</code>别名</li>
</ul>
</blockquote>
<h4 id="Matrix对象property属性"><a href="#Matrix对象property属性" class="headerlink" title="Matrix对象property属性"></a>Matrix对象property属性</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Property</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>matrix.T</code></td>
<td>转置</td>
</tr>
<tr>
<td><code>matrix.H</code></td>
<td>复数共轭</td>
</tr>
<tr>
<td><code>matrix.I</code></td>
<td>逆矩阵</td>
</tr>
<tr>
<td><code>matrix.A</code></td>
<td>返回<code>ndarray</code></td>
</tr>
</tbody>
</table>
</div>
<h4 id="Matrix创建"><a href="#Matrix创建" class="headerlink" title="Matrix创建"></a>Matrix创建</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>np.mat(data[,dtype])</code></td>
<td>创建矩阵</td>
</tr>
<tr>
<td><code>np.matrix(data[,dtype,copy])</code></td>
<td>不建议使用</td>
</tr>
<tr>
<td><code>np.asmatrix(data[,dtype])</code></td>
<td>将数据转换为矩阵</td>
</tr>
<tr>
<td><code>np.bmat(obj[,ldict,gdict])</code></td>
<td>从字符串、嵌套序列、数组中构建</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>mp.bmat</code>：可使用Matlab样式字符串表示法创建Matrix<ul>
<li>空格分割列</li>
<li><code>;</code>分割行</li>
</ul>
</li>
</ul>
<h3 id="np-matlib"><a href="#np-matlib" class="headerlink" title="np.matlib"></a><code>np.matlib</code></h3><ul>
<li><code>numpy.matlib</code>模块中包含<code>numpy</code>命名空间下所有函数<ul>
<li>返回<code>matrix</code>而不是<code>ndarray</code></li>
<li><code>matrix</code>被限制为小于2维，会改变形状的函数可能无法
得到预期结果</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><code>np.matlib</code>是为了方便矩阵运算的模块</li>
</ul>
</blockquote>
<h2 id="np-char"><a href="#np-char" class="headerlink" title="np.char"></a><code>np.char</code></h2><h3 id="np-chararray"><a href="#np-chararray" class="headerlink" title="np.chararray"></a><code>np.chararray</code></h3><ul>
<li><code>np.chararray</code>类：<code>string_</code>、<code>unicode_</code>数据类型的增强型
数组，继承自<code>ndarray</code><ul>
<li>继承由<em>Numarray</em>引入的特性：项检索和比较操作中，数组
元素末尾空格被忽略</li>
<li>定义有基于元素的<code>+</code>、<code>*</code>、<code>%</code>的操作</li>
<li>具有所有标准<code>string</code>、<code>unicode</code>方法，可以逐元素执行</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>char.array(obj[,itemsize,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>char.asarray(obj[,itemsize,...])</code></td>
<td>转换输入为<code>chararray</code>，必要时复制数据</td>
</tr>
<tr>
<td><code>chararray(shape[,itemsize,unicode,...])</code></td>
<td>不应直接使用此构造函数</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<ul>
<li><code>np.chararray</code>类是为了后向兼容<em>Numarray</em>，建议使用
  <code>object_</code>、<code>string_</code>、<code>unicode_</code>类型的数组替代，并利用
  <code>numpy.char</code>模块的自由函数用于字符串快速向量化操作</li>
</ul>
</blockquote>
<h3 id="NDArray-Char-Routine"><a href="#NDArray-Char-Routine" class="headerlink" title="NDArray Char Routine"></a>NDArray Char Routine</h3><ul>
<li><code>np.char</code>/<code>np.core.defchararray</code>模块为<code>np.string_</code>、
<code>np.unicode_</code>类型的数组提供向量化的字符串操作<ul>
<li>基于标准库中<code>string</code>、<code>unicode</code>的方法</li>
</ul>
</li>
</ul>
<h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>char.add(x1,x2)</code></td>
<td></td>
</tr>
<tr>
<td><code>char.multiply(a,i)</code></td>
<td></td>
</tr>
<tr>
<td><code>char.mod(a,values)</code></td>
<td><code>%</code>格式化（<code>str.__mod__</code>为<code>%</code>调用方法）</td>
</tr>
<tr>
<td><code>char.capialize(a)</code></td>
<td>首字符大写</td>
</tr>
<tr>
<td><code>char.title(a)</code></td>
<td>单词首字符大写</td>
</tr>
<tr>
<td><code>char.center(a,width[,fillchar])</code></td>
<td><code>a</code>居中、<code>fillchar</code>填充字符串</td>
</tr>
<tr>
<td><code>char.ljust(a,width(,fillchar))</code></td>
<td><code>a</code>靠左</td>
</tr>
<tr>
<td><code>char.rjust(a,width(,fillchar))</code></td>
<td><code>a</code>靠左</td>
</tr>
<tr>
<td><code>char.zfill(a,width)</code></td>
<td><code>0</code>填充左侧</td>
</tr>
<tr>
<td><code>char.char.decode(a[,encoding,errors])</code></td>
<td></td>
</tr>
<tr>
<td><code>char.char.encode(a[,encoding,errors])</code></td>
<td></td>
</tr>
<tr>
<td><code>char.char.expandtabs(a[,tabsize])</code></td>
<td>替换tab为空格</td>
</tr>
<tr>
<td><code>char.join(sep, seq)</code></td>
<td></td>
</tr>
<tr>
<td><code>char.lower(a)</code></td>
<td></td>
</tr>
<tr>
<td><code>char.upper(a)</code></td>
<td></td>
</tr>
<tr>
<td><code>char.swapcase(a)</code></td>
<td></td>
</tr>
<tr>
<td><code>char.strip(a[,chars])</code></td>
<td></td>
</tr>
<tr>
<td><code>char.lstrip(a[,chars])</code></td>
<td></td>
</tr>
<tr>
<td><code>char.rstrip(a[,chars])</code></td>
<td></td>
</tr>
<tr>
<td><code>char.partition(a,sep)</code></td>
<td>从左至右切分一次，返回三元组</td>
</tr>
<tr>
<td><code>char.rpartition(a,sep)</code></td>
<td>从右至左切分一次</td>
</tr>
<tr>
<td><code>char.split(a[,sep,maxsplit])</code></td>
<td>从左至右切分<code>maxsplit</code>次，返回列表</td>
</tr>
<tr>
<td><code>char.rsplit(a[,sep,maxsplit])</code></td>
<td></td>
</tr>
<tr>
<td><code>char.splitlines(a[,keepends])</code></td>
<td>切分行，即<code>\n</code>为切分点</td>
</tr>
<tr>
<td><code>char.replace(a,old,new[,count])</code></td>
</tr>
</tbody>
</table>
</div>
<h4 id="Camparison"><a href="#Camparison" class="headerlink" title="Camparison"></a>Camparison</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>equal(x1,x2)</code></td>
<td></td>
</tr>
<tr>
<td><code>greater(x1,x2)</code></td>
<td></td>
</tr>
<tr>
<td><code>less(x1,x2)</code></td>
<td></td>
</tr>
<tr>
<td><code>not_equal(x1,x2)</code></td>
<td></td>
</tr>
<tr>
<td><code>greater_equal(x1,x2)</code></td>
<td></td>
</tr>
<tr>
<td><code>less_equal(x1,x2)</code></td>
<td></td>
</tr>
<tr>
<td><code>compare_chararrays(a,b,com_op,rstrip)</code></td>
<td><code>com_op</code>指定比较方法</td>
</tr>
</tbody>
</table>
</div>
<h4 id="字符串信息"><a href="#字符串信息" class="headerlink" title="字符串信息"></a>字符串信息</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>count(a,sub[,start,end])</code></td>
<td>统计不重叠<code>sub</code>出现次数</td>
</tr>
<tr>
<td><code>startwith(a,prefix[,start,end])</code></td>
<td></td>
</tr>
<tr>
<td><code>endswith(a,suffix[,start,end])</code></td>
<td></td>
</tr>
<tr>
<td><code>find(a,sub[,start,end])</code></td>
<td>返回首个<code>sub</code>位置，不存在返回<code>-1</code></td>
</tr>
<tr>
<td><code>rfind(a,sub[,start,end])</code></td>
<td>从右至左<code>find</code></td>
</tr>
<tr>
<td><code>index(a,sub[,start,end])</code></td>
<td>同<code>find</code>，不存在<code>ValueError</code></td>
</tr>
<tr>
<td><code>rindex(a,sub[,start,end])</code></td>
<td>从右至左<code>index</code></td>
</tr>
<tr>
<td><code>isalpha(a)</code></td>
<td></td>
</tr>
<tr>
<td><code>iaalnum(a)</code></td>
<td></td>
</tr>
<tr>
<td><code>isdecimal(a)</code></td>
<td></td>
</tr>
<tr>
<td><code>isdigit(a)</code></td>
<td></td>
</tr>
<tr>
<td><code>islower(a)</code></td>
<td></td>
</tr>
<tr>
<td><code>isnumeric(a)</code></td>
<td></td>
</tr>
<tr>
<td><code>isspace(a)</code></td>
<td></td>
</tr>
<tr>
<td><code>istitle(a)</code></td>
<td>是否各单词首字符大写</td>
</tr>
<tr>
<td><code>isupper(a)</code></td>
<td></td>
</tr>
<tr>
<td><code>str_len(a)</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="np-rec"><a href="#np-rec" class="headerlink" title="np.rec"></a><code>np.rec</code></h2><ul>
<li><code>np.rec</code>/<code>np.core.records</code></li>
</ul>
<h3 id="np-recarray"><a href="#np-recarray" class="headerlink" title="np.recarray"></a><code>np.recarray</code></h3><ul>
<li><code>np.recarray</code>类：允许将结构化数组的字段作为属性访问</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>np.recarray</code></td>
<td>创建允许属性访问字段的<code>ndarray</code></td>
</tr>
<tr>
<td><code>np.record</code></td>
<td>允许使用属性查找字段的数据类型标量</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Record-Arrays"><a href="#Record-Arrays" class="headerlink" title="Record Arrays"></a>Record Arrays</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>core.records.array(obj[,dtype,shape,...])</code></td>
<td>从多类型对象中创建</td>
</tr>
<tr>
<td><code>core.records.fromarrays(arrayList[,dtype,...])</code></td>
<td>从数组列表中创建</td>
</tr>
<tr>
<td><code>core.records.fromrecords(recList[,dtype])</code></td>
<td>从文本格式的records列表创建</td>
</tr>
<tr>
<td><code>core.records.fromstring(datastring[,dtype,...])</code></td>
<td>从二进制数据字符串中创建只读</td>
</tr>
<tr>
<td><code>core.records.fromfile(fd[,dtype,shape,...])</code></td>
<td>从二进制文件中创建</td>
</tr>
</tbody>
</table>
</div>
<h2 id="np-ma"><a href="#np-ma" class="headerlink" title="np.ma"></a><code>np.ma</code></h2><h3 id="ma-MaskedArray"><a href="#ma-MaskedArray" class="headerlink" title="ma.MaskedArray"></a><code>ma.MaskedArray</code></h3><ul>
<li><p><code>ma.MaskedArray</code>：掩码数组，是<code>np.ma</code>核心，<code>ndarray</code>子类</p>
<ul>
<li><code>ma.MaskedArray</code>由标准<code>np.ndarray</code>和掩码组成</li>
</ul>
</li>
<li><p>掩码数组<code>.mask</code></p>
<ul>
<li>掩码可以被设置为<em>hardmask</em>、<em>softmask</em>，由只读属性
<code>hardmask</code>指定<ul>
<li><em>hardmask</em>：无法修改被遮蔽值</li>
<li><em>softmask</em>：可修改被遮蔽值，并恢复被遮蔽状态</li>
</ul>
</li>
<li><code>.mask</code>可以被设置<ul>
<li>为bool数组，指示各位置元素是否被遮蔽</li>
<li><code>ma.maskded/ma.unmask/True/False</code>，设置掩码数组
整体是被遮蔽</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><code>ma.nomask</code>是<code>np.bool_</code>类型的<code>False</code>，<code>ma.masked</code>是特殊
  常数</li>
<li><p><code>ma.MaskType</code>是<code>np.bool_</code>别名</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.numpy.org.cn/reference/arrays/maskedarray.html">https://www.numpy.org.cn/reference/arrays/maskedarray.html</a></p>
</li>
<li><a target="_blank" rel="noopener" href="https://www.numpy.org.cn/reference/routines/ma.html">https://www.numpy.org.cn/reference/routines/ma.html</a></li>
</ul>
</blockquote>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Attr</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.hardmask</code></td>
<td>硬掩码标志</td>
</tr>
<tr>
<td><code>.data</code></td>
<td>值数组</td>
</tr>
<tr>
<td><code>.mask</code></td>
<td>掩码数组、<code>ma.unmask</code>、<code>ma.masked</code></td>
</tr>
<tr>
<td><code>.recordmask</code></td>
<td>项目中命名字段全遮蔽则遮蔽</td>
</tr>
</tbody>
</table>
</div>
<h4 id="创建掩码数组"><a href="#创建掩码数组" class="headerlink" title="创建掩码数组"></a>创建掩码数组</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ma.MaskedArray(data[,mask,dtype,...])</code></td>
<td>类</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.masked_array(data[,mask,dtype,...])</code></td>
<td><code>MaskedArray</code>别名</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.array(data[,dtype,copy,...])</code></td>
<td>构造函数</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.frombuffer(buffer[,dtype,count,offset])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.fromfunction(function,shape,dtype)</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.fromflex(fxarray)</code></td>
<td>从有<code>_data</code>、<code>_mask</code>字段的结构化<code>fxarray</code>中创建</td>
<td>无</td>
</tr>
<tr>
<td><code>copy(a[,order])</code></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h5 id="Ones-and-Zeros"><a href="#Ones-and-Zeros" class="headerlink" title="Ones and Zeros"></a>Ones and Zeros</h5><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ma.empty(shape[,dtype,order])</code></td>
<td>无初始化</td>
</tr>
<tr>
<td><code>ma.empty_like(prototype[,dtype,order,subok,...])</code></td>
<td>shape、类型同<code>prototype</code></td>
</tr>
<tr>
<td><code>ma.ones(shape[,dtype,order])</code></td>
<td></td>
</tr>
<tr>
<td><code>ma.zeros(shape[,dtype,order])</code></td>
<td></td>
</tr>
<tr>
<td><code>ma.masked_all(shape[,dtype])</code></td>
<td>所有元素被屏蔽</td>
</tr>
<tr>
<td><code>ma.masked_all_like(shape[,dtype])</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="MaskedArray-Routine"><a href="#MaskedArray-Routine" class="headerlink" title="MaskedArray Routine"></a>MaskedArray Routine</h3><ul>
<li><code>np.ma</code>模块下的函数、<code>ma.MaskedArray</code>方法和<code>ndarray</code>
类似，但行为可能不同<ul>
<li><code>np</code>命名空间下部分函数（<code>hstack</code>等）应用在
<code>MaskedArray</code>上<ul>
<li>操作时忽略<code>mask</code>（即会操作被遮罩元素）</li>
<li>返回结果中<code>mask</code>被置为<code>False</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>这里仅记录<code>ma</code>模块中额外、或需额外说明部分</li>
</ul>
</blockquote>
<h4 id="数组检查"><a href="#数组检查" class="headerlink" title="数组检查"></a>数组检查</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ma.all(a[,axis,out,keepdims])</code></td>
<td>全遮蔽时返回<code>ma.masked</code></td>
<td></td>
</tr>
<tr>
<td><code>ma.any(a[,axis,out,keepdims])</code></td>
<td>存在遮蔽时返回<code>ma.masked</code></td>
<td></td>
</tr>
<tr>
<td><code>ma.count(arr,[axis,keepdims])</code></td>
<td>沿给定轴统计未被遮罩元素数量</td>
<td></td>
</tr>
<tr>
<td><code>ma.count_masked(arr,[axis])</code></td>
<td>沿给定轴统计被遮罩元素数量</td>
<td></td>
</tr>
<tr>
<td><code>ma.nonzero(a)</code></td>
<td>非0、未屏蔽元素索引</td>
<td></td>
</tr>
<tr>
<td><code>ma.is_mask(m)</code></td>
<td>是否为标准掩码数组</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.is_masked(x)</code></td>
<td>是否包含遮蔽元素</td>
</tr>
</tbody>
</table>
</div>
<h4 id="获取、创建、修改掩码"><a href="#获取、创建、修改掩码" class="headerlink" title="获取、创建、修改掩码"></a>获取、创建、修改掩码</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ma.getmask(a)</code></td>
<td>返回掩码、或<code>ma.nomask</code>、<code>ma.masked</code></td>
<td><code>.mask</code>属性</td>
</tr>
<tr>
<td><code>ma.getmaskarray(arr)</code></td>
<td>返回掩码、或完整<code>False</code>数组</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.make_mask(m[,copy,shrink,dtype])</code></td>
<td>从数组创建掩码</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.make_mask_none(newshape[,dtype])</code></td>
<td>创建给定形状掩码</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.make_mask_descr(ndtype)</code></td>
<td>为给定类型的创建掩码类型</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.mask_rowcols(a[,axis])</code></td>
<td>遮蔽包含遮蔽元素的<code>axis</code>方向分量</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.mask_rows(a[,axis])</code></td>
<td>缺省为<code>0</code>的<code>mask_rowcols()</code></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.mask_cols(a[,axis])</code></td>
<td>缺省为<code>1</code>的<code>mask_rowcols()</code></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.mask_mask_or(m1,m2[,copy,shrink])</code></td>
<td>掩码或</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.harden_mask(a)</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>ma.soften_mask(a)</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>.shrink_mask()</code></td>
<td>无</td>
<td>尽可能缩小掩码</td>
</tr>
<tr>
<td><code>.share_mask()</code></td>
<td>无</td>
<td>复制掩码，并设置<code>sharedmask=False</code></td>
</tr>
</tbody>
</table>
</div>
<h4 id="获取、创建索引"><a href="#获取、创建索引" class="headerlink" title="获取、创建索引"></a>获取、创建索引</h4><ul>
<li><p>索引非结构化掩码数组</p>
<ul>
<li>mask为<code>False</code>：返回数组标量</li>
<li>mask为<code>True</code>：返回<code>ma.masked</code></li>
</ul>
</li>
<li><p>索引结构化掩码数组</p>
<ul>
<li>所有字段mask均为<code>False</code>：返回<code>np.void</code>对象</li>
<li>存在字段mask为<code>True</code>：返回零维掩码数组</li>
</ul>
</li>
<li><p>切片</p>
<ul>
<li><code>.data</code>属性：原始数据视图</li>
<li><code>.mask</code>属性：<code>ma.nomask</code>或者原始mask视图</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ma.nonzero(a)</code></td>
<td>未屏蔽、非0元素索引</td>
<td></td>
</tr>
<tr>
<td><code>ma.mr_[]</code></td>
<td>沿第1轴concate切片、数组、标量，类<code>np.r_[]</code></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.flatnotmasked_contiguous(a)</code></td>
<td>展平后未遮蔽切片</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.flatnotmasked_edges(a)</code></td>
<td>展平后首个、末个未遮蔽位置</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.notmasked_contiguous(a[,axis])</code></td>
<td>沿给定轴，未遮蔽切片</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.notmasked_edges(a[,axis])</code></td>
<td>沿给定轴，首个、末个未遮蔽位置</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.clump_masked(a)</code></td>
<td>展平后遮蔽切片</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.clump_unmasked(a)</code></td>
<td>展位后未遮蔽切片</td>
<td>无</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>ma.mr_[]</code>类似<code>np.r_[]</code>，但<code>np.r_[]</code>返回结果掩码被置为
<code>False</code>，而<code>ma.mr_[]</code>同时也操作掩码</li>
</ul>
<h4 id="获取、修改值"><a href="#获取、修改值" class="headerlink" title="获取、修改值"></a>获取、修改值</h4><ul>
<li><p>仅访问有效数据</p>
<ul>
<li>对掩码mask取反作为索引<code>~X.mask</code></li>
<li>使用<code>.compressed</code>方法得到一维<code>ndarray</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(X[~X.mask])</span><br><span class="line"><span class="built_in">print</span>(X.compressed())</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问数据</p>
<ul>
<li>通过<code>.data</code>属性：可能是<code>ndarray</code>或其子类的视图<ul>
<li>等同于直接在掩码数组上创建<code>ndarray</code>或其子类视图</li>
</ul>
</li>
<li><code>__array__</code>方法：<code>ndarray</code></li>
<li>使用<code>ma.getdata</code>函数</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ma.getdata(a[,subok])</code></td>
<td>返回掩码数组数据</td>
<td><code>.data</code>属性</td>
</tr>
<tr>
<td><code>ma.fix_valid(a[,mask,copy,fill_value])</code></td>
<td>替换<code>a</code>中无效值，并遮盖</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.masked_equal(x,value[,copy])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.masked_greater(x,value[,copy])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.masked_greater_equal(x,value[,copy])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.masked_inside(x,v1,v2[,copy])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.masked_outside(x,v1,v2[,copy])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.masked_invalid(x[,copy])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.masked_less(x,value[,copy])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.masked_less_equal(x,value[,copy])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.masked_not_equal(x,value[,copy])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.masked_values(x,value[,rtol,atol,...])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.masked_object(x,value[,copy,shrink])</code></td>
<td>类<code>masked_values</code>，适合值类型为<code>object</code>时</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.masked_where(condition,a[,copy])</code></td>
<td>按<code>condition</code>遮蔽指定值</td>
<td>无</td>
</tr>
</tbody>
</table>
</div>
<h4 id="其他属性、方法"><a href="#其他属性、方法" class="headerlink" title="其他属性、方法"></a>其他属性、方法</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ma.common_fill_value(a,b)</code></td>
<td>若<code>a,b</code>填充值相同则返回，否则返回<code>None</code></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.default_fill_value(obj)</code></td>
<td>默认填充值</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.maximum_fill_value(obj)</code></td>
<td>对象类型决定的最大值</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.minimum_fill_value(obj)</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.sef_fill_value(a,fill_value)</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>.get_fill_value()</code>/<code>.fill_value</code></td>
<td>无</td>
<td></td>
</tr>
<tr>
<td><code>ma.allequal(a,b[,fill_value])</code></td>
<td>若<code>a,b</code>元素均相等，则使用<code>fill_value</code>填充</td>
</tr>
</tbody>
</table>
</div>
<h3 id="np-ma运算"><a href="#np-ma运算" class="headerlink" title="np.ma运算"></a><code>np.ma</code>运算</h3><ul>
<li><p>掩码数组支持代数、比较运算</p>
<ul>
<li>被遮蔽元素不参与运算，元素在运算前后保持不变</li>
<li>掩码数组支持标准的<em>ufunc</em>，返回掩码数组<ul>
<li>运算中任意元素被遮蔽，则结果中相应元素被遮蔽</li>
<li>若<em>ufunc</em>返回可选的上下文输出，则上下文会被处理，
且无定义结果被遮蔽</li>
</ul>
</li>
</ul>
</li>
<li><p><code>np.ma</code>模块中对大部分ufunc有特别实现</p>
<ul>
<li>对于定义域有限制的一元、二元运算，无定义的结果会
自动mask</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ma.log([-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ma.anom(a[,axis,dtype])</code></td>
<td>沿给定轴计算与算数均值的偏差</td>
</tr>
</tbody>
</table>
</div>
<h2 id="np-memmap"><a href="#np-memmap" class="headerlink" title="np.memmap"></a><code>np.memmap</code></h2><ul>
<li><p><code>np.memmap</code>：内存映射文件数组，使用内存映射文件作为数组
数据缓冲区</p>
<ul>
<li>对大文件，使用内存映射可以节省大量资源</li>
</ul>
</li>
<li><p>方法</p>
<p>|Method|Desc|
|——-|——-|
|<code>np.memmap(filename[,dtype,mode,shape])</code>|创建存储在磁盘文件的内存映射数组|
|<code>np.flush()</code>|flush内存数据至磁盘|</p>
</li>
</ul>
<h2 id="标准容器类"><a href="#标准容器类" class="headerlink" title="标准容器类"></a>标准容器类</h2><ul>
<li><p><code>np.lib.user_array.container</code></p>
<ul>
<li>为向后兼容、作为标准容器类而引入</li>
<li>其中<code>self.array</code>属性是<code>ndarray</code></li>
<li>比<code>ndarray</code>本身更方便多继承</li>
</ul>
</li>
<li><p>类、方法、函数</p>
<p>|Method|Desc|
|——-|——-|
|<code>np.lib.user_array.container(data[,...])</code>|简化多继承的标准容器类|</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-02-01T00:32:44.000Z" title="2/1/2021, 8:32:44 AM">2021-02-01</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-02-01T00:32:44.000Z" title="2/1/2021, 8:32:44 AM">2021-02-01</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Numpy/">Numpy</a></span><span class="level-item">20 minutes read (About 3066 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Numpy/ndarray_scalars.html">NDArray标量</a></h1><div class="content"><h2 id="NDArray标量类型"><a href="#NDArray标量类型" class="headerlink" title="NDArray标量类型"></a>NDArray标量类型</h2><ul>
<li><p>numpy中定义了24种新python类型（NDArray标量类型）</p>
<ul>
<li>类型描述符主要基于CPython中C语言可用的类型</li>
</ul>
</li>
<li><p>标量具有和<code>ndarray</code>相同的属性和方法</p>
<ul>
<li>数组标量不可变，故属性不可设置</li>
</ul>
</li>
</ul>
<p><img src="/imgs/numpy_dtype_hierarchy.png" alt="numpy_dtype_hierarchy"></p>
<h3 id="内置标量类型"><a href="#内置标量类型" class="headerlink" title="内置标量类型"></a>内置标量类型</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>iinfo(int_type)</code></td>
<td>整数类型的取值范围等信息</td>
</tr>
<tr>
<td><code>finfo(float_type)</code></td>
<td>浮点类型的取值范围等信息</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Python关联"><a href="#Python关联" class="headerlink" title="Python关联"></a>Python关联</h4><div class="table-container">
<table>
<thead>
<tr>
<th>NumPy类型</th>
<th>Python类型</th>
<th>64位NumPy定长类型</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int_</code></td>
<td>继承自<code>int</code>（Python2）</td>
<td><code>int64</code></td>
<td></td>
</tr>
<tr>
<td><code>float_</code></td>
<td>继承自<code>float</code></td>
<td><code>float64</code></td>
<td></td>
</tr>
<tr>
<td><code>complex_</code></td>
<td>继承自<code>complex</code></td>
<td><code>complex128</code></td>
<td></td>
</tr>
<tr>
<td><code>bytes_</code></td>
<td>继承自<code>bytes</code></td>
<td><code>S#&quot;</code>/<code>&quot;a#&quot;</code></td>
<td>Python字节串</td>
</tr>
<tr>
<td><code>unicode_</code></td>
<td>继承自<code>str</code></td>
<td><code>&quot;U#&quot;</code></td>
<td>Python字符串</td>
</tr>
<tr>
<td><code>void</code></td>
<td></td>
<td><code>&quot;V#&quot;</code></td>
<td>Python缓冲类型</td>
</tr>
<tr>
<td><code>object_</code></td>
<td>继承自<code>object</code>（Python3）</td>
<td><code>&quot;O&quot;</code></td>
<td>Python对象引用</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p><code>np.bool_</code>类似Python中<code>bool</code>类型，但不继承它</p>
<ul>
<li>Python中<code>bool</code>类型不允许被继承</li>
<li><code>np.bool_</code>大小和<code>bool</code>类型大小不同</li>
</ul>
</li>
<li><p><code>np.int_</code>不继承自<code>int</code>，因为后者宽度不再固定</p>
<ul>
<li>NumPy中数组没有真正<code>np.int</code>类型，因为宽度不再固定，
各产品</li>
</ul>
</li>
<li><p><code>bytes_</code>、<code>unicode_</code>、<code>void</code>是可灵活配置宽度的类型</p>
<ul>
<li>在指定长度后不能更改，赋长于指定长度的值会被截断</li>
<li><code>unicode_</code>：强调内容为字符串</li>
<li><code>bytes_</code>：强调内容为字节串</li>
<li><code>void</code>：类型强调内容为二进制内容，但不是字节串</li>
</ul>
</li>
<li><p><code>object_</code>存储的是python对象的引用而不对象本身</p>
<ul>
<li>其中引用不必是相同的python类型</li>
<li>兜底类型</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>Python基本类型等在NumPy命名空间下都有同名别名，如：
  <code>np.unicode == np.str == str</code></li>
<li>NumPy数组中数据类型无法被真正设置为<code>int</code>类型，为保证数组
  中元素宽度一致性，必然无法被设置为非定长类型</li>
</ul>
</blockquote>
<h4 id="C类型关联"><a href="#C类型关联" class="headerlink" title="C类型关联"></a>C类型关联</h4><blockquote>
<ul>
<li>NumPy支持的原始类型和C中原始类型紧密相关</li>
</ul>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>NumPy类型</th>
<th>C类型</th>
<th>64位定长别名</th>
<th>Desc</th>
<th>单字符代码</th>
<th>定长字符串代码</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bool_</code></td>
<td><code>bool</code></td>
<td><code>bool8</code></td>
<td>存储为字节的bool值</td>
<td><code>&quot;?&quot;</code></td>
<td>无</td>
</tr>
<tr>
<td><code>byte</code></td>
<td><code>signed char</code></td>
<td><code>int8</code></td>
<td></td>
<td><code>&quot;b&quot;</code></td>
<td><code>&quot;i1&quot;</code></td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>short</code></td>
<td><code>int16</code></td>
<td></td>
<td><code>&quot;h&quot;</code></td>
<td><code>&quot;i2&quot;</code></td>
</tr>
<tr>
<td><code>intc</code></td>
<td><code>int</code></td>
<td><code>int32</code></td>
<td></td>
<td><code>&quot;i&quot;</code></td>
<td><code>&quot;i4&quot;</code></td>
</tr>
<tr>
<td><code>int_</code></td>
<td><code>long</code></td>
<td><code>int64</code></td>
<td></td>
<td><code>&quot;l&quot;</code></td>
<td><code>&quot;i8&quot;</code></td>
</tr>
<tr>
<td><code>longlong</code></td>
<td><code>long long</code></td>
<td>无</td>
<td></td>
<td><code>&quot;q&quot;</code></td>
<td>无</td>
</tr>
<tr>
<td><code>ubyte</code></td>
<td><code>unsigned char</code></td>
<td><code>uint8</code></td>
<td></td>
<td><code>&quot;B&quot;</code></td>
<td><code>&quot;u1&quot;</code></td>
</tr>
<tr>
<td><code>ushort</code></td>
<td><code>unsigned short</code></td>
<td><code>uint16</code></td>
<td></td>
<td><code>&quot;H&quot;</code></td>
<td><code>&quot;u2&quot;</code></td>
</tr>
<tr>
<td><code>uintc</code></td>
<td><code>unsigned int</code></td>
<td><code>uint32</code></td>
<td></td>
<td><code>&quot;I&quot;</code></td>
<td><code>&quot;u4&quot;</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>usigned long</code></td>
<td><code>uint64</code></td>
<td></td>
<td><code>&quot;L&quot;</code></td>
<td><code>&quot;u8&quot;</code></td>
</tr>
<tr>
<td><code>ulonglong</code></td>
<td><code>unsigned long long</code></td>
<td>无</td>
<td></td>
<td><code>&quot;Q&quot;</code></td>
<td>无</td>
</tr>
<tr>
<td><code>half</code></td>
<td>无</td>
<td><code>float16</code></td>
<td>半精度浮点：1+5+10</td>
<td><code>&quot;e&quot;</code></td>
<td><code>&quot;f2&quot;</code></td>
</tr>
<tr>
<td><code>single</code></td>
<td><code>float</code></td>
<td><code>float32</code></td>
<td>单精度浮点，通常为：1+8+23</td>
<td><code>&quot;f4&quot;</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td><code>double</code></td>
<td><code>float64</code></td>
<td>双精度浮点，通常为：1+11+52</td>
<td><code>&quot;d&quot;</code></td>
<td><code>&quot;f8&quot;</code></td>
</tr>
<tr>
<td><code>longdouble</code>/<code>longfloat</code></td>
<td><code>long double</code></td>
<td><code>float128</code></td>
<td>平台定义的扩展精度浮点</td>
<td><code>&quot;g&quot;</code></td>
<td><code>&quot;f16&quot;</code></td>
</tr>
<tr>
<td><code>csingle</code></td>
<td><code>float complex</code></td>
<td><code>complex64</code></td>
<td>两个单精度浮点</td>
<td><code>&quot;F&quot;</code></td>
<td><code>&quot;c8&quot;</code></td>
</tr>
<tr>
<td><code>cdouble</code>/<code>cfloat</code></td>
<td><code>double complex</code></td>
<td><code>complex128</code></td>
<td>两个双精度浮点</td>
<td><code>&quot;D&quot;</code></td>
<td><code>&quot;c16&quot;</code></td>
</tr>
<tr>
<td><code>clongdouble</code>/<code>clongfloat</code></td>
<td><code>long duoble complex</code></td>
<td><code>complex256</code></td>
<td>两个扩展精度浮点</td>
<td><code>&quot;G&quot;</code></td>
<td><code>&quot;c32&quot;</code></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<ul>
<li><code>float complex</code>、<code>double complex</code>类型定义在<code>complex.h</code>中</li>
<li>C中的定长类型别名定义在<code>stdint.h</code>中</li>
</ul>
</blockquote>
<h4 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Python类型</th>
<th>Desc</th>
<th>单字符代码</th>
<th>定长字符串代码</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>timedelta64</code></td>
<td>时间增量</td>
<td><code>&quot;m&quot;</code></td>
<td><code>&quot;m8&quot;</code></td>
</tr>
<tr>
<td><code>datetime64</code></td>
<td>日期时间</td>
<td><code>&quot;M&quot;</code></td>
<td><code>&quot;M8&quot;</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="属性、索引、方法"><a href="#属性、索引、方法" class="headerlink" title="属性、索引、方法"></a>属性、索引、方法</h3><ul>
<li><p>数组标量属性基本同<code>ndarray</code></p>
</li>
<li><p>数组标量类似0维数组一样支持索引</p>
<ul>
<li><code>X[()]</code>返回副本</li>
<li><code>X[...]</code>返回0维数组</li>
<li><code>X[&lt;field-name&gt;]</code>返回对应字段的数组标量</li>
</ul>
</li>
<li><p>数组标量与<code>ndarray</code>有完全相同的方法</p>
<ul>
<li>默认行为是在内部将标量转换维等效0维数组，并调用相应
数组方法</li>
</ul>
</li>
</ul>
<h3 id="定义数组标量类型"><a href="#定义数组标量类型" class="headerlink" title="定义数组标量类型"></a>定义数组标量类型</h3><ul>
<li>从内置类型组合结构化类型</li>
<li>子类化<code>ndarray</code><ul>
<li>部分内部行为会由数组类型替代</li>
</ul>
</li>
<li>完全自定义数据类型，在numpy中注册<ul>
<li>只能使用numpy C-API在C中定义</li>
</ul>
</li>
</ul>
<h2 id="数据类型相关函数"><a href="#数据类型相关函数" class="headerlink" title="数据类型相关函数"></a>数据类型相关函数</h2><h3 id="数据类型信息"><a href="#数据类型信息" class="headerlink" title="数据类型信息"></a>数据类型信息</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>finfo(dtype)</code></td>
<td>机器对浮点类型限制</td>
</tr>
<tr>
<td><code>iinfo(type)</code></td>
<td>机器对整型限制</td>
</tr>
<tr>
<td><code>MachAr([float_conv,int_conv])</code></td>
<td>诊断机器参数</td>
</tr>
<tr>
<td><code>typename(char)</code></td>
<td>对给定数据类型字符代码的说明</td>
</tr>
</tbody>
</table>
</div>
<h3 id="数据类型测试"><a href="#数据类型测试" class="headerlink" title="数据类型测试"></a>数据类型测试</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>can_cast(from_,to[,casting])</code></td>
<td>是否可以类型转换</td>
</tr>
<tr>
<td><code>issctype(rep)</code></td>
<td><code>rep</code>（不能为可转换字符串）是否表示标量数据类型</td>
</tr>
<tr>
<td><code>issubdtype(arg1,arg2)</code></td>
<td><code>arg1</code>在数据类型层次中较低（即<code>dtype</code>的<code>issubclass</code>）</td>
</tr>
<tr>
<td><code>issubsctype(arg1,arg2)</code></td>
<td>同<code>issubdtype</code>，但支持包含<code>dtype</code>属性对象作为参数</td>
</tr>
<tr>
<td><code>issubclass_(arg1,arg2)</code></td>
<td>同内置<code>issubclass</code>，但参数非类时仅返回<code>False</code>，而不是<code>raise TypeError</code></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p><code>np.int64</code>、<code>np.int32</code>在层次体系中不同、且层级一致，所以
会出现<code>issubdtype(np.int64, int) -&gt; True</code>，其他情况为
<code>False</code></p>
</li>
<li><p>通过<code>np.can_cast</code>函数确定safely类型转换</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_casting</span>(<span class="params">ntypes</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;X&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> char <span class="keyword">in</span> ntypes:</span><br><span class="line">		<span class="built_in">print</span>(char, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> row <span class="keyword">in</span> ntypes:</span><br><span class="line">		<span class="built_in">print</span>(row, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">		<span class="keyword">for</span> col <span class="keyword">in</span> ntypes:</span><br><span class="line">			<span class="built_in">print</span>(<span class="built_in">int</span>(np.can_cast(row, col)), end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">print_casting(np.typecodes[<span class="string">&quot;All&quot;</span>])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数据类型确定"><a href="#数据类型确定" class="headerlink" title="数据类型确定"></a>数据类型确定</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Params</th>
<th>ReturnType</th>
<th>ReturnDesc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>min_scalar_type(a)</code></td>
<td>标量值</td>
<td>dtype实例</td>
<td>满足要求最小类型</td>
</tr>
<tr>
<td><code>promote_types(type1,type2)</code></td>
<td>dtype等</td>
<td>dtype实例</td>
<td>可安全转换的最小类型</td>
</tr>
<tr>
<td><code>result_type(*array_and_dtypes)</code></td>
<td>dtype等、标量值、数组</td>
<td>dtype实例</td>
<td>应用<em>promotion rules</em>得到类型</td>
</tr>
<tr>
<td><code>find_common_type(array_types,scalar_types)</code></td>
<td>dtype等列表</td>
<td>dtype实例</td>
<td>综合考虑标量类型、数组类型</td>
</tr>
<tr>
<td><code>common_type(*arrays)</code></td>
<td>数值型数组（有<code>dtype</code>属性）</td>
<td>预定义类型</td>
<td>满足要求类型中、最高精度类型</td>
</tr>
<tr>
<td><code>maximum_sctype(t)</code></td>
<td>dtype等、标量值、数组</td>
<td>预定义类型</td>
<td>满足要求类型中、最高精度类型</td>
</tr>
<tr>
<td><code>obj2sctype(rep[,default])</code></td>
<td>dtype等、标量值、数组</td>
<td>预定义类型</td>
<td>对象类型</td>
</tr>
<tr>
<td><code>sctype2char(sctype)</code></td>
<td>dtype等、标量值、数组</td>
<td>类型字符代码</td>
<td>满足要求的最小类型</td>
</tr>
<tr>
<td><code>mintypecode(typechars[,typeset,default])</code></td>
<td>dtype等、标量值、数组</td>
<td>类型字符代码</td>
<td><code>typeset</code>中选择</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>除非标量和数组为不同体系内数据类型，否则标量不能up_cast
数组数据类型</li>
</ul>
<blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://numpy.org/devdocs/reference/generated/numpy.issubdtype.html#numpy.issubdtype">https://numpy.org/devdocs/reference/generated/numpy.issubdtype.html#numpy.issubdtype</a></li>
<li><a target="_blank" rel="noopener" href="https://numpy.org/devdocs/reference/generated/numpy.issubsctype.html#numpy.issubsctype">https://numpy.org/devdocs/reference/generated/numpy.issubsctype.html#numpy.issubsctype</a></li>
<li><a target="_blank" rel="noopener" href="https://numpy.org/devdocs/reference/generated/numpy.find_common_type.html#numpy.find_common_type">https://numpy.org/devdocs/reference/generated/numpy.find_common_type.html#numpy.find_common_type</a></li>
<li><a target="_blank" rel="noopener" href="https://numpy.org/devdocs/reference/generated/numpy.result_type.html#numpy.result_type">https://numpy.org/devdocs/reference/generated/numpy.result_type.html#numpy.result_type</a></li>
<li><a target="_blank" rel="noopener" href="https://numpy.org/devdocs/reference/generated/numpy.common_type.html#numpy.common_type">https://numpy.org/devdocs/reference/generated/numpy.common_type.html#numpy.common_type</a></li>
</ul>
</blockquote>
<h2 id="数据类型类np-dtype"><a href="#数据类型类np-dtype" class="headerlink" title="数据类型类np.dtype"></a>数据类型类<code>np.dtype</code></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dtype</span>(<span class="params">obj[,align,copy]</span>)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>numpy.dtype</code>类描述如何解释数组项对应内存块中字节</p>
<ul>
<li>数据大小</li>
<li>数据内存顺序：<em>little-endian</em>、<em>big-endian</em></li>
<li>数据类型<ul>
<li>结构化数据<ul>
<li>各字段名称</li>
<li>各字段数据类型</li>
<li>字段占用的内存数据块</li>
</ul>
</li>
<li>子数组<ul>
<li>形状</li>
<li>数据类型</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>需<code>numpy.dtype</code>实例作为参数的场合，大部分场景可用等价、
可转换为<code>dtype</code>实例的其他值代替</p>
<ul>
<li>python、numpy中预定义的标量类型、泛型类型</li>
<li>创建<code>dtype</code>实例类型的字符串、字典、列表</li>
<li>包含<code>dtype</code>属性的类、实例</li>
</ul>
</li>
</ul>
<h3 id="数据类型元素"><a href="#数据类型元素" class="headerlink" title="数据类型元素"></a>数据类型元素</h3><h4 id="类型类"><a href="#类型类" class="headerlink" title="类型类"></a>类型类</h4><ul>
<li><p>NumPy内置类型</p>
<ul>
<li>24中内置数组标量类型</li>
<li><p>泛型类型</p>
<p>|Generic类型|转换后类型|
|——-|——-|
|<code>number</code>,<code>inexact</code>,<code>floating</code>|<code>float_</code>|
|<code>complexfloating</code>|<code>complex_</code>|
|<code>integer</code>,<code>signedinteger</code>|<code>int_</code>|
|<code>unsignedinteger</code>|<code>uint</code>|
|<code>character</code>|<code>string</code>|
|<code>generic</code>,<code>flexible</code>|<code>void</code>|</p>
</li>
</ul>
</li>
<li><p>python内置类型，等效于相应数组标量</p>
<ul>
<li>转换规则同NumPy内置数组标量类型</li>
<li><p><code>None</code>：缺省值，转换为<code>float_</code></p>
<p>|Python内置类型|转换后类型|
|——-|——-|
|<code>int</code>|<code>int_</code>|
|<code>bool</code>|<code>bool_</code>|
|<code>float</code>|<code>float_</code>|
|<code>complex</code>|<code>complex_</code>|
|<code>bytes</code>|<code>bytes_</code>|
|<code>str</code>|<code>unicode_</code>|
|<code>unicode</code>|<code>unicode_</code>|
|<code>buffer</code>|<code>void</code>|
|Others|<code>object_</code>|</p>
</li>
</ul>
</li>
<li><p>带有<code>.dtype</code>属性的类型：直接访问、使用该属性</p>
<ul>
<li>该属性需返回可转换为<code>dtype</code>对象的内容</li>
</ul>
</li>
</ul>
<h4 id="可转换类型的字符串"><a href="#可转换类型的字符串" class="headerlink" title="可转换类型的字符串"></a>可转换类型的字符串</h4><ul>
<li><p><code>numpy.sctypeDict.keys()</code>中字符串</p>
</li>
<li><p><em>Array-protocal</em>类型字符串，详细参见NumPy数组标量类型</p>
<ul>
<li>首个字符指定数据类型</li>
<li>支持指定字节数的字符可在之后指定项目占用字节数<ul>
<li>定长类型只能指定满足平台要求的字节数</li>
<li>非定长类型可以指定任意字节数</li>
</ul>
</li>
</ul>
<p>|代码|类型|
|——-|——-|
|<code>&#39;?&#39;</code>|boolean|
|<code>&#39;b&#39;</code>|(signed) byte，等价于<code>&#39;i1&#39;</code>|
|<code>&#39;B&#39;</code>|unsigned byte，等价于<code>&#39;u1&#39;</code>|
|<code>&#39;i&#39;</code>|(signed) integer|
|<code>&#39;u&#39;</code>|unsigned integer|
|<code>&#39;f&#39;</code>|floating-point|
|<code>&#39;c&#39;</code>|complex-floating point|
|<code>&#39;m&#39;</code>|timedelta|
|<code>&#39;M&#39;</code>|datetime|
|<code>&#39;O&#39;</code>|(Python) objects|
|<code>&#39;S&#39;</code>/<code>&#39;a&#39;</code>|zero-terminated bytes (not recommended)|
|<code>&#39;U&#39;</code>|Unicode string|
|<code>&#39;V&#39;</code>|raw data (void)|</p>
</li>
</ul>
<h3 id="结构化数据类型"><a href="#结构化数据类型" class="headerlink" title="结构化数据类型"></a>结构化数据类型</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>format_parser(formats,names,titles[,aligned,byteorder])</code></td>
<td>创建数据类型</td>
</tr>
<tr>
<td><code>dtype(obj[,align,copy])</code></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>结构化数据类型</p>
<ul>
<li>包含一个或多个数据类型字段，每个字段有可用于访问的
名称</li>
<li>父数据类型应有足够大小包含所有字段</li>
<li>父数据类型几乎总是基于<code>void</code>类型</li>
</ul>
</li>
<li><p>仅包含不具名、单个基本类型时，数组结构会穿透</p>
<ul>
<li>字段不会被隐式分配名称</li>
<li>子数组shape会被添加至数组shape</li>
</ul>
</li>
</ul>
<h4 id="参数格式"><a href="#参数格式" class="headerlink" title="参数格式"></a>参数格式</h4><ul>
<li><p>可转换数据类型的字符串指定类型、shape</p>
<ul>
<li>依次包含四个部分<ul>
<li>字段shape</li>
<li>字节序描述符：<code>&lt;</code>、<code>&gt;</code>、<code>|</code></li>
<li>基本类型描述符</li>
<li>数据类型占用字节数<ul>
<li>对非变长数据类型，需按特定类型设置</li>
<li>对变长数据类型，指字段包含的数量</li>
</ul>
</li>
</ul>
</li>
<li>逗号作为分隔符，分隔多个字段</li>
<li>各字段名称只能为默认字段名称</li>
</ul>
<blockquote>
<ul>
<li>对变长类型，仅设置shape时，会将其视为bytes长度</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dt = np.dtype(<span class="string">&quot;i4, (2,3)f8, f4&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>元组指定字段类型、shape</p>
<ul>
<li>元组中各元素指定各字段名、数据类型、shape：
<code>(&lt;field_name&gt;, &lt;dtype&gt;, &lt;shape&gt;)</code><ul>
<li>若名称为<code>&#39;&#39;</code>空字符串，则分配标准字段名称</li>
</ul>
</li>
<li>可在列表中多个元组指定多个字段
<code>[(&lt;field_name&gt;, &lt;dtype&gt;, &lt;shape&gt;),...]</code></li>
<li>数据类型<code>dtype</code>可以<strong>嵌套其他数据类型</strong><ul>
<li>可转换类型字符串</li>
<li>元组/列表</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dt = np.dtype((<span class="string">&quot;U10&quot;</span>, (<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line">dt = np.dtype((<span class="string">&quot;i4, (2,3)f8, f4&quot;</span>, (<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">dt = np.dtype([(<span class="string">&quot;big&quot;</span>, <span class="string">&quot;&gt;i4&quot;</span>), (<span class="string">&quot;little&quot;</span>, <span class="string">&quot;&lt;i4&quot;</span>)])</span><br></pre></td></tr></table></figure>
</li>
<li><p>字典元素为名称、类型、shape列表</p>
<ul>
<li>类似<code>format_parser</code>函数，字典各键值对分别指定名称
列表、类型列表等：
<code>&#123;&quot;names&quot;:...,&quot;formats&quot;:...,&quot;offsets&quot;:...,&quot;titles&quot;:...,&quot;itemsize&quot;:...&#125;</code><ul>
<li><code>&quot;name&quot;</code>、<code>&quot;formats&quot;</code>为必须</li>
<li><code>&quot;itemsize&quot;</code>指定总大小，必须足够大</li>
</ul>
</li>
<li>分别指定各字段：<code>&quot;field_1&quot;:..., &quot;field_2&quot;:...</code><ul>
<li>不鼓励，容易与上一种方法冲突</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dt = np.dtype(&#123;</span><br><span class="line">	<span class="string">&quot;names&quot;</span>: [<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>],</span><br><span class="line">	<span class="string">&quot;formats&quot;</span>: [<span class="string">&quot;u1&quot;</span>, <span class="string">&quot;u1&quot;</span>, <span class="string">&quot;u1&quot;</span>, <span class="string">&quot;u1&quot;</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>解释基数据类型为结构化数据类型：
<code>(&lt;base_dtype&gt;, &lt;new_dtype&gt;)</code></p>
<ul>
<li>此方式使得<code>union</code>成为可能</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dt = np.dtype((<span class="string">&quot;i4&quot;</span>, [(<span class="string">&quot;r&quot;</span>, <span class="string">&quot;I1&quot;</span>), (<span class="string">&quot;g&quot;</span>, <span class="string">&quot;I1&quot;</span>), (<span class="string">&quot;b&quot;</span>, <span class="string">&quot;I1&quot;</span>), (<span class="string">&quot;a&quot;</span>, <span class="string">&quot;I1&quot;</span>)]))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li><p>描述数据类型</p>
<p>|属性|描述|
|——-|——-|
|<code>.type</code>|用于实例化此数据类型的数组标量类型|
|<code>.kind</code>|内置类型字符码|
|<code>.char</code>|内置类型字符码|
|<code>.num</code>|内置类型唯一编号|
|<code>.str</code>|类型标识字符串|</p>
</li>
<li><p>数据大小</p>
<p>|属性|描述|
|——-|——-|
|<code>.name</code>|数据类型位宽名称|
|<code>.itemsize</code>|元素大小|</p>
</li>
<li><p>字节顺序</p>
<p>|属性|描述|
|——-|——-|
|<code>.byteorder</code>|指示字节顺序|</p>
</li>
<li><p>字段描述</p>
<p>|属性|描述|
|——-|——-|
|<code>.fields</code>|命名字段字典|
|<code>.names</code>|字典名称列表|</p>
</li>
<li><p>数组类型（非结构化）描述</p>
<p>|属性|描述|
|——-|——-|
|<code>.subtype</code>|<code>(item_dtype,shape)</code>|
|<code>.shape</code>||</p>
</li>
<li><p>附加信息</p>
<p>|属性|描述|
|——-|——-|
|<code>.hasobject</code>|是否包含任何引用计数对象|
|<code>.flags</code>|数据类型解释标志|
|<code>.isbuiltin</code>|与内置数据类型相关|
|<code>.isnative</code>|字节顺序是否为平台原生|
|<code>.descr</code>|<code>__array_interface__</code>数据类型说明|
|<code>.alignment</code>|数据类型需要对齐的字节（编译器决定）|
|<code>.base</code>|基本元素的<code>dtype</code>|</p>
</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><p>更改字节顺序</p>
<p>|方法|描述|
|——-|——-|
|<code>.newbyteorder([new_order])</code>|创建不同字节顺序数据类型|</p>
</li>
<li><p>Pickle协议实现</p>
<p>|方法|描述|
|——-|——-|
|<code>.reduce()</code>|pickle化|
|<code>.setstate()</code>||</p>
</li>
</ul>
<h2 id="Datetime"><a href="#Datetime" class="headerlink" title="Datetime"></a>Datetime</h2><ul>
<li>Numpy种时间相关数据类型<ul>
<li>支持大量时间单位</li>
<li>基于POSIX时间存储日期时间</li>
<li>使用64位整形存储值，也由此决定了时间跨度</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.numpy.org.cn/reference/arrays/datetime.html">https://www.numpy.org.cn/reference/arrays/datetime.html</a></li>
</ul>
</blockquote>
<h3 id="np-datetime64"><a href="#np-datetime64" class="headerlink" title="np.datetime64"></a><code>np.datetime64</code></h3><ul>
<li><code>np.datetime64</code>表示单个时刻<ul>
<li>若两个日期时间具有不同单位，可能仍然代表相同时刻</li>
<li>从较大单位转换为较小单位是安全的投射</li>
</ul>
</li>
</ul>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ul>
<li><p>创建规则</p>
<ul>
<li>内部存储单元自动从字符串形式中选择单位</li>
<li>接受<code>&quot;NAT&quot;</code>字符串，表示“非时间”值</li>
<li>可以强制使用特定单位</li>
</ul>
</li>
<li><p>基本方法：ISO 8601格式的字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.datetime64(<span class="string">&quot;2020-05-23T14:23&quot;</span>)</span><br><span class="line">np.datetime64(<span class="string">&quot;2020-05-23T14:23&quot;</span>, <span class="string">&quot;D&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>从字符串创建日期时间数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.array([<span class="string">&quot;2020-01-23&quot;</span>, <span class="string">&quot;2020-04-23&quot;</span>], dtype=<span class="string">&quot;datetime64&quot;</span>)</span><br><span class="line">np.array([<span class="string">&quot;2020-01-23&quot;</span>, <span class="string">&quot;2020-04-23&quot;</span>], dtype=<span class="string">&quot;datetime64[D]&quot;</span>)</span><br><span class="line">np.arange(<span class="string">&quot;2020-01-01&quot;</span>, <span class="string">&quot;2020-05-03&quot;</span>, dtype=<span class="string">&quot;datetime64[D]&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<ul>
<li><code>np.datetime64</code>为向后兼容，仍然支持解析时区</li>
</ul>
</blockquote>
<h3 id="np-timedelta64"><a href="#np-timedelta64" class="headerlink" title="np.timedelta64"></a><code>np.timedelta64</code></h3><ul>
<li><code>np.timedelta64</code>：时间增量</li>
</ul>
<blockquote>
<ul>
<li><code>np.timedelta64</code>是对<code>np.datetime64</code>的补充，弥补Numpy对
  物理量的支持</li>
</ul>
</blockquote>
<h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><ul>
<li><p>创建规则</p>
<ul>
<li>接受<code>&quot;NAT&quot;</code>字符串，表示“非时间”值数字</li>
<li>可以强制使用特定单位</li>
</ul>
</li>
<li><p>直接从数字创建</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.timedelta64(<span class="number">100</span>, <span class="string">&quot;D&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>从已有<code>np.timedelta64</code>创建，指定单位</p>
<ul>
<li>注意，不能将月份及以上转换为日，因为不同时点进制不同</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.timedelta(a, <span class="string">&quot;M&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><ul>
<li><p><code>np.datetime64</code>可以和<code>np.timedelta64</code>联合使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.datetime64(<span class="string">&quot;2020-05-14&quot;</span>) - np.datetime64(<span class="string">&quot;2020-01-12&quot;</span>)</span><br><span class="line">np.datetime64(<span class="string">&quot;2020-05-14&quot;</span>) + np.timedelta64(<span class="number">2</span>, <span class="string">&quot;D&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>np.busdaycalendar(weekmask,holidays)</code></td>
<td>返回存储有效工作日对象</td>
</tr>
<tr>
<td><code>np.busday_offset(date,offset[,roll,weekmask,holidays,busdaycal,out])</code></td>
<td>工作日offset</td>
</tr>
<tr>
<td><code>np.is_busday(date[,weekmask,holidays,busdaycal,out])</code></td>
<td>判断是否是工作日</td>
</tr>
<tr>
<td><code>np.busday_count(begindates,enddates[,weekmask,holidays,busdaycal,out])</code></td>
<td>指定天数</td>
</tr>
<tr>
<td><code>np.datetime_as_string(arr[,unit,timezone,...])</code></td>
<td>转换为字符串数组</td>
</tr>
<tr>
<td><code>np.datetime_date(dtype,/)</code></td>
<td>获取日期、时间类型步长信息</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>np.busday_offset</code>中<ul>
<li><code>roll</code>缺省为<code>&quot;raise&quot;</code>，要求<code>date</code>本身为工作日</li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-01-31T07:49:17.000Z" title="1/31/2021, 3:49:17 PM">2021-01-31</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-01-31T07:49:17.000Z" title="1/31/2021, 3:49:17 PM">2021-01-31</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Numpy/">Numpy</a></span><span class="level-item">17 minutes read (About 2611 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Numpy/ndarray.html">NDArray</a></h1><div class="content"><h2 id="NDArray"><a href="#NDArray" class="headerlink" title="NDArray"></a>NDArray</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ndarray</span>(<span class="params">shape[,dtype,buffer,offset]</span>)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>ndarray</code>：具有相同类型、大小（固定大小）项目的多维容器</p>
<ul>
<li><code>ndarray</code>由计算中内存连续的一维段组成，并与将<code>N</code>个整数
映射到块中项的位置的索引方案相结合</li>
<li>可以共享相同数据段，即可以是其他数据区的视图<ul>
<li>另一个<code>ndarray</code></li>
<li>实现<code>buffer</code>的对象</li>
</ul>
</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li><code>shape</code>：指定尺寸、项目数量</li>
<li><code>dtype</code>（<em>data-type object</em>）：指定项目类型</li>
<li><code>strides</code>：存储各维度步幅，用于计算连续数据段中偏移</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.numpy.org.cn/reference/arrays/ndarray.html">https://www.numpy.org.cn/reference/arrays/ndarray.html</a><a href="/https://www.numpy.org.cn/reference/arrays/ndarray.html">/https://www.numpy.org.cn/reference/arrays/ndarray.html</a></p>
<h3 id="Broadcast-广播规则"><a href="#Broadcast-广播规则" class="headerlink" title="Broadcast 广播规则"></a>Broadcast 广播规则</h3><p>Broadcasting：4条广播规则用于处理不同shape的数组</p>
<ul>
<li>非维数最大者在<code>shape</code>前用<code>1</code>补足</li>
<li>输出的<code>shape</code>中各维度是各输入对应维度最大值</li>
<li>各输入的维度同输出对应维度相同、或为<code>1</code></li>
<li>输入中维度为<code>1</code>者，对应的（首个）数据被用于沿该轴的
所有计算
（即对应的<code>stride</code>为<code>0</code>，<em>ufunc</em>不step along该维度）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shape(3, 2, 2, 1) + shape(1, 3)</span><br><span class="line">	-&gt; shape(3, 2, 2, 1) + shape(1, 1, 1, 3)</span><br><span class="line">	-&gt; shape(3, 2, 2, 3) + shape(1, 1, 2, 3)</span><br><span class="line">	-&gt; shape(3, 2, 2, 3) + shape(1, 2, 2, 3)</span><br><span class="line">	-&gt; shape(3, 2, 2, 3) + shape(3, 2, 2, 3)</span><br></pre></td></tr></table></figure>
<h2 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h2><h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ndarray.flags</code></td>
<td>有关数组内存布局的信息</td>
</tr>
<tr>
<td><code>ndarray.shape</code></td>
<td>数组维度（元组）</td>
</tr>
<tr>
<td><code>ndarray.strides</code></td>
<td>遍历数组时每个维度中的字节数量（元组）</td>
</tr>
<tr>
<td><code>ndarray.ndim</code></td>
<td>数组维数</td>
</tr>
<tr>
<td><code>ndarray.data</code></td>
<td>Python缓冲区对象指向数组的数据的开头</td>
</tr>
<tr>
<td><code>ndarray.size</code></td>
<td>数组中的元素数</td>
</tr>
<tr>
<td><code>ndarray.itemsize</code></td>
<td>数组元素的长度，以字节为单位</td>
</tr>
<tr>
<td><code>ndarray.nbytes</code></td>
<td>数组元素消耗的总字节数</td>
</tr>
<tr>
<td><code>ndarray.base</code></td>
<td>如果内存来自其他对象，则为基础对象</td>
</tr>
</tbody>
</table>
</div>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.numpy.org.cn/reference/arrays/dtypes.html"><code>ndarray.dtype</code></a></td>
<td>元素数据类型</td>
</tr>
</tbody>
</table>
</div>
<h3 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h3><div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ndarray.T</code></td>
<td>转置</td>
</tr>
<tr>
<td><code>ndarray.real</code></td>
<td>实数部分</td>
</tr>
<tr>
<td><code>ndarray.imag</code></td>
<td>虚数部分</td>
</tr>
<tr>
<td><code>ndarray.flat</code></td>
<td>数组的一维迭代器</td>
</tr>
</tbody>
</table>
</div>
<h3 id="数组接口"><a href="#数组接口" class="headerlink" title="数组接口"></a>数组接口</h3><div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__array_interface__</code></td>
<td>数组接口python端</td>
</tr>
<tr>
<td><code>__array_struct__</code></td>
<td>数组接口C语言端</td>
</tr>
</tbody>
</table>
</div>
<h3 id="ctypes外部函数接口"><a href="#ctypes外部函数接口" class="headerlink" title="ctypes外部函数接口"></a><code>ctypes</code>外部函数接口</h3><div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ndarray.ctypes</code></td>
<td>简化数组和<code>ctypes</code>模块交互的对象</td>
</tr>
</tbody>
</table>
</div>
<h2 id="np-nditer"><a href="#np-nditer" class="headerlink" title="np.nditer"></a><code>np.nditer</code></h2><ul>
<li><p><code>ndarray</code>对象的默认迭代器是序列类型的默认迭代器</p>
<ul>
<li><p>即以对象本身作为迭代器时，默认行为类似</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(X.shape[<span class="number">0</span>]):</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>nditer(op[,flags,op_flags,...])</code></td>
<td>高性能迭代器</td>
<td>无</td>
</tr>
<tr>
<td><code>nested_iters(op,axes[,flags,op_flags,...])</code></td>
<td>在多组轴上嵌套创建<code>nditer</code>迭代器</td>
<td>无</td>
</tr>
<tr>
<td><code>ndenumerate(arr)</code></td>
<td><code>(idx,val)</code>迭代器</td>
<td>无</td>
</tr>
<tr>
<td><code>lib.Arrayterator(var[,buf_size])</code></td>
<td>适合大数组的缓冲迭代</td>
</tr>
<tr>
<td><code>flat</code></td>
<td>无</td>
<td>返回<code>np.flatiter</code>迭代器</td>
</tr>
<tr>
<td><code>ndindex(*shape)</code></td>
<td>迭代shape对应数组的索引</td>
<td>无</td>
</tr>
</tbody>
</table>
</div>
<h3 id="np-nditer-1"><a href="#np-nditer-1" class="headerlink" title="np.nditer"></a><code>np.nditer</code></h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class np.nditer(</span><br><span class="line"><span class="code">	op,</span></span><br><span class="line"><span class="code">	flags=None,</span></span><br><span class="line"><span class="code">	op_flags=None,</span></span><br><span class="line"><span class="code">	op_dtypes=None,</span></span><br><span class="line"><span class="code">	order=&#x27;K&#x27;/&#x27;C&#x27;/&#x27;F&#x27;/&#x27;A&#x27;,</span></span><br><span class="line"><span class="code">	casting=&#x27;safe&#x27;,</span></span><br><span class="line"><span class="code">	op_axes=None,</span></span><br><span class="line"><span class="code">	itershape=None,</span></span><br><span class="line"><span class="code">	buffersize=0</span></span><br><span class="line"><span class="code">)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>迭代方式</p>
<ul>
<li>通过标准python接口迭代数组中各数组标量元素</li>
<li>显式使用迭代器本身，访问其属性、方法<ul>
<li><code>np.nditer[0]</code>访问当前迭代的结果</li>
<li><code>np.iternext()</code>获取下个迭代对象</li>
</ul>
</li>
</ul>
</li>
<li><p>包含特殊属性、方法获取额外信息（可能需设置迭代标志）</p>
<ul>
<li>跟踪索引：获取索引<code>np.nditer.index</code>、
<code>np.nditer.multi_index</code></li>
<li>手动迭代<code>np.nditer.iternext()</code>得到下个
<code>np.nditer</code>对象</li>
<li>获取操作数<code>np.nditer.operands</code>：迭代器关闭之后
将无法访问，需要在关闭前获得引用</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.numpy.org.cn/reference/arrays/nditer.html">https://www.numpy.org.cn/reference/arrays/nditer.html</a></p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li><p><code>flags</code>：迭代器标志</p>
<ul>
<li><code>buffered</code>：允许缓冲<ul>
<li>增大迭代器提供给循环内部的数据块</li>
<li>减少开销、提升性能</li>
</ul>
</li>
<li><code>c_index</code>：track C顺序索引</li>
<li><code>f_index</code>：track C顺序索引</li>
<li><code>multi_index</code>：track 多维索引</li>
<li><code>common_dtype</code>：将所有操作数转换为公共类型<ul>
<li>需设置<code>copying</code>或<code>buffered</code></li>
</ul>
</li>
<li><code>copy_if_overlap</code>：迭代器决定是否读操作数覆盖写
操作数，还是使用临时副本避免覆盖</li>
<li><code>delay_bufalloc</code>：延迟缓冲区设置直至<code>reset()</code>函数
调用<ul>
<li>允许<code>allocate</code>操作数在其值被复制到缓冲区前初始化</li>
</ul>
</li>
<li><code>external_loop</code>：迭代一维数组而不是零维数组标量<ul>
<li>利于矢量化操作</li>
<li>返回的循环块与迭代顺序相关</li>
</ul>
</li>
<li><code>grow_inner</code>：允许迭代数组大小大于缓冲区大小<ul>
<li><code>buffered</code>、<code>external_loop</code>均设置情况下</li>
</ul>
</li>
<li><code>ranged</code>：</li>
<li><code>refs_ok</code>：允许迭代引用类型，如<code>object</code>数组</li>
<li><code>reduce_ok</code>：允许迭代广播后的<code>readwrite</code>操作数
（也即<code>reduction</code>操作数）</li>
<li><code>zerosize_ok</code>：允许迭代大小为0</li>
</ul>
</li>
<li><p><code>op_flags</code></p>
<ul>
<li><code>readonly</code>：操作数只能被读取</li>
<li><code>readwrite</code>：操作数能被读写</li>
<li><code>writeonly</code>：操作只能被写入</li>
<li><code>no_broadcast</code>：禁止操作数被广播</li>
<li><code>contig</code>：强制操作数数据连续</li>
<li><code>aligned</code>：强制操作数数据对齐</li>
<li><code>nbo</code>：强值操作数数据按原生字节序</li>
<li><code>copy</code>：允许临时只读拷贝</li>
<li><code>updateifcopy</code>：允许临时读写拷贝</li>
<li><code>allocate</code>：允许数组分配若<code>op</code>中包含<code>None</code><ul>
<li>迭代器为<code>None</code>分配空间，不会为非空操作数分配
空间，即使是广播后赋值空间不足</li>
<li>操作数中<code>op</code>中<code>None</code>对应<code>op_flags</code>缺省为
<code>[&quot;allocate&quot;, &quot;writeonly&quot;]</code></li>
</ul>
</li>
<li><code>no_subtype</code>：阻止<code>allocate</code>操作数使用子类型</li>
<li><code>arraymask</code>：表明对应操作数为mask数组<ul>
<li>用于从设置有<code>writemasked</code>标志的操作数中选择写回
部分</li>
</ul>
</li>
<li><code>writemasked</code>：只有<code>arraymask</code>操作数选择的元素被写回</li>
<li><code>overlap_assume_elementwise</code>：标记操作数只能按照迭代
顺序获取<ul>
<li>允许在<code>copy_if_overlap</code>设置的场合，更保守的拷贝</li>
</ul>
</li>
</ul>
</li>
<li><p><code>op_dtypes</code>：操作数需求的数据类型</p>
<ul>
<li>在循环内对单个值进行数据类型转换效率低</li>
<li>迭代器以缓冲、复制整体进行类型转换提高效率</li>
<li>需要同时设置<code>&quot;copy&quot;</code>或<code>&quot;buffered&quot;</code>，否则因无法复制、
缓冲报错（类型不同时）
（类型转换不修改原数组值，需要额外空间存储转换后值）</li>
</ul>
</li>
<li><p><code>order</code>：迭代顺序</p>
<ul>
<li><code>C</code>/<code>F</code>：C风格、Fortran风格</li>
<li><code>A</code>：若所有数组均为Fortran风格则为Fortran风格，否则
为C风格</li>
<li><code>K</code>：尽量贴近内存布局</li>
</ul>
<blockquote>
<ul>
<li><code>allocate</code>操作数的内存布局会兼容此参数设置</li>
</ul>
</blockquote>
</li>
<li><p><code>casting</code>：指明在拷贝、缓冲时允许的数据类型转换规则
（包括读取、写回数组时可能的类型转换）</p>
<ul>
<li><code>no</code>：不允许任何类型转换</li>
<li><code>equiv</code>：仅允许字节顺序改变</li>
<li><code>safe</code>：仅允许可保证数据精度的类型转换</li>
<li><code>same_kind</code>：只能允许<code>safe</code>或同类别类型转换</li>
<li><code>unsafe</code>：允许所有类型转换</li>
</ul>
</li>
<li><p><code>op_axes</code>：设置迭代器维度到操作数维度的映射</p>
<ul>
<li>需为每个操作数设置维度映射</li>
</ul>
</li>
<li><p><code>itershape</code>：设置迭代器的shape</p>
</li>
<li><p><code>buffersize</code>：设置缓冲区大小</p>
<ul>
<li><code>buffered</code>设置的情况下</li>
<li><code>0</code>表示默认大小</li>
</ul>
</li>
</ul>
<h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><ul>
<li><p>控制迭代顺序</p>
<ul>
<li>设置<code>order</code>参数</li>
<li>缺省按照<strong>内存布局</strong>迭代<ul>
<li>提高效率</li>
<li>适合不关心迭代顺序场合</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 二者迭代顺序完全相同</span></span><br><span class="line">np.nditer(X, order=<span class="string">&quot;K&quot;</span>)</span><br><span class="line">np.nditer(X.T)</span><br><span class="line"><span class="comment"># 指定按C或Fortran顺序</span></span><br><span class="line">np.nditer(X, order=<span class="string">&quot;C&quot;</span>)</span><br><span class="line">np.nditer(X, order=<span class="string">&quot;F&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改数组值</p>
<ul>
<li>设置<code>writeonly</code>、<code>readwrite</code><ul>
<li>生成可写的缓冲区数组，并在迭代完成后复制回原始
数组</li>
<li>发出迭代结束信号，将缓冲区数据复制回原始数组<ul>
<li>支持<code>with</code>语句上下文管理</li>
<li>迭代完成后手动<code>.close()</code></li>
</ul>
</li>
</ul>
</li>
<li><p>可设置<code>allocate</code>标志支持为空操作数分配空间</p>
<ul>
<li>对<code>None</code>参数<code>op</code>，其<code>op_flags</code>缺省设置为
<code>[&quot;allocate&quot;, &quot;readwrite&quot;]</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> np.nditer(X, op_flags=[<span class="string">&quot;readwrite&quot;</span>]) <span class="keyword">as</span> it:</span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">		x[...] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>迭代一维数组而不是数组标量</p>
<ul>
<li>缺省返回最低维维度长的一维数组</li>
<li>可以通过设置<code>buffered</code>扩大返回的数组长度<ul>
<li><code>buffersize</code>设置<code>buffered</code>大小，可用此参数决定
返回的数组长度</li>
<li>返回数组长度完全由<code>buffersize</code>决定，与数组shape
无关<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(30).reshape(5,6)</span><br><span class="line">for x in np.nditer(a, flags=[&quot;external<span class="emphasis">_loop&quot;, &quot;buffered&quot;], buffersize=11):</span></span><br><span class="line"><span class="emphasis">	print(x, type(x))</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>跟踪、获取索引</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">it = np.nditer(a, flags=[<span class="string">&quot;multi_index&quot;</span>])</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> it.finished:</span><br><span class="line">	<span class="built_in">print</span>(it[<span class="number">0</span>], it.multi_index)</span><br><span class="line">	it.iternext()</span><br></pre></td></tr></table></figure>
</li>
<li><p>以特定数据类型迭代</p>
<ul>
<li><code>op_dtypes</code>参数设置迭代返回的数据类型</li>
<li>需同时设置<code>&quot;copy&quot;</code>或<code>&quot;buffered&quot;</code>字段</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a, op_dtypes=[<span class="string">&quot;complex128&quot;</span>]):</span><br><span class="line">	<span class="built_in">print</span>(np.sqrt(x), end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代器分配空间</p>
<ul>
<li><code>allocate</code>标志表示允许为操作数分配空间，即允许空
操作数</li>
<li>若分配空间初值被使用，注意迭代前初始化
（如<em>reduction</em>迭代场合）</li>
</ul>
<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def square(a, ret=None):</span><br><span class="line"><span class="code">	with np.nditer([a, ret],</span></span><br><span class="line"><span class="code">		op_flags=[[&quot;readonly&quot;], [&quot;writeonly&quot;, &quot;allocate&quot;]]</span></span><br><span class="line"><span class="code">	) as it:</span></span><br><span class="line"><span class="code">		for x, y in it:</span></span><br><span class="line"><span class="code">			y[...] = x**2</span></span><br><span class="line"><span class="code">	return ret</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>外积（笛卡尔积）迭代</p>
<ul>
<li><p>设置<code>op_axes</code>参数指定各操作数<code>op</code>各维度位置、顺序</p>
<ul>
<li>迭代器负责将迭代器维度映射回各操作数维度</li>
<li>类似于手动自由广播</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定维度位置、顺序</span></span><br><span class="line">it = np.nditer([a,b,<span class="literal">None</span>], flags=[<span class="string">&quot;external_loop&quot;</span>],</span><br><span class="line">		op_axes=[[<span class="number">0</span>,-<span class="number">1</span>,-<span class="number">1</span>], [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],<span class="literal">None</span>])</span><br><span class="line"><span class="comment"># 迭代得到外积</span></span><br><span class="line"><span class="keyword">with</span> it:</span><br><span class="line">	<span class="keyword">for</span> x,y,z <span class="keyword">in</span> it:</span><br><span class="line">		z[...] = x*y</span><br><span class="line">	result = it.operands[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><em>Reduction</em>迭代</p>
<ul>
<li>触发条件：<strong>可写的</strong>操作数中元素数量<strong>小于</strong>迭代空间<ul>
<li><code>&quot;reduce_ok&quot;</code>需被设置</li>
<li><code>&quot;readwrite&quot;</code>而不是<code>&quot;writeonly&quot;</code>被设置，即使循环
内部未读</li>
<li>暗含<code>&quot;no_broadcast&quot;</code>必然不被设置</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ret = np.array([<span class="number">0</span>])</span><br><span class="line"><span class="keyword">with</span> np.nditer([a,b], flags=[<span class="string">&quot;reduce_ok&quot;</span>, <span class="string">&quot;external_loop&quot;</span>],</span><br><span class="line">		op_flags=[[<span class="string">&quot;readonly&quot;</span>], [<span class="string">&quot;readwrite&quot;</span>]]) <span class="keyword">as</span> it:</span><br><span class="line">	<span class="keyword">for</span> x,y <span class="keyword">in</span> it:</span><br><span class="line">		y[...] += x</span><br><span class="line"><span class="comment"># 或者同样设置`allocate`标志，并且在迭代器内设置初始值</span></span><br><span class="line">np.nditer([a, <span class="literal">None</span>], flags=[<span class="string">&quot;reduce_ok&quot;</span>, <span class="string">&quot;external_loop&quot;</span>],</span><br><span class="line">		op_flags=[[<span class="string">&quot;readonly&quot;</span>], [<span class="string">&quot;readwrite&quot;</span>, <span class="string">&quot;allocate&quot;</span>]],</span><br><span class="line">		op_axes=[<span class="literal">None</span>, [<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>]])</span><br><span class="line"><span class="keyword">with</span> it:</span><br><span class="line">	<span class="comment"># 设置初始值</span></span><br><span class="line">	it.operands[<span class="number">1</span>][...] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> x, y <span class="keyword">in</span> it:</span><br><span class="line">		y[...] += x</span><br><span class="line">	result = it.operands[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="nested-iters"><a href="#nested-iters" class="headerlink" title="nested_iters"></a><code>nested_iters</code></h3><ul>
<li><p><code>nested_iters</code>：按维度嵌套<code>nditer</code></p>
<ul>
<li>迭代参数类似<code>nditer</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i, j = np.nested_iters(X, flags=[<span class="string">&quot;multi_index&quot;</span>])</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> i:</span><br><span class="line">	<span class="built_in">print</span>(i.multi_index)</span><br><span class="line">	<span class="keyword">for</span> y <span class="keyword">in</span> j:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;&quot;</span>, j.multi_index, y)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="flat迭代器"><a href="#flat迭代器" class="headerlink" title="flat迭代器"></a><code>flat</code>迭代器</h3><ul>
<li><code>X.flat</code>：返回C-contiguous风格迭代器<code>np.flatiter</code><ul>
<li>支持切片、高级索引</li>
<li>实质上是数组的一维视图</li>
</ul>
</li>
</ul>
<h3 id="np-ndenumerate"><a href="#np-ndenumerate" class="headerlink" title="np.ndenumerate"></a><code>np.ndenumerate</code></h3><ul>
<li><p><code>np.ndenumerate</code>：多维索引迭代器，返回多维索引、值元组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> multi_idx, val <span class="keyword">in</span> np.ndenumerate(X):</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="np-broadcast"><a href="#np-broadcast" class="headerlink" title="np.broadcast"></a><code>np.broadcast</code></h3><ul>
<li><p><code>np.broadcast</code>：返回（多个）数组广播结果元组的迭代器</p>
<ul>
<li>类似广播后<em>zip</em>，即先将数组广播，然后将广播后元素
组合成元组作为迭代器中元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> np.broadcast([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]], [<span class="number">5</span>,<span class="number">6</span>]):</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/tags/Numpy/page/0/">Previous</a></div><div class="pagination-next"><a href="/tags/Numpy/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/tags/Numpy/">1</a></li><li><a class="pagination-link" href="/tags/Numpy/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">36</span></span></a><ul><li><a class="level is-mobile" href="/categories/Algorithm/Data-Structure/"><span class="level-start"><span class="level-item">Data Structure</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Heuristic/"><span class="level-start"><span class="level-item">Heuristic</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Issue/"><span class="level-start"><span class="level-item">Issue</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Problem/"><span class="level-start"><span class="level-item">Problem</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Specification/"><span class="level-start"><span class="level-item">Specification</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/C-C/"><span class="level-start"><span class="level-item">C/C++</span></span><span class="level-end"><span class="level-item tag">34</span></span></a><ul><li><a class="level is-mobile" href="/categories/C-C/Cppref/"><span class="level-start"><span class="level-item">Cppref</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/Cstd/"><span class="level-start"><span class="level-item">Cstd</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/MPI/"><span class="level-start"><span class="level-item">MPI</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/STL/"><span class="level-start"><span class="level-item">STL</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/CS/"><span class="level-start"><span class="level-item">CS</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/CS/Character/"><span class="level-start"><span class="level-item">Character</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Parallel/"><span class="level-start"><span class="level-item">Parallel</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Program-Design/"><span class="level-start"><span class="level-item">Program Design</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Storage/"><span class="level-start"><span class="level-item">Storage</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Daily-Life/"><span class="level-start"><span class="level-item">Daily Life</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/Daily-Life/Maxism/"><span class="level-start"><span class="level-item">Maxism</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Database/"><span class="level-start"><span class="level-item">Database</span></span><span class="level-end"><span class="level-item tag">27</span></span></a><ul><li><a class="level is-mobile" href="/categories/Database/Hadoop/"><span class="level-start"><span class="level-item">Hadoop</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Database/SQL-DB/"><span class="level-start"><span class="level-item">SQL DB</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Database/Spark/"><span class="level-start"><span class="level-item">Spark</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/Scala/"><span class="level-start"><span class="level-item">Scala</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">42</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Bash-Programming/"><span class="level-start"><span class="level-item">Bash Programming</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Configuration/"><span class="level-start"><span class="level-item">Configuration</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/File-System/"><span class="level-start"><span class="level-item">File System</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/IPC/"><span class="level-start"><span class="level-item">IPC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Process-Schedual/"><span class="level-start"><span class="level-item">Process Schedual</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Shell/"><span class="level-start"><span class="level-item">Shell</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Tool/"><span class="level-start"><span class="level-item">Tool</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Tool/Vi/"><span class="level-start"><span class="level-item">Vi</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Model/"><span class="level-start"><span class="level-item">ML Model</span></span><span class="level-end"><span class="level-item tag">21</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Model/Linear-Model/"><span class="level-start"><span class="level-item">Linear Model</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Model-Component/"><span class="level-start"><span class="level-item">Model Component</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Nolinear-Model/"><span class="level-start"><span class="level-item">Nolinear Model</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Unsupervised-Model/"><span class="level-start"><span class="level-item">Unsupervised Model</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/"><span class="level-start"><span class="level-item">ML Specification</span></span><span class="level-end"><span class="level-item tag">17</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/Click-Through-Rate/"><span class="level-start"><span class="level-item">Click Through Rate</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/Click-Through-Rate/Recommandation-System/"><span class="level-start"><span class="level-item">Recommandation System</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/Computer-Vision/"><span class="level-start"><span class="level-item">Computer Vision</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Specification/FinTech/"><span class="level-start"><span class="level-item">FinTech</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/FinTech/Risk-Control/"><span class="level-start"><span class="level-item">Risk Control</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/Graph-Analysis/"><span class="level-start"><span class="level-item">Graph Analysis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Specification/NLP/"><span class="level-start"><span class="level-item">NLP</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Technique/"><span class="level-start"><span class="level-item">ML Technique</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Technique/Feature-Engineering/"><span class="level-start"><span class="level-item">Feature Engineering</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Technique/Neural-Network/"><span class="level-start"><span class="level-item">Neural Network</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Theory/"><span class="level-start"><span class="level-item">ML Theory</span></span><span class="level-end"><span class="level-item tag">11</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Theory/Loss/"><span class="level-start"><span class="level-item">Loss</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Theory/Model-Enhencement/"><span class="level-start"><span class="level-item">Model Enhencement</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Theory/Optimization/"><span class="level-start"><span class="level-item">Optimization</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Algebra/"><span class="level-start"><span class="level-item">Math Algebra</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Algebra/Linear-Algebra/"><span class="level-start"><span class="level-item">Linear Algebra</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Algebra/Universal-Algebra/"><span class="level-start"><span class="level-item">Universal Algebra</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Analysis/"><span class="level-start"><span class="level-item">Math Analysis</span></span><span class="level-end"><span class="level-item tag">23</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Analysis/Fourier-Analysis/"><span class="level-start"><span class="level-item">Fourier Analysis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Functional-Analysis/"><span class="level-start"><span class="level-item">Functional Analysis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Optimization/"><span class="level-start"><span class="level-item">Optimization</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Real-Analysis/"><span class="level-start"><span class="level-item">Real Analysis</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Mixin/"><span class="level-start"><span class="level-item">Math Mixin</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Mixin/Statistics/"><span class="level-start"><span class="level-item">Statistics</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Mixin/Time-Series/"><span class="level-start"><span class="level-item">Time Series</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Probability/"><span class="level-start"><span class="level-item">Probability</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">89</span></span></a><ul><li><a class="level is-mobile" href="/categories/Python/Cookbook/"><span class="level-start"><span class="level-item">Cookbook</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Jupyter/"><span class="level-start"><span class="level-item">Jupyter</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Keras/"><span class="level-start"><span class="level-item">Keras</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Matplotlib/"><span class="level-start"><span class="level-item">Matplotlib</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Numpy/"><span class="level-start"><span class="level-item">Numpy</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Pandas/"><span class="level-start"><span class="level-item">Pandas</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Py3Ref/"><span class="level-start"><span class="level-item">Py3Ref</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Py3std/"><span class="level-start"><span class="level-item">Py3std</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Pywin32/"><span class="level-start"><span class="level-item">Pywin32</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Readme/"><span class="level-start"><span class="level-item">Readme</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/TensorFlow/"><span class="level-start"><span class="level-item">TensorFlow</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Twists/"><span class="level-start"><span class="level-item">Twists</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/RLang/"><span class="level-start"><span class="level-item">RLang</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Rust/"><span class="level-start"><span class="level-item">Rust</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Set/"><span class="level-start"><span class="level-item">Set</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/"><span class="level-start"><span class="level-item">Tool</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/Tool/Editor/"><span class="level-start"><span class="level-item">Editor</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Markup-Language/"><span class="level-start"><span class="level-item">Markup Language</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Web-Browser/"><span class="level-start"><span class="level-item">Web Browser</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Windows/"><span class="level-start"><span class="level-item">Windows</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/Web/CSS/"><span class="level-start"><span class="level-item">CSS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/NPM/"><span class="level-start"><span class="level-item">NPM</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/Proxy/"><span class="level-start"><span class="level-item">Proxy</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/Thrift/"><span class="level-start"><span class="level-item">Thrift</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://octodex.github.com/images/hula_loop_octodex03.gif" alt="UBeaRLy"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">UBeaRLy</p><p class="is-size-6 is-block">Protector of Proxy</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">392</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">93</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">522</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/xyy15926" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/xyy15926"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-04T15:07:54.896Z">2021-08-04</time></p><p class="title"><a href="/uncategorized/README.html"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-03T07:46:51.000Z">2021-08-03</time></p><p class="title"><a href="/Web/NPM/hexo_config.html">Hexo 建站</a></p><p class="categories"><a href="/categories/Web/">Web</a> / <a href="/categories/Web/NPM/">NPM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-03T02:32:45.000Z">2021-08-03</time></p><p class="title"><a href="/Web/NPM/config.html">NPM 总述</a></p><p class="categories"><a href="/categories/Web/">Web</a> / <a href="/categories/Web/NPM/">NPM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-02T08:11:11.000Z">2021-08-02</time></p><p class="title"><a href="/Python/Py3std/internet_data.html">互联网数据</a></p><p class="categories"><a href="/categories/Python/">Python</a> / <a href="/categories/Python/Py3std/">Py3std</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-29T13:55:00.000Z">2021-07-29</time></p><p class="title"><a href="/Linux/Shell/sh_apps.html">Shell 应用程序</a></p><p class="categories"><a href="/categories/Linux/">Linux</a> / <a href="/categories/Linux/Shell/">Shell</a></p></div></article></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">Advertisement</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5385776267343559" data-ad-slot="6371777973" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a><p class="is-size-7"><span>&copy; 2021 UBeaRLy</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/xyy15926/proxy"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>