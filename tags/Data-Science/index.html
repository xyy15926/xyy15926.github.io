<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Tag: Data Science - UBeaRLy</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="UBeaRLy&#039;s Proxy"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="UBeaRLy&#039;s Proxy"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="UBeaRLy"><meta property="og:url" content="https://xyy15926.github.io/"><meta property="og:site_name" content="UBeaRLy"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://xyy15926.github.io/img/og_image.png"><meta property="article:author" content="UBeaRLy"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xyy15926.github.io"},"headline":"UBeaRLy","image":["https://xyy15926.github.io/img/og_image.png"],"author":{"@type":"Person","name":"UBeaRLy"},"publisher":{"@type":"Organization","name":"UBeaRLy","logo":{"@type":"ImageObject","url":"https://xyy15926.github.io/img/logo.svg"}},"description":""}</script><link rel="alternate" href="/atom.xml" title="UBeaRLy" type="application/atom+xml"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/darcula.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><script data-ad-client="ca-pub-5385776267343559" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><meta name="follow_it-verification-code" content="SVBypAPPHxjjr7Y4hHfn"><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="UBeaRLy" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Visit on GitHub" href="https://github.com/xyy15926/proxy"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">Tags</a></li><li class="is-active"><a href="#" aria-current="page">Data Science</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-03-14T09:52:56.000Z" title="3/14/2021, 5:52:56 PM">2021-03-14</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-03-14T09:52:56.000Z" title="3/14/2021, 5:52:56 PM">2021-03-14</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Numpy/">Numpy</a></span><span class="level-item">6 minutes read (About 907 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Numpy/ndarray_sci.html">NDArray 科学计算</a></h1><div class="content"><h2 id="NumPy-Numeric"><a href="#NumPy-Numeric" class="headerlink" title="NumPy Numeric"></a>NumPy Numeric</h2><h3 id="矩阵、向量乘积"><a href="#矩阵、向量乘积" class="headerlink" title="矩阵、向量乘积"></a>矩阵、向量乘积</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dot(a,b[,out])</code></td>
<td><code>a</code>最后轴与<code>b</code>倒数第二轴的点积，即shape满足线代要求</td>
</tr>
<tr>
<td><code>inner(a,b[,out])</code></td>
<td><code>a</code>最后轴与<code>b</code>最后轴的点积</td>
</tr>
<tr>
<td><code>vdot(a,b)</code></td>
<td>向量点积，多维将被展平</td>
</tr>
<tr>
<td><code>outer(a,b[,out])</code></td>
<td>向量外积，多维将被展平</td>
</tr>
<tr>
<td><code>matmul(x1,x2,/[,out,casting,order,...])</code></td>
<td>矩阵乘积</td>
</tr>
<tr>
<td><code>tensordot(a,b[,axes])</code></td>
<td>沿指定轴计算张量积</td>
</tr>
<tr>
<td><code>einsum(subscripts,*operands[,out,dtype,...])</code></td>
<td>Einstein求和约定</td>
</tr>
<tr>
<td><code>einsum_path(subscripts,*operands[,optimize])</code></td>
<td>考虑中间数组情况下评估计算表达式最小代价</td>
</tr>
<tr>
<td><code>linalg.matrix_power(a,n)</code></td>
<td>方阵幂</td>
</tr>
<tr>
<td><code>kron(a,b)</code></td>
<td>Kronecker积（矩阵外积，分块）</td>
</tr>
<tr>
<td><code>trace(a[,offset,axis1,axis2,dtype,out])</code></td>
<td>迹</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>Einstein求和约定：简化求和式中的求和符号</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">15</span>).reshape(<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">b = np.arange(<span class="number">1</span>,<span class="number">16</span>).reshape(<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment"># Transpose</span></span><br><span class="line">np.einsum(<span class="string">&quot;ij-&gt;ji&quot;</span>, a)</span><br><span class="line"><span class="comment"># Sum all</span></span><br><span class="line">np.einsum(<span class="string">&quot;ij-&gt;&quot;</span>, a)</span><br><span class="line"><span class="comment"># Sum along given axis</span></span><br><span class="line">np.einsum(<span class="string">&quot;ij-&gt;i&quot;</span>, a)</span><br><span class="line">np.einsum(<span class="string">&quot;ij-&gt;j&quot;</span>, a)</span><br><span class="line"><span class="comment"># Multiply</span></span><br><span class="line">np.einsum(<span class="string">&quot;ij,ij-&gt;&quot;</span>,a,b)</span><br><span class="line"><span class="comment"># Inner product</span></span><br><span class="line">np.einsum(<span class="string">&quot;ik,jk-&gt;&quot;</span>,a,b)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>np.tensordot</code>：张量积，类似普通内积，仅有结构</p>
<ul>
<li><code>axes</code>为整形<ul>
<li><code>axes&gt;0</code>：<code>a</code>末尾<code>axes</code>维度、<code>b</code>开头<code>axes</code>维度
内积</li>
<li><code>axes=0</code>：Kronecker积</li>
</ul>
</li>
<li><code>axes</code>为2-Tuple：分别指定<code>a</code>、<code>b</code>内积的轴</li>
</ul>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>|Function|Desc|
|<code>np.i0(X)</code>|第1类修改的Bessel函数，0阶|</p>
<h2 id="np-linalg"><a href="#np-linalg" class="headerlink" title="np.linalg"></a><code>np.linalg</code></h2><ul>
<li>NumPy的线代基于<em>BLAS</em>、<em>LAPACK</em>提供高效的标准底层实现<ul>
<li>依赖库可以是NumPy提供的C版本子集</li>
<li>也可是针对特定平台优化的库（更好）<ul>
<li><em>OpenBLAS</em></li>
<li><em>MKL</em></li>
<li><em>ATLAS</em></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="np-linalg-1"><a href="#np-linalg-1" class="headerlink" title="np.linalg"></a><code>np.linalg</code></h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>multi_dot(arrays)</code></td>
<td>自动选择最快的计算顺序计算内积</td>
</tr>
<tr>
<td><code>cholesky(a)</code></td>
<td>cholesky分解</td>
</tr>
<tr>
<td><code>det(a)</code></td>
<td>行列式</td>
</tr>
<tr>
<td><code>eig(a)</code></td>
<td>特征值、特征向量（右乘）</td>
</tr>
<tr>
<td><code>eigh(a[,UPLO])</code></td>
<td>Hermitian（共轭对称）或实对称矩阵特征值、特征向量</td>
</tr>
<tr>
<td><code>eigvals(a)</code></td>
<td>特征值</td>
</tr>
<tr>
<td><code>eigvalsh(a[,UPLO])</code></td>
<td>Hermitian（共轭对称）或实对称矩阵特征值</td>
</tr>
<tr>
<td><code>inv(a)</code></td>
<td>矩阵逆</td>
</tr>
<tr>
<td><code>lstsq(a,b[,rcond])</code></td>
<td>最小二乘解</td>
</tr>
<tr>
<td><code>norm(x[,ord,axis,keepdims])</code></td>
<td>矩阵、向量范数</td>
</tr>
<tr>
<td><code>pinv(a[,rcond,hermitian])</code></td>
<td>Moore-Penrose伪逆</td>
</tr>
<tr>
<td><code>solve(a,b)</code></td>
<td>线程方程组求解</td>
</tr>
<tr>
<td><code>tensorsolve(a,b[,axes])</code></td>
<td>张量方程组求解</td>
</tr>
<tr>
<td><code>tensorrinv(a[,ind])</code></td>
<td>张量逆</td>
</tr>
<tr>
<td><code>svd(a[,full_matrices,compute_uv,hermitian])</code></td>
<td>奇异值分解</td>
</tr>
<tr>
<td><code>qr(a[,mode])</code></td>
<td>QR分解</td>
</tr>
<tr>
<td><code>matrix_rank(M[,tol,hermitian])</code></td>
<td>使用SVD方法计算矩阵秩</td>
</tr>
<tr>
<td><code>slogdet(a)</code></td>
<td>行列式的符号、自然对数</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>部分线代函数支持传入高维数组、数组序列，同时计算结果<ul>
<li>对高维数组，要求数组最后2、1维度满足计算要求</li>
</ul>
</li>
</ul>
<h2 id="（快速）傅里叶变换np-fft"><a href="#（快速）傅里叶变换np-fft" class="headerlink" title="（快速）傅里叶变换np.fft"></a>（快速）傅里叶变换<code>np.fft</code></h2><h3 id="Standard-FFTs"><a href="#Standard-FFTs" class="headerlink" title="Standard FFTs"></a>Standard FFTs</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>fft(a[,n,axis,norm])</code></td>
<td>1维离散傅里叶变换</td>
</tr>
<tr>
<td><code>fft2(a[,n,axes,norm])</code></td>
<td>2维离散FFT</td>
</tr>
<tr>
<td><code>fftn(a[,n,axes,norm])</code></td>
<td>N维离散FFT</td>
</tr>
<tr>
<td><code>ifft(a[,n,axis,norm])</code></td>
<td>1维离散逆FFT</td>
</tr>
<tr>
<td><code>ifft2(a[,n,axes,norm])</code></td>
<td>2维离散逆FFT</td>
</tr>
<tr>
<td><code>ifftn(a[,n,axes,norm])</code></td>
<td>N维离散逆FFT</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Real-FFTs"><a href="#Real-FFTs" class="headerlink" title="Real FFTs"></a>Real FFTs</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>rfft(a[,n,axis,norm])</code></td>
<td>1维离散傅里叶变换</td>
</tr>
<tr>
<td><code>rfft2(a[,n,axes,norm])</code></td>
<td>2维离散FFT</td>
</tr>
<tr>
<td><code>rfftn(a[,n,axes,norm])</code></td>
<td>N维离散FFT</td>
</tr>
<tr>
<td><code>irfft(a[,n,axis,norm])</code></td>
<td>1维逆离散FFT</td>
</tr>
<tr>
<td><code>irfft2(a[,n,axes,norm])</code></td>
<td>2维离散逆FFT</td>
</tr>
<tr>
<td><code>irfftn(a[,n,axes,norm])</code></td>
<td>N维离散逆FFT</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Hermitian-FFTs"><a href="#Hermitian-FFTs" class="headerlink" title="Hermitian FFTs"></a>Hermitian FFTs</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>hfft(a[,n,axis,norm])</code></td>
<td>Hermitian对称（实谱）的信号的FFT</td>
</tr>
<tr>
<td><code>ihfft(a[,n,axis,norm])</code></td>
<td>Hermitian对称（实谱）的信号的逆FFT</td>
</tr>
</tbody>
</table>
</div>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>fftfreq(n[,d])</code></td>
<td>离散FFT样本频率</td>
</tr>
<tr>
<td><code>rfftfreq(n[,d])</code></td>
<td></td>
</tr>
<tr>
<td><code>fftshift(x[,axes])</code></td>
<td>平移0频成分到频谱中间</td>
</tr>
<tr>
<td><code>ifftshift(x[,axes])</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="np-lib-scimath"><a href="#np-lib-scimath" class="headerlink" title="np.lib.scimath"></a><code>np.lib.scimath</code></h2><ul>
<li><p><code>np.lib.scimath</code>中包含一些顶层命名空间的同名函数</p>
<ul>
<li><p>相较于顶层空间，其定义域被扩展，相应其值域也扩展到
复数域</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.emath.log(-np.e) == <span class="number">1</span> + np.pi * <span class="number">1j</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><code>np.emath</code>是<code>np.lib.scimath</code>模块的推荐别名</li>
</ul>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-03-11T02:12:42.000Z" title="3/11/2021, 10:12:42 AM">2021-03-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-03-11T02:12:42.000Z" title="3/11/2021, 10:12:42 AM">2021-03-11</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Numpy/">Numpy</a></span><span class="level-item">35 minutes read (About 5293 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Numpy/ndarray_routines.html">NDArray Routine</a></h1><div class="content"><h2 id="Array-Manipulation"><a href="#Array-Manipulation" class="headerlink" title="Array Manipulation"></a>Array Manipulation</h2><h3 id="Shape-Only"><a href="#Shape-Only" class="headerlink" title="Shape Only"></a>Shape Only</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>reshape(a,newshape[,order])</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>resize(a,new_shape)</code></td>
<td>大小可不同，重复<code>a</code>补不足</td>
<td><code>0</code>补不足</td>
</tr>
<tr>
<td><code>ravel(a[,order])</code></td>
<td>展平视图</td>
<td></td>
</tr>
<tr>
<td><code>.flatten([order])</code></td>
<td>无</td>
<td>展平副本</td>
</tr>
<tr>
<td><code>shape(a)</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>size(a)</code></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Order-Alteration"><a href="#Order-Alteration" class="headerlink" title="Order Alteration"></a>Order Alteration</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>transpose(a[,axes])</code></td>
<td>调整轴顺序，缺省逆序即转置</td>
<td></td>
</tr>
<tr>
<td><code>moveaxis(a,source,destination)</code></td>
<td>移动数组轴到新位置</td>
<td>无</td>
</tr>
<tr>
<td><code>rollaxis(a,axis[,start])</code></td>
<td>将指定后向插入至指定位置（缺省0）</td>
<td>无</td>
</tr>
<tr>
<td><code>swapaxes(a,axis1,axis2)</code></td>
<td>交换轴</td>
<td></td>
</tr>
<tr>
<td><code>flip(m[,axis])</code></td>
<td>沿指定轴反向，缺省所有轴</td>
<td>无</td>
</tr>
<tr>
<td><code>fliplr(m)</code></td>
<td>左右反向（沿第2轴）</td>
<td>无</td>
</tr>
<tr>
<td><code>flipud(m)</code></td>
<td>上下反向（沿第1轴）</td>
<td>无</td>
</tr>
<tr>
<td><code>roll(a,shift[,axis])</code></td>
<td>沿轴滚动<code>shift</code></td>
<td>无</td>
</tr>
<tr>
<td><code>rot90(m[,k,axes])</code></td>
<td>在<code>axes</code>指定的平面中旋转<code>k</code>次90度</td>
<td>无</td>
</tr>
<tr>
<td><code>lib.stride_tricks.as_strided(x[,shape,...])</code></td>
<td>利用给定shape、stride在<code>x</code>上创建视图</td>
</tr>
</tbody>
</table>
</div>
<h3 id="维数改变"><a href="#维数改变" class="headerlink" title="维数改变"></a>维数改变</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>atleast_1d(*arys)</code></td>
<td>prepend维度直至维度至少维数至少1</td>
<td>无</td>
</tr>
<tr>
<td><code>atleast_2d(*arys)</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>atleatt_3d(*arys)</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>broadcast(*arys)</code></td>
<td>广播、打包输入对应元素的元组迭代器，类似<code>zip</code></td>
<td>无</td>
</tr>
<tr>
<td><code>broadcast_to(array,shape[,subok])</code></td>
<td>广播为指定shape</td>
<td>无</td>
</tr>
<tr>
<td><code>boradcast_arrays(*args,**kwargs)</code></td>
<td>输入的广播结果列表</td>
<td>无</td>
</tr>
<tr>
<td><code>expand_dims(a,axis)</code></td>
<td>在指定位置插入新轴</td>
<td>无</td>
</tr>
<tr>
<td><code>squeeze(a[,axis])</code></td>
<td>删除大小为1维度</td>
</tr>
</tbody>
</table>
</div>
<h3 id="插入、删除元素"><a href="#插入、删除元素" class="headerlink" title="插入、删除元素"></a>插入、删除元素</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>delete(arr,obj[,axis])</code></td>
<td>删除<code>obj</code>指定部分，缺省按展平数组删除</td>
</tr>
<tr>
<td><code>insert(arr,obj,values[,axis])</code></td>
<td>缺省按展平数组插入</td>
</tr>
<tr>
<td><code>append(arr,values[,axis])</code></td>
<td>缺省<code>arr</code>、<code>values</code>展平再添加</td>
</tr>
<tr>
<td><code>trim_zeros(filt[,trim])</code></td>
<td>trim前导、尾随0，缺省两边</td>
</tr>
</tbody>
</table>
</div>
<h3 id="改变类型"><a href="#改变类型" class="headerlink" title="改变类型"></a>改变类型</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>asarray(a[,dtype,order])</code></td>
<td>转换为数组</td>
<td>无</td>
</tr>
<tr>
<td><code>asarray_chkfinite(a[,dtype,order])</code></td>
<td>检查<code>NaN</code>、<code>inf</code></td>
<td>无</td>
</tr>
<tr>
<td><code>asanyarray(a[,dtype,order])</code></td>
<td>转换为数组，数组子类则不变</td>
<td>无</td>
</tr>
<tr>
<td><code>ascalar(a)</code></td>
<td>将大小为1的数组转换为等效标量</td>
</tr>
<tr>
<td><code>require(a[,dtype,requirements])</code></td>
<td>创建满足要求<code>ndarray.flags</code>数组</td>
<td>无</td>
</tr>
<tr>
<td><code>asfortranarray(a[,dtype])</code></td>
<td>转换为Fortran-contiguous风格内存布局</td>
<td>无</td>
</tr>
<tr>
<td><code>ascontiguousarray(a[,dtype])</code></td>
<td>转换为C-contiguous风格内存布局</td>
<td>无</td>
</tr>
<tr>
<td><code>asmatrix(data[,dtype])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>asfarray(a[,dtype])</code></td>
<td>转换为浮点类型</td>
<td>无</td>
</tr>
<tr>
<td><code>.astype(dtype[,order,casting,...])</code></td>
<td>无</td>
<td>转换为指定类型</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<ul>
<li>numpy中数组不是仅有C、Fortran风格内存布局，对数组的形态
  变换会导致内存布局不为任何风格内存布局</li>
</ul>
</blockquote>
<h3 id="组合数组"><a href="#组合数组" class="headerlink" title="组合数组"></a>组合数组</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>concatenate((a1,a2,...)[,axis,out])</code></td>
<td>沿现有轴连接数组</td>
</tr>
<tr>
<td><code>stack(arrays[,axis,out])</code></td>
<td>创建给定（新）轴堆叠数组</td>
</tr>
<tr>
<td><code>row_stack(tup)/vstack(tup)</code></td>
<td>沿第1（竖直）轴堆叠</td>
</tr>
<tr>
<td><code>column_stack(tup)/hstack(tup)</code></td>
<td>沿第2（水平）轴堆叠</td>
</tr>
<tr>
<td><code>dstack(tup)</code></td>
<td>沿第3轴堆叠</td>
</tr>
<tr>
<td><code>block(arrays)</code></td>
<td>按照<code>arrays</code>中给定数组块、位置组装</td>
</tr>
</tbody>
</table>
</div>
<h3 id="拆分数组"><a href="#拆分数组" class="headerlink" title="拆分数组"></a>拆分数组</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>split(ary,indices_or_sections[,axis])</code></td>
<td>沿轴拆分成视图</td>
</tr>
<tr>
<td><code>array_split(ary,indices_or_sections[,axis])</code></td>
<td>同<code>split</code>，但可处理不整除拆分</td>
</tr>
<tr>
<td><code>vsplit(ary,indices_or_sections)</code></td>
<td>沿第1（竖直）轴拆分</td>
</tr>
<tr>
<td><code>hsplit(ary,indices_or_sections)</code></td>
<td>沿第2（水平）轴拆分</td>
</tr>
<tr>
<td><code>dsplit(ary,indices_or_sections)</code></td>
<td>沿第3轴拆分</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pad(array,pad_width[,mode])</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="Index-Routine"><a href="#Index-Routine" class="headerlink" title="Index Routine"></a>Index Routine</h2><ul>
<li><p>结果数组shape考虑逻辑链</p>
<ul>
<li>确定输出数组的维数<code>ndim</code></li>
<li>确定参数数组原维度轴位置、补1轴位置，参数维度轴对齐</li>
<li>修正各维度大小<ul>
<li>沿轴操作：保持不变</li>
<li>沿轴采样：采样数目</li>
<li>沿轴concate：维度相加</li>
<li>沿轴聚集：删除维度</li>
<li>沿轴切片聚集：删除其余维度</li>
</ul>
</li>
</ul>
</li>
<li><p>numpy中（多维）索引往往使用整数高级索引的方式返回</p>
<ul>
<li><code>np.ndarray</code>数组：首维度各分量分别表示各维度的高级
索引</li>
<li>list、tuple：各元素分别为各维度的高级索引</li>
</ul>
</li>
</ul>
<h3 id="数组无关切片、高级索引"><a href="#数组无关切片、高级索引" class="headerlink" title="数组无关切片、高级索引"></a>数组无关切片、高级索引</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>返回值类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s_[]</code></td>
<td>支持多维切片生成，类<code>slice()</code></td>
<td>切片、元组</td>
</tr>
<tr>
<td><code>index_exp[]</code></td>
<td>同<code>s_</code>，但总返回元组</td>
<td>元组</td>
</tr>
<tr>
<td><code>r_[]</code></td>
<td>沿第1轴concate切片、数组、标量</td>
<td>数组</td>
</tr>
<tr>
<td><code>c_[]</code></td>
<td>沿第-1轴concate切片、数组、标量（1维则被视为列向量）</td>
<td>数组</td>
</tr>
<tr>
<td><code>ravel_multi_index(multi_index,dims[,mode,order])</code></td>
<td>计算高级索引<code>multi_index</code>在<code>dims</code>数组展平后的位置</td>
<td>数组</td>
</tr>
<tr>
<td><code>unravel_index(indices,shape[,order])</code></td>
<td><code>ravel_multi_index</code>逆向</td>
<td>元组</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p><code>np.r_[]</code>、<code>np.c_[]</code>除可concate切片方便生成数组，还可以
传递两个参数修改行为</p>
<ul>
<li><p><code>r</code>/<code>c</code>字符被设置时，返回矩阵</p>
<ul>
<li>1维数组，<code>r</code>被设置时返回1 <em> N矩阵，<code>c</code>被设置时
返回N </em> 1矩阵</li>
<li>2维数组，<code>r</code>、<code>c</code>被设置时，结果矩阵相同</li>
</ul>
</li>
<li><p><code>&lt;axis&gt;[,&lt;ndim&gt;,&lt;ori_pos&gt;]</code>三个整形，决定shape</p>
<p>|参数|说明|<code>np.r_[]</code>缺省值|<code>np.c_[]</code>缺省值|
|——-|——-|——-|——-|
|<code>&lt;axis&gt;</code>|concate执行轴|<code>0</code>|<code>-1</code>|
|<code>&lt;ndim&gt;</code>|目标维数，仅在其大于结果维数时才生效|<code>1</code>|<code>2</code>|
|<code>&lt;ori_pos&gt;</code>|原数据轴所在的位置|<code>-1</code>，即prepend全<code>1</code>轴|<code>0</code>，即postpend全<code>1</code>轴|</p>
</li>
<li><p>相同参数时，两者结果相同，可根据不同数组设置合适的
参数相互实现</p>
<ul>
<li><code>np.r_[]</code>可视为参数缺省为<code>0,1,-1</code></li>
<li><code>np.c_[]</code>可视为参数缺省为<code>-1,2,0</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><code>np.r_</code>、<code>np.c_</code>分别是<code>np.lib.index_tricks.RClass</code>、
  <code>np.lib.index_tricks.CClass</code>实例</li>
<li><code>np.s_</code>、<code>np.index_exp</code>均是
  <code>np.lib.index_tricks.IndexExpression</code>实例，仅初始化参数
  不同</li>
</ul>
</blockquote>
<h3 id="网格"><a href="#网格" class="headerlink" title="网格"></a>网格</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>返回值类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ix_(*args)</code></td>
<td>以<code>args</code>为基点创建开网格（仅设置基点、维度）</td>
<td>元组</td>
</tr>
<tr>
<td><code>meshgrid(*xi,**kwargs)</code></td>
<td>以<code>xi</code>作为基点创建稠密网格（所有网格点高级索引）</td>
<td>列表</td>
</tr>
<tr>
<td><code>mgrid[]</code></td>
<td>根据切片创建稠密网格</td>
<td>数组</td>
</tr>
<tr>
<td><code>ogrid[]</code></td>
<td>根据切片创建开网格</td>
<td>列表</td>
</tr>
<tr>
<td><code>indices(dimensions[,dtype,sparse])</code></td>
<td>以<code>dimensions</code>作为各维度长创建网格</td>
<td>数组、元组</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>开网格广播即可得到稠密网格</li>
</ul>
<h3 id="值相关索引"><a href="#值相关索引" class="headerlink" title="值相关索引"></a>值相关索引</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>nonzero(a)</code></td>
<td>非0元素整形高级索引</td>
<td></td>
</tr>
<tr>
<td><code>where(condition,[x,y])</code></td>
<td><code>condition</code>对应整形高级索引，给出<code>x,y</code>时则从中抽取元素</td>
<td>无</td>
</tr>
<tr>
<td><code>flatnonzero(a)</code></td>
<td>展平非0位置</td>
<td>无</td>
</tr>
</tbody>
</table>
</div>
<h3 id="特殊位置索引"><a href="#特殊位置索引" class="headerlink" title="特殊位置索引"></a>特殊位置索引</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>diag_indices(n[,ndim])</code></td>
<td><code>ndim</code>维长为<code>n</code>数组对角索引</td>
</tr>
<tr>
<td><code>diag_indices_from(arr)</code></td>
<td>获取<code>arr</code>对角索引</td>
</tr>
<tr>
<td><code>mask_indices(n,mask_func[,k])</code></td>
<td>根据<code>mask_func</code>获取n * n数组索引</td>
</tr>
<tr>
<td><code>tril_indices(n[,k,m])</code></td>
<td>n * m的下三角索引</td>
</tr>
<tr>
<td><code>triu_indices(n[,k,m])</code></td>
<td>n * m的上三角索引</td>
</tr>
<tr>
<td><code>tril_indices_from(arr[,k])</code></td>
<td><code>arr</code>的下三角索引</td>
</tr>
<tr>
<td><code>triu_indices_from(arr[,k])</code></td>
<td><code>arr</code>的下三角索引</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>np.ndindex(*args) == np.broadcast(*np.indices(*args))</code></li>
</ul>
<h3 id="Searching-索引"><a href="#Searching-索引" class="headerlink" title="Searching 索引"></a>Searching 索引</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>argwhere(a)</code></td>
<td>非0点坐标数组</td>
<td>无</td>
</tr>
<tr>
<td><code>argmax(a[,axis,out])</code></td>
<td>展平后位置，存在<code>NaN</code>则返回<code>0</code></td>
<td></td>
</tr>
<tr>
<td><code>argmin(a[,axis])</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>nanargmax(a[,axis])</code></td>
<td>忽略<code>NaN</code></td>
</tr>
<tr>
<td><code>nanargmin(a[,axis])</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>searchsorted(a,v[,side,sorter])</code></td>
<td>应插入（保持有序）位置</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Value-Manipulation"><a href="#Value-Manipulation" class="headerlink" title="Value Manipulation"></a>Value Manipulation</h2><h3 id="Value-Extraction"><a href="#Value-Extraction" class="headerlink" title="Value Extraction"></a>Value Extraction</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>take(a,indices[,axis,out,mode])</code></td>
<td>按<code>indices</code>沿给定轴获取超平面（缺省将数组展平）</td>
<td></td>
</tr>
<tr>
<td><code>take_along_axis(arr,indices,axis)</code></td>
<td>将<code>arr</code>、<code>indices</code>沿<code>axis</code>匹配，选取元素</td>
<td>无</td>
</tr>
<tr>
<td><code>compress(condition,a[,axis,out])</code></td>
<td>按bool数组<code>condition</code>沿给定轴<code>axis</code>选取超平面（缺省将数组展平）</td>
<td></td>
</tr>
<tr>
<td><code>extract(condition,arr)</code></td>
<td>在展平数组上抽取元素</td>
<td>无</td>
</tr>
<tr>
<td><code>choose(a,choices[,out,mode])</code></td>
<td>根据<code>a</code>广播后元素值选择<code>choices</code>中数组填充对应位置</td>
<td></td>
</tr>
<tr>
<td><code>select(condlist,choicelist[,default])</code></td>
<td><code>condlist</code>中首个真值对应的<code>choicelist</code>数组填充对应位置</td>
<td>无</td>
</tr>
<tr>
<td><code>diag(v[,k])</code></td>
<td>从2维<code>v</code>抽取对角、或以1维<code>v</code>作为对角</td>
<td>无</td>
</tr>
<tr>
<td><code>diagonal(a[,offset,axis1,axis2])</code></td>
<td>返回给定对象</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p><code>take</code>：沿给定轴从数组中获取元素</p>
<ul>
<li><code>axis</code>为<code>None</code>时，按展平后获取<code>indices</code>指定元素，
非<code>None</code>时<ul>
<li>函数行为同高级索引</li>
<li>指定<code>axis</code>可以简化通过高级索引获取指定轴的元素</li>
</ul>
</li>
<li>基本元素为数组在该轴的切片</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ni, Nk = a.shape[:axis], a.shape[axis+<span class="number">1</span>:]</span><br><span class="line">Nj = indices.shape</span><br><span class="line"><span class="keyword">for</span> ii <span class="keyword">in</span> np.ndindex(Ni):</span><br><span class="line">	<span class="keyword">for</span> jj <span class="keyword">in</span> np.ndindex(Nj):</span><br><span class="line">		<span class="keyword">for</span> kk <span class="keyword">in</span> np.ndindex(Nk):</span><br><span class="line">			out[ii+jj+kk] = a[ii+(indices[jj],)+kk]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>take_along_axis</code>：匹配给定轴方向的1维索引、数据切片，
获取元素</p>
<ul>
<li>基本元素为单个元素<ul>
<li>将<code>indices</code>和<code>arr</code>对齐，除给定维度外，其余维度
大小均须相同</li>
<li>其余维度给定下，按照<code>indices</code>在超平面上给出的
位置获取对应的元素</li>
<li>即<code>take</code>以超平面为单位获取整个超平面的元素，而
<code>take_along_axis</code>按元素为单位，沿给定轴方向调整
元素顺序</li>
</ul>
</li>
<li><code>np.argsort</code>、<code>np.argpartition</code>等函数能够返回适合此
函数的索引</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">N1, M, Nk = arr.shape[:axis], arr.shape[axis], arr.shape[axis+<span class="number">1</span>:]</span><br><span class="line">J = indices.shape[axis]</span><br><span class="line">out = np.empty(Ni + (J,) + Nk)</span><br><span class="line"><span class="keyword">for</span> ii <span class="keyword">in</span> np.ndindex(Ni):</span><br><span class="line">	<span class="keyword">for</span> kk <span class="keyword">in</span> np.ndindex(Nk):</span><br><span class="line">		a_1d = arr[ii + np.s_[:,] + kk]</span><br><span class="line">		indices_1d = indices[ii + np.s_[:,] +kk]</span><br><span class="line">		out_1d = out[ii + np.s_[:,] + kk]</span><br><span class="line">		out_1d = a_1d[indices_1d[j]]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>np.choose</code></p>
<ul>
<li><code>choices</code>：数组序列，其中数组和<code>a</code>需广播兼容<ul>
<li>若本身为数组，则其最外层被视为序列</li>
</ul>
</li>
<li>逻辑<ul>
<li><code>a</code>、<code>choices</code>中数组共同广播</li>
<li>广播结果的shape即为结果shape，其中<code>a</code>取值为<code>n</code>
处用数组<code>choices[n]</code>填充</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.choose(a,choices) == np.array([choices[a[I]][I] <span class="keyword">for</span> I <span class="keyword">in</span> np.ndindex(a.shape)])</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>np.select</code></p>
<ul>
<li>使用各位置<code>condlist</code>首个真值出现的位序值构建<code>a</code>，则
等价于<code>np.choose(a,choicelist)</code>
（不考虑缺省值）</li>
</ul>
</li>
<li><p><code>np.extract</code></p>
<ul>
<li>等价于<code>np.compress(np.ravel(condition), np.ravel(arr))</code></li>
<li>若<code>condition</code>为bool数组，也等价于<code>arr[condition]</code></li>
</ul>
</li>
</ul>
<h3 id="Value-Modification"><a href="#Value-Modification" class="headerlink" title="Value Modification"></a>Value Modification</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>place(arr,mask,vals)</code></td>
<td>按照<code>mask</code>循环使用<code>vals</code>中值替换<code>arr</code>中元素</td>
<td>无</td>
</tr>
<tr>
<td><code>put(a,ind,v[,mode])</code></td>
<td>同<code>place</code>，但根据展平索引<code>ind</code>替换</td>
<td></td>
</tr>
<tr>
<td><code>put_along_axis(arr,indices,values,axis)</code></td>
<td>匹配<code>indices</code>和<code>arr</code>沿<code>axis</code>分量，替换值</td>
<td>无</td>
</tr>
<tr>
<td><code>copyto(dst,src[,casting,where])</code></td>
<td>根据bool数组<code>where</code>替换<code>dst</code>中元素</td>
<td>无</td>
</tr>
<tr>
<td><code>putmask(a,mask,values)</code></td>
<td>同<code>copyto</code></td>
<td>无</td>
</tr>
<tr>
<td><code>fill_diagonal(a,val[,wrap])</code></td>
<td>用<code>val</code>填充<code>a</code>的主对角</td>
<td>无</td>
</tr>
<tr>
<td><code>clip(a,a_min,a_max[,out=None,**kwargs])</code></td>
<td>裁剪值</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<ul>
<li><code>where</code>、<code>mask</code>、<code>condition</code>缺省为、等价为bool数组</li>
<li><code>np.clip</code>是<em>ufunc</em></li>
</ul>
</blockquote>
<h3 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sort(a[,axis,kind,order,])</code></td>
<td></td>
<td>在位排序</td>
</tr>
<tr>
<td><code>lexsort(keys[,axis])</code></td>
<td>根据<code>keys</code>中多组键沿<code>axis</code>轴排序（靠后优先级高）</td>
<td>无</td>
</tr>
<tr>
<td><code>msort(a)</code></td>
<td>沿第1轴排序</td>
<td>无</td>
</tr>
<tr>
<td><code>argsort(a[,axis,kind,order])</code></td>
<td>沿<code>axis</code>方向间接排序</td>
<td></td>
</tr>
<tr>
<td><code>sort_complex(a)</code></td>
<td>先实、后虚排序</td>
<td></td>
</tr>
<tr>
<td><code>partition(a,kth[,axis,kind,order])</code></td>
<td>以第<code>kth</code>大小数划分</td>
</tr>
<tr>
<td><code>argpartition(a,kth[,axis,kind,order])</code></td>
<td>间接分段</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>lexsort</code>：按照<code>axis</code>方向、以<code>keys</code>中数组顺序作为权重
进行间接排序<ul>
<li><code>keys</code>：数组序列或2维以上数组<ul>
<li>数组最高维视为序列</li>
<li><code>keys</code>为数组时，最高维被省略</li>
<li>多个数组视为权重不同的排序依据，靠后优先级高</li>
</ul>
</li>
<li><code>axis</code>：排序所沿轴方向，缺省为<code>-1</code>，沿最低维轴排序<ul>
<li>可视为按<code>keys</code>中数组逆序优先级，取用各数组沿轴
方向的间接排序结果</li>
<li>即对每个第1轴、<code>axis</code>构成平面，优先考虑第1轴末尾
<code>axis</code>方向数组进行排序，再依次考虑前序</li>
</ul>
</li>
<li><code>lexsort</code>、<code>argsort</code>排序方向相同时，<code>lexsort</code>结果中
最后子数组和<code>argsort</code>结果应差别不大
（排序方向相同而不是<code>axis</code>参数取值相同）</li>
</ul>
</li>
</ul>
<h2 id="Logical-Test"><a href="#Logical-Test" class="headerlink" title="Logical Test"></a>Logical Test</h2><h3 id="真值测试"><a href="#真值测试" class="headerlink" title="真值测试"></a>真值测试</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>all(a[,axis,out,keepdims])</code></td>
<td>给定轴方向所有元素为真</td>
<td></td>
</tr>
<tr>
<td><code>any(a[,axis,out,keepdims])</code></td>
<td>给定轴方向存在元素为真</td>
</tr>
</tbody>
</table>
</div>
<h3 id="数组内容"><a href="#数组内容" class="headerlink" title="数组内容"></a>数组内容</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>isfinite(x,/[,out,where,casting,order,...])</code></td>
<td>逐元素是否有限</td>
</tr>
<tr>
<td><code>isinf(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>isnan(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>isnat(x,/[,out,where,casting,order,...])</code></td>
<td>逐元素是否<code>NaT</code></td>
</tr>
<tr>
<td><code>isneginf(x,/[,out])</code></td>
<td></td>
</tr>
<tr>
<td><code>isposinf(x,/[,out])</code></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<ul>
<li><code>isneginf</code>、<code>isposinf</code>行为类似<em>ufunc</em>，但不是</li>
</ul>
</blockquote>
<h3 id="类型测试"><a href="#类型测试" class="headerlink" title="类型测试"></a>类型测试</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>iscomplex(x)</code></td>
<td></td>
</tr>
<tr>
<td><code>iscomplexobj(x)</code></td>
<td>复数类型或复数值</td>
</tr>
<tr>
<td><code>isfortran(a)</code></td>
<td>Fortran contiguous</td>
</tr>
<tr>
<td><code>isreal(x)</code></td>
<td></td>
</tr>
<tr>
<td><code>isrealobj(x)</code></td>
<td>实数类型或实数值</td>
</tr>
<tr>
<td><code>isscalar(x)</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="Mathmatics"><a href="#Mathmatics" class="headerlink" title="Mathmatics"></a>Mathmatics</h2><blockquote>
<ul>
<li>部分数学函数为<em>ufunc</em></li>
</ul>
</blockquote>
<h3 id="UFunc初等运算"><a href="#UFunc初等运算" class="headerlink" title="UFunc初等运算"></a>UFunc初等运算</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>add(x1,x2,/[out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>subtract(x1,x2,/[,out,where,casting,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>multiply(x1,x2,/[,out,where,casting,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>divide(x1,x2,/[,out,where,casting,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>true_devide(x1,x2,/[,out,where,casting,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>floor_devide(x1,x2,/[,out,where,casting,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>logaddexp(x1,x2,/[,out,where,casting,...])</code></td>
<td><code>ln(x1+x2)</code></td>
</tr>
<tr>
<td><code>logaddexp2(x1,x2,/[,out,where,casting,...])</code></td>
<td><code>log_2 (x1+x2)</code></td>
</tr>
<tr>
<td><code>negative(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>positive(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>power(x1,x2,/[,out,where,casting,order,...])</code></td>
<td><code>x1^x2</code></td>
</tr>
<tr>
<td><code>float_power(x1,x2,/[,out,where,casting,...])</code></td>
<td><code>x1^x2</code></td>
</tr>
<tr>
<td><code>remainder(x1,x2,/[,out,where,casting,...])</code></td>
<td>求余/取模</td>
</tr>
<tr>
<td><code>mod(x1,x2,/[,out,where,casting,order,...])</code></td>
<td>求余/取模</td>
</tr>
<tr>
<td><code>fmod(x1,x2,/[,out,where,casting,order,...])</code></td>
<td>求余/取模</td>
</tr>
<tr>
<td><code>divmod(x1,x2,/[,out1,out2],/[out,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>absolute(x,/[,out,where,casting,order,...])</code>/<code>abs</code></td>
<td></td>
</tr>
<tr>
<td><code>rint(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>sign(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>heaviside(x1,x2,/[,out,where,casting,...])</code></td>
<td>阶跃函数</td>
</tr>
<tr>
<td><code>conj(x,/[,out,where,casting,...])</code></td>
<td>对偶</td>
</tr>
<tr>
<td><code>exp(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>exp2(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>log(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>log2(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>log10(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>expm1(x,/[,out,where,casting,order,...])</code></td>
<td>计算<code>exp(x)-1</code></td>
</tr>
<tr>
<td><code>log1p(x,/[,out,where,casting,order,...])</code></td>
<td>计算<code>ln(x+1)</code></td>
</tr>
<tr>
<td><code>sqrt(x,/[,out,where,casting,order,...])</code></td>
<td>非负平方根</td>
</tr>
<tr>
<td><code>square(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>cbrt(x,/[,out,where,casting,order,...])</code></td>
<td>立方根</td>
</tr>
<tr>
<td><code>reciprocal(x,/[,out,where,casting,order,...])</code></td>
<td>倒数</td>
</tr>
<tr>
<td><code>gcd(x,/[,out,where,casting,order,...])</code></td>
<td>最大公约数</td>
</tr>
<tr>
<td><code>lcm(x,/[,out,where,casting,order,...])</code></td>
<td>最小公倍数</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>out</code>参数可用于节省内存，如：<code>G=A*B+C</code><ul>
<li>等价于：<code>t1=A*B; G=t1+C; del t1;</code></li>
<li>可利用<code>out</code>节省中间过程内存：<code>G=A*B; np.add(G,C,G)</code></li>
</ul>
</li>
</ul>
<h3 id="UFunc-Floating函数"><a href="#UFunc-Floating函数" class="headerlink" title="UFunc Floating函数"></a>UFunc Floating函数</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>fabs(x,/[,out,where,casting,order,...])</code></td>
<td>不可用于复数</td>
</tr>
<tr>
<td><code>signbit(x,/[,out,where,casting,order,...])</code></td>
<td><em>signbit</em>是否设置，即<code>&lt;0</code></td>
</tr>
<tr>
<td><code>copysign(x1,x2,/[,out,where,casting,order,...])</code></td>
<td>根据<code>x1</code>设置<code>x2</code>的<em>signbit</em></td>
</tr>
<tr>
<td><code>nextafter(x1,x2,/[,out,where,casting,order,...])</code></td>
<td><code>x1</code>朝向<code>x2</code>的下个浮点数，即变动最小精度</td>
</tr>
<tr>
<td><code>spacing(x,/[,out,where,casting,order,...])</code></td>
<td><code>x</code>和最近浮点数距离，即取值的最小精度</td>
</tr>
<tr>
<td><code>modf(x[,out1,out2],/[,out,where],...)</code></td>
<td>返回取值的整数、小数部分</td>
</tr>
<tr>
<td><code>ldexp(x1,x2,/[,out,where,casting,...])</code></td>
<td>计算<code>x1*2**x2</code>，即还原2为底的科学计数</td>
</tr>
<tr>
<td><code>frexp(x[,out1,out2],/[,out,where],...)</code></td>
<td>返回2为底的科学计数的假数、指数</td>
</tr>
<tr>
<td><code>floor(x,/,out,*,where,...)</code></td>
<td></td>
</tr>
<tr>
<td><code>ceil(x,/,out,*,where,...)</code></td>
<td></td>
</tr>
<tr>
<td><code>trunc(x,/,out,*,where,...)</code></td>
<td></td>
</tr>
<tr>
<td><code>rint(x,/[,out,where,casting,order,...])</code></td>
<td>最近整数</td>
</tr>
<tr>
<td><code>around(a[,decimals,out])</code>/<code>round</code>/<code>round_</code></td>
<td></td>
</tr>
<tr>
<td><code>fix(x[,out])</code></td>
<td>向零点取整</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<ul>
<li><code>np.fix</code>不是<em>ufunc</em>，但行为类似</li>
</ul>
</blockquote>
<h3 id="比较函数"><a href="#比较函数" class="headerlink" title="比较函数"></a>比较函数</h3><ul>
<li><p>数值比较</p>
<ul>
<li><code>np.equal()</code>更多应用于整形比较，比较浮点使用
<code>np.isclose()</code>更合适</li>
<li><code>np.allclose()</code>则是判断数组整体是否相同</li>
<li><code>array_equal(a1,a2)</code>数组<code>a1</code>、<code>a2</code>相同</li>
<li><code>array_equiv(a1,a2)</code>数组<code>a1</code>、<code>a2</code>广播后相同</li>
</ul>
</li>
<li><p>逻辑运算符</p>
<ul>
<li><code>&amp;</code>、<code>|</code>、<code>~</code>：逐元素逻辑运算<ul>
<li>优先级高于比较运算符</li>
</ul>
</li>
<li><code>and</code>、<code>or</code>、<code>not</code>：整个数组的逻辑运算</li>
</ul>
</li>
<li><p><code>np.maximum()</code>、<code>np.minimum()</code>函数</p>
<ul>
<li><code>max()</code>寻找最大值效率比<code>np.maximum.reduce()</code>低，同样
<code>min()</code>效率也较低</li>
</ul>
</li>
</ul>
<h4 id="UFunc比较函数"><a href="#UFunc比较函数" class="headerlink" title="UFunc比较函数"></a>UFunc比较函数</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>greater(x1,x2,/[,out,where,casting,...])</code></td>
<td></td>
<td><code>&gt;</code></td>
</tr>
<tr>
<td><code>greater_equal(x1,x2,/[,out,where,casting,...])</code></td>
<td><code>&gt;=</code></td>
</tr>
<tr>
<td><code>less(x1,x2,/[,out,where,casting,...])</code></td>
<td></td>
<td><code>&lt;</code></td>
</tr>
<tr>
<td><code>less_equal(x1,x2,/[,out,where,casting,...])</code></td>
<td></td>
<td><code>&lt;=</code></td>
</tr>
<tr>
<td><code>not_equal(x1,x2,/[,out,where,casting,...])</code></td>
<td></td>
<td><code>!=</code></td>
</tr>
<tr>
<td><code>equal(x1,x2,/[,out,where,casting,...])</code></td>
<td></td>
<td><code>==</code></td>
</tr>
<tr>
<td><code>logical_and(x1,x2,/[,out,where,casting,...])</code></td>
<td>逐元素<code>and</code></td>
<td><code>and</code></td>
</tr>
<tr>
<td><code>logical_or(x1,x2,/[,out,where,casting,...])</code></td>
<td></td>
<td><code>or</code></td>
</tr>
<tr>
<td><code>logical_xor(x1,x2,/[,out,where,casting,...])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>logical_not(x1,x2,/[,out,where,casting,...])</code></td>
<td></td>
<td><code>not</code></td>
</tr>
<tr>
<td><code>maximum(x1,x2,/[,out,where,casting,...])</code></td>
<td>逐元素选择较大者</td>
<td></td>
</tr>
<tr>
<td><code>minimum(x1,x2,/[,out,where,casting,...])</code></td>
<td>逐元素选择较小者</td>
<td></td>
</tr>
<tr>
<td><code>fmax(x1,x2,/[,out,where,casting,...])</code></td>
<td>逐元素选择较大者，忽略<code>NaN</code></td>
<td></td>
</tr>
<tr>
<td><code>fmin(x1,x2,/[,out,where,casting,...])</code></td>
<td>逐元素选择较小者，忽略<code>NaN</code></td>
</tr>
</tbody>
</table>
</div>
<h4 id="非UFunc"><a href="#非UFunc" class="headerlink" title="非UFunc"></a>非UFunc</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>isclose(a,b[,rtol,atol,equal_nan])</code></td>
<td>逐元素容忍度范围内相等</td>
</tr>
<tr>
<td><code>allclose(a,b[,rtol,atol,equal_nan])</code></td>
<td><code>all(isclose())</code></td>
</tr>
<tr>
<td><code>array_equal(a1,a2[,equal_nan])</code></td>
<td>数组整体</td>
</tr>
<tr>
<td><code>array_equiv(a1,a2)</code></td>
<td>广播后相等</td>
</tr>
</tbody>
</table>
</div>
<h3 id="UFunc-Bit-twiddling函数"><a href="#UFunc-Bit-twiddling函数" class="headerlink" title="UFunc Bit-twiddling函数"></a>UFunc Bit-twiddling函数</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bitwise_and(x1,x2,/[,out,where,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>bitwise_or(x1,x2,/[,out,where,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>bitwise_xor(x1,x2,/[,out,where,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>invert(x,/[,out,where,casting,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>left_shift(x1,x2,/[,out,where,casting...])</code></td>
<td></td>
</tr>
<tr>
<td><code>left_shift(x1,x2,/[,out,where,casting...])</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="UFunc-三角函数"><a href="#UFunc-三角函数" class="headerlink" title="UFunc 三角函数"></a>UFunc 三角函数</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sin(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>cos(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>tan(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>arcsin(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>arccos(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>arctan(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>arctan2(x1,x2,/[,out,where,casting,order,...])</code></td>
<td>考虑象限下，<code>arctan(x1/x2)</code></td>
</tr>
<tr>
<td><code>hypot(x1,x2,/[,out,where,casting,order,...])</code></td>
<td>计算斜边</td>
</tr>
<tr>
<td><code>sinh(x,/[,out,where,casting,order,...])</code></td>
<td>双曲正弦</td>
</tr>
<tr>
<td><code>cosh(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>tanh(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>arcsinh(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>arccosh(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>arctanh(x,/[,out,where,casting,order,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>deg2rad(x,/[,out,where,casting,order,...])</code></td>
<td>角度转换为弧度</td>
</tr>
<tr>
<td><code>rad2deg/degrees(x,/[,out,where,casting,order,...])</code></td>
<td>弧度转换为角度</td>
</tr>
</tbody>
</table>
</div>
<h3 id="基本数学"><a href="#基本数学" class="headerlink" title="基本数学"></a>基本数学</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>prod(a[,axis,dtype,out,keepdims,...])</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>nanprod(a[,axis,dtype,out,keepdims,...])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>sum(a[,axis,dtype,out,keepdims,...])</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>nansum(a[,axis,dtype,out,keepdims,...])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>cumprod(a[,axis,dtype,out,keepdims,...])</code></td>
<td>累乘（也可用<em>ufunc.accumulate</em>）</td>
<td></td>
</tr>
<tr>
<td><code>cumsum(a[,axis,dtype,out,keepdims,...])</code></td>
<td>累加</td>
<td></td>
</tr>
<tr>
<td><code>nancumprod(a[,axis,dtype,out,keepdims,...])</code></td>
<td><code>NaN</code>视为<code>1</code></td>
<td>无</td>
</tr>
<tr>
<td><code>nancumsum(a[,axis,dtype,out,keepdims,...])</code></td>
<td><code>NaN</code>视为<code>0</code></td>
<td>无</td>
</tr>
<tr>
<td><code>diff(a[,n,axis,prepend,append,...])</code></td>
<td>沿给定轴1阶差分（保持类型不变，注意溢出）</td>
<td>无</td>
</tr>
<tr>
<td><code>ediff1d(ary[,to_end,to_begin]</code></td>
<td>沿展平顺序1阶差分</td>
<td>无</td>
</tr>
<tr>
<td><code>gradient(f,*varargs,**kwargs)</code></td>
<td>梯度</td>
<td>无</td>
</tr>
<tr>
<td><code>cross(a,b[,axisa,axisb,axisc,axis])</code></td>
<td>向量叉积</td>
<td>无</td>
</tr>
<tr>
<td><code>trapz(y[,x,dx,axis])</code></td>
<td>梯形法则定积分</td>
<td>无</td>
</tr>
</tbody>
</table>
</div>
<h3 id="复数运算"><a href="#复数运算" class="headerlink" title="复数运算"></a>复数运算</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>angle(z[,deg])</code></td>
<td>角度</td>
<td>无</td>
</tr>
<tr>
<td><code>real(val)</code></td>
<td>实部</td>
<td></td>
</tr>
<tr>
<td><code>imag(val)</code></td>
<td>虚部</td>
<td></td>
</tr>
<tr>
<td><code>conj/conjugate(x,/[,out,where,casting,order,...])</code></td>
<td>复共轭</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>nan_to_num(x[,copy,nan,posinf,neginf])</code></td>
<td>替换<code>NaN</code>、<code>inf</code>为数值</td>
</tr>
<tr>
<td><code>real_if_close(a[,to])</code></td>
<td>虚部接近0则省略</td>
</tr>
<tr>
<td><code>interp(x,xp,fp[,left,right,period])</code></td>
<td>1维线性插值</td>
</tr>
<tr>
<td><code>polyfit(x,y,deg[,rcond,full,w,cov])</code></td>
<td>最小二乘多项式拟合</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Statistics"><a href="#Statistics" class="headerlink" title="Statistics"></a>Statistics</h2><blockquote>
<ul>
<li><code>axis=None</code>：默认值<code>None</code>，表示在整个数组上执行操作</li>
</ul>
</blockquote>
<h3 id="Count"><a href="#Count" class="headerlink" title="Count"></a>Count</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>count_nonzero(a[,axis])</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>amin/min(a[,axis,out,keepdims,initial,where])</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>amax/max(a[,axis,out,keepdims,initial,where])</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>nanmin(a[,axis,out,keepdims,initial,where])</code></td>
<td>忽略<code>NaN</code></td>
</tr>
<tr>
<td><code>nanmax(a[,axis,out,keepdims,initial,where])</code></td>
<td></td>
</tr>
<tr>
<td><code>ptp(a[,axis,out,keepdims])</code></td>
<td>极差</td>
<td></td>
</tr>
<tr>
<td><code>percentile(a,q[,axis,out,...])</code></td>
<td><code>q</code>取值<code>[0-100]</code></td>
<td>无</td>
</tr>
<tr>
<td><code>nanpercentile(a,q[,axis,out,...])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>quantile(a,q[,axis,out,overwrite_input,...])</code></td>
<td><code>q</code>取值<code>[0,1]</code></td>
<td>无</td>
</tr>
<tr>
<td><code>nanquantile(a,q[,axis,out,...])</code></td>
<td></td>
<td>无</td>
</tr>
</tbody>
</table>
</div>
<h3 id="均值、方差"><a href="#均值、方差" class="headerlink" title="均值、方差"></a>均值、方差</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>median(a[,axis,out,overwrite_input,keepdims])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>average(a[,axis,weights,returned])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>mean(a[,axis,dtype,out,keepdims])</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>std(a[,axis,dtype,out,ddof,keepdims])</code></td>
<td>标准差</td>
<td></td>
</tr>
<tr>
<td><code>var(a[,axis,dtype,out,ddof,keepdims])</code></td>
<td>方查</td>
<td></td>
</tr>
<tr>
<td><code>nanmedian(a[,axis,out,overwrite_input,...])</code></td>
<td>无</td>
</tr>
<tr>
<td><code>nanmean(a[,axis,dtype,out,keepdims])</code></td>
<td>无</td>
</tr>
<tr>
<td><code>nanstd(a[,axis,dtype,out,ddof,keepdims])</code></td>
<td>无</td>
</tr>
<tr>
<td><code>nanvar(a[,axis,dtype,out,ddof,keepdims])</code></td>
<td>无</td>
</tr>
</tbody>
</table>
</div>
<h3 id="相关系数"><a href="#相关系数" class="headerlink" title="相关系数"></a>相关系数</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>corrcoef(x[,y,rowvar,bias,ddof])</code></td>
<td>Pearson积差相关系数</td>
</tr>
<tr>
<td><code>correlate(a,v[,mode])</code></td>
<td>卷积</td>
</tr>
<tr>
<td><code>convolve(a,v[,mode])</code></td>
<td>离散、线性卷积</td>
</tr>
<tr>
<td><code>cov(m[,y,rowvar,bias,ddof,fweights,...])</code></td>
<td>方差</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Array-Creation"><a href="#Array-Creation" class="headerlink" title="Array Creation"></a>Array Creation</h2><h3 id="Ones-and-Zeros"><a href="#Ones-and-Zeros" class="headerlink" title="Ones and Zeros"></a>Ones and Zeros</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>empty(shape[,dtype,order])</code></td>
<td>无初始化</td>
</tr>
<tr>
<td><code>empty_like(prototype[,dtype,order,subok,...])</code></td>
<td>shape、类型同<code>prototype</code></td>
</tr>
<tr>
<td><code>eye(N[,M,k,dtype,order])</code></td>
<td>对角为1的2D数组</td>
</tr>
<tr>
<td><code>identity(n[,dtype])</code></td>
<td>单位矩阵数组</td>
</tr>
<tr>
<td><code>ones(shape[,dtype,order])</code></td>
<td></td>
</tr>
<tr>
<td><code>ones_like(a[,dtype,order,subok,shape])</code></td>
<td></td>
</tr>
<tr>
<td><code>zeros(shape[,dtype,order])</code></td>
<td></td>
</tr>
<tr>
<td><code>zeros_like(a[,dtype,order,subok,shape])</code></td>
<td></td>
</tr>
<tr>
<td><code>full(shape,fill_value[,dtype,order])</code></td>
<td>全<code>full_value</code>数组</td>
</tr>
<tr>
<td><code>full_like(a,fill_value[,dtype,order,...])</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Numerical-Ranges"><a href="#Numerical-Ranges" class="headerlink" title="Numerical Ranges"></a>Numerical Ranges</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>arange([start,]stop[,step][,dtpye])</code></td>
<td>给定间距</td>
</tr>
<tr>
<td><code>linspace(start,stop[,num,endpoint])</code></td>
<td>给定数量，等差均分</td>
</tr>
<tr>
<td><code>geomspace(start,stop[,num,endpoint,base,...])</code></td>
<td>等比均分</td>
</tr>
<tr>
<td><code>logspace(start,stop[,num,endpoint,base,...])</code></td>
<td>在<em>log10</em>尺度上均分，同<code>np.power(10, np.linspace(start,stop))</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Repetition"><a href="#Repetition" class="headerlink" title="Repetition"></a>Repetition</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tile(A,reps)</code></td>
<td>重复<code>A</code>（可是数组）创建一维数组</td>
<td>无</td>
</tr>
<tr>
<td><code>repeat(a,repeats[,axis])</code></td>
<td>沿已有轴重复<code>a</code>创建</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Matrix-Relative"><a href="#Matrix-Relative" class="headerlink" title="Matrix-Relative"></a>Matrix-Relative</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>diag(v[,k])</code></td>
<td>从2维<code>v</code>抽取对角、或以1维<code>v</code>作为对角</td>
</tr>
<tr>
<td><code>diagflat(v[,k])</code></td>
<td></td>
</tr>
<tr>
<td><code>tri(N[,M,k,dtype])</code></td>
<td>对角线及以下为1、其余为0矩阵</td>
</tr>
<tr>
<td><code>tril(m[,k])</code></td>
<td>下三角</td>
</tr>
<tr>
<td><code>triu(m[,k])</code></td>
<td>上三角</td>
</tr>
<tr>
<td><code>vander(x[,N,increasing])</code></td>
<td>Vandermonde矩阵</td>
</tr>
</tbody>
</table>
</div>
<h3 id="From-Existing-Data"><a href="#From-Existing-Data" class="headerlink" title="From Existing Data"></a>From Existing Data</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>array(object[,dtype,copy,order,subok,ndmin])</code></td>
<td></td>
</tr>
<tr>
<td><code>copy(a[,order])</code></td>
<td></td>
</tr>
<tr>
<td><code>frombuffer(buffer[,dtype,count,offset]</code></td>
<td>从缓冲（如字节串）创建数组</td>
</tr>
<tr>
<td><code>fromfunction(function,shape,**kwargs)</code></td>
<td>以坐标为参数，从函数创建数组</td>
</tr>
<tr>
<td><code>fromiter(iterable,dtype[,count])</code></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<ul>
<li>改变数组数据类型也可以视为是创建新数组</li>
</ul>
</blockquote>
<h2 id="转入、转出"><a href="#转入、转出" class="headerlink" title="转入、转出"></a>转入、转出</h2><h3 id="类型转出"><a href="#类型转出" class="headerlink" title="类型转出"></a>类型转出</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.item(*args)</code></td>
<td>根据<code>args</code>选择元素复制至标准python标量</td>
</tr>
<tr>
<td><code>.tolist()</code></td>
<td>转换为<code>.ndim</code>层嵌套python标量列表</td>
</tr>
<tr>
<td><code>.itemset(*args)</code></td>
<td>插入元素（尝试转换类型）</td>
</tr>
<tr>
<td><code>.byteswap([inplace])</code></td>
<td>反转字节序</td>
</tr>
<tr>
<td><code>.view([dtype,type])</code></td>
<td>创建新视图</td>
</tr>
<tr>
<td><code>.getfield(dtype[,offset])</code></td>
<td>设置数据类型为指定类型</td>
</tr>
<tr>
<td><code>.setflags([write,align,uic])</code></td>
<td>设置标志</td>
</tr>
<tr>
<td><code>.fill(value)</code></td>
<td>使用标量填充</td>
</tr>
</tbody>
</table>
</div>
<h3 id="打包二进制"><a href="#打包二进制" class="headerlink" title="打包二进制"></a>打包二进制</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>packbits(a[,axis,bitorder])</code></td>
<td>元素打包为标志位，<code>0</code>补足，返回<code>uint8</code>数组</td>
</tr>
<tr>
<td><code>upackbits(a[,axis,bitorder])</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="输入、输出"><a href="#输入、输出" class="headerlink" title="输入、输出"></a>输入、输出</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>格式</th>
<th>输入</th>
<th>输出</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dump(file)</code></td>
<td>pickle</td>
<td>无</td>
<td>文件</td>
</tr>
<tr>
<td><code>tofile(fid[,sep,format])</code></td>
<td>内存内容（<code>sep=&quot;&quot;</code>）、分割符串</td>
<td>无</td>
<td>文件</td>
</tr>
<tr>
<td><code>fromfile(file[,dtype,count,sep,offset])</code></td>
<td>字节串、分割符串</td>
<td>文件</td>
<td>数组</td>
</tr>
<tr>
<td><code>save(file,arr[,allow_pickle,fix_imports])</code></td>
<td><code>.npy</code></td>
<td>数组</td>
<td>文件</td>
</tr>
<tr>
<td><code>savez(file,*args,**kwds)</code></td>
<td>非压缩的<code>.npz</code></td>
<td>（多个）数组</td>
<td>文件</td>
</tr>
<tr>
<td><code>savez_compressed(file,*args,**kwds)</code></td>
<td>压缩的<code>.npz</code></td>
<td>（多个）数组</td>
<td>无</td>
</tr>
<tr>
<td><code>load(file[,mmap_mode,allow_pickle,...])</code></td>
<td><code>.npy</code>、<code>.npz</code>、pickle</td>
<td>文件</td>
<td>数组</td>
</tr>
<tr>
<td><code>savetxt(fname,X[,fmt,delimiter,newline,...])</code></td>
<td>分割符串</td>
<td>二维以下数组</td>
<td>文件</td>
</tr>
<tr>
<td><code>loadtxt(fname[,dtype,comments,delimiter,...])</code></td>
<td>分割符串</td>
<td>文件</td>
<td>数组</td>
</tr>
<tr>
<td><code>genfromtxt(fname[,dtype,comments,...])</code></td>
<td>分割符串</td>
<td>文件</td>
<td>数组</td>
</tr>
<tr>
<td><code>fromregex(file,regexp,dtype[,encoding])</code></td>
<td>正则表达式结构</td>
<td>文件</td>
<td>数组</td>
</tr>
</tbody>
</table>
</div>
<h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>array2string(a[,max_line_width,precision,...])</code></td>
<td></td>
<td><code>__str__</code></td>
</tr>
<tr>
<td><code>array_repr(arr[,max_line_width,precision,...])</code></td>
<td></td>
<td><code>__repr__</code></td>
</tr>
<tr>
<td><code>array_str(arr[,max_line_width,precision,...])</code></td>
<td></td>
<td><code>__str__</code></td>
</tr>
<tr>
<td><code>dumps()</code></td>
<td>无</td>
<td>pickle序列化</td>
</tr>
<tr>
<td><code>loads(*args,**kwargs)</code></td>
<td>pickle</td>
<td>字节串</td>
<td>数组</td>
</tr>
<tr>
<td><code>tobytes([order])</code>/<code>tostring</code></td>
<td>内存内容字节串</td>
</tr>
<tr>
<td><code>fromstring(string[,dtype,count,sep])</code></td>
<td>从字符串、字节串（<code>sep=&quot;&quot;</code>，且缺省）创建1维数组</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>np.loads</code>即<code>pickle.loads</code>，不建议使用</li>
<li><code>np.fromstring</code><ul>
<li><code>sep=&quot;&quot;</code>：从二进制字节串中创建数组，类<code>frombuffer</code></li>
<li><code>sep</code>置为分割符时，只能指定一种元素分隔符，也只能
解析1维数组的字符串</li>
</ul>
</li>
</ul>
<h3 id="字符串输出格式"><a href="#字符串输出格式" class="headerlink" title="字符串输出格式"></a>字符串输出格式</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>format_float_positional(x[,precision,...])</code></td>
<td>格式化位置计数</td>
</tr>
<tr>
<td><code>format_float_scientific(x[,precision,...])</code></td>
<td>格式化科学计数</td>
</tr>
<tr>
<td><code>set_printoptions([precision,threshold,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>get_printoptions()</code></td>
<td></td>
</tr>
<tr>
<td><code>set_string_function(f[,repr])</code></td>
<td></td>
</tr>
<tr>
<td><code>printoptions(*args,**kwargs)</code></td>
<td>设置打印选项的上下文管理器</td>
</tr>
<tr>
<td><code>binary_repr(num[,width])</code></td>
<td>二进制字符串</td>
</tr>
<tr>
<td><code>base_repr(number[,base,padding])</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Data-Source"><a href="#Data-Source" class="headerlink" title="Data Source"></a>Data Source</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>DataSource([destpath])</code></td>
<td>通用数据源文件（file，http，ftp等）</td>
</tr>
</tbody>
</table>
</div>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-03-11T01:34:47.000Z" title="3/11/2021, 9:34:47 AM">2021-03-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-03-11T01:34:47.000Z" title="3/11/2021, 9:34:47 AM">2021-03-11</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Numpy/">Numpy</a></span><span class="level-item">8 minutes read (About 1151 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Numpy/ndarray_index.html">Numpy 索引</a></h1><div class="content"><h2 id="索引、切片"><a href="#索引、切片" class="headerlink" title="索引、切片"></a>索引、切片</h2><h3 id="基本切片、索引"><a href="#基本切片、索引" class="headerlink" title="基本切片、索引"></a>基本切片、索引</h3><ul>
<li><p>基本切片<code>[Slice]start:stop:step</code>（基本同原生类型切片）</p>
<ul>
<li><code>start</code>、<code>stop</code>负值时，按维度长取正模</li>
<li><code>step&gt;0</code>时，<code>start</code>缺省为<code>0</code>、<code>stop</code>缺省为维度长<code>N</code></li>
<li><code>step&lt;0</code>时，<code>start</code>缺省为<code>N-1</code>、<code>stop</code>缺省为<code>-N-1</code></li>
<li><code>stop</code>、<code>start</code>可以超过维度长<code>N</code></li>
</ul>
</li>
<li><p><code>Ellipsis</code>/<code>...</code>：放在切片中表示选择所有</p>
<ul>
<li><code>...</code>存在的场合，结果总是数组而不是数组标量，即使其
没有大小</li>
</ul>
</li>
<li><p><code>np.newaxis</code>/<code>None</code>：为切片生成数组在所在位置添加长度为
<code>1</code>的维度</p>
</li>
<li><p>切片可以用于设置数组中的值</p>
</li>
</ul>
<blockquote>
<ul>
<li>基本切片可认为是依次对各维度切片，若靠前维度为索引，则
  可以把靠前维度独立出来</li>
<li>基本切片生成的所有数组始终是原始数组的视图，也因此存在
  切片引用的数组内存不会被释放</li>
<li>注意：基本索引可用于改变数组的值，但是返回值不是对数组
  中对应值的引用</li>
</ul>
</blockquote>
<h3 id="高级索引"><a href="#高级索引" class="headerlink" title="高级索引"></a>高级索引</h3><ul>
<li><p>选择对象为以下类型时会触发高级索引</p>
<ul>
<li>非元组序列</li>
<li><code>ndarray</code>（整形或boolean类型）</li>
<li>包含至少一个序列、<code>ndarray</code>（整型或boolean类型）的
元组</li>
</ul>
</li>
<li><p>高级索引总是返回数据的<strong>副本</strong></p>
<ul>
<li>高级索引结果不能保证任何内存布局</li>
</ul>
</li>
</ul>
<h4 id="整数索引"><a href="#整数索引" class="headerlink" title="整数索引"></a>整数索引</h4><ul>
<li><p>整数索引<code>X[obj]</code>允许根据其各维度索引选择数组<code>X</code>任意元素</p>
<ul>
<li>各整数索引（数组）表示对应维度的索引</li>
<li>各维度索引迭代、连接得到各元素位置：<code>zip(obj*)</code></li>
<li>索引维数小于数组维数时，以子数组作为元素
（可以理解为索引和数组高维对齐后广播）</li>
</ul>
</li>
<li><p>整数索引结果shape由<code>obj</code>中各维度索引shape决定</p>
<ul>
<li>整数索引<code>obj</code>中各维度索引数组会被广播<ul>
<li>各维度索引shape可能不同</li>
<li>为保证各维度索引能正常迭代选取元素，各维度索引
shape需要能被广播、符合广播要求</li>
</ul>
</li>
<li>则高级索引出现场合<ul>
<li>“普通索引（标量值）”不存在，必然被广播</li>
<li>切片能够共存</li>
</ul>
</li>
</ul>
</li>
<li><p>切片（包括<code>np.newaxis</code>）和高级索引共存时</p>
<ul>
<li>高级索引特点导致其结果维度不可割<ul>
<li>“标量索引”本应削减该维度</li>
<li>而高级索引整体（广播后）决定唯一shape</li>
</ul>
</li>
<li>高级索引结果维度应整体参与结果构建<ul>
<li>高级索引被切片分割：高级索引结果维度整体提前</li>
<li>高级索引相邻：高级索引结果维度填充至该处</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>高级索引操作结果中无元素，但单个维度索引越界的错误未定义</li>
<li>高级索引结果内存布局对每个索引操作有优化，不能假设特定
  内存顺序</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">X = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]])</span><br><span class="line">rows = [<span class="number">0</span>, <span class="number">3</span>]</span><br><span class="line">cols = [<span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line"> <span class="comment"># 整数索引</span></span><br><span class="line">X[np.ix_(rows, cols)]</span><br><span class="line"> <span class="comment"># 整数索引数组</span></span><br><span class="line">X[[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>]],:]</span><br><span class="line">X.take([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>]], axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Boolean索引"><a href="#Boolean索引" class="headerlink" title="Boolean索引"></a>Boolean索引</h4><ul>
<li><p>Boolean索引<code>obj</code>选择其中<code>True</code>处位置对应元素</p>
<ul>
<li>索引<code>obj</code>维数较数组<code>X</code>小，直接抽取子数组作为元素
（可以理解为索引和数组高维对齐后广播）</li>
<li>索引<code>obj</code>在超出数组<code>X.shape</code>范围处有<code>True</code>值，会引发
索引错误</li>
<li>索引<code>obj</code>在<code>X.shape</code>内未填充处等同于填充<code>False</code></li>
</ul>
</li>
<li><p>Boolean索引通过<code>.nonezero</code>方法转换为高级整数索引实现</p>
<ul>
<li>Boolean索引等价于<code>True</code>数量长的1维整数索引<ul>
<li><code>X[..,bool_obj,..]</code>等价于
<code>X[..,bool_obj.nonzero(),..]</code></li>
<li>Boolean索引总是削减对应索引，展开为1维</li>
</ul>
</li>
<li>Boolean索引、高级整数索引共同存在场合行为诡异<ul>
<li>Boolean索引转换为等价的整数索引</li>
<li>整数索引需要广播兼容转换后整数索引</li>
<li>整数索引、转换后整数索引整体得到结果</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>索引<code>obj</code>和数组<code>X</code>形状相同计算速度更快</li>
</ul>
</blockquote>
<h3 id="字段名称形式访问"><a href="#字段名称形式访问" class="headerlink" title="字段名称形式访问"></a>字段名称形式访问</h3><ul>
<li><code>ndarray</code>中元素为结构化数据类型时，可以使用字符串索引
访问<ul>
<li>字段元素非子数组时<ul>
<li>其shape同原数组</li>
<li>仅包含该字段数据</li>
<li>数据类型为该字段数据类型</li>
</ul>
</li>
<li>字段元素为子数组时<ul>
<li>子数组shape会同原数组shape合并</li>
</ul>
</li>
<li>支持字符串列表形式访问<ul>
<li>返回数组视图而不是副本（Numpy1.6后）</li>
</ul>
</li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-02-20T00:40:31.000Z" title="2/20/2021, 8:40:31 AM">2021-02-20</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-02-20T00:40:31.000Z" title="2/20/2021, 8:40:31 AM">2021-02-20</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Numpy/">Numpy</a></span><span class="level-item">8 minutes read (About 1242 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Numpy/numpy_ufunc.html">Universal Functions</a></h1><div class="content"><h2 id="Universal-Functions"><a href="#Universal-Functions" class="headerlink" title="Universal Functions"></a>Universal Functions</h2><ul>
<li><p><em>UFunc</em>：在数组上执行逐元素运算函数</p>
<ul>
<li>支持广播、类型映射等</li>
<li>可视为是函数的向量化包装</li>
<li>基本<em>ufunc</em>在标量上执行操作，更泛化的<em>ufunc</em>也可以
在以子数组为基本元素进行操作</li>
</ul>
</li>
<li><p>numpy中的<em>ufunc</em>是<code>np.ufunc</code>的实例</p>
<ul>
<li>许多内建的<em>ufunc</em>是通过C编译实现的</li>
<li>可以通过<code>np.frompyfunc</code>工厂方法自定义<em>ufunc</em>实例</li>
<li>numpy中包含超过60种<em>ufunc</em><ul>
<li>部分<em>ufunc</em>在相关运算标记调用时，会被自动调用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="内部缓冲"><a href="#内部缓冲" class="headerlink" title="内部缓冲"></a>内部缓冲</h3><ul>
<li>Internal Buffers<ul>
<li>用于数据非对齐、数据交换、数据类型转换场合</li>
<li><code>.setbufsize(size)</code>：基于线程设置内部缓冲，缺省为
<code>10,000</code>元素</li>
</ul>
</li>
</ul>
<h3 id="类型转换规则"><a href="#类型转换规则" class="headerlink" title="类型转换规则"></a>类型转换规则</h3><ul>
<li><p>各<em>ufunc</em>内部维护列表，给出适用的输入类型（组合）、
相应的输出类型
（可通过<code>.types</code>属性查看）</p>
</li>
<li><p>当<em>ufunc</em>内部列表中没有给定的输入类型组合时，则需要
进行safely类型转换
（可通过<code>np.can_cast</code>函数判断）</p>
<ul>
<li><code>&quot;S&quot;, &quot;U&quot;, &quot;V&quot;</code>类型不能支持<em>ufunc</em>运算</li>
<li>标量-数组操作使用不同类型转换规则确保标量不会降低
数组精度，除非标量和数组属于同一类型体系</li>
</ul>
</li>
</ul>
<h3 id="UFunc维度说明"><a href="#UFunc维度说明" class="headerlink" title="UFunc维度说明"></a>UFunc维度说明</h3><ul>
<li><p><em>core dimension</em>：核心维度，<em>ufunc</em>执行操作所在的维度</p>
<ul>
<li>核心维度一般使用元组表示<ul>
<li>对一般<em>ufunc</em>：核心维度为空元组</li>
<li>对广义<em>ufunc</em>：核心维度为非空元组、空元组</li>
</ul>
</li>
<li><em>signature</em>：签名，包含<em>ufunc</em>涉及的输出操作数和输出
操作数的核心维度字符串，如：<code>(i,),(j,)-&gt;()</code></li>
<li>签名中各输入操作数的对应核心维度大小必须相同，移除后
剩余的循环维度共同广播，加上输出操作数的核心维度得到
输出结果shape</li>
</ul>
</li>
<li><p><em>loop dimension</em>：循环维度，除核心维度之外的维度</p>
</li>
</ul>
<blockquote>
<ul>
<li>这些术语来自<em>Perl Vector Library</em></li>
<li><a target="_blank" rel="noopener" href="https://numpy.org/doc/1.17/reference/c-api.generalized-ufuncs.html">https://numpy.org/doc/1.17/reference/c-api.generalized-ufuncs.html</a></li>
</ul>
</blockquote>
<h3 id="UFunc原型"><a href="#UFunc原型" class="headerlink" title="UFunc原型"></a>UFunc原型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NDA = <span class="function"><span class="keyword">def</span> <span class="title">numpy</span>.&lt;<span class="title">ufunc</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">	x1 [,x2], /,</span></span></span><br><span class="line"><span class="params"><span class="function">	[out1, out2,], out, *,</span></span></span><br><span class="line"><span class="params"><span class="function">	where=<span class="literal">True</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	casting=<span class="string">&quot;same_kind&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	order=<span class="string">&quot;K&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	dtype=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	subok=<span class="literal">True</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	[signature, extobj]</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>where=True/False/Array[bool]</code></p>
<ul>
<li>此参数不用于对子数组做操作的广义<em>ufunc</em></li>
</ul>
</li>
<li><p><code>keepdims=False/True</code></p>
<ul>
<li>对广义<em>ufunc</em>，只在输入操作数上有相同数量核心维度、
输出操作数没有核心维度（即返回标量）时使用</li>
</ul>
</li>
<li><p><code>axes=tuple/int</code></p>
<ul>
<li>含义：广义<em>ufunc</em>执行操作、存储结果所在的轴序号<ul>
<li><code>[tuple]</code>：各元组为各输入操作数应被执行操作、
输出操作数存储结果的轴的序号</li>
<li><code>[int]</code>：广义<em>ufunc</em>在1维向量上执行操作时，可以
直接使用整形</li>
</ul>
</li>
<li>若广义<em>ufunc</em>的输出操作数均为标量，可省略其对应元组</li>
</ul>
</li>
<li><p><code>axis=int</code></p>
<ul>
<li>含义：广义<em>ufunc</em>执行操作所在的single轴序号<ul>
<li><code>int</code>：广义<em>ufunc</em>在相同的轴<code>axis</code>上执行操作，
等价于<code>axes=[(axis,),(axis,),...]</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>signature=np.dtype/tuple[np.dtype]/str</code></p>
<ul>
<li>含义：指示<em>ufunc</em>的输入、输出的数据类型，</li>
<li>对于底层计算1维loop，是通过比较输入的数据类型，找到
让所有输入都能安全转换的数据类型<ul>
<li>此参数允许绕过查找，直接指定loop</li>
</ul>
</li>
<li>可通过<code>ufunc.types</code>属性查看可用的signature列表</li>
</ul>
</li>
<li><p><code>extobj=list</code></p>
<ul>
<li>含义：指定<em>ufunc</em>的缓冲大小、错误模式整数、错误处理
回调函数<ul>
<li><code>list</code>：长度为1、或2、或3的列表</li>
</ul>
</li>
<li>默认这些值会在对应线程字典中查找，此参数可以通过更
底层的控制<ul>
<li>可优化在小数组上大量<em>ufunc</em>的调用</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>部分参数含义通用，参见<em>README</em></li>
</ul>
</blockquote>
<h3 id="UFunc属性"><a href="#UFunc属性" class="headerlink" title="UFunc属性"></a>UFunc属性</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Attr</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ufunc.nin</code></td>
<td>输入数量</td>
</tr>
<tr>
<td><code>ufunc.nout</code></td>
<td>输出数量</td>
</tr>
<tr>
<td><code>ufunc.nargs</code></td>
<td>参数数量</td>
</tr>
<tr>
<td><code>ufunc.ntypes</code></td>
<td>类型数量</td>
</tr>
<tr>
<td><code>ufunc.types</code></td>
<td><em>input-&gt;output</em>列表</td>
</tr>
<tr>
<td><code>ufunc.identity</code></td>
<td>标志值</td>
</tr>
<tr>
<td><code>ufunc.signature</code></td>
<td>广义<em>ufunc</em>执行操作所在的核心元素的定义</td>
</tr>
</tbody>
</table>
</div>
<h3 id="UFunc方法"><a href="#UFunc方法" class="headerlink" title="UFunc方法"></a>UFunc方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Method</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ufunc.reduce(a[,axis,dtype,out,...])</code></td>
<td>通过沿轴应用<em>ufunc</em>缩减维度</td>
</tr>
<tr>
<td><code>ufunc.accumulate(array[,axis,dtype,out])</code></td>
<td>累加所有元素的计算结果</td>
</tr>
<tr>
<td><code>ufunc.reduceat(a,indice[,axis,dtype,out])</code></td>
<td>在single轴指定切片上执行reduce</td>
</tr>
<tr>
<td><code>ufunc.outer(A,B,**kwargs)</code></td>
<td>在分属<code>A,B</code>的元素对上应用<em>ufunc</em></td>
</tr>
<tr>
<td><code>ufunc.at(a,indices[,b])</code></td>
<td>在<code>indices</code>处在位无缓冲执行操作</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>所有<em>ufunc</em>都有4个方法，但是这些方法只在标量<em>ufunc</em>、
包含2输入参数、1输出参数里有价值，否则导致<code>ValueError</code></li>
</ul>
<h2 id="UFunc相关函数"><a href="#UFunc相关函数" class="headerlink" title="UFunc相关函数"></a><em>UFunc</em>相关函数</h2><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>apply_along_axis(func1d,axis,arr,*args,...)</code></td>
<td>沿给定轴应用函数</td>
</tr>
<tr>
<td><code>apply_over_axes(func,a,axes)</code></td>
<td>依次沿给定轴应用函数<code>func(a,axis)</code></td>
</tr>
<tr>
<td><code>frompyfunc(func,nin,nout[,identity])</code></td>
<td>创建ufunc，指定输入、输出数量</td>
</tr>
<tr>
<td><code>vertorize(pyfunc[,otypes,doc,excluded,cache,signature])</code></td>
<td>创建ufunc，较<code>frompyfunc</code>提供更多特性</td>
</tr>
<tr>
<td><code>piecewise(x,condlist,funclist,*args,**kw)</code></td>
<td>按照<code>condlist</code>中索引，对应应用<code>funclist</code>中函数</td>
</tr>
</tbody>
</table>
</div>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-02-19T01:02:01.000Z" title="2/19/2021, 9:02:01 AM">2021-02-19</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-02-19T01:02:01.000Z" title="2/19/2021, 9:02:01 AM">2021-02-19</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Numpy/">Numpy</a></span><span class="level-item">5 minutes read (About 801 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Numpy/ndarray_interface.html">NDArray开发</a></h1><div class="content"><h2 id="NDArray-Interface-Protocol"><a href="#NDArray-Interface-Protocol" class="headerlink" title="NDArray Interface/Protocol"></a>NDArray Interface/Protocol</h2><ul>
<li>数组接口（规范）：为重用数据缓冲区设计的规范<ul>
<li>接口描述内容<ul>
<li>获取<code>ndarray</code>内容的方式</li>
<li>数组需为同质数组，即其中各元素数据类型相同</li>
</ul>
</li>
<li>接口包含C和Python两个部分<ul>
<li>Python-API：对象应包含属性<code>__array_interface__</code>字典</li>
<li>C-API：结构体<code>__array_struct__</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.numpy.org.cn/en/reference/arrays/interface.html#python-side">https://www.numpy.org.cn/en/reference/arrays/interface.html#python-side</a></p>
<h3 id="Python-API"><a href="#Python-API" class="headerlink" title="Python API"></a>Python API</h3><blockquote>
<ul>
<li><code>__array_interface__</code>：由3个必须字段和5个可选字段构成</li>
</ul>
</blockquote>
<ul>
<li><p><code>shape</code>：各维度长度（使用时注意取值范围）</p>
</li>
<li><p><code>typestr</code>：指明同质数组数据类型的字符串</p>
<ul>
<li>格式、含义基本同<em>Array-Protocol</em>，但有部分字符
含义不同</li>
<li>但不同于自定义数据类型字符串，不指定结构化数据、
shape，非基本类型就是<code>void</code>，具体含义由<code>descr</code>
给出</li>
</ul>
<p>|代码|类型|
|——-|——-|
|<code>&#39;t&#39;</code>|bit|
|<code>&#39;b&#39;</code>|boolean|
|<code>&#39;B&#39;</code>|unsigned byte|
|<code>&#39;i&#39;</code>|(signed) integer|
|<code>&#39;u&#39;</code>|unsigned integer|
|<code>&#39;f&#39;</code>|floating-point|
|<code>&#39;c&#39;</code>|complex-floating point|
|<code>&#39;m&#39;</code>|timedelta|
|<code>&#39;M&#39;</code>|datetime|
|<code>&#39;O&#39;</code>|(Python) objects|
|<code>&#39;S&#39;</code>/<code>&#39;a&#39;</code>|zero-terminated bytes (not recommended)|
|<code>&#39;U&#39;</code>|Unicode string|
|<code>&#39;V&#39;</code>|raw data (void)|</p>
</li>
<li><p><code>descr</code>：给出同质数组中各元素中内存布局的详细描述的
列表</p>
<ul>
<li>各元素为包含2、3个元素的元组<ul>
<li>名称：字符串、或<code>(&lt;fullname&gt;,&lt;basicname&gt;)</code>
形式的元组</li>
<li>类型：描述基础类型字符串、或嵌套列表</li>
<li>shape：该结构的重复次数，若没有给出则表示无
重复</li>
</ul>
</li>
<li>一般此属性在<code>typestr</code>为取值为<code>V[0-9]+</code>时使用，
要求表示的内存字节数相同</li>
<li>缺省为<code>[(&#39;&#39;), typestr]</code></li>
</ul>
</li>
<li><p><code>data</code>：给出数据位置的2元素元组或暴露有缓冲接口
的对象</p>
<ul>
<li>元组首个元素：表示存储数组内容的数据区域，指向
数据中首个元素（即<code>offset</code>被忽略）</li>
<li>元素第二个元素：只读标记</li>
<li>缺省为<code>None</code>，表示内存共享通过缓冲接口自身实现，
此时<code>offset</code>用于指示缓冲的开始</li>
</ul>
</li>
<li><p><code>strides</code>：存储各维度跃迁的strides的元组</p>
<ul>
<li>元组各元素为各维度跃迁字节数整形值，注意取值范围</li>
<li>缺省为<code>None</code>，C-contiguous风格</li>
</ul>
</li>
<li><p><code>mask</code>：指示数据是否有效的暴露有缓冲接口的对象</p>
<ul>
<li>其shape需要同原始数据shape广播兼容</li>
<li>缺省为<code>None</code>，表示所有数据均有效</li>
</ul>
</li>
<li><p><code>offset</code>：指示数组数据区域offset的整形值</p>
<ul>
<li>仅在数据为<code>None</code>或为<code>buffer</code>对象时使用</li>
<li>缺省为<code>0</code></li>
</ul>
</li>
<li><p><code>version</code>：指示接口版本</p>
</li>
</ul>
<h3 id="C-API"><a href="#C-API" class="headerlink" title="C API"></a>C API</h3><ul>
<li><p><code>__array_struct__</code>：ctype的<code>PyCObject</code>，其中<code>voidptr</code>
指向<code>PyArrayInterface</code></p>
<ul>
<li><code>PyCObject</code>内存空间动态分配</li>
<li><code>PyArrayInterface</code>有相应的析构，访问其之后需要在其上
调用<code>Py_DECREF</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> two;				<span class="comment">// 值为2，sanity check</span></span><br><span class="line">	<span class="keyword">int</span> nd;					<span class="comment">// 维数</span></span><br><span class="line">	<span class="keyword">char</span> typekind;			<span class="comment">// 数组中数据类型</span></span><br><span class="line">	<span class="keyword">int</span> itemsize;			<span class="comment">// 数据类型size</span></span><br><span class="line">	<span class="keyword">int</span> flags;				<span class="comment">// 指示如何解释数据的标志</span></span><br><span class="line">							<span class="comment">// 5bits指示数据解释的5个标志位</span></span><br><span class="line">								<span class="comment">// `CONTIGUOUS`	0x01</span></span><br><span class="line">								<span class="comment">// `FROTRAN`	0x02</span></span><br><span class="line">								<span class="comment">// `ALIGNED`	0x100</span></span><br><span class="line">								<span class="comment">// `NOTSWAPPED` 0x200</span></span><br><span class="line">								<span class="comment">// `WRITABLE`	0X400</span></span><br><span class="line">							<span class="comment">// 1bit指示接口解释（是否包含有效`descr`字段）</span></span><br><span class="line">								<span class="comment">// `ARR_HAS_DESCR` 0x800</span></span><br><span class="line">	Py_intptr_t *shape;		<span class="comment">// shape</span></span><br><span class="line">	Py_intptr_t *strides;	<span class="comment">// strides</span></span><br><span class="line">	<span class="keyword">void</span> *data;				<span class="comment">// 指向数组中首个元素</span></span><br><span class="line">	PyObject *descr;		<span class="comment">// NULL或数据描述（需设置`flags`中的`ARR_HAS_DESCR`，否则被忽略）</span></span><br><span class="line">&#125; PyArrayInterface;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-02-18T09:10:18.000Z" title="2/18/2021, 5:10:18 PM">2021-02-18</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-02-18T09:10:18.000Z" title="2/18/2021, 5:10:18 PM">2021-02-18</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Numpy/">Numpy</a></span><span class="level-item">21 minutes read (About 3088 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Numpy/ndarray_derived.html">NDArray子类</a></h1><div class="content"><h2 id="子类相关钩子属性、方法"><a href="#子类相关钩子属性、方法" class="headerlink" title="子类相关钩子属性、方法"></a>子类相关钩子属性、方法</h2><h3 id="array-方法"><a href="#array-方法" class="headerlink" title="__array__方法"></a><code>__array__</code>方法</h3><ul>
<li><p><code>class.__array_ufunc__(ufunc, method, *inputs, **kwargs)</code></p>
<ul>
<li>功能：供自定义以覆盖numpy中ufunc行为<ul>
<li>返回操作结果，或<code>NotImplemented</code>
（将此方法置<code>None</code>）</li>
</ul>
</li>
<li>参数<ul>
<li><code>ufunc</code>：被调用的ufunc对象</li>
<li><code>method</code>：字符串，指示调用的<code>ufunc</code>对象的方法</li>
<li><code>inputs</code>：<code>ufunc</code>顺序参数元组</li>
<li><code>kwargs</code>：<code>ufunc</code>关键字参数字典</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><em>Ufunc</em>、与<code>__array_ufunc__</code>关系参见ufunc部分</li>
</ul>
</blockquote>
</li>
<li><p><code>class.__array_function__(func,types,args,kwargs)</code></p>
<ul>
<li>参数<ul>
<li><code>func</code>：任意callable，以<code>func(*args, **kwargs)</code>
形式调用</li>
<li><code>types</code>：来自实现`</li>
<li><code>args</code>、<code>kwargs</code>：原始调用的参数</li>
</ul>
</li>
</ul>
</li>
<li><p><code>class.__array__finalize(obj)</code></p>
<ul>
<li>功能：构造之后更改<code>self</code>的属性<ul>
<li>在为<code>obj</code>类型数组分配空间时调用</li>
</ul>
</li>
<li>参数<ul>
<li><code>obj</code>：<code>ndarray</code>子类</li>
</ul>
</li>
</ul>
</li>
<li><p><code>class.__array_prepare__(array,context=None)</code></p>
<ul>
<li>功能：在ufunc计算前，将ouput数组转换为子类实例、
更新元数据<ul>
<li>调用任何ufunc前，在最高优先级的input数组，或指定
的output数组上调用，返回结果传递给ufunc</li>
<li>默认实现：保持原样</li>
</ul>
</li>
</ul>
</li>
<li><p><code>class.__array_wrap__(array,context=None)</code></p>
<ul>
<li>功能：在将结果返回给用户前，将output数组转换为子类
实例、更新元信息<ul>
<li>ufunc计算结果返回给用户前，在最高优先级的output
数组、或指定output对象上调用</li>
<li>默认实现：将数组转换为新</li>
</ul>
</li>
</ul>
</li>
<li><p><code>class.__array__([dtype])</code></p>
<ul>
<li>功能：若output对象有该方法，ufunc结果将被写入其
返回值中</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>若ufunc中所有<code>__array_ufunc__</code>返回<code>NotImplemented</code>，那么
  <code>raise TypeError</code></li>
</ul>
</blockquote>
<h3 id="array-属性"><a href="#array-属性" class="headerlink" title="__array__属性"></a><code>__array__</code>属性</h3><ul>
<li><code>class.__array_priority__</code><ul>
<li>功能：决定返回对象的数据类型（有多种可能性时）<ul>
<li>默认值：<code>0.0</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Matrix"><a href="#Matrix" class="headerlink" title="Matrix"></a>Matrix</h2><h3 id="np-matrix"><a href="#np-matrix" class="headerlink" title="np.matrix"></a><code>np.matrix</code></h3><p>Matrix对象：继承自<code>ndarray</code>，具有<code>ndarray</code>的属性、方法</p>
<ul>
<li>Matrix对象的特殊行为<ul>
<li>维数始终为2<ul>
<li><code>.ravel()</code>仍然二维</li>
<li><em>item selection</em>返回二维对象</li>
</ul>
</li>
<li>数学操作<ul>
<li>覆盖乘法为矩阵乘法</li>
<li>覆盖幂次为矩阵幂次</li>
</ul>
</li>
<li>属性<ul>
<li>默认<code>__array_priority__</code>为<code>10.0</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>Matrix类被设计用于与<code>scipy.sparse</code>交互，建议不使用</li>
<li><code>np.mat</code>是<code>np.matrix</code>别名</li>
</ul>
</blockquote>
<h4 id="Matrix对象property属性"><a href="#Matrix对象property属性" class="headerlink" title="Matrix对象property属性"></a>Matrix对象property属性</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Property</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>matrix.T</code></td>
<td>转置</td>
</tr>
<tr>
<td><code>matrix.H</code></td>
<td>复数共轭</td>
</tr>
<tr>
<td><code>matrix.I</code></td>
<td>逆矩阵</td>
</tr>
<tr>
<td><code>matrix.A</code></td>
<td>返回<code>ndarray</code></td>
</tr>
</tbody>
</table>
</div>
<h4 id="Matrix创建"><a href="#Matrix创建" class="headerlink" title="Matrix创建"></a>Matrix创建</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>np.mat(data[,dtype])</code></td>
<td>创建矩阵</td>
</tr>
<tr>
<td><code>np.matrix(data[,dtype,copy])</code></td>
<td>不建议使用</td>
</tr>
<tr>
<td><code>np.asmatrix(data[,dtype])</code></td>
<td>将数据转换为矩阵</td>
</tr>
<tr>
<td><code>np.bmat(obj[,ldict,gdict])</code></td>
<td>从字符串、嵌套序列、数组中构建</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>mp.bmat</code>：可使用Matlab样式字符串表示法创建Matrix<ul>
<li>空格分割列</li>
<li><code>;</code>分割行</li>
</ul>
</li>
</ul>
<h3 id="np-matlib"><a href="#np-matlib" class="headerlink" title="np.matlib"></a><code>np.matlib</code></h3><ul>
<li><code>numpy.matlib</code>模块中包含<code>numpy</code>命名空间下所有函数<ul>
<li>返回<code>matrix</code>而不是<code>ndarray</code></li>
<li><code>matrix</code>被限制为小于2维，会改变形状的函数可能无法
得到预期结果</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><code>np.matlib</code>是为了方便矩阵运算的模块</li>
</ul>
</blockquote>
<h2 id="np-char"><a href="#np-char" class="headerlink" title="np.char"></a><code>np.char</code></h2><h3 id="np-chararray"><a href="#np-chararray" class="headerlink" title="np.chararray"></a><code>np.chararray</code></h3><ul>
<li><code>np.chararray</code>类：<code>string_</code>、<code>unicode_</code>数据类型的增强型
数组，继承自<code>ndarray</code><ul>
<li>继承由<em>Numarray</em>引入的特性：项检索和比较操作中，数组
元素末尾空格被忽略</li>
<li>定义有基于元素的<code>+</code>、<code>*</code>、<code>%</code>的操作</li>
<li>具有所有标准<code>string</code>、<code>unicode</code>方法，可以逐元素执行</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>char.array(obj[,itemsize,...])</code></td>
<td></td>
</tr>
<tr>
<td><code>char.asarray(obj[,itemsize,...])</code></td>
<td>转换输入为<code>chararray</code>，必要时复制数据</td>
</tr>
<tr>
<td><code>chararray(shape[,itemsize,unicode,...])</code></td>
<td>不应直接使用此构造函数</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<ul>
<li><code>np.chararray</code>类是为了后向兼容<em>Numarray</em>，建议使用
  <code>object_</code>、<code>string_</code>、<code>unicode_</code>类型的数组替代，并利用
  <code>numpy.char</code>模块的自由函数用于字符串快速向量化操作</li>
</ul>
</blockquote>
<h3 id="NDArray-Char-Routine"><a href="#NDArray-Char-Routine" class="headerlink" title="NDArray Char Routine"></a>NDArray Char Routine</h3><ul>
<li><code>np.char</code>/<code>np.core.defchararray</code>模块为<code>np.string_</code>、
<code>np.unicode_</code>类型的数组提供向量化的字符串操作<ul>
<li>基于标准库中<code>string</code>、<code>unicode</code>的方法</li>
</ul>
</li>
</ul>
<h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>char.add(x1,x2)</code></td>
<td></td>
</tr>
<tr>
<td><code>char.multiply(a,i)</code></td>
<td></td>
</tr>
<tr>
<td><code>char.mod(a,values)</code></td>
<td><code>%</code>格式化（<code>str.__mod__</code>为<code>%</code>调用方法）</td>
</tr>
<tr>
<td><code>char.capialize(a)</code></td>
<td>首字符大写</td>
</tr>
<tr>
<td><code>char.title(a)</code></td>
<td>单词首字符大写</td>
</tr>
<tr>
<td><code>char.center(a,width[,fillchar])</code></td>
<td><code>a</code>居中、<code>fillchar</code>填充字符串</td>
</tr>
<tr>
<td><code>char.ljust(a,width(,fillchar))</code></td>
<td><code>a</code>靠左</td>
</tr>
<tr>
<td><code>char.rjust(a,width(,fillchar))</code></td>
<td><code>a</code>靠左</td>
</tr>
<tr>
<td><code>char.zfill(a,width)</code></td>
<td><code>0</code>填充左侧</td>
</tr>
<tr>
<td><code>char.char.decode(a[,encoding,errors])</code></td>
<td></td>
</tr>
<tr>
<td><code>char.char.encode(a[,encoding,errors])</code></td>
<td></td>
</tr>
<tr>
<td><code>char.char.expandtabs(a[,tabsize])</code></td>
<td>替换tab为空格</td>
</tr>
<tr>
<td><code>char.join(sep, seq)</code></td>
<td></td>
</tr>
<tr>
<td><code>char.lower(a)</code></td>
<td></td>
</tr>
<tr>
<td><code>char.upper(a)</code></td>
<td></td>
</tr>
<tr>
<td><code>char.swapcase(a)</code></td>
<td></td>
</tr>
<tr>
<td><code>char.strip(a[,chars])</code></td>
<td></td>
</tr>
<tr>
<td><code>char.lstrip(a[,chars])</code></td>
<td></td>
</tr>
<tr>
<td><code>char.rstrip(a[,chars])</code></td>
<td></td>
</tr>
<tr>
<td><code>char.partition(a,sep)</code></td>
<td>从左至右切分一次，返回三元组</td>
</tr>
<tr>
<td><code>char.rpartition(a,sep)</code></td>
<td>从右至左切分一次</td>
</tr>
<tr>
<td><code>char.split(a[,sep,maxsplit])</code></td>
<td>从左至右切分<code>maxsplit</code>次，返回列表</td>
</tr>
<tr>
<td><code>char.rsplit(a[,sep,maxsplit])</code></td>
<td></td>
</tr>
<tr>
<td><code>char.splitlines(a[,keepends])</code></td>
<td>切分行，即<code>\n</code>为切分点</td>
</tr>
<tr>
<td><code>char.replace(a,old,new[,count])</code></td>
</tr>
</tbody>
</table>
</div>
<h4 id="Camparison"><a href="#Camparison" class="headerlink" title="Camparison"></a>Camparison</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>equal(x1,x2)</code></td>
<td></td>
</tr>
<tr>
<td><code>greater(x1,x2)</code></td>
<td></td>
</tr>
<tr>
<td><code>less(x1,x2)</code></td>
<td></td>
</tr>
<tr>
<td><code>not_equal(x1,x2)</code></td>
<td></td>
</tr>
<tr>
<td><code>greater_equal(x1,x2)</code></td>
<td></td>
</tr>
<tr>
<td><code>less_equal(x1,x2)</code></td>
<td></td>
</tr>
<tr>
<td><code>compare_chararrays(a,b,com_op,rstrip)</code></td>
<td><code>com_op</code>指定比较方法</td>
</tr>
</tbody>
</table>
</div>
<h4 id="字符串信息"><a href="#字符串信息" class="headerlink" title="字符串信息"></a>字符串信息</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>count(a,sub[,start,end])</code></td>
<td>统计不重叠<code>sub</code>出现次数</td>
</tr>
<tr>
<td><code>startwith(a,prefix[,start,end])</code></td>
<td></td>
</tr>
<tr>
<td><code>endswith(a,suffix[,start,end])</code></td>
<td></td>
</tr>
<tr>
<td><code>find(a,sub[,start,end])</code></td>
<td>返回首个<code>sub</code>位置，不存在返回<code>-1</code></td>
</tr>
<tr>
<td><code>rfind(a,sub[,start,end])</code></td>
<td>从右至左<code>find</code></td>
</tr>
<tr>
<td><code>index(a,sub[,start,end])</code></td>
<td>同<code>find</code>，不存在<code>ValueError</code></td>
</tr>
<tr>
<td><code>rindex(a,sub[,start,end])</code></td>
<td>从右至左<code>index</code></td>
</tr>
<tr>
<td><code>isalpha(a)</code></td>
<td></td>
</tr>
<tr>
<td><code>iaalnum(a)</code></td>
<td></td>
</tr>
<tr>
<td><code>isdecimal(a)</code></td>
<td></td>
</tr>
<tr>
<td><code>isdigit(a)</code></td>
<td></td>
</tr>
<tr>
<td><code>islower(a)</code></td>
<td></td>
</tr>
<tr>
<td><code>isnumeric(a)</code></td>
<td></td>
</tr>
<tr>
<td><code>isspace(a)</code></td>
<td></td>
</tr>
<tr>
<td><code>istitle(a)</code></td>
<td>是否各单词首字符大写</td>
</tr>
<tr>
<td><code>isupper(a)</code></td>
<td></td>
</tr>
<tr>
<td><code>str_len(a)</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="np-rec"><a href="#np-rec" class="headerlink" title="np.rec"></a><code>np.rec</code></h2><ul>
<li><code>np.rec</code>/<code>np.core.records</code></li>
</ul>
<h3 id="np-recarray"><a href="#np-recarray" class="headerlink" title="np.recarray"></a><code>np.recarray</code></h3><ul>
<li><code>np.recarray</code>类：允许将结构化数组的字段作为属性访问</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>np.recarray</code></td>
<td>创建允许属性访问字段的<code>ndarray</code></td>
</tr>
<tr>
<td><code>np.record</code></td>
<td>允许使用属性查找字段的数据类型标量</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Record-Arrays"><a href="#Record-Arrays" class="headerlink" title="Record Arrays"></a>Record Arrays</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>core.records.array(obj[,dtype,shape,...])</code></td>
<td>从多类型对象中创建</td>
</tr>
<tr>
<td><code>core.records.fromarrays(arrayList[,dtype,...])</code></td>
<td>从数组列表中创建</td>
</tr>
<tr>
<td><code>core.records.fromrecords(recList[,dtype])</code></td>
<td>从文本格式的records列表创建</td>
</tr>
<tr>
<td><code>core.records.fromstring(datastring[,dtype,...])</code></td>
<td>从二进制数据字符串中创建只读</td>
</tr>
<tr>
<td><code>core.records.fromfile(fd[,dtype,shape,...])</code></td>
<td>从二进制文件中创建</td>
</tr>
</tbody>
</table>
</div>
<h2 id="np-ma"><a href="#np-ma" class="headerlink" title="np.ma"></a><code>np.ma</code></h2><h3 id="ma-MaskedArray"><a href="#ma-MaskedArray" class="headerlink" title="ma.MaskedArray"></a><code>ma.MaskedArray</code></h3><ul>
<li><p><code>ma.MaskedArray</code>：掩码数组，是<code>np.ma</code>核心，<code>ndarray</code>子类</p>
<ul>
<li><code>ma.MaskedArray</code>由标准<code>np.ndarray</code>和掩码组成</li>
</ul>
</li>
<li><p>掩码数组<code>.mask</code></p>
<ul>
<li>掩码可以被设置为<em>hardmask</em>、<em>softmask</em>，由只读属性
<code>hardmask</code>指定<ul>
<li><em>hardmask</em>：无法修改被遮蔽值</li>
<li><em>softmask</em>：可修改被遮蔽值，并恢复被遮蔽状态</li>
</ul>
</li>
<li><code>.mask</code>可以被设置<ul>
<li>为bool数组，指示各位置元素是否被遮蔽</li>
<li><code>ma.maskded/ma.unmask/True/False</code>，设置掩码数组
整体是被遮蔽</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><code>ma.nomask</code>是<code>np.bool_</code>类型的<code>False</code>，<code>ma.masked</code>是特殊
  常数</li>
<li><p><code>ma.MaskType</code>是<code>np.bool_</code>别名</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.numpy.org.cn/reference/arrays/maskedarray.html">https://www.numpy.org.cn/reference/arrays/maskedarray.html</a></p>
</li>
<li><a target="_blank" rel="noopener" href="https://www.numpy.org.cn/reference/routines/ma.html">https://www.numpy.org.cn/reference/routines/ma.html</a></li>
</ul>
</blockquote>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Attr</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.hardmask</code></td>
<td>硬掩码标志</td>
</tr>
<tr>
<td><code>.data</code></td>
<td>值数组</td>
</tr>
<tr>
<td><code>.mask</code></td>
<td>掩码数组、<code>ma.unmask</code>、<code>ma.masked</code></td>
</tr>
<tr>
<td><code>.recordmask</code></td>
<td>项目中命名字段全遮蔽则遮蔽</td>
</tr>
</tbody>
</table>
</div>
<h4 id="创建掩码数组"><a href="#创建掩码数组" class="headerlink" title="创建掩码数组"></a>创建掩码数组</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ma.MaskedArray(data[,mask,dtype,...])</code></td>
<td>类</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.masked_array(data[,mask,dtype,...])</code></td>
<td><code>MaskedArray</code>别名</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.array(data[,dtype,copy,...])</code></td>
<td>构造函数</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.frombuffer(buffer[,dtype,count,offset])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.fromfunction(function,shape,dtype)</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.fromflex(fxarray)</code></td>
<td>从有<code>_data</code>、<code>_mask</code>字段的结构化<code>fxarray</code>中创建</td>
<td>无</td>
</tr>
<tr>
<td><code>copy(a[,order])</code></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h5 id="Ones-and-Zeros"><a href="#Ones-and-Zeros" class="headerlink" title="Ones and Zeros"></a>Ones and Zeros</h5><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ma.empty(shape[,dtype,order])</code></td>
<td>无初始化</td>
</tr>
<tr>
<td><code>ma.empty_like(prototype[,dtype,order,subok,...])</code></td>
<td>shape、类型同<code>prototype</code></td>
</tr>
<tr>
<td><code>ma.ones(shape[,dtype,order])</code></td>
<td></td>
</tr>
<tr>
<td><code>ma.zeros(shape[,dtype,order])</code></td>
<td></td>
</tr>
<tr>
<td><code>ma.masked_all(shape[,dtype])</code></td>
<td>所有元素被屏蔽</td>
</tr>
<tr>
<td><code>ma.masked_all_like(shape[,dtype])</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="MaskedArray-Routine"><a href="#MaskedArray-Routine" class="headerlink" title="MaskedArray Routine"></a>MaskedArray Routine</h3><ul>
<li><code>np.ma</code>模块下的函数、<code>ma.MaskedArray</code>方法和<code>ndarray</code>
类似，但行为可能不同<ul>
<li><code>np</code>命名空间下部分函数（<code>hstack</code>等）应用在
<code>MaskedArray</code>上<ul>
<li>操作时忽略<code>mask</code>（即会操作被遮罩元素）</li>
<li>返回结果中<code>mask</code>被置为<code>False</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>这里仅记录<code>ma</code>模块中额外、或需额外说明部分</li>
</ul>
</blockquote>
<h4 id="数组检查"><a href="#数组检查" class="headerlink" title="数组检查"></a>数组检查</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ma.all(a[,axis,out,keepdims])</code></td>
<td>全遮蔽时返回<code>ma.masked</code></td>
<td></td>
</tr>
<tr>
<td><code>ma.any(a[,axis,out,keepdims])</code></td>
<td>存在遮蔽时返回<code>ma.masked</code></td>
<td></td>
</tr>
<tr>
<td><code>ma.count(arr,[axis,keepdims])</code></td>
<td>沿给定轴统计未被遮罩元素数量</td>
<td></td>
</tr>
<tr>
<td><code>ma.count_masked(arr,[axis])</code></td>
<td>沿给定轴统计被遮罩元素数量</td>
<td></td>
</tr>
<tr>
<td><code>ma.nonzero(a)</code></td>
<td>非0、未屏蔽元素索引</td>
<td></td>
</tr>
<tr>
<td><code>ma.is_mask(m)</code></td>
<td>是否为标准掩码数组</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.is_masked(x)</code></td>
<td>是否包含遮蔽元素</td>
</tr>
</tbody>
</table>
</div>
<h4 id="获取、创建、修改掩码"><a href="#获取、创建、修改掩码" class="headerlink" title="获取、创建、修改掩码"></a>获取、创建、修改掩码</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ma.getmask(a)</code></td>
<td>返回掩码、或<code>ma.nomask</code>、<code>ma.masked</code></td>
<td><code>.mask</code>属性</td>
</tr>
<tr>
<td><code>ma.getmaskarray(arr)</code></td>
<td>返回掩码、或完整<code>False</code>数组</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.make_mask(m[,copy,shrink,dtype])</code></td>
<td>从数组创建掩码</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.make_mask_none(newshape[,dtype])</code></td>
<td>创建给定形状掩码</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.make_mask_descr(ndtype)</code></td>
<td>为给定类型的创建掩码类型</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.mask_rowcols(a[,axis])</code></td>
<td>遮蔽包含遮蔽元素的<code>axis</code>方向分量</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.mask_rows(a[,axis])</code></td>
<td>缺省为<code>0</code>的<code>mask_rowcols()</code></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.mask_cols(a[,axis])</code></td>
<td>缺省为<code>1</code>的<code>mask_rowcols()</code></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.mask_mask_or(m1,m2[,copy,shrink])</code></td>
<td>掩码或</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.harden_mask(a)</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>ma.soften_mask(a)</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>.shrink_mask()</code></td>
<td>无</td>
<td>尽可能缩小掩码</td>
</tr>
<tr>
<td><code>.share_mask()</code></td>
<td>无</td>
<td>复制掩码，并设置<code>sharedmask=False</code></td>
</tr>
</tbody>
</table>
</div>
<h4 id="获取、创建索引"><a href="#获取、创建索引" class="headerlink" title="获取、创建索引"></a>获取、创建索引</h4><ul>
<li><p>索引非结构化掩码数组</p>
<ul>
<li>mask为<code>False</code>：返回数组标量</li>
<li>mask为<code>True</code>：返回<code>ma.masked</code></li>
</ul>
</li>
<li><p>索引结构化掩码数组</p>
<ul>
<li>所有字段mask均为<code>False</code>：返回<code>np.void</code>对象</li>
<li>存在字段mask为<code>True</code>：返回零维掩码数组</li>
</ul>
</li>
<li><p>切片</p>
<ul>
<li><code>.data</code>属性：原始数据视图</li>
<li><code>.mask</code>属性：<code>ma.nomask</code>或者原始mask视图</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ma.nonzero(a)</code></td>
<td>未屏蔽、非0元素索引</td>
<td></td>
</tr>
<tr>
<td><code>ma.mr_[]</code></td>
<td>沿第1轴concate切片、数组、标量，类<code>np.r_[]</code></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.flatnotmasked_contiguous(a)</code></td>
<td>展平后未遮蔽切片</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.flatnotmasked_edges(a)</code></td>
<td>展平后首个、末个未遮蔽位置</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.notmasked_contiguous(a[,axis])</code></td>
<td>沿给定轴，未遮蔽切片</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.notmasked_edges(a[,axis])</code></td>
<td>沿给定轴，首个、末个未遮蔽位置</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.clump_masked(a)</code></td>
<td>展平后遮蔽切片</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.clump_unmasked(a)</code></td>
<td>展位后未遮蔽切片</td>
<td>无</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>ma.mr_[]</code>类似<code>np.r_[]</code>，但<code>np.r_[]</code>返回结果掩码被置为
<code>False</code>，而<code>ma.mr_[]</code>同时也操作掩码</li>
</ul>
<h4 id="获取、修改值"><a href="#获取、修改值" class="headerlink" title="获取、修改值"></a>获取、修改值</h4><ul>
<li><p>仅访问有效数据</p>
<ul>
<li>对掩码mask取反作为索引<code>~X.mask</code></li>
<li>使用<code>.compressed</code>方法得到一维<code>ndarray</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(X[~X.mask])</span><br><span class="line"><span class="built_in">print</span>(X.compressed())</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问数据</p>
<ul>
<li>通过<code>.data</code>属性：可能是<code>ndarray</code>或其子类的视图<ul>
<li>等同于直接在掩码数组上创建<code>ndarray</code>或其子类视图</li>
</ul>
</li>
<li><code>__array__</code>方法：<code>ndarray</code></li>
<li>使用<code>ma.getdata</code>函数</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ma.getdata(a[,subok])</code></td>
<td>返回掩码数组数据</td>
<td><code>.data</code>属性</td>
</tr>
<tr>
<td><code>ma.fix_valid(a[,mask,copy,fill_value])</code></td>
<td>替换<code>a</code>中无效值，并遮盖</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.masked_equal(x,value[,copy])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.masked_greater(x,value[,copy])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.masked_greater_equal(x,value[,copy])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.masked_inside(x,v1,v2[,copy])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.masked_outside(x,v1,v2[,copy])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.masked_invalid(x[,copy])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.masked_less(x,value[,copy])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.masked_less_equal(x,value[,copy])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.masked_not_equal(x,value[,copy])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.masked_values(x,value[,rtol,atol,...])</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.masked_object(x,value[,copy,shrink])</code></td>
<td>类<code>masked_values</code>，适合值类型为<code>object</code>时</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.masked_where(condition,a[,copy])</code></td>
<td>按<code>condition</code>遮蔽指定值</td>
<td>无</td>
</tr>
</tbody>
</table>
</div>
<h4 id="其他属性、方法"><a href="#其他属性、方法" class="headerlink" title="其他属性、方法"></a>其他属性、方法</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ma.common_fill_value(a,b)</code></td>
<td>若<code>a,b</code>填充值相同则返回，否则返回<code>None</code></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.default_fill_value(obj)</code></td>
<td>默认填充值</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.maximum_fill_value(obj)</code></td>
<td>对象类型决定的最大值</td>
<td>无</td>
</tr>
<tr>
<td><code>ma.minimum_fill_value(obj)</code></td>
<td></td>
<td>无</td>
</tr>
<tr>
<td><code>ma.sef_fill_value(a,fill_value)</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>.get_fill_value()</code>/<code>.fill_value</code></td>
<td>无</td>
<td></td>
</tr>
<tr>
<td><code>ma.allequal(a,b[,fill_value])</code></td>
<td>若<code>a,b</code>元素均相等，则使用<code>fill_value</code>填充</td>
</tr>
</tbody>
</table>
</div>
<h3 id="np-ma运算"><a href="#np-ma运算" class="headerlink" title="np.ma运算"></a><code>np.ma</code>运算</h3><ul>
<li><p>掩码数组支持代数、比较运算</p>
<ul>
<li>被遮蔽元素不参与运算，元素在运算前后保持不变</li>
<li>掩码数组支持标准的<em>ufunc</em>，返回掩码数组<ul>
<li>运算中任意元素被遮蔽，则结果中相应元素被遮蔽</li>
<li>若<em>ufunc</em>返回可选的上下文输出，则上下文会被处理，
且无定义结果被遮蔽</li>
</ul>
</li>
</ul>
</li>
<li><p><code>np.ma</code>模块中对大部分ufunc有特别实现</p>
<ul>
<li>对于定义域有限制的一元、二元运算，无定义的结果会
自动mask</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ma.log([-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ma.anom(a[,axis,dtype])</code></td>
<td>沿给定轴计算与算数均值的偏差</td>
</tr>
</tbody>
</table>
</div>
<h2 id="np-memmap"><a href="#np-memmap" class="headerlink" title="np.memmap"></a><code>np.memmap</code></h2><ul>
<li><p><code>np.memmap</code>：内存映射文件数组，使用内存映射文件作为数组
数据缓冲区</p>
<ul>
<li>对大文件，使用内存映射可以节省大量资源</li>
</ul>
</li>
<li><p>方法</p>
<p>|Method|Desc|
|——-|——-|
|<code>np.memmap(filename[,dtype,mode,shape])</code>|创建存储在磁盘文件的内存映射数组|
|<code>np.flush()</code>|flush内存数据至磁盘|</p>
</li>
</ul>
<h2 id="标准容器类"><a href="#标准容器类" class="headerlink" title="标准容器类"></a>标准容器类</h2><ul>
<li><p><code>np.lib.user_array.container</code></p>
<ul>
<li>为向后兼容、作为标准容器类而引入</li>
<li>其中<code>self.array</code>属性是<code>ndarray</code></li>
<li>比<code>ndarray</code>本身更方便多继承</li>
</ul>
</li>
<li><p>类、方法、函数</p>
<p>|Method|Desc|
|——-|——-|
|<code>np.lib.user_array.container(data[,...])</code>|简化多继承的标准容器类|</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-02-01T00:32:44.000Z" title="2/1/2021, 8:32:44 AM">2021-02-01</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-02-01T00:32:44.000Z" title="2/1/2021, 8:32:44 AM">2021-02-01</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Numpy/">Numpy</a></span><span class="level-item">20 minutes read (About 3066 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Numpy/ndarray_scalars.html">NDArray标量</a></h1><div class="content"><h2 id="NDArray标量类型"><a href="#NDArray标量类型" class="headerlink" title="NDArray标量类型"></a>NDArray标量类型</h2><ul>
<li><p>numpy中定义了24种新python类型（NDArray标量类型）</p>
<ul>
<li>类型描述符主要基于CPython中C语言可用的类型</li>
</ul>
</li>
<li><p>标量具有和<code>ndarray</code>相同的属性和方法</p>
<ul>
<li>数组标量不可变，故属性不可设置</li>
</ul>
</li>
</ul>
<p><img src="/imgs/numpy_dtype_hierarchy.png" alt="numpy_dtype_hierarchy"></p>
<h3 id="内置标量类型"><a href="#内置标量类型" class="headerlink" title="内置标量类型"></a>内置标量类型</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>iinfo(int_type)</code></td>
<td>整数类型的取值范围等信息</td>
</tr>
<tr>
<td><code>finfo(float_type)</code></td>
<td>浮点类型的取值范围等信息</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Python关联"><a href="#Python关联" class="headerlink" title="Python关联"></a>Python关联</h4><div class="table-container">
<table>
<thead>
<tr>
<th>NumPy类型</th>
<th>Python类型</th>
<th>64位NumPy定长类型</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int_</code></td>
<td>继承自<code>int</code>（Python2）</td>
<td><code>int64</code></td>
<td></td>
</tr>
<tr>
<td><code>float_</code></td>
<td>继承自<code>float</code></td>
<td><code>float64</code></td>
<td></td>
</tr>
<tr>
<td><code>complex_</code></td>
<td>继承自<code>complex</code></td>
<td><code>complex128</code></td>
<td></td>
</tr>
<tr>
<td><code>bytes_</code></td>
<td>继承自<code>bytes</code></td>
<td><code>S#&quot;</code>/<code>&quot;a#&quot;</code></td>
<td>Python字节串</td>
</tr>
<tr>
<td><code>unicode_</code></td>
<td>继承自<code>str</code></td>
<td><code>&quot;U#&quot;</code></td>
<td>Python字符串</td>
</tr>
<tr>
<td><code>void</code></td>
<td></td>
<td><code>&quot;V#&quot;</code></td>
<td>Python缓冲类型</td>
</tr>
<tr>
<td><code>object_</code></td>
<td>继承自<code>object</code>（Python3）</td>
<td><code>&quot;O&quot;</code></td>
<td>Python对象引用</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p><code>np.bool_</code>类似Python中<code>bool</code>类型，但不继承它</p>
<ul>
<li>Python中<code>bool</code>类型不允许被继承</li>
<li><code>np.bool_</code>大小和<code>bool</code>类型大小不同</li>
</ul>
</li>
<li><p><code>np.int_</code>不继承自<code>int</code>，因为后者宽度不再固定</p>
<ul>
<li>NumPy中数组没有真正<code>np.int</code>类型，因为宽度不再固定，
各产品</li>
</ul>
</li>
<li><p><code>bytes_</code>、<code>unicode_</code>、<code>void</code>是可灵活配置宽度的类型</p>
<ul>
<li>在指定长度后不能更改，赋长于指定长度的值会被截断</li>
<li><code>unicode_</code>：强调内容为字符串</li>
<li><code>bytes_</code>：强调内容为字节串</li>
<li><code>void</code>：类型强调内容为二进制内容，但不是字节串</li>
</ul>
</li>
<li><p><code>object_</code>存储的是python对象的引用而不对象本身</p>
<ul>
<li>其中引用不必是相同的python类型</li>
<li>兜底类型</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>Python基本类型等在NumPy命名空间下都有同名别名，如：
  <code>np.unicode == np.str == str</code></li>
<li>NumPy数组中数据类型无法被真正设置为<code>int</code>类型，为保证数组
  中元素宽度一致性，必然无法被设置为非定长类型</li>
</ul>
</blockquote>
<h4 id="C类型关联"><a href="#C类型关联" class="headerlink" title="C类型关联"></a>C类型关联</h4><blockquote>
<ul>
<li>NumPy支持的原始类型和C中原始类型紧密相关</li>
</ul>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>NumPy类型</th>
<th>C类型</th>
<th>64位定长别名</th>
<th>Desc</th>
<th>单字符代码</th>
<th>定长字符串代码</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bool_</code></td>
<td><code>bool</code></td>
<td><code>bool8</code></td>
<td>存储为字节的bool值</td>
<td><code>&quot;?&quot;</code></td>
<td>无</td>
</tr>
<tr>
<td><code>byte</code></td>
<td><code>signed char</code></td>
<td><code>int8</code></td>
<td></td>
<td><code>&quot;b&quot;</code></td>
<td><code>&quot;i1&quot;</code></td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>short</code></td>
<td><code>int16</code></td>
<td></td>
<td><code>&quot;h&quot;</code></td>
<td><code>&quot;i2&quot;</code></td>
</tr>
<tr>
<td><code>intc</code></td>
<td><code>int</code></td>
<td><code>int32</code></td>
<td></td>
<td><code>&quot;i&quot;</code></td>
<td><code>&quot;i4&quot;</code></td>
</tr>
<tr>
<td><code>int_</code></td>
<td><code>long</code></td>
<td><code>int64</code></td>
<td></td>
<td><code>&quot;l&quot;</code></td>
<td><code>&quot;i8&quot;</code></td>
</tr>
<tr>
<td><code>longlong</code></td>
<td><code>long long</code></td>
<td>无</td>
<td></td>
<td><code>&quot;q&quot;</code></td>
<td>无</td>
</tr>
<tr>
<td><code>ubyte</code></td>
<td><code>unsigned char</code></td>
<td><code>uint8</code></td>
<td></td>
<td><code>&quot;B&quot;</code></td>
<td><code>&quot;u1&quot;</code></td>
</tr>
<tr>
<td><code>ushort</code></td>
<td><code>unsigned short</code></td>
<td><code>uint16</code></td>
<td></td>
<td><code>&quot;H&quot;</code></td>
<td><code>&quot;u2&quot;</code></td>
</tr>
<tr>
<td><code>uintc</code></td>
<td><code>unsigned int</code></td>
<td><code>uint32</code></td>
<td></td>
<td><code>&quot;I&quot;</code></td>
<td><code>&quot;u4&quot;</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>usigned long</code></td>
<td><code>uint64</code></td>
<td></td>
<td><code>&quot;L&quot;</code></td>
<td><code>&quot;u8&quot;</code></td>
</tr>
<tr>
<td><code>ulonglong</code></td>
<td><code>unsigned long long</code></td>
<td>无</td>
<td></td>
<td><code>&quot;Q&quot;</code></td>
<td>无</td>
</tr>
<tr>
<td><code>half</code></td>
<td>无</td>
<td><code>float16</code></td>
<td>半精度浮点：1+5+10</td>
<td><code>&quot;e&quot;</code></td>
<td><code>&quot;f2&quot;</code></td>
</tr>
<tr>
<td><code>single</code></td>
<td><code>float</code></td>
<td><code>float32</code></td>
<td>单精度浮点，通常为：1+8+23</td>
<td><code>&quot;f4&quot;</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td><code>double</code></td>
<td><code>float64</code></td>
<td>双精度浮点，通常为：1+11+52</td>
<td><code>&quot;d&quot;</code></td>
<td><code>&quot;f8&quot;</code></td>
</tr>
<tr>
<td><code>longdouble</code>/<code>longfloat</code></td>
<td><code>long double</code></td>
<td><code>float128</code></td>
<td>平台定义的扩展精度浮点</td>
<td><code>&quot;g&quot;</code></td>
<td><code>&quot;f16&quot;</code></td>
</tr>
<tr>
<td><code>csingle</code></td>
<td><code>float complex</code></td>
<td><code>complex64</code></td>
<td>两个单精度浮点</td>
<td><code>&quot;F&quot;</code></td>
<td><code>&quot;c8&quot;</code></td>
</tr>
<tr>
<td><code>cdouble</code>/<code>cfloat</code></td>
<td><code>double complex</code></td>
<td><code>complex128</code></td>
<td>两个双精度浮点</td>
<td><code>&quot;D&quot;</code></td>
<td><code>&quot;c16&quot;</code></td>
</tr>
<tr>
<td><code>clongdouble</code>/<code>clongfloat</code></td>
<td><code>long duoble complex</code></td>
<td><code>complex256</code></td>
<td>两个扩展精度浮点</td>
<td><code>&quot;G&quot;</code></td>
<td><code>&quot;c32&quot;</code></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<ul>
<li><code>float complex</code>、<code>double complex</code>类型定义在<code>complex.h</code>中</li>
<li>C中的定长类型别名定义在<code>stdint.h</code>中</li>
</ul>
</blockquote>
<h4 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Python类型</th>
<th>Desc</th>
<th>单字符代码</th>
<th>定长字符串代码</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>timedelta64</code></td>
<td>时间增量</td>
<td><code>&quot;m&quot;</code></td>
<td><code>&quot;m8&quot;</code></td>
</tr>
<tr>
<td><code>datetime64</code></td>
<td>日期时间</td>
<td><code>&quot;M&quot;</code></td>
<td><code>&quot;M8&quot;</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="属性、索引、方法"><a href="#属性、索引、方法" class="headerlink" title="属性、索引、方法"></a>属性、索引、方法</h3><ul>
<li><p>数组标量属性基本同<code>ndarray</code></p>
</li>
<li><p>数组标量类似0维数组一样支持索引</p>
<ul>
<li><code>X[()]</code>返回副本</li>
<li><code>X[...]</code>返回0维数组</li>
<li><code>X[&lt;field-name&gt;]</code>返回对应字段的数组标量</li>
</ul>
</li>
<li><p>数组标量与<code>ndarray</code>有完全相同的方法</p>
<ul>
<li>默认行为是在内部将标量转换维等效0维数组，并调用相应
数组方法</li>
</ul>
</li>
</ul>
<h3 id="定义数组标量类型"><a href="#定义数组标量类型" class="headerlink" title="定义数组标量类型"></a>定义数组标量类型</h3><ul>
<li>从内置类型组合结构化类型</li>
<li>子类化<code>ndarray</code><ul>
<li>部分内部行为会由数组类型替代</li>
</ul>
</li>
<li>完全自定义数据类型，在numpy中注册<ul>
<li>只能使用numpy C-API在C中定义</li>
</ul>
</li>
</ul>
<h2 id="数据类型相关函数"><a href="#数据类型相关函数" class="headerlink" title="数据类型相关函数"></a>数据类型相关函数</h2><h3 id="数据类型信息"><a href="#数据类型信息" class="headerlink" title="数据类型信息"></a>数据类型信息</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>finfo(dtype)</code></td>
<td>机器对浮点类型限制</td>
</tr>
<tr>
<td><code>iinfo(type)</code></td>
<td>机器对整型限制</td>
</tr>
<tr>
<td><code>MachAr([float_conv,int_conv])</code></td>
<td>诊断机器参数</td>
</tr>
<tr>
<td><code>typename(char)</code></td>
<td>对给定数据类型字符代码的说明</td>
</tr>
</tbody>
</table>
</div>
<h3 id="数据类型测试"><a href="#数据类型测试" class="headerlink" title="数据类型测试"></a>数据类型测试</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>can_cast(from_,to[,casting])</code></td>
<td>是否可以类型转换</td>
</tr>
<tr>
<td><code>issctype(rep)</code></td>
<td><code>rep</code>（不能为可转换字符串）是否表示标量数据类型</td>
</tr>
<tr>
<td><code>issubdtype(arg1,arg2)</code></td>
<td><code>arg1</code>在数据类型层次中较低（即<code>dtype</code>的<code>issubclass</code>）</td>
</tr>
<tr>
<td><code>issubsctype(arg1,arg2)</code></td>
<td>同<code>issubdtype</code>，但支持包含<code>dtype</code>属性对象作为参数</td>
</tr>
<tr>
<td><code>issubclass_(arg1,arg2)</code></td>
<td>同内置<code>issubclass</code>，但参数非类时仅返回<code>False</code>，而不是<code>raise TypeError</code></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p><code>np.int64</code>、<code>np.int32</code>在层次体系中不同、且层级一致，所以
会出现<code>issubdtype(np.int64, int) -&gt; True</code>，其他情况为
<code>False</code></p>
</li>
<li><p>通过<code>np.can_cast</code>函数确定safely类型转换</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_casting</span>(<span class="params">ntypes</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;X&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> char <span class="keyword">in</span> ntypes:</span><br><span class="line">		<span class="built_in">print</span>(char, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> row <span class="keyword">in</span> ntypes:</span><br><span class="line">		<span class="built_in">print</span>(row, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">		<span class="keyword">for</span> col <span class="keyword">in</span> ntypes:</span><br><span class="line">			<span class="built_in">print</span>(<span class="built_in">int</span>(np.can_cast(row, col)), end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">print_casting(np.typecodes[<span class="string">&quot;All&quot;</span>])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数据类型确定"><a href="#数据类型确定" class="headerlink" title="数据类型确定"></a>数据类型确定</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Params</th>
<th>ReturnType</th>
<th>ReturnDesc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>min_scalar_type(a)</code></td>
<td>标量值</td>
<td>dtype实例</td>
<td>满足要求最小类型</td>
</tr>
<tr>
<td><code>promote_types(type1,type2)</code></td>
<td>dtype等</td>
<td>dtype实例</td>
<td>可安全转换的最小类型</td>
</tr>
<tr>
<td><code>result_type(*array_and_dtypes)</code></td>
<td>dtype等、标量值、数组</td>
<td>dtype实例</td>
<td>应用<em>promotion rules</em>得到类型</td>
</tr>
<tr>
<td><code>find_common_type(array_types,scalar_types)</code></td>
<td>dtype等列表</td>
<td>dtype实例</td>
<td>综合考虑标量类型、数组类型</td>
</tr>
<tr>
<td><code>common_type(*arrays)</code></td>
<td>数值型数组（有<code>dtype</code>属性）</td>
<td>预定义类型</td>
<td>满足要求类型中、最高精度类型</td>
</tr>
<tr>
<td><code>maximum_sctype(t)</code></td>
<td>dtype等、标量值、数组</td>
<td>预定义类型</td>
<td>满足要求类型中、最高精度类型</td>
</tr>
<tr>
<td><code>obj2sctype(rep[,default])</code></td>
<td>dtype等、标量值、数组</td>
<td>预定义类型</td>
<td>对象类型</td>
</tr>
<tr>
<td><code>sctype2char(sctype)</code></td>
<td>dtype等、标量值、数组</td>
<td>类型字符代码</td>
<td>满足要求的最小类型</td>
</tr>
<tr>
<td><code>mintypecode(typechars[,typeset,default])</code></td>
<td>dtype等、标量值、数组</td>
<td>类型字符代码</td>
<td><code>typeset</code>中选择</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>除非标量和数组为不同体系内数据类型，否则标量不能up_cast
数组数据类型</li>
</ul>
<blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://numpy.org/devdocs/reference/generated/numpy.issubdtype.html#numpy.issubdtype">https://numpy.org/devdocs/reference/generated/numpy.issubdtype.html#numpy.issubdtype</a></li>
<li><a target="_blank" rel="noopener" href="https://numpy.org/devdocs/reference/generated/numpy.issubsctype.html#numpy.issubsctype">https://numpy.org/devdocs/reference/generated/numpy.issubsctype.html#numpy.issubsctype</a></li>
<li><a target="_blank" rel="noopener" href="https://numpy.org/devdocs/reference/generated/numpy.find_common_type.html#numpy.find_common_type">https://numpy.org/devdocs/reference/generated/numpy.find_common_type.html#numpy.find_common_type</a></li>
<li><a target="_blank" rel="noopener" href="https://numpy.org/devdocs/reference/generated/numpy.result_type.html#numpy.result_type">https://numpy.org/devdocs/reference/generated/numpy.result_type.html#numpy.result_type</a></li>
<li><a target="_blank" rel="noopener" href="https://numpy.org/devdocs/reference/generated/numpy.common_type.html#numpy.common_type">https://numpy.org/devdocs/reference/generated/numpy.common_type.html#numpy.common_type</a></li>
</ul>
</blockquote>
<h2 id="数据类型类np-dtype"><a href="#数据类型类np-dtype" class="headerlink" title="数据类型类np.dtype"></a>数据类型类<code>np.dtype</code></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dtype</span>(<span class="params">obj[,align,copy]</span>)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>numpy.dtype</code>类描述如何解释数组项对应内存块中字节</p>
<ul>
<li>数据大小</li>
<li>数据内存顺序：<em>little-endian</em>、<em>big-endian</em></li>
<li>数据类型<ul>
<li>结构化数据<ul>
<li>各字段名称</li>
<li>各字段数据类型</li>
<li>字段占用的内存数据块</li>
</ul>
</li>
<li>子数组<ul>
<li>形状</li>
<li>数据类型</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>需<code>numpy.dtype</code>实例作为参数的场合，大部分场景可用等价、
可转换为<code>dtype</code>实例的其他值代替</p>
<ul>
<li>python、numpy中预定义的标量类型、泛型类型</li>
<li>创建<code>dtype</code>实例类型的字符串、字典、列表</li>
<li>包含<code>dtype</code>属性的类、实例</li>
</ul>
</li>
</ul>
<h3 id="数据类型元素"><a href="#数据类型元素" class="headerlink" title="数据类型元素"></a>数据类型元素</h3><h4 id="类型类"><a href="#类型类" class="headerlink" title="类型类"></a>类型类</h4><ul>
<li><p>NumPy内置类型</p>
<ul>
<li>24中内置数组标量类型</li>
<li><p>泛型类型</p>
<p>|Generic类型|转换后类型|
|——-|——-|
|<code>number</code>,<code>inexact</code>,<code>floating</code>|<code>float_</code>|
|<code>complexfloating</code>|<code>complex_</code>|
|<code>integer</code>,<code>signedinteger</code>|<code>int_</code>|
|<code>unsignedinteger</code>|<code>uint</code>|
|<code>character</code>|<code>string</code>|
|<code>generic</code>,<code>flexible</code>|<code>void</code>|</p>
</li>
</ul>
</li>
<li><p>python内置类型，等效于相应数组标量</p>
<ul>
<li>转换规则同NumPy内置数组标量类型</li>
<li><p><code>None</code>：缺省值，转换为<code>float_</code></p>
<p>|Python内置类型|转换后类型|
|——-|——-|
|<code>int</code>|<code>int_</code>|
|<code>bool</code>|<code>bool_</code>|
|<code>float</code>|<code>float_</code>|
|<code>complex</code>|<code>complex_</code>|
|<code>bytes</code>|<code>bytes_</code>|
|<code>str</code>|<code>unicode_</code>|
|<code>unicode</code>|<code>unicode_</code>|
|<code>buffer</code>|<code>void</code>|
|Others|<code>object_</code>|</p>
</li>
</ul>
</li>
<li><p>带有<code>.dtype</code>属性的类型：直接访问、使用该属性</p>
<ul>
<li>该属性需返回可转换为<code>dtype</code>对象的内容</li>
</ul>
</li>
</ul>
<h4 id="可转换类型的字符串"><a href="#可转换类型的字符串" class="headerlink" title="可转换类型的字符串"></a>可转换类型的字符串</h4><ul>
<li><p><code>numpy.sctypeDict.keys()</code>中字符串</p>
</li>
<li><p><em>Array-protocal</em>类型字符串，详细参见NumPy数组标量类型</p>
<ul>
<li>首个字符指定数据类型</li>
<li>支持指定字节数的字符可在之后指定项目占用字节数<ul>
<li>定长类型只能指定满足平台要求的字节数</li>
<li>非定长类型可以指定任意字节数</li>
</ul>
</li>
</ul>
<p>|代码|类型|
|——-|——-|
|<code>&#39;?&#39;</code>|boolean|
|<code>&#39;b&#39;</code>|(signed) byte，等价于<code>&#39;i1&#39;</code>|
|<code>&#39;B&#39;</code>|unsigned byte，等价于<code>&#39;u1&#39;</code>|
|<code>&#39;i&#39;</code>|(signed) integer|
|<code>&#39;u&#39;</code>|unsigned integer|
|<code>&#39;f&#39;</code>|floating-point|
|<code>&#39;c&#39;</code>|complex-floating point|
|<code>&#39;m&#39;</code>|timedelta|
|<code>&#39;M&#39;</code>|datetime|
|<code>&#39;O&#39;</code>|(Python) objects|
|<code>&#39;S&#39;</code>/<code>&#39;a&#39;</code>|zero-terminated bytes (not recommended)|
|<code>&#39;U&#39;</code>|Unicode string|
|<code>&#39;V&#39;</code>|raw data (void)|</p>
</li>
</ul>
<h3 id="结构化数据类型"><a href="#结构化数据类型" class="headerlink" title="结构化数据类型"></a>结构化数据类型</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>format_parser(formats,names,titles[,aligned,byteorder])</code></td>
<td>创建数据类型</td>
</tr>
<tr>
<td><code>dtype(obj[,align,copy])</code></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>结构化数据类型</p>
<ul>
<li>包含一个或多个数据类型字段，每个字段有可用于访问的
名称</li>
<li>父数据类型应有足够大小包含所有字段</li>
<li>父数据类型几乎总是基于<code>void</code>类型</li>
</ul>
</li>
<li><p>仅包含不具名、单个基本类型时，数组结构会穿透</p>
<ul>
<li>字段不会被隐式分配名称</li>
<li>子数组shape会被添加至数组shape</li>
</ul>
</li>
</ul>
<h4 id="参数格式"><a href="#参数格式" class="headerlink" title="参数格式"></a>参数格式</h4><ul>
<li><p>可转换数据类型的字符串指定类型、shape</p>
<ul>
<li>依次包含四个部分<ul>
<li>字段shape</li>
<li>字节序描述符：<code>&lt;</code>、<code>&gt;</code>、<code>|</code></li>
<li>基本类型描述符</li>
<li>数据类型占用字节数<ul>
<li>对非变长数据类型，需按特定类型设置</li>
<li>对变长数据类型，指字段包含的数量</li>
</ul>
</li>
</ul>
</li>
<li>逗号作为分隔符，分隔多个字段</li>
<li>各字段名称只能为默认字段名称</li>
</ul>
<blockquote>
<ul>
<li>对变长类型，仅设置shape时，会将其视为bytes长度</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dt = np.dtype(<span class="string">&quot;i4, (2,3)f8, f4&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>元组指定字段类型、shape</p>
<ul>
<li>元组中各元素指定各字段名、数据类型、shape：
<code>(&lt;field_name&gt;, &lt;dtype&gt;, &lt;shape&gt;)</code><ul>
<li>若名称为<code>&#39;&#39;</code>空字符串，则分配标准字段名称</li>
</ul>
</li>
<li>可在列表中多个元组指定多个字段
<code>[(&lt;field_name&gt;, &lt;dtype&gt;, &lt;shape&gt;),...]</code></li>
<li>数据类型<code>dtype</code>可以<strong>嵌套其他数据类型</strong><ul>
<li>可转换类型字符串</li>
<li>元组/列表</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dt = np.dtype((<span class="string">&quot;U10&quot;</span>, (<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line">dt = np.dtype((<span class="string">&quot;i4, (2,3)f8, f4&quot;</span>, (<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">dt = np.dtype([(<span class="string">&quot;big&quot;</span>, <span class="string">&quot;&gt;i4&quot;</span>), (<span class="string">&quot;little&quot;</span>, <span class="string">&quot;&lt;i4&quot;</span>)])</span><br></pre></td></tr></table></figure>
</li>
<li><p>字典元素为名称、类型、shape列表</p>
<ul>
<li>类似<code>format_parser</code>函数，字典各键值对分别指定名称
列表、类型列表等：
<code>&#123;&quot;names&quot;:...,&quot;formats&quot;:...,&quot;offsets&quot;:...,&quot;titles&quot;:...,&quot;itemsize&quot;:...&#125;</code><ul>
<li><code>&quot;name&quot;</code>、<code>&quot;formats&quot;</code>为必须</li>
<li><code>&quot;itemsize&quot;</code>指定总大小，必须足够大</li>
</ul>
</li>
<li>分别指定各字段：<code>&quot;field_1&quot;:..., &quot;field_2&quot;:...</code><ul>
<li>不鼓励，容易与上一种方法冲突</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dt = np.dtype(&#123;</span><br><span class="line">	<span class="string">&quot;names&quot;</span>: [<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>],</span><br><span class="line">	<span class="string">&quot;formats&quot;</span>: [<span class="string">&quot;u1&quot;</span>, <span class="string">&quot;u1&quot;</span>, <span class="string">&quot;u1&quot;</span>, <span class="string">&quot;u1&quot;</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>解释基数据类型为结构化数据类型：
<code>(&lt;base_dtype&gt;, &lt;new_dtype&gt;)</code></p>
<ul>
<li>此方式使得<code>union</code>成为可能</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dt = np.dtype((<span class="string">&quot;i4&quot;</span>, [(<span class="string">&quot;r&quot;</span>, <span class="string">&quot;I1&quot;</span>), (<span class="string">&quot;g&quot;</span>, <span class="string">&quot;I1&quot;</span>), (<span class="string">&quot;b&quot;</span>, <span class="string">&quot;I1&quot;</span>), (<span class="string">&quot;a&quot;</span>, <span class="string">&quot;I1&quot;</span>)]))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li><p>描述数据类型</p>
<p>|属性|描述|
|——-|——-|
|<code>.type</code>|用于实例化此数据类型的数组标量类型|
|<code>.kind</code>|内置类型字符码|
|<code>.char</code>|内置类型字符码|
|<code>.num</code>|内置类型唯一编号|
|<code>.str</code>|类型标识字符串|</p>
</li>
<li><p>数据大小</p>
<p>|属性|描述|
|——-|——-|
|<code>.name</code>|数据类型位宽名称|
|<code>.itemsize</code>|元素大小|</p>
</li>
<li><p>字节顺序</p>
<p>|属性|描述|
|——-|——-|
|<code>.byteorder</code>|指示字节顺序|</p>
</li>
<li><p>字段描述</p>
<p>|属性|描述|
|——-|——-|
|<code>.fields</code>|命名字段字典|
|<code>.names</code>|字典名称列表|</p>
</li>
<li><p>数组类型（非结构化）描述</p>
<p>|属性|描述|
|——-|——-|
|<code>.subtype</code>|<code>(item_dtype,shape)</code>|
|<code>.shape</code>||</p>
</li>
<li><p>附加信息</p>
<p>|属性|描述|
|——-|——-|
|<code>.hasobject</code>|是否包含任何引用计数对象|
|<code>.flags</code>|数据类型解释标志|
|<code>.isbuiltin</code>|与内置数据类型相关|
|<code>.isnative</code>|字节顺序是否为平台原生|
|<code>.descr</code>|<code>__array_interface__</code>数据类型说明|
|<code>.alignment</code>|数据类型需要对齐的字节（编译器决定）|
|<code>.base</code>|基本元素的<code>dtype</code>|</p>
</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><p>更改字节顺序</p>
<p>|方法|描述|
|——-|——-|
|<code>.newbyteorder([new_order])</code>|创建不同字节顺序数据类型|</p>
</li>
<li><p>Pickle协议实现</p>
<p>|方法|描述|
|——-|——-|
|<code>.reduce()</code>|pickle化|
|<code>.setstate()</code>||</p>
</li>
</ul>
<h2 id="Datetime"><a href="#Datetime" class="headerlink" title="Datetime"></a>Datetime</h2><ul>
<li>Numpy种时间相关数据类型<ul>
<li>支持大量时间单位</li>
<li>基于POSIX时间存储日期时间</li>
<li>使用64位整形存储值，也由此决定了时间跨度</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.numpy.org.cn/reference/arrays/datetime.html">https://www.numpy.org.cn/reference/arrays/datetime.html</a></li>
</ul>
</blockquote>
<h3 id="np-datetime64"><a href="#np-datetime64" class="headerlink" title="np.datetime64"></a><code>np.datetime64</code></h3><ul>
<li><code>np.datetime64</code>表示单个时刻<ul>
<li>若两个日期时间具有不同单位，可能仍然代表相同时刻</li>
<li>从较大单位转换为较小单位是安全的投射</li>
</ul>
</li>
</ul>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ul>
<li><p>创建规则</p>
<ul>
<li>内部存储单元自动从字符串形式中选择单位</li>
<li>接受<code>&quot;NAT&quot;</code>字符串，表示“非时间”值</li>
<li>可以强制使用特定单位</li>
</ul>
</li>
<li><p>基本方法：ISO 8601格式的字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.datetime64(<span class="string">&quot;2020-05-23T14:23&quot;</span>)</span><br><span class="line">np.datetime64(<span class="string">&quot;2020-05-23T14:23&quot;</span>, <span class="string">&quot;D&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>从字符串创建日期时间数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.array([<span class="string">&quot;2020-01-23&quot;</span>, <span class="string">&quot;2020-04-23&quot;</span>], dtype=<span class="string">&quot;datetime64&quot;</span>)</span><br><span class="line">np.array([<span class="string">&quot;2020-01-23&quot;</span>, <span class="string">&quot;2020-04-23&quot;</span>], dtype=<span class="string">&quot;datetime64[D]&quot;</span>)</span><br><span class="line">np.arange(<span class="string">&quot;2020-01-01&quot;</span>, <span class="string">&quot;2020-05-03&quot;</span>, dtype=<span class="string">&quot;datetime64[D]&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<ul>
<li><code>np.datetime64</code>为向后兼容，仍然支持解析时区</li>
</ul>
</blockquote>
<h3 id="np-timedelta64"><a href="#np-timedelta64" class="headerlink" title="np.timedelta64"></a><code>np.timedelta64</code></h3><ul>
<li><code>np.timedelta64</code>：时间增量</li>
</ul>
<blockquote>
<ul>
<li><code>np.timedelta64</code>是对<code>np.datetime64</code>的补充，弥补Numpy对
  物理量的支持</li>
</ul>
</blockquote>
<h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><ul>
<li><p>创建规则</p>
<ul>
<li>接受<code>&quot;NAT&quot;</code>字符串，表示“非时间”值数字</li>
<li>可以强制使用特定单位</li>
</ul>
</li>
<li><p>直接从数字创建</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.timedelta64(<span class="number">100</span>, <span class="string">&quot;D&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>从已有<code>np.timedelta64</code>创建，指定单位</p>
<ul>
<li>注意，不能将月份及以上转换为日，因为不同时点进制不同</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.timedelta(a, <span class="string">&quot;M&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><ul>
<li><p><code>np.datetime64</code>可以和<code>np.timedelta64</code>联合使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.datetime64(<span class="string">&quot;2020-05-14&quot;</span>) - np.datetime64(<span class="string">&quot;2020-01-12&quot;</span>)</span><br><span class="line">np.datetime64(<span class="string">&quot;2020-05-14&quot;</span>) + np.timedelta64(<span class="number">2</span>, <span class="string">&quot;D&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Function</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>np.busdaycalendar(weekmask,holidays)</code></td>
<td>返回存储有效工作日对象</td>
</tr>
<tr>
<td><code>np.busday_offset(date,offset[,roll,weekmask,holidays,busdaycal,out])</code></td>
<td>工作日offset</td>
</tr>
<tr>
<td><code>np.is_busday(date[,weekmask,holidays,busdaycal,out])</code></td>
<td>判断是否是工作日</td>
</tr>
<tr>
<td><code>np.busday_count(begindates,enddates[,weekmask,holidays,busdaycal,out])</code></td>
<td>指定天数</td>
</tr>
<tr>
<td><code>np.datetime_as_string(arr[,unit,timezone,...])</code></td>
<td>转换为字符串数组</td>
</tr>
<tr>
<td><code>np.datetime_date(dtype,/)</code></td>
<td>获取日期、时间类型步长信息</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>np.busday_offset</code>中<ul>
<li><code>roll</code>缺省为<code>&quot;raise&quot;</code>，要求<code>date</code>本身为工作日</li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-01-31T07:49:17.000Z" title="1/31/2021, 3:49:17 PM">2021-01-31</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-01-31T07:49:17.000Z" title="1/31/2021, 3:49:17 PM">2021-01-31</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Numpy/">Numpy</a></span><span class="level-item">17 minutes read (About 2611 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Numpy/ndarray.html">NDArray</a></h1><div class="content"><h2 id="NDArray"><a href="#NDArray" class="headerlink" title="NDArray"></a>NDArray</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ndarray</span>(<span class="params">shape[,dtype,buffer,offset]</span>)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>ndarray</code>：具有相同类型、大小（固定大小）项目的多维容器</p>
<ul>
<li><code>ndarray</code>由计算中内存连续的一维段组成，并与将<code>N</code>个整数
映射到块中项的位置的索引方案相结合</li>
<li>可以共享相同数据段，即可以是其他数据区的视图<ul>
<li>另一个<code>ndarray</code></li>
<li>实现<code>buffer</code>的对象</li>
</ul>
</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li><code>shape</code>：指定尺寸、项目数量</li>
<li><code>dtype</code>（<em>data-type object</em>）：指定项目类型</li>
<li><code>strides</code>：存储各维度步幅，用于计算连续数据段中偏移</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.numpy.org.cn/reference/arrays/ndarray.html">https://www.numpy.org.cn/reference/arrays/ndarray.html</a><a href="/https://www.numpy.org.cn/reference/arrays/ndarray.html">/https://www.numpy.org.cn/reference/arrays/ndarray.html</a></p>
<h3 id="Broadcast-广播规则"><a href="#Broadcast-广播规则" class="headerlink" title="Broadcast 广播规则"></a>Broadcast 广播规则</h3><p>Broadcasting：4条广播规则用于处理不同shape的数组</p>
<ul>
<li>非维数最大者在<code>shape</code>前用<code>1</code>补足</li>
<li>输出的<code>shape</code>中各维度是各输入对应维度最大值</li>
<li>各输入的维度同输出对应维度相同、或为<code>1</code></li>
<li>输入中维度为<code>1</code>者，对应的（首个）数据被用于沿该轴的
所有计算
（即对应的<code>stride</code>为<code>0</code>，<em>ufunc</em>不step along该维度）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shape(3, 2, 2, 1) + shape(1, 3)</span><br><span class="line">	-&gt; shape(3, 2, 2, 1) + shape(1, 1, 1, 3)</span><br><span class="line">	-&gt; shape(3, 2, 2, 3) + shape(1, 1, 2, 3)</span><br><span class="line">	-&gt; shape(3, 2, 2, 3) + shape(1, 2, 2, 3)</span><br><span class="line">	-&gt; shape(3, 2, 2, 3) + shape(3, 2, 2, 3)</span><br></pre></td></tr></table></figure>
<h2 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h2><h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ndarray.flags</code></td>
<td>有关数组内存布局的信息</td>
</tr>
<tr>
<td><code>ndarray.shape</code></td>
<td>数组维度（元组）</td>
</tr>
<tr>
<td><code>ndarray.strides</code></td>
<td>遍历数组时每个维度中的字节数量（元组）</td>
</tr>
<tr>
<td><code>ndarray.ndim</code></td>
<td>数组维数</td>
</tr>
<tr>
<td><code>ndarray.data</code></td>
<td>Python缓冲区对象指向数组的数据的开头</td>
</tr>
<tr>
<td><code>ndarray.size</code></td>
<td>数组中的元素数</td>
</tr>
<tr>
<td><code>ndarray.itemsize</code></td>
<td>数组元素的长度，以字节为单位</td>
</tr>
<tr>
<td><code>ndarray.nbytes</code></td>
<td>数组元素消耗的总字节数</td>
</tr>
<tr>
<td><code>ndarray.base</code></td>
<td>如果内存来自其他对象，则为基础对象</td>
</tr>
</tbody>
</table>
</div>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.numpy.org.cn/reference/arrays/dtypes.html"><code>ndarray.dtype</code></a></td>
<td>元素数据类型</td>
</tr>
</tbody>
</table>
</div>
<h3 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h3><div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ndarray.T</code></td>
<td>转置</td>
</tr>
<tr>
<td><code>ndarray.real</code></td>
<td>实数部分</td>
</tr>
<tr>
<td><code>ndarray.imag</code></td>
<td>虚数部分</td>
</tr>
<tr>
<td><code>ndarray.flat</code></td>
<td>数组的一维迭代器</td>
</tr>
</tbody>
</table>
</div>
<h3 id="数组接口"><a href="#数组接口" class="headerlink" title="数组接口"></a>数组接口</h3><div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__array_interface__</code></td>
<td>数组接口python端</td>
</tr>
<tr>
<td><code>__array_struct__</code></td>
<td>数组接口C语言端</td>
</tr>
</tbody>
</table>
</div>
<h3 id="ctypes外部函数接口"><a href="#ctypes外部函数接口" class="headerlink" title="ctypes外部函数接口"></a><code>ctypes</code>外部函数接口</h3><div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ndarray.ctypes</code></td>
<td>简化数组和<code>ctypes</code>模块交互的对象</td>
</tr>
</tbody>
</table>
</div>
<h2 id="np-nditer"><a href="#np-nditer" class="headerlink" title="np.nditer"></a><code>np.nditer</code></h2><ul>
<li><p><code>ndarray</code>对象的默认迭代器是序列类型的默认迭代器</p>
<ul>
<li><p>即以对象本身作为迭代器时，默认行为类似</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(X.shape[<span class="number">0</span>]):</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Routine</th>
<th>Function Version</th>
<th>Method Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>nditer(op[,flags,op_flags,...])</code></td>
<td>高性能迭代器</td>
<td>无</td>
</tr>
<tr>
<td><code>nested_iters(op,axes[,flags,op_flags,...])</code></td>
<td>在多组轴上嵌套创建<code>nditer</code>迭代器</td>
<td>无</td>
</tr>
<tr>
<td><code>ndenumerate(arr)</code></td>
<td><code>(idx,val)</code>迭代器</td>
<td>无</td>
</tr>
<tr>
<td><code>lib.Arrayterator(var[,buf_size])</code></td>
<td>适合大数组的缓冲迭代</td>
</tr>
<tr>
<td><code>flat</code></td>
<td>无</td>
<td>返回<code>np.flatiter</code>迭代器</td>
</tr>
<tr>
<td><code>ndindex(*shape)</code></td>
<td>迭代shape对应数组的索引</td>
<td>无</td>
</tr>
</tbody>
</table>
</div>
<h3 id="np-nditer-1"><a href="#np-nditer-1" class="headerlink" title="np.nditer"></a><code>np.nditer</code></h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class np.nditer(</span><br><span class="line"><span class="code">	op,</span></span><br><span class="line"><span class="code">	flags=None,</span></span><br><span class="line"><span class="code">	op_flags=None,</span></span><br><span class="line"><span class="code">	op_dtypes=None,</span></span><br><span class="line"><span class="code">	order=&#x27;K&#x27;/&#x27;C&#x27;/&#x27;F&#x27;/&#x27;A&#x27;,</span></span><br><span class="line"><span class="code">	casting=&#x27;safe&#x27;,</span></span><br><span class="line"><span class="code">	op_axes=None,</span></span><br><span class="line"><span class="code">	itershape=None,</span></span><br><span class="line"><span class="code">	buffersize=0</span></span><br><span class="line"><span class="code">)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>迭代方式</p>
<ul>
<li>通过标准python接口迭代数组中各数组标量元素</li>
<li>显式使用迭代器本身，访问其属性、方法<ul>
<li><code>np.nditer[0]</code>访问当前迭代的结果</li>
<li><code>np.iternext()</code>获取下个迭代对象</li>
</ul>
</li>
</ul>
</li>
<li><p>包含特殊属性、方法获取额外信息（可能需设置迭代标志）</p>
<ul>
<li>跟踪索引：获取索引<code>np.nditer.index</code>、
<code>np.nditer.multi_index</code></li>
<li>手动迭代<code>np.nditer.iternext()</code>得到下个
<code>np.nditer</code>对象</li>
<li>获取操作数<code>np.nditer.operands</code>：迭代器关闭之后
将无法访问，需要在关闭前获得引用</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.numpy.org.cn/reference/arrays/nditer.html">https://www.numpy.org.cn/reference/arrays/nditer.html</a></p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li><p><code>flags</code>：迭代器标志</p>
<ul>
<li><code>buffered</code>：允许缓冲<ul>
<li>增大迭代器提供给循环内部的数据块</li>
<li>减少开销、提升性能</li>
</ul>
</li>
<li><code>c_index</code>：track C顺序索引</li>
<li><code>f_index</code>：track C顺序索引</li>
<li><code>multi_index</code>：track 多维索引</li>
<li><code>common_dtype</code>：将所有操作数转换为公共类型<ul>
<li>需设置<code>copying</code>或<code>buffered</code></li>
</ul>
</li>
<li><code>copy_if_overlap</code>：迭代器决定是否读操作数覆盖写
操作数，还是使用临时副本避免覆盖</li>
<li><code>delay_bufalloc</code>：延迟缓冲区设置直至<code>reset()</code>函数
调用<ul>
<li>允许<code>allocate</code>操作数在其值被复制到缓冲区前初始化</li>
</ul>
</li>
<li><code>external_loop</code>：迭代一维数组而不是零维数组标量<ul>
<li>利于矢量化操作</li>
<li>返回的循环块与迭代顺序相关</li>
</ul>
</li>
<li><code>grow_inner</code>：允许迭代数组大小大于缓冲区大小<ul>
<li><code>buffered</code>、<code>external_loop</code>均设置情况下</li>
</ul>
</li>
<li><code>ranged</code>：</li>
<li><code>refs_ok</code>：允许迭代引用类型，如<code>object</code>数组</li>
<li><code>reduce_ok</code>：允许迭代广播后的<code>readwrite</code>操作数
（也即<code>reduction</code>操作数）</li>
<li><code>zerosize_ok</code>：允许迭代大小为0</li>
</ul>
</li>
<li><p><code>op_flags</code></p>
<ul>
<li><code>readonly</code>：操作数只能被读取</li>
<li><code>readwrite</code>：操作数能被读写</li>
<li><code>writeonly</code>：操作只能被写入</li>
<li><code>no_broadcast</code>：禁止操作数被广播</li>
<li><code>contig</code>：强制操作数数据连续</li>
<li><code>aligned</code>：强制操作数数据对齐</li>
<li><code>nbo</code>：强值操作数数据按原生字节序</li>
<li><code>copy</code>：允许临时只读拷贝</li>
<li><code>updateifcopy</code>：允许临时读写拷贝</li>
<li><code>allocate</code>：允许数组分配若<code>op</code>中包含<code>None</code><ul>
<li>迭代器为<code>None</code>分配空间，不会为非空操作数分配
空间，即使是广播后赋值空间不足</li>
<li>操作数中<code>op</code>中<code>None</code>对应<code>op_flags</code>缺省为
<code>[&quot;allocate&quot;, &quot;writeonly&quot;]</code></li>
</ul>
</li>
<li><code>no_subtype</code>：阻止<code>allocate</code>操作数使用子类型</li>
<li><code>arraymask</code>：表明对应操作数为mask数组<ul>
<li>用于从设置有<code>writemasked</code>标志的操作数中选择写回
部分</li>
</ul>
</li>
<li><code>writemasked</code>：只有<code>arraymask</code>操作数选择的元素被写回</li>
<li><code>overlap_assume_elementwise</code>：标记操作数只能按照迭代
顺序获取<ul>
<li>允许在<code>copy_if_overlap</code>设置的场合，更保守的拷贝</li>
</ul>
</li>
</ul>
</li>
<li><p><code>op_dtypes</code>：操作数需求的数据类型</p>
<ul>
<li>在循环内对单个值进行数据类型转换效率低</li>
<li>迭代器以缓冲、复制整体进行类型转换提高效率</li>
<li>需要同时设置<code>&quot;copy&quot;</code>或<code>&quot;buffered&quot;</code>，否则因无法复制、
缓冲报错（类型不同时）
（类型转换不修改原数组值，需要额外空间存储转换后值）</li>
</ul>
</li>
<li><p><code>order</code>：迭代顺序</p>
<ul>
<li><code>C</code>/<code>F</code>：C风格、Fortran风格</li>
<li><code>A</code>：若所有数组均为Fortran风格则为Fortran风格，否则
为C风格</li>
<li><code>K</code>：尽量贴近内存布局</li>
</ul>
<blockquote>
<ul>
<li><code>allocate</code>操作数的内存布局会兼容此参数设置</li>
</ul>
</blockquote>
</li>
<li><p><code>casting</code>：指明在拷贝、缓冲时允许的数据类型转换规则
（包括读取、写回数组时可能的类型转换）</p>
<ul>
<li><code>no</code>：不允许任何类型转换</li>
<li><code>equiv</code>：仅允许字节顺序改变</li>
<li><code>safe</code>：仅允许可保证数据精度的类型转换</li>
<li><code>same_kind</code>：只能允许<code>safe</code>或同类别类型转换</li>
<li><code>unsafe</code>：允许所有类型转换</li>
</ul>
</li>
<li><p><code>op_axes</code>：设置迭代器维度到操作数维度的映射</p>
<ul>
<li>需为每个操作数设置维度映射</li>
</ul>
</li>
<li><p><code>itershape</code>：设置迭代器的shape</p>
</li>
<li><p><code>buffersize</code>：设置缓冲区大小</p>
<ul>
<li><code>buffered</code>设置的情况下</li>
<li><code>0</code>表示默认大小</li>
</ul>
</li>
</ul>
<h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><ul>
<li><p>控制迭代顺序</p>
<ul>
<li>设置<code>order</code>参数</li>
<li>缺省按照<strong>内存布局</strong>迭代<ul>
<li>提高效率</li>
<li>适合不关心迭代顺序场合</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 二者迭代顺序完全相同</span></span><br><span class="line">np.nditer(X, order=<span class="string">&quot;K&quot;</span>)</span><br><span class="line">np.nditer(X.T)</span><br><span class="line"><span class="comment"># 指定按C或Fortran顺序</span></span><br><span class="line">np.nditer(X, order=<span class="string">&quot;C&quot;</span>)</span><br><span class="line">np.nditer(X, order=<span class="string">&quot;F&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改数组值</p>
<ul>
<li>设置<code>writeonly</code>、<code>readwrite</code><ul>
<li>生成可写的缓冲区数组，并在迭代完成后复制回原始
数组</li>
<li>发出迭代结束信号，将缓冲区数据复制回原始数组<ul>
<li>支持<code>with</code>语句上下文管理</li>
<li>迭代完成后手动<code>.close()</code></li>
</ul>
</li>
</ul>
</li>
<li><p>可设置<code>allocate</code>标志支持为空操作数分配空间</p>
<ul>
<li>对<code>None</code>参数<code>op</code>，其<code>op_flags</code>缺省设置为
<code>[&quot;allocate&quot;, &quot;readwrite&quot;]</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> np.nditer(X, op_flags=[<span class="string">&quot;readwrite&quot;</span>]) <span class="keyword">as</span> it:</span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">		x[...] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>迭代一维数组而不是数组标量</p>
<ul>
<li>缺省返回最低维维度长的一维数组</li>
<li>可以通过设置<code>buffered</code>扩大返回的数组长度<ul>
<li><code>buffersize</code>设置<code>buffered</code>大小，可用此参数决定
返回的数组长度</li>
<li>返回数组长度完全由<code>buffersize</code>决定，与数组shape
无关<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(30).reshape(5,6)</span><br><span class="line">for x in np.nditer(a, flags=[&quot;external<span class="emphasis">_loop&quot;, &quot;buffered&quot;], buffersize=11):</span></span><br><span class="line"><span class="emphasis">	print(x, type(x))</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>跟踪、获取索引</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">it = np.nditer(a, flags=[<span class="string">&quot;multi_index&quot;</span>])</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> it.finished:</span><br><span class="line">	<span class="built_in">print</span>(it[<span class="number">0</span>], it.multi_index)</span><br><span class="line">	it.iternext()</span><br></pre></td></tr></table></figure>
</li>
<li><p>以特定数据类型迭代</p>
<ul>
<li><code>op_dtypes</code>参数设置迭代返回的数据类型</li>
<li>需同时设置<code>&quot;copy&quot;</code>或<code>&quot;buffered&quot;</code>字段</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a, op_dtypes=[<span class="string">&quot;complex128&quot;</span>]):</span><br><span class="line">	<span class="built_in">print</span>(np.sqrt(x), end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代器分配空间</p>
<ul>
<li><code>allocate</code>标志表示允许为操作数分配空间，即允许空
操作数</li>
<li>若分配空间初值被使用，注意迭代前初始化
（如<em>reduction</em>迭代场合）</li>
</ul>
<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def square(a, ret=None):</span><br><span class="line"><span class="code">	with np.nditer([a, ret],</span></span><br><span class="line"><span class="code">		op_flags=[[&quot;readonly&quot;], [&quot;writeonly&quot;, &quot;allocate&quot;]]</span></span><br><span class="line"><span class="code">	) as it:</span></span><br><span class="line"><span class="code">		for x, y in it:</span></span><br><span class="line"><span class="code">			y[...] = x**2</span></span><br><span class="line"><span class="code">	return ret</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>外积（笛卡尔积）迭代</p>
<ul>
<li><p>设置<code>op_axes</code>参数指定各操作数<code>op</code>各维度位置、顺序</p>
<ul>
<li>迭代器负责将迭代器维度映射回各操作数维度</li>
<li>类似于手动自由广播</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定维度位置、顺序</span></span><br><span class="line">it = np.nditer([a,b,<span class="literal">None</span>], flags=[<span class="string">&quot;external_loop&quot;</span>],</span><br><span class="line">		op_axes=[[<span class="number">0</span>,-<span class="number">1</span>,-<span class="number">1</span>], [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],<span class="literal">None</span>])</span><br><span class="line"><span class="comment"># 迭代得到外积</span></span><br><span class="line"><span class="keyword">with</span> it:</span><br><span class="line">	<span class="keyword">for</span> x,y,z <span class="keyword">in</span> it:</span><br><span class="line">		z[...] = x*y</span><br><span class="line">	result = it.operands[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><em>Reduction</em>迭代</p>
<ul>
<li>触发条件：<strong>可写的</strong>操作数中元素数量<strong>小于</strong>迭代空间<ul>
<li><code>&quot;reduce_ok&quot;</code>需被设置</li>
<li><code>&quot;readwrite&quot;</code>而不是<code>&quot;writeonly&quot;</code>被设置，即使循环
内部未读</li>
<li>暗含<code>&quot;no_broadcast&quot;</code>必然不被设置</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ret = np.array([<span class="number">0</span>])</span><br><span class="line"><span class="keyword">with</span> np.nditer([a,b], flags=[<span class="string">&quot;reduce_ok&quot;</span>, <span class="string">&quot;external_loop&quot;</span>],</span><br><span class="line">		op_flags=[[<span class="string">&quot;readonly&quot;</span>], [<span class="string">&quot;readwrite&quot;</span>]]) <span class="keyword">as</span> it:</span><br><span class="line">	<span class="keyword">for</span> x,y <span class="keyword">in</span> it:</span><br><span class="line">		y[...] += x</span><br><span class="line"><span class="comment"># 或者同样设置`allocate`标志，并且在迭代器内设置初始值</span></span><br><span class="line">np.nditer([a, <span class="literal">None</span>], flags=[<span class="string">&quot;reduce_ok&quot;</span>, <span class="string">&quot;external_loop&quot;</span>],</span><br><span class="line">		op_flags=[[<span class="string">&quot;readonly&quot;</span>], [<span class="string">&quot;readwrite&quot;</span>, <span class="string">&quot;allocate&quot;</span>]],</span><br><span class="line">		op_axes=[<span class="literal">None</span>, [<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>]])</span><br><span class="line"><span class="keyword">with</span> it:</span><br><span class="line">	<span class="comment"># 设置初始值</span></span><br><span class="line">	it.operands[<span class="number">1</span>][...] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> x, y <span class="keyword">in</span> it:</span><br><span class="line">		y[...] += x</span><br><span class="line">	result = it.operands[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="nested-iters"><a href="#nested-iters" class="headerlink" title="nested_iters"></a><code>nested_iters</code></h3><ul>
<li><p><code>nested_iters</code>：按维度嵌套<code>nditer</code></p>
<ul>
<li>迭代参数类似<code>nditer</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i, j = np.nested_iters(X, flags=[<span class="string">&quot;multi_index&quot;</span>])</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> i:</span><br><span class="line">	<span class="built_in">print</span>(i.multi_index)</span><br><span class="line">	<span class="keyword">for</span> y <span class="keyword">in</span> j:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;&quot;</span>, j.multi_index, y)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="flat迭代器"><a href="#flat迭代器" class="headerlink" title="flat迭代器"></a><code>flat</code>迭代器</h3><ul>
<li><code>X.flat</code>：返回C-contiguous风格迭代器<code>np.flatiter</code><ul>
<li>支持切片、高级索引</li>
<li>实质上是数组的一维视图</li>
</ul>
</li>
</ul>
<h3 id="np-ndenumerate"><a href="#np-ndenumerate" class="headerlink" title="np.ndenumerate"></a><code>np.ndenumerate</code></h3><ul>
<li><p><code>np.ndenumerate</code>：多维索引迭代器，返回多维索引、值元组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> multi_idx, val <span class="keyword">in</span> np.ndenumerate(X):</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="np-broadcast"><a href="#np-broadcast" class="headerlink" title="np.broadcast"></a><code>np.broadcast</code></h3><ul>
<li><p><code>np.broadcast</code>：返回（多个）数组广播结果元组的迭代器</p>
<ul>
<li>类似广播后<em>zip</em>，即先将数组广播，然后将广播后元素
组合成元组作为迭代器中元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> np.broadcast([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]], [<span class="number">5</span>,<span class="number">6</span>]):</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:37.000Z" title="3/21/2019, 5:27:37 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-02-17T03:57:07.000Z" title="2/17/2019, 11:57:07 AM">2019-02-17</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Pandas/">Pandas</a></span><span class="level-item">10 minutes read (About 1573 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Pandas/data_structure.html">Pandas数据结构</a></h1><div class="content"><h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><p>可以看作包含两个Index类（index、columns）、一个二维ndarray类
（values）</p>
<ul>
<li>二维values + 结构化index + 结构化columns<ul>
<li>values自己还有两根只能使用integer indice的轴</li>
</ul>
</li>
<li>结构同数据库表相似：列为属性，行为个体</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DF = pd.DataFrame(</span><br><span class="line">	data=ndarray/&#123;col_name: val&#125;/DF/array-like,</span><br><span class="line">	index=Index/array-like,</span><br><span class="line">	columns=Index/array-like,</span><br><span class="line">	dtype=<span class="literal">None</span>/dtype,</span><br><span class="line">	copy=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># `data=dict`：可以通过`columns`仅使用部分键值对创建</span></span><br><span class="line">	<span class="comment"># `copy`：仅影响`data`为DF/ndarray时，默认不使用拷贝</span></span><br></pre></td></tr></table></figure>
<h3 id="DF行列逻辑"><a href="#DF行列逻辑" class="headerlink" title="DF行列逻辑"></a>DF行列逻辑</h3><p>可以通过<code>DF = df1.T</code>作转制更改行列逻辑</p>
<h4 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h4><h5 id="列优先"><a href="#列优先" class="headerlink" title="列优先"></a>列优先</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Ser = df1[col_name]</span><br><span class="line">Ser = df1.col_name</span><br><span class="line">	<span class="comment"># 取列</span></span><br><span class="line">Ser = df1[col_level_0, col_level_1,...]</span><br><span class="line">Ser = df1[(col_level_0, col_level_1,...)]</span><br><span class="line">Ser = df1.col_level_0.col_level_1</span><br><span class="line">	<span class="comment"># 对层级索引取列</span></span><br><span class="line"></span><br><span class="line">Val = df1[col_name][index_name]</span><br><span class="line">Val = df1.col_name.index_name</span><br><span class="line">	<span class="comment"># 取具体值</span></span><br><span class="line">	<span class="comment"># 属性方式，要求`*_name`为字符串</span></span><br><span class="line">	<span class="comment"># `.`、`[]`应该是覆盖过</span></span><br><span class="line"></span><br><span class="line">Val = df1[col_level_0, col_level_1,...]\</span><br><span class="line">	[index_level_0, index_level_1,...]</span><br><span class="line"></span><br><span class="line">Val = df1[(col_level_0, col_level_1,...)]\</span><br><span class="line">	[index_level_0, index_level_1,...]</span><br><span class="line"></span><br><span class="line">Val = df1.col_level_0.col_level_1....\</span><br><span class="line">	.index_level_0.index_level_1...</span><br><span class="line">	<span class="comment"># 对层级索引取值</span></span><br><span class="line"></span><br><span class="line">DF = df1[cond1 &amp; cond2 &amp;...]</span><br><span class="line">DF = df1[cond1][cond2]...</span><br><span class="line">	<span class="comment"># `condX`为Ser(bool)</span></span><br><span class="line">	<span class="comment"># 两种讲道理应该没差</span></span><br></pre></td></tr></table></figure>
<h5 id="行优先"><a href="#行优先" class="headerlink" title="行优先"></a>行优先</h5><h6 id="loc"><a href="#loc" class="headerlink" title=".loc[]"></a><code>.loc[]</code></h6><p>行优先,逻辑和df1[]列优先类似</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Ser = df.loc[index_name]</span><br><span class="line">	<span class="comment"># 取行</span></span><br><span class="line">Ser = df.loc[index_level_0, index_level_1,...]</span><br><span class="line">Ser = df.loc[(index_level_0, index_level_1,...)]</span><br><span class="line">	<span class="comment"># 层级索引取行Ser/DF</span></span><br><span class="line"></span><br><span class="line">Val = df1.loc[index_name, column_name]</span><br><span class="line">	<span class="comment"># 还可以这样的取值</span></span><br><span class="line">	<span class="comment"># 不建议使用，容易照成混淆</span></span><br><span class="line"> <span class="comment"># Val = df1.loc.index_name`</span></span><br><span class="line">	<span class="comment"># 不可</span></span><br><span class="line"></span><br><span class="line">Val = df1.loc[index_level_0, index_level_1,...]\</span><br><span class="line">	[col_level_0, col_level_1,...]</span><br><span class="line">	<span class="comment"># 层级索引时，index、col不能混在一起</span></span><br><span class="line"></span><br><span class="line">Val = df1.loc[(index_level_0, index_level_1,...)]\</span><br><span class="line">	[(col_level_0, col_level_1,...)]</span><br></pre></td></tr></table></figure>
<h6 id="iloc"><a href="#iloc" class="headerlink" title=".iloc[]"></a><code>.iloc[]</code></h6><p>indices locate，应视为对value（ndarray）进行操作，index和
columns的结构对其没有任何影响</p>
<ul>
<li>在层级索引情况下，仍然返回Ser</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ser = df1.iloc[indice]</span><br><span class="line">	<span class="comment"># 返回values第indice行Ser对象</span></span><br><span class="line">Val = df1.iloc[index_indice, col_indice]</span><br><span class="line">	<span class="comment"># 取得values第index_indice行、第col_indice列元素</span></span><br></pre></td></tr></table></figure>
<h6 id="ix"><a href="#ix" class="headerlink" title=".ix[]"></a><code>.ix[]</code></h6><p><code>.loc</code>、<code>.iloc</code>的封装，不建议使用</p>
<ul>
<li>优先使用<code>.loc</code>，除非参数为int、且Index不是int类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ser = df1.ix[index]</span><br></pre></td></tr></table></figure>
<h5 id="行优先快速版本"><a href="#行优先快速版本" class="headerlink" title="行优先快速版本"></a>行优先快速版本</h5><p><strong>只能</strong>、<strong>必须</strong>取一个值</p>
<ul>
<li>不能用于获取切片</li>
<li><p>对于多重索引必须将Index、Columns所有level全部指定</p>
</li>
<li><p><code>.iat</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Val = df1.iat[index_indice, col_indice]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>.at</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Val = df1.at[index_name, col_name]</span><br><span class="line">	<span class="comment"># 单索引</span></span><br><span class="line">Val = df1.at[(index_level_0, index_level_1,...), (col_level_0, col_level_1,...)]</span><br><span class="line">	<span class="comment"># 多重索引必须指定全部level保证只取到一个值</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><h4 id="Values切片"><a href="#Values切片" class="headerlink" title="Values切片"></a>Values切片</h4><p>切片对象是values</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DF = df1.iloc[irow_start: irow_end, icol_start: icol_end]</span><br><span class="line">	<span class="comment"># 对values的切片，参数都是indices</span></span><br><span class="line">	<span class="comment"># 这个应该就是ndarray切片操作，不包括上限</span></span><br><span class="line">	<span class="comment"># 如果只对行切片，可以省略`.iloc`，但不建议，因为这个</span></span><br><span class="line">		<span class="comment"># 同时也可以表示Index切片（优先）</span></span><br></pre></td></tr></table></figure>
<h4 id="Index切片"><a href="#Index切片" class="headerlink" title="Index切片"></a>Index切片</h4><p>切片对象是index，包括上限</p>
<h5 id="全切片"><a href="#全切片" class="headerlink" title="全切片"></a>全切片</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DF = df1.loc[</span><br><span class="line">	(index_0, index_1,...): (index_0, index_1,...),</span><br><span class="line">	(col_0, col_1,...): (col_0, col_1,...)]</span><br><span class="line">	<span class="comment"># `.loc`可以替换为`.ix`，但不能删除，不建议使用</span></span><br></pre></td></tr></table></figure>
<h5 id="行切片"><a href="#行切片" class="headerlink" title="行切片"></a>行切片</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DF = df1.loc[[(index_0, index_1,...),...]]</span><br><span class="line">DF = df1.loc[(index_0, index_1,...): (index_0, index_1,...)]</span><br><span class="line">	<span class="comment"># index_level可以不用指定到最低level，</span></span><br><span class="line">	<span class="comment"># 同样的，`.loc`可以替换为`.ix`，但不建议使用</span></span><br></pre></td></tr></table></figure>
<h5 id="列切片"><a href="#列切片" class="headerlink" title="列切片"></a>列切片</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DF = df1[[col_name,...]]</span><br><span class="line">DF = df1.loc[:, (col_0,...): (col_0,...)]</span><br><span class="line">	<span class="comment"># `.loc`可以替换为`.ix`，但是不能删除，不建议使用</span></span><br><span class="line">	<span class="comment"># 列切片没有`:`语法，只能通过设置行切片为`:`得到</span></span><br></pre></td></tr></table></figure>
<h3 id="DF数据共享逻辑"><a href="#DF数据共享逻辑" class="headerlink" title="DF数据共享逻辑"></a>DF数据共享逻辑</h3><p>DF数据（values）共享的逻辑</p>
<ul>
<li>一般尽量共享数据，直至无法处理（数据同时增加/删除行、列）</li>
<li>有些方法会有<code>copy</code>参数，可以显式控制是否拷贝副本<ul>
<li>如<code>.reindex</code>默认拷贝副本</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">df1_T = df1.T</span><br><span class="line">	<span class="comment"># 两个此时共享数据，对任一的更改会反映在另一者</span></span><br><span class="line">df1_T[<span class="string">&quot;new_col_1&quot;</span>] = [ ]</span><br><span class="line">	<span class="comment"># 添加新列后，两者仍然共享公共部分数据，只是`df1`中无法</span></span><br><span class="line">		<span class="comment"># 访问新列</span></span><br><span class="line">df1[<span class="string">&quot;new_col_2&quot;</span>] = [ ]</span><br><span class="line">	<span class="comment"># 此时两者数据均独立</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 类似的`del`删除列也是如此逻辑</span></span><br></pre></td></tr></table></figure>
<h2 id="Index-索引"><a href="#Index-索引" class="headerlink" title="Index 索引"></a>Index 索引</h2><p>使用integer作为index时注意df1.ix[]的逻辑</p>
<h3 id="MultiIndex-层级索引"><a href="#MultiIndex-层级索引" class="headerlink" title="MultiIndex 层级索引"></a>MultiIndex 层级索引</h3><p>层级索引允许以低维度形式表示高纬度数据</p>
<ul>
<li>层级索引可以使用tuple形式表示：<code>(level_0, level_1,...)</code><ul>
<li>需要注意区分和tuple本身作为index<ul>
<li>打印时可以tuple有括号，而层级索引没有</li>
<li>层级索引有时可以省略括号</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="from-arrays"><a href="#from-arrays" class="headerlink" title="from_arrays"></a><code>from_arrays</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Index = pd.MultiIndex.from_arrays(</span><br><span class="line">	arrays([[],[]]),</span><br><span class="line">	sortorder=<span class="literal">None</span>/<span class="built_in">int</span>,</span><br><span class="line">	names=<span class="literal">None</span>/[])</span><br><span class="line"></span><br><span class="line">Index = [</span><br><span class="line">	level_0_list,</span><br><span class="line">	level_1_list,...]</span><br><span class="line">	<span class="comment"># 隐式构建层级索引，各list长度相同，其按顺序组合</span></span><br><span class="line">	<span class="comment"># 可以在：DF构造参数、给DF对象Index赋值等使用</span></span><br><span class="line">	<span class="comment"># 应该是可以看作pandas使用`from_arrays`处理</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：将arrays转换为MultiIndex</p>
</li>
<li><p>参数</p>
<ul>
<li><code>arrays</code>：包含多个list作为各个level索引<ul>
<li>各list按照传递顺序决定level</li>
<li><strong>不会自动合并</strong>不连续labels（否则需要交换数据位置）</li>
</ul>
</li>
<li><code>sortorder</code>：sortedness级别？</li>
<li><code>names</code>：level名</li>
</ul>
</li>
</ul>
<h4 id="from-tuples"><a href="#from-tuples" class="headerlink" title="from_tuples"></a><code>from_tuples</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Index = pd.MultiIndex.from_tuples(</span><br><span class="line">	tuples=[<span class="built_in">tuple</span>-like],</span><br><span class="line">	sortorder=<span class="literal">None</span>/<span class="built_in">int</span>,</span><br><span class="line">	names=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：将<code>tuples</code>转换为MultiIndex</p>
</li>
<li><p>参数</p>
<ul>
<li><code>tuples</code>：每个tuple为一个index，按照tuple中元素顺序
决定各元素level</li>
</ul>
</li>
</ul>
<h4 id="from-product"><a href="#from-product" class="headerlink" title="from_product"></a><code>from_product</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Index = pd.MultiIndex.from_product(</span><br><span class="line">	iterables([[]]/[iterables]),</span><br><span class="line">	sortorder=<span class="literal">None</span>/<span class="built_in">int</span>,</span><br><span class="line">	names)</span><br></pre></td></tr></table></figure>
<ul>
<li>说明：对<code>iterables</code>元素作product（积）作为MultiIndex</li>
</ul>
<ol>
<li><p>Series：可以看作是包含一个Index类（index，存放标签）、一个一维ndarray类（values，存放数据）</p>
<p>a.    ser=pd.Series(data=np.darray/dict, index=list)</p>
<p>b.    Series对象可以处理标签不一致的数据，但是只有标签的交集才能得到有意义的结果，其余为NaN</p>
<p>c.    其余性质类似于DataFrame对象</p>
</li>
<li><p>Index属性#todo</p>
<p>a.    index属性</p>
<ol>
<li><p>df1.columns=[]：更改列名称，index同</p>
</li>
<li><p>df1.columns.names=[]：更改列名，index同</p>
</li>
</ol>
</li>
<li><p>pandas库中的其他一些问题</p>
<p>a.    数据类型转换：Series对象和DF对象在运算过程中dtype类型可能发生”无意义”的转换</p>
<ol>
<li><p>dtype=i8的对象之间的+、-结果为dtype=f8类型的对象（当然这个可能是保持和\的一致性）</p>
</li>
<li><p>SeriesObj.reindex(new_index)会”可能”会改变原有数据类型（由i8-&gt;f8）（有增加新index时）</p>
</li>
</ol>
</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:37.000Z" title="3/21/2019, 5:27:37 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-02-17T03:57:07.000Z" title="2/17/2019, 11:57:07 AM">2019-02-17</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Pandas/">Pandas</a></span><span class="level-item">33 minutes read (About 4992 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Pandas/df_funcs.html">Pandas函数目录</a></h1><div class="content"><h2 id="“内容结构”变换"><a href="#“内容结构”变换" class="headerlink" title="“内容结构”变换"></a>“内容结构”变换</h2><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><h4 id="merge"><a href="#merge" class="headerlink" title="merge"></a><code>merge</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DF = pd.merge(</span><br><span class="line">	left(DF),</span><br><span class="line">	right(DF),</span><br><span class="line">	on=col_name/[col_names],</span><br><span class="line">	left_on=<span class="string">&quot;left_col_name&quot;</span>,</span><br><span class="line">	right_on=<span class="string">&quot;right_col_name&quot;</span>,</span><br><span class="line">	left_index=<span class="literal">False</span>/<span class="literal">True</span>,</span><br><span class="line">	right_index=<span class="literal">False</span>/true,</span><br><span class="line">	how=<span class="string">&quot;Inner&quot;</span>/<span class="string">&quot;outer&quot;</span>/<span class="string">&quot;left&quot;</span>/<span class="string">&quot;right&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>功能：合并操作，类似于sql的<em>join</em>操作</p>
</li>
<li><p>参数</p>
<ul>
<li><code>on</code>：merge合并基准列，可以是多个列名称的list，df1、
df2仅有一列名称相同时可省略，否则返回空DF对象</li>
<li><code>left_on</code>、<code>right_on</code>：df1、df2合并基准列名称不同时
使用</li>
<li><code>left_index</code>、<code>right_index</code>：默认为<code>False</code>，值为
<code>True</code>时使用索引作为基准进行合并（此时也可以使用
<code>df1.join(df2)</code>）</li>
<li><code>how</code>：合并方式，默认是inner join，参数取值：’outer’
、’left’、’right’（不知道能不能取’inner’，这个应该
是默认取值，可以使用）</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li>df1、df2有多个列名相同且不全是合并基准列时，返回的
DF对象的重复列名称会改变</li>
</ul>
</li>
</ul>
<h4 id="join"><a href="#join" class="headerlink" title="join"></a><code>join</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DF = df1.join(</span><br><span class="line">	other(DF/Ser/[DF]),</span><br><span class="line">	on=<span class="literal">None</span>/[col_names],</span><br><span class="line">	how=<span class="string">&quot;Left/right/outer/inner&quot;</span>,</span><br><span class="line">	lsuffix=<span class="built_in">str</span>,</span><br><span class="line">	rsuffix=<span class="built_in">str</span>,</span><br><span class="line">	sort=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：和其他DF对象进行join操作</p>
</li>
<li><p>参数</p>
<ul>
<li><code>other</code><ul>
<li>参数为Ser时，必须设置field名称</li>
</ul>
</li>
<li><code>on</code><ul>
<li>默认<code>None</code>，按照index-on-index进行join</li>
<li>也可以按照col_name进行join</li>
</ul>
</li>
<li><code>how</code>：同上</li>
<li><code>lsuffix</code>：df1重名列使用的后缀</li>
<li><code>rsuffix</code>：df2重名列使用的后缀</li>
<li><code>sort</code>：按照join-key排序</li>
</ul>
</li>
</ul>
<h4 id="concat"><a href="#concat" class="headerlink" title="concat"></a><code>concat</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Df/Ser = pd.concat(</span><br><span class="line">	objs=[Ser, DF, <span class="built_in">dict</span>],</span><br><span class="line">	axix=<span class="number">0</span>/<span class="number">1</span>/<span class="string">&quot;index&quot;</span>/<span class="string">&quot;columns&quot;</span>,</span><br><span class="line">	join=<span class="string">&quot;Outer&quot;</span>/<span class="string">&quot;inner&quot;</span>,</span><br><span class="line">	join_axes=<span class="literal">None</span>/[index],</span><br><span class="line">	ignore_index=<span class="literal">False</span>/<span class="literal">True</span>,</span><br><span class="line">	keys=<span class="literal">None</span>/[]/[()],</span><br><span class="line">	levels=<span class="literal">None</span>/[],</span><br><span class="line">	names=<span class="literal">None</span>/[index_names],</span><br><span class="line">	verify_integrity=<span class="literal">False</span>,</span><br><span class="line">	copy=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：以某个轴为方向将多个Series对象或DF对象拼接</p>
</li>
<li><p>参数</p>
<ul>
<li><code>objs</code><ul>
<li>dict作为参数值传递，排序后的keys传递给<code>keys</code></li>
</ul>
</li>
<li><code>join</code>：处理其他轴的方式（其他轴长度、命名不同）</li>
<li><code>join_axes</code>：指定其他轴的index</li>
<li><code>ingore_index</code>：默认<code>False</code>，为<code>True</code>拼接后的DF的
Index将为RangeIndex</li>
<li><code>keys</code>：指定构建多级索引最外层Index</li>
<li><code>levels</code>：用于构建多重索引的具体层级，默认从<code>keys</code>
推断</li>
<li><code>names</code>：返回DF对象索引名称</li>
<li><code>verify_integrity</code>：默认<code>False</code>，不检查返回DF对象
是否含有重复index
<code>copy</code>：默认拷贝数据</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li><p><code>pd.concat</code>只涉及拼接方向，而merge只能沿列数增加的
方向“拼接”</p>
</li>
<li><p><code>pd.concat()</code>时即使有相同的列名称、index序号也不会
重命名</p>
</li>
<li><p><code>pd.concat(axis=1,...)</code>和
<code>pd.merge(left_index=True, right_index=True,...)</code>的
作用应该是一样的，只是不会将相同的列名称重命名</p>
</li>
<li><p><code>pd.merge</code>可以指定合并基准列，而<code>pd.concat</code>只能按
Index“合并”，且只能inner join或时outer join</p>
</li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li><p><code>pd.concat</code>默认会对索引进行排序，所以若索引包含不可
比较元素则会报错，尤其是在多重索引情况下</p>
<ul>
<li><p>改变索引类型规避</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改为categorical索引</span></span><br><span class="line">df.index.astype(<span class="string">&quot;categorical&quot;</span>)</span><br><span class="line"><span class="comment"># 改为str类型</span></span><br><span class="line">df.index.astype(<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>reset索引规避</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_new = pd.cancat([df1.reset_index(), df2.reset_index()])</span><br><span class="line">df_new = df_new.set_index(col_name)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>pd.concat</code>连接会尝试转换数据类型，如：
<code>pd.Timestamp</code>可能会被转换为<code>int</code></p>
</li>
</ul>
</li>
</ul>
<h4 id="combine-first"><a href="#combine-first" class="headerlink" title="combine_first"></a><code>combine_first</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ser = ser1.combine_first(other(Ser))</span><br><span class="line">Df = df1.combine_first(other(DF))</span><br></pre></td></tr></table></figure>
<ul>
<li>说明：和其他DF/Ser进行元素级别的combine，即填充<strong>NULL</strong>
元素<ul>
<li>元素级别</li>
<li>返回对象包含所有的index</li>
</ul>
</li>
</ul>
<h3 id="增、删"><a href="#增、删" class="headerlink" title="增、删"></a>增、删</h3><h4 id="drop"><a href="#drop" class="headerlink" title="drop"></a><code>drop</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DF/<span class="literal">None</span> = df1.drop(</span><br><span class="line">	labels=<span class="literal">None</span>/label/[labels],</span><br><span class="line">	axis=<span class="number">0</span>/<span class="number">1</span>/<span class="string">&quot;index&quot;</span>/<span class="string">&quot;columns&quot;</span>,</span><br><span class="line">	index=<span class="literal">None</span>/index_name/[index_names],</span><br><span class="line">	columns=<span class="literal">None</span>/col_name/[col_names],</span><br><span class="line">	level=<span class="literal">None</span>/<span class="built_in">int</span>/level_name,</span><br><span class="line">	inplace=<span class="literal">False</span>,</span><br><span class="line">	errors==<span class="string">&quot;Raise/ignore&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：删除df1某轴上的labels</p>
</li>
<li><p>参数</p>
<ul>
<li><code>columns</code>/<code>index</code>：替代<code>axis</code>+<code>label</code>指定需要删除的
列/行</li>
</ul>
</li>
</ul>
<h4 id="new-col-name"><a href="#new-col-name" class="headerlink" title="[new_col_name]"></a><code>[new_col_name]</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df1[new_col_name] = <span class="built_in">list</span></span><br><span class="line">df1.loc[new_index_name] = <span class="built_in">list</span></span><br></pre></td></tr></table></figure>
<ul>
<li>说明：添加新列/行<ul>
<li><code>.iloc[new_index_name]</code>不可用</li>
</ul>
</li>
</ul>
<h4 id="append"><a href="#append" class="headerlink" title="append"></a><code>append</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DF = df1.append(</span><br><span class="line">	other(DF/Ser/<span class="built_in">dict</span>/[]),</span><br><span class="line">	ignore_index=<span class="literal">False</span>,</span><br><span class="line">	verify_integrity=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>说明：将<code>other</code>行追加到df1</li>
</ul>
<h4 id="del"><a href="#del" class="headerlink" title="del"></a><code>del</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> df1[col_name]</span><br><span class="line">	<span class="comment"># python自身语法直接删除某列</span></span><br></pre></td></tr></table></figure>
<h2 id="形、态变换"><a href="#形、态变换" class="headerlink" title="形、态变换"></a>形、态变换</h2><h3 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h3><h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a><code>stack</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DF/Ser = df1.stack(</span><br><span class="line">	level=-<span class="number">1</span>/<span class="built_in">int</span>,</span><br><span class="line">	dropna=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：<strong>旋转</strong><code>level</code>级列索引</p>
</li>
<li><p>参数</p>
<ul>
<li><code>dropna</code>：默认剔除返回DF/Ser对象中NULL行</li>
</ul>
</li>
</ul>
<h4 id="unstack"><a href="#unstack" class="headerlink" title="unstack"></a><code>unstack</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DF/Ser = df1.unstack(</span><br><span class="line">	level=-<span class="number">1</span>/<span class="built_in">int</span>,</span><br><span class="line">	fill_value=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：<strong>旋转</strong><code>level</code>级行索引</p>
</li>
<li><p>参数</p>
<ul>
<li><code>fill_value</code>：替换NaN的值</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li>两个函数好像都有排序操作，<code>df1.unstack().stack()</code>会
合并层级索引</li>
</ul>
</li>
</ul>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="sort-index"><a href="#sort-index" class="headerlink" title="sort_index"></a><code>sort_index</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DF = df1.sort_index(</span><br><span class="line">	axis=<span class="number">0</span>/<span class="number">1</span>,</span><br><span class="line">	level=<span class="literal">None</span>/<span class="built_in">int</span>/<span class="built_in">str</span>,</span><br><span class="line">	ascending=<span class="literal">True</span>,</span><br><span class="line">	inplace=<span class="literal">False</span>,</span><br><span class="line">	kind=<span class="string">&quot;Quicksort&quot;</span>/<span class="string">&quot;mergesort&quot;</span>/<span class="string">&quot;heapsort&quot;</span>,</span><br><span class="line">	na_position=<span class="string">&quot;First&quot;</span>/<span class="string">&quot;last&quot;</span>,</span><br><span class="line">	sort_remaining=<span class="literal">True</span>/<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：按照labels排序</p>
</li>
<li><p>参数</p>
<ul>
<li><code>kind</code>：排序方法</li>
<li><code>na_position</code>：默认将NaN放在开头<ul>
<li>对多重索引无效</li>
</ul>
</li>
<li><code>sort_remaining</code>：默认依次对剩余层级排序</li>
</ul>
</li>
</ul>
<h4 id="sort-value"><a href="#sort-value" class="headerlink" title="sort_value"></a><code>sort_value</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DF = df1.sort_value(</span><br><span class="line">	by(label/[labels]),</span><br><span class="line">	axis=<span class="number">0</span>/<span class="number">1</span>,</span><br><span class="line">	ascending=<span class="literal">True</span>/<span class="literal">False</span>,</span><br><span class="line">	inplace=<span class="literal">False</span>,</span><br><span class="line">	kind=<span class="string">&quot;Quicksort&quot;</span>/<span class="string">&quot;mergesort&quot;</span>/<span class="string">&quot;heapsort&quot;</span>,</span><br><span class="line">	na_position=<span class="string">&quot;Last&quot;</span>/<span class="string">&quot;first&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>说明：依某labels（行、列）值排列</li>
</ul>
<h4 id="rank"><a href="#rank" class="headerlink" title="rank"></a><code>rank</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DF = df1.rank(</span><br><span class="line">	axis=<span class="number">0</span>/<span class="number">1</span>,</span><br><span class="line">	method=<span class="string">&quot;Average&quot;</span>/<span class="string">&quot;min&quot;</span>/<span class="string">&quot;max&quot;</span>/<span class="string">&quot;first&quot;</span>/<span class="string">&quot;dense&quot;</span>,</span><br><span class="line">	numeric_only=<span class="literal">None</span>/<span class="literal">True</span>/<span class="literal">False</span>,</span><br><span class="line">	na_option=<span class="string">&quot;Keep&quot;</span>/<span class="string">&quot;top&quot;</span>/<span class="string">&quot;bottom&quot;</span>,</span><br><span class="line">	ascending=<span class="literal">True</span>,</span><br><span class="line">	pct=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：沿轴计算数值型数据的rank</p>
<ul>
<li>rank值相同者取rank值平均</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><code>method</code><ul>
<li><code>average</code>：组（延轴分组）rank平均</li>
<li><code>min</code>/<code>max</code>：组内最小/大</li>
<li><code>first</code>：label出现顺序优先</li>
<li><code>dense</code>：类似<code>min</code>，但是rank值总是增加1</li>
</ul>
</li>
<li><code>numeric_only</code>：默认不考虑<strong>含有</strong>非数值型数据label<ul>
<li>但是文档上确实写默认值为<code>None</code></li>
</ul>
</li>
<li><code>na_option</code><ul>
<li><code>keep</code>：NaN值rank值不变</li>
<li><code>top</code>：NaN作为“小”值</li>
<li><code>bottom</code>：NaN作为“大”值</li>
</ul>
</li>
<li><code>ascending</code>：默认小值rank值小</li>
<li><code>pct</code>：默认不计算rank值占比</li>
</ul>
</li>
</ul>
<h4 id="take"><a href="#take" class="headerlink" title="take"></a><code>take</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DF = df1.take(</span><br><span class="line">	indices([indice]),</span><br><span class="line">	axis=<span class="number">0</span>/<span class="number">1</span>,</span><br><span class="line">	covert=<span class="literal">True</span>,</span><br><span class="line">	is_copy=<span class="literal">True</span>,</span><br><span class="line">	**kwargs)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：按照indices对应的labels顺序返回DF</p>
</li>
<li><p>参数</p>
<ul>
<li><code>indices</code>：指明返回indices、及其顺序<ul>
<li>indices是指行数，不是labels</li>
<li>可以为负值indice，类似list</li>
</ul>
</li>
<li><code>convert</code>：是否处理负值indice（将废除，均处理）</li>
<li><code>is_copy</code>：默认创建副本返回</li>
</ul>
</li>
</ul>
<h4 id="reindex"><a href="#reindex" class="headerlink" title="reindex"></a><code>reindex</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DF = df1.reindex(</span><br><span class="line">	labels=<span class="literal">None</span>/[labels]/Index,</span><br><span class="line">	index=<span class="literal">None</span>/[labels]/Index,</span><br><span class="line">	columns=<span class="literal">None</span>/[labels],</span><br><span class="line">	axis=<span class="number">0</span>/<span class="number">1</span>/<span class="string">&quot;index&quot;</span>/<span class="string">&quot;columns&quot;</span>,</span><br><span class="line">	method=<span class="literal">None</span>/<span class="string">&quot;backfill&quot;</span>/<span class="string">&quot;bfill&quot;</span>/<span class="string">&quot;pad&quot;</span>/<span class="string">&quot;ffill&quot;</span>/<span class="string">&quot;nearest&quot;</span>,</span><br><span class="line">	copy=<span class="literal">True</span>/<span class="literal">False</span>,</span><br><span class="line">	level=<span class="literal">None</span>/<span class="built_in">int</span>/level_name,</span><br><span class="line">	fill_value=NaN/scalar,</span><br><span class="line">	limit=<span class="literal">None</span>/limit,</span><br><span class="line">	tolerance=scalar/array-like)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：将DF对象转换有其他Index的对象</p>
<ul>
<li>可以包含之前没有的labels</li>
<li>类似于labels版本<code>.take</code>，是<strong>选择</strong>不是重命名</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><code>labels</code>：新Index，配合<code>axis</code>决定替换轴</li>
<li><code>index</code>/<code>columns</code>：两根轴的Index</li>
<li><code>method</code>：新labels值填补方法<ul>
<li>用于填补的值不一定会出现在返回DF对象中，可能是
使用原DF对象中未被选择labels</li>
</ul>
</li>
<li><code>copy</code>：默认拷贝副本</li>
<li><code>fill_value</code>：新labels值填补值</li>
<li><code>limit</code>：允许最长连续使用<code>method</code>方法填补值</li>
<li><code>tolerance</code>：使用<code>method</code>方法填补新labels值时，用于
填补labels和新labels的最大差距<ul>
<li>超过<code>tolerance</code>则为默认NaN</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><h3 id="简单统计"><a href="#简单统计" class="headerlink" title="简单统计"></a>简单统计</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Ser = df1.<span class="built_in">sum</span>(</span><br><span class="line">	level=<span class="literal">None</span>/<span class="number">0</span>/<span class="number">1</span>,</span><br><span class="line">	axis=<span class="number">0</span>/<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">Ser = df1.mean(</span><br><span class="line">	axis=<span class="number">0</span>/<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">Ser = df1.std(</span><br><span class="line">	axis=<span class="number">0</span>/<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">DF = df1.describe()</span><br><span class="line"></span><br><span class="line">DF = df1.corr()</span><br><span class="line"></span><br><span class="line">DF = df1.cov()</span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> = ser1.corr(</span><br><span class="line">	ser1)</span><br><span class="line"></span><br><span class="line">Ser = df1.corwith(</span><br><span class="line">	other(DF/Ser),</span><br><span class="line">	axis=<span class="number">0</span>/<span class="number">1</span>,</span><br><span class="line">	drop=<span class="literal">False</span>/<span class="literal">True</span>)</span><br><span class="line">	<span class="comment"># `other`为DF对象时计算相同名称相关系数</span></span><br></pre></td></tr></table></figure>
<h4 id="value-count"><a href="#value-count" class="headerlink" title="value_count"></a><code>value_count</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Ser = pd.value_counts(</span><br><span class="line">	values(ndarray(1d)),</span><br><span class="line">	sort=<span class="literal">True</span>/<span class="literal">False</span>,</span><br><span class="line">	ascending=<span class="literal">False</span>/<span class="literal">True</span>,</span><br><span class="line">	normalize=<span class="literal">False</span>/<span class="literal">True</span>,</span><br><span class="line">	bins=<span class="literal">None</span>/<span class="built_in">int</span>/[num],</span><br><span class="line">	dropna=<span class="literal">True</span>/<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：计算hisgram</p>
</li>
<li><p>参数</p>
<ul>
<li><code>sort</code>：默认按值排序</li>
<li><code>normalize</code>：默认不正则化（计算相对histgram）</li>
<li><code>bins</code>：hisgrams划分bins<ul>
<li>默认每个值划分为一个bins</li>
<li>给出<code>int</code>时表示数目，<code>(min, max]</code>均等分</li>
<li>给出<code>[num]</code>计算列表内数量（范围外不考虑）</li>
</ul>
</li>
<li><code>dropna</code>：默认不计算NaN值个数</li>
</ul>
</li>
</ul>
<h4 id="quantile"><a href="#quantile" class="headerlink" title="quantile"></a><code>quantile</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ser/DF = df1.quantile(</span><br><span class="line">	q=<span class="number">0.5</span>/<span class="built_in">float</span>/[<span class="built_in">float</span>],</span><br><span class="line">	axis=<span class="number">0</span>/<span class="number">1</span>/<span class="string">&quot;index&quot;</span>/<span class="string">&quot;columns&quot;</span>,</span><br><span class="line">	numeric_only=<span class="literal">True</span>,</span><br><span class="line">	interpolation=<span class="string">&quot;linear&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：计算<code>q</code>分位数</p>
</li>
<li><p>参数</p>
<ul>
<li><code>q</code>：分位，可以是列表，计算多个分位数</li>
<li><code>interpolation</code>：分位数计算方式（分位数位i、j间）<ul>
<li><code>linear</code>：<code>i+(j-i)*fraction</code>（线性回归）</li>
<li><code>low</code>：<code>i</code></li>
<li><code>high</code>：<code>i+1</code></li>
<li><code>nearest</code>：<code>i</code>、<code>i+1</code>中近者</li>
<li><code>midpoint</code>：(<code>i</code>+<code>j</code>)/2</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="元素级"><a href="#元素级" class="headerlink" title="元素级"></a>元素级</h2><h3 id="Apply"><a href="#Apply" class="headerlink" title="Apply"></a>Apply</h3><h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a><code>apply</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DF/Ser = df1.apply(</span><br><span class="line">	func(func/&#123;label: func&#125;),</span><br><span class="line">	axis=<span class="number">0</span>/<span class="number">1</span>/<span class="string">&quot;index&quot;</span>/<span class="string">&quot;columns&quot;</span>,</span><br><span class="line">	broadcast=<span class="literal">False</span>,</span><br><span class="line">	raw=<span class="literal">False</span>,</span><br><span class="line">	reduce=<span class="literal">None</span>/<span class="literal">True</span>/<span class="literal">False</span>,</span><br><span class="line">	args=(),</span><br><span class="line">	**kwargs)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：对<code>df1</code>沿轴方向labels应用func</p>
<ul>
<li>可以用于DFGB对象<ul>
<li>为聚合函数时返回DF对象Index为groupby键，类似于
<code>agg</code></li>
<li>非聚合函数时返回DF对象为原Index，类似于
<code>transform</code>，但包含用于groupby的label</li>
<li>但是此时其他参数无法使用，<code>func</code>也仅能为单一
function，而<code>agg</code>可以使用各种</li>
</ul>
</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><code>broadcast</code>：仅对aggregation（聚合）函数，默认不保持
原shape<ul>
<li>0.23.0 deprecated</li>
</ul>
</li>
<li><code>raw</code>：默认不是将label作为ndarray对象传递，而是保持
Series对象<ul>
<li>如果函数处理nadarry对象，<code>True</code>性能更好</li>
</ul>
</li>
<li><code>reduce</code>：默认根据函数判断是否返回DF<ul>
<li><code>False</code>：尽量返回DF对象</li>
<li>0.23.0 deprecated</li>
</ul>
</li>
<li><code>result_type</code><ul>
<li><code>expand</code>：返回DF对象</li>
<li><code>reduce</code>：尽量返回Ser对象</li>
<li><code>broadcast</code>：保持原shape返回</li>
<li>0.23.0 new</li>
</ul>
</li>
<li><code>args</code>：传递给<code>func</code>的VAR_POSITIONs</li>
<li><code>kwargs</code>：传递给<code>func</code>的VAR_KEYWORDs</li>
</ul>
</li>
</ul>
<h4 id="agg"><a href="#agg" class="headerlink" title="agg"></a><code>agg</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DF = df1.agg(</span><br><span class="line">	func(<span class="built_in">callable</span>/<span class="string">&quot;func_name&quot;</span>(<span class="built_in">str</span>)/&#123;label:func&#125;/[],</span><br><span class="line">	axis=<span class="number">0</span>/<span class="number">1</span>/<span class="string">&quot;index&quot;</span>/<span class="string">&quot;columns&quot;</span>,</span><br><span class="line">	*args,</span><br><span class="line">	**kwargs)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：聚合</p>
<ul>
<li>可以用于DFGB，必然返回DF，因此要求函数<strong>结果</strong>必须
聚合<ul>
<li>如果分组结果都只有单个label，函数可以非聚合</li>
<li>如果分结果中由多label分组，函数必须聚合</li>
</ul>
</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><code>func</code><ul>
<li>dict键应为column labels，值为function</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="transform"><a href="#transform" class="headerlink" title="transform"></a><code>transform</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DF = df1/dfgb1.transform(</span><br><span class="line">	func(<span class="built_in">callable</span>/<span class="string">&quot;func_name&quot;</span>(<span class="built_in">str</span>)/<span class="built_in">dict</span>/[]),</span><br><span class="line">	*args,</span><br><span class="line">	**kwargs)</span><br></pre></td></tr></table></figure>
<ul>
<li>说明：返回应用<code>func</code>处理后DF<ul>
<li>应用于DF对象时，等同于<code>axis=0</code>的<code>agg</code>、<code>apply</code></li>
<li>应用于DFGB对象时，无价值，和应用于原DF对象结果一样，
仅剔除groupby label</li>
</ul>
</li>
</ul>
<h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a><code>replace</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DF = df1.replace(</span><br><span class="line">	to_replace=<span class="literal">None</span>/<span class="built_in">str</span>/regex/num/[]/&#123;&#125;/Series,</span><br><span class="line">	value=<span class="literal">None</span>/<span class="built_in">str</span>/num/[]/&#123;&#125;,</span><br><span class="line">	inplace=<span class="literal">False</span>,</span><br><span class="line">	limit=<span class="literal">None</span>/<span class="built_in">int</span>,</span><br><span class="line">	regex=<span class="literal">False</span>,</span><br><span class="line">	method=<span class="string">&quot;pad&quot;</span>/<span class="string">&quot;ffill&quot;</span>/<span class="string">&quot;bfill&quot;</span>/<span class="string">&quot;backfill&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：替换</p>
</li>
<li><p>参数</p>
<ul>
<li><code>to_replace</code>：<strong>被替换</strong>对象<ul>
<li>str/regex/num：匹配str/regex/num的值被替换为<code>value</code></li>
<li>[ ]<ul>
<li><code>value</code>也为list时，长度必须相同</li>
<li>str元素可看作regex</li>
</ul>
</li>
<li>{}<ul>
<li>nested dict顶层键匹配列label，然后应用对应
子dict进行匹配（此时包含<code>value</code>功能）</li>
<li>非顶层键可以为regex</li>
</ul>
</li>
<li>None：此时<code>regex</code>必为str/[]/{}/Ser</li>
</ul>
</li>
<li><code>value</code>：<strong>替换</strong>值<ul>
<li>str/num：替换值</li>
<li>{}：键匹配列label然后替换值，无匹配保持原样</li>
<li>[ ]：长度必须和<code>to_replace</code>相同</li>
</ul>
</li>
<li><code>limit</code>：允许最长连续bfill、ffill替换</li>
<li><code>regex</code><ul>
<li>为<code>True</code>时，<code>to_replace</code>、<code>value</code>将作为regex</li>
<li>代替<code>to_replace</code>作regex替换</li>
</ul>
</li>
<li><code>method</code>：<code>to_replace</code>为list时替换方法</li>
</ul>
</li>
<li><p>说明</p>
<ul>
<li><code>to_replace</code>为{regex:str}时，只替换DF中str匹配的部分
，如果需要替换整个str，需要<code>^.*str.*$</code>匹配整个str</li>
<li>但为{regex:int}时，不需要<code>^.*str.*$</code>也会匹配整个str
并替换为int</li>
</ul>
</li>
</ul>
<h4 id="where"><a href="#where" class="headerlink" title="where"></a><code>where</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">df = df1.where(</span><br><span class="line">	cond(df(<span class="built_in">bool</span>)/<span class="built_in">callable</span>/[]),</span><br><span class="line">	other=num/df/<span class="built_in">callable</span>,</span><br><span class="line">	inplace=false,</span><br><span class="line">	axis=none,</span><br><span class="line">	level=none,</span><br><span class="line">	errors=<span class="string">&quot;raise&quot;</span>,</span><br><span class="line">	try_cast=<span class="literal">False</span>,</span><br><span class="line">	raise_on_error=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：mask <code>True</code>，替换<code>False</code>为<code>other</code>值，默认（<code>other</code>
中无法找到对应值）NaN</p>
<ul>
<li><code>cond</code>、<code>other</code>是按照<code>[index][col]</code>对应位置，而不是
打印位置</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><code>cond</code><ul>
<li>DF(bool)：<code>True</code>保持原值不变，<code>False</code>从<code>other</code>
替换</li>
<li>callable：应用在<code>df1</code>上，返回DF(bool)，不应改变
`df</li>
<li><code>cond</code>不提供位置视为被替换1`</li>
</ul>
</li>
<li><code>other</code><ul>
<li>num：替换为num</li>
<li>DF：替换值</li>
<li>callable：应用在<code>df1</code>上，返回DF用于替换</li>
</ul>
</li>
<li><code>axis</code>：alignment axis if needed</li>
<li><code>level</code>：alignemnt level if needed</li>
<li><code>errors</code><ul>
<li><code>raise</code>：允许raise exceptions</li>
<li><code>ignore</code>：suppress exceptions，错误时返回原对象</li>
</ul>
</li>
<li><code>try_cast</code>：默认不尝试将结果cast为原输入</li>
</ul>
</li>
</ul>
<h4 id="mask"><a href="#mask" class="headerlink" title="mask"></a><code>mask</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DF = df1.mask(</span><br><span class="line">	cond(DF(<span class="built_in">bool</span>)/<span class="built_in">callable</span>/[]),</span><br><span class="line">	other=num/DF/<span class="built_in">callable</span>,</span><br><span class="line">	inplace=<span class="literal">False</span>,</span><br><span class="line">	axis=<span class="literal">None</span>,</span><br><span class="line">	level=<span class="literal">None</span>,</span><br><span class="line">	errors=<span class="string">&quot;raise&quot;</span>,</span><br><span class="line">	try_cast=<span class="literal">False</span>,</span><br><span class="line">	raise_on_error=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>说明：<code>True</code>、<code>False</code> mask规则同<code>where</code>相反，其他同</li>
</ul>
<h3 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h3><h4 id="isin"><a href="#isin" class="headerlink" title="isin"></a><code>isin</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DF = df1.isin(</span><br><span class="line">	values(iterable/&#123;&#125;/DF))</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：判断元素是否存在于<code>values</code>中</p>
</li>
<li><p>参数</p>
<ul>
<li><code>values</code><ul>
<li>iterable：元素在iterable中为<code>True</code></li>
<li>{}：<code>df1</code>元素在dict中对应键<strong>值</strong>中存在为<code>True</code></li>
<li>DF：<code>df1</code>元素在DF对应index、columns labels存在
才为<code>True</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="to-numeric"><a href="#to-numeric" class="headerlink" title="to_numeric"></a><code>to_numeric</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Ser = pd.to_numeric(</span><br><span class="line">	arg([]/()/ndarray(1d)/Ser),</span><br><span class="line">	errors=<span class="string">&quot;Raise&quot;</span>/<span class="string">&quot;ingore&quot;</span>/<span class="string">&quot;coerce&quot;</span>,</span><br><span class="line">	downcast=<span class="literal">None</span>/<span class="string">&quot;integer&quot;</span>/<span class="string">&quot;signed&quot;</span>/<span class="string">&quot;unsigned&quot;</span>/<span class="string">&quot;float&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：转换为numeric类型</p>
</li>
<li><p>参数</p>
<ul>
<li><code>errors</code><ul>
<li><code>raise</code>：无效值将raise exception</li>
<li><code>coerce</code>：无效值设为NaN</li>
<li><code>ignore</code>：无效值保持原样</li>
</ul>
</li>
<li><code>downcast</code>：根据参数downcast值为“最小”类型<ul>
<li>downcast过程中exception不受<code>errors</code>影响</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="to-datetime"><a href="#to-datetime" class="headerlink" title="to_datetime"></a><code>to_datetime</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Ser = pd.to_datetime(</span><br><span class="line">	arg(<span class="built_in">int</span>/<span class="built_in">float</span>/<span class="built_in">str</span>/datetime/[]/()/ndarray(1d)/Ser/DF,</span><br><span class="line">	error=<span class="string">&quot;Raise&quot;</span>/<span class="string">&quot;ignore&quot;</span>/<span class="string">&quot;coerce&quot;</span>,</span><br><span class="line">	dayfirst=<span class="literal">False</span>,</span><br><span class="line">	yearfirst=<span class="literal">False</span>,</span><br><span class="line">	utc=<span class="literal">None</span>/<span class="literal">True</span>,</span><br><span class="line">	box=<span class="literal">True</span>/<span class="literal">False</span>,</span><br><span class="line">	<span class="built_in">format</span>=<span class="literal">None</span>/<span class="built_in">str</span>,</span><br><span class="line">	exact=<span class="literal">True</span>,</span><br><span class="line">	unit=<span class="string">&quot;ns&quot;</span>/<span class="string">&quot;D&quot;</span>/<span class="string">&quot;s&quot;</span>/<span class="string">&quot;ms&quot;</span>/<span class="string">&quot;us&quot;</span>/<span class="string">&quot;ns&quot;</span>,</span><br><span class="line">	infer_datatime_format=<span class="literal">False</span>,</span><br><span class="line">	origin=<span class="string">&quot;unit&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：转换为datetime</p>
</li>
<li><p>参数</p>
<ul>
<li><code>dayfirst</code>：处理类”10/11/12”，设置day在前</li>
<li><code>yearfirst</code>：处理类”10/11/12”，设置year在前</li>
<li><code>utc</code>：默认不返回UTC DatatimeIndex</li>
<li><code>box</code><ul>
<li><code>True</code>：返回DatetimeIndex</li>
<li><code>False</code>：返回ndarray值</li>
</ul>
</li>
<li><code>format</code>：parse格式，如”%d/%m/%y %H:%M:%S”</li>
<li><code>exact</code>：默认要求<code>arg</code>精确匹配<code>format</code></li>
<li><code>unit</code>：<code>arg</code>传递数值时作为单位</li>
<li><code>infer_datatime_format</code>：在<code>format</code>为<code>None</code>时，尝试
猜测格式，并选择最快的方式parse，耗时5~10倍</li>
<li><code>origin</code>：决定参考（起始）时间<ul>
<li><code>unix</code>：起始时间：1970-01-01</li>
<li><code>julian</code>：4714 BC 1.1（此时<code>unit</code>必须为<code>D</code>）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="infer-objects"><a href="#infer-objects" class="headerlink" title="infer_objects"></a><code>infer_objects</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DF = df1.infer_objects()</span><br></pre></td></tr></table></figure>
<ul>
<li>说明：soft转换数据类型，无法转换保持原样</li>
</ul>
<h4 id="astype"><a href="#astype" class="headerlink" title="astype"></a><code>astype</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DF = df.astype(</span><br><span class="line">	dtype(dtype/&#123;col_name:dtype&#125;),</span><br><span class="line">	copy=<span class="literal">True</span>,</span><br><span class="line">	errors=<span class="string">&quot;raise&quot;</span>/<span class="string">&quot;ingore&quot;</span>,</span><br><span class="line">	**kwargs)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：强制转换为<code>dtype</code>类型</p>
</li>
<li><p>参数</p>
<ul>
<li><code>copy</code>：默认返回拷贝</li>
<li><code>kwargs</code>：传递给构造函数的参数</li>
</ul>
</li>
</ul>
<h3 id="Ser"><a href="#Ser" class="headerlink" title="Ser"></a>Ser</h3><h4 id="map"><a href="#map" class="headerlink" title="map"></a><code>map</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ser = ser1.<span class="built_in">map</span>(</span><br><span class="line">	arg=&#123;&#125;/Ser/<span class="built_in">callable</span>,</span><br><span class="line">	na_action=<span class="literal">None</span>/<span class="string">&quot;ignore&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：对Ser中元素进行映射</p>
<ul>
<li><strong>map</strong>对无法<strong>配置</strong>（dict）返回None而不是保持不变</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><code>arg</code><ul>
<li>{}：对Ser中值根据键值对映射</li>
<li>callable：对元素<strong>应用</strong>callable</li>
</ul>
</li>
<li><code>no_action</code>：默认对NA也处理，否则忽略</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li>好像默认会应用类似于<code>apply(convert_type=True)</code>，如
直接取值是<code>np.float64</code>类型，传给函数就变成了<code>float</code>
类型</li>
</ul>
</li>
</ul>
<h4 id="apply-1"><a href="#apply-1" class="headerlink" title="apply"></a><code>apply</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ser = ser1.apply(</span><br><span class="line">	func(<span class="built_in">callable</span>/&#123;&#125;/[]),</span><br><span class="line">	convert_type=<span class="literal">True</span>/<span class="literal">False</span>,</span><br><span class="line">	args=(),</span><br><span class="line">	**kwargs)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：在Ser上应用<code>func</code></p>
</li>
<li><p>参数</p>
<ul>
<li><p><code>func</code></p>
<ul>
<li>{}：返回<strong>多重索引</strong>Ser，键作为顶层索引，不是对
不同值应用不同方法</li>
<li>[ ]：返回DF对象，列labels根据list元素命令，list
元素不能聚合、非聚合混合</li>
</ul>
</li>
<li><p><code>convert_type</code>：默认转换为合适的类型，否则设为
<code>dtype=object</code></p>
</li>
</ul>
</li>
</ul>
<h4 id="agg-1"><a href="#agg-1" class="headerlink" title="agg"></a><code>agg</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ser = ser1.agg(</span><br><span class="line">	func(<span class="built_in">callable</span>/&#123;&#125;/[]),</span><br><span class="line">	axis=<span class="number">0</span>,</span><br><span class="line">	args=(),</span><br><span class="line">	**kwargs)</span><br></pre></td></tr></table></figure>
<ul>
<li>说明：好像和<code>apply</code>完全相同，只是参数不同，但<code>axis</code>没用</li>
</ul>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><h4 id="cut"><a href="#cut" class="headerlink" title="cut"></a><code>cut</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Ser = pd.cut(</span><br><span class="line">	x(array-like),</span><br><span class="line">	bins(<span class="built_in">int</span>/[num]/IntervalIndex),</span><br><span class="line">	right=<span class="literal">True</span>,</span><br><span class="line">	labels=<span class="literal">None</span>/[],</span><br><span class="line">	retbins=<span class="literal">False</span>,</span><br><span class="line">	precision=<span class="number">3</span>/<span class="built_in">int</span>,</span><br><span class="line">	include_lowest=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：返回各个元素所属区间，同时也是对应indice</p>
</li>
<li><p>参数</p>
<ul>
<li><code>bins</code>：左开右闭<ul>
<li>int：将<code>x</code>等分（事实上为了包含最小值，<code>bins</code>
左边界会扩展.1%）</li>
<li>[num]：定义<code>bins</code>边界</li>
</ul>
</li>
<li><code>right</code>：默认包含right-most边界</li>
<li><code>labels</code>：指定生成bins的labels</li>
<li><code>retbins</code>：默认不返回bins，设为<code>True</code>将返回tuple</li>
<li><code>precision</code>：bins labels显示精度</li>
<li><code>include_lowest</code>：第一个bin是否应该包括最小值<ul>
<li>应该仅对<code>bins=[]</code>有效</li>
<li>设为<code>True</code>仍然为左开右闭区间，但是左边界会小于
<code>bins=[]</code>中的最小值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="qcut"><a href="#qcut" class="headerlink" title="qcut"></a><code>qcut</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Ser = pd.qcut(</span><br><span class="line">	x(array-like),</span><br><span class="line">	q=<span class="built_in">int</span>/quantile_list,</span><br><span class="line">	labels=<span class="literal">None</span>,</span><br><span class="line">	retbins=<span class="literal">False</span>,</span><br><span class="line">	precision=<span class="number">3</span>,</span><br><span class="line">	duplicates=<span class="string">&quot;Raise&quot;</span>/<span class="string">&quot;drop&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：将<code>x</code>按照<code>q</code>划分分位数后进组（即按照数量分组）</p>
</li>
<li><p>参数</p>
<ul>
<li><code>q</code><ul>
<li>int：划分int个等分位数</li>
<li>[num]：将<code>x</code>元素按照给出<strong>分位数</strong>分组</li>
</ul>
</li>
<li><code>duplicates</code><ul>
<li><code>raise</code>：bins边缘不唯一raise exception</li>
<li><code>drop</code>：bins边缘不唯一则丢弃不唯一值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="groupby"><a href="#groupby" class="headerlink" title="groupby"></a><code>groupby</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DFGB = df1.groupby(</span><br><span class="line">	by(col_name),</span><br><span class="line">	axis=<span class="number">0</span>,</span><br><span class="line">	level=<span class="literal">None</span>,</span><br><span class="line">	as_index=<span class="literal">True</span>,</span><br><span class="line">	sort=<span class="literal">True</span>,</span><br><span class="line">	group_keys=<span class="literal">True</span>,</span><br><span class="line">	squeeze=<span class="literal">False</span>,</span><br><span class="line">	**kwargs)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：根据<code>by</code>对DF分组</p>
</li>
<li><p>参数</p>
<ul>
<li><code>by</code><ul>
<li>func：应用于DF的Index上，结果作分组依据</li>
<li>dict/Ser：对Index作映射，映射结果作分组依据</li>
<li>array-like：其值依顺序标记DF行，据此分组，因此
要求长度必须和DF行数相同</li>
<li>col_name/[col_name]：根据col_name分组</li>
</ul>
</li>
<li><code>as_index</code>：默认使用分组依据作为分组Index（labels）</li>
<li><code>sort</code>：默认组内各保持原DF顺序，可以关闭获得更好性能</li>
<li><code>group_keys</code>：默认在calling apply时，添加group键用于
标识各组</li>
<li><code>squeeze</code>：为<code>True</code>时尽可能减少返回值维度，否则返回
consistent type</li>
</ul>
</li>
</ul>
<h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><h3 id="Index值"><a href="#Index值" class="headerlink" title="Index值"></a>Index值</h3><h4 id="pivot"><a href="#pivot" class="headerlink" title="pivot"></a><code>pivot</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DF = df1.pivot(</span><br><span class="line">	index=<span class="literal">None</span>/<span class="built_in">str</span>,</span><br><span class="line">	columns=<span class="literal">None</span>/<span class="built_in">str</span>,</span><br><span class="line">	values=<span class="literal">None</span>/<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：根据某列值reshape数据（创建一个<strong>枢</strong>）</p>
</li>
<li><p>参数</p>
<ul>
<li><code>index</code>：用作Index的列名，默认Index</li>
<li><code>columns</code>：用作Column的列名</li>
<li><code>values</code>：填充进新DF对象的列名，默认所有剩余所有列
（列索引为层级索引）</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li>但是如果选取的两列元素两两组合有重复回报错</li>
</ul>
</li>
</ul>
<h4 id="set-index"><a href="#set-index" class="headerlink" title="set_index"></a><code>set_index</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DF = df1.set_index(</span><br><span class="line">	keys(col_name/[ ]/[col_names,[ ]]),</span><br><span class="line">	drop=<span class="literal">True</span>,</span><br><span class="line">	append=<span class="literal">False</span>,</span><br><span class="line">	inplace=<span class="literal">False</span>,</span><br><span class="line">	verify_integrity=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：用一列/多列作为新DF的Index（row labels）</p>
</li>
<li><p>参数</p>
<ul>
<li><code>keys</code>：列名，列名列表</li>
<li><code>drop</code>：默认删除用作Index的列</li>
<li><code>append</code>：默认不保留原Index（不以<strong>添加</strong>方式设置
Index）</li>
<li><code>verify_integrity</code>：默认不检查新Index是否唯一，直至
必要的时候</li>
</ul>
</li>
</ul>
<h4 id="reset-index"><a href="#reset-index" class="headerlink" title="reset_index"></a><code>reset_index</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DF = df1.reset_index(</span><br><span class="line">	level=<span class="literal">None</span>/<span class="built_in">int</span>/<span class="built_in">str</span>/[<span class="built_in">int</span>, <span class="built_in">str</span>],</span><br><span class="line">	drop=<span class="literal">False</span>,</span><br><span class="line">	inplace=<span class="literal">False</span>,</span><br><span class="line">	col_level=<span class="number">0</span>/<span class="built_in">int</span>/<span class="built_in">str</span>,</span><br><span class="line">	col_fill=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：</p>
</li>
<li><p>参数</p>
<ul>
<li><code>level</code>：默认所有层级</li>
<li><code>drop</code>：默认将Index作为一列添加</li>
<li><code>col_level</code>：Index作为列添加进的列索引层次，默认
最高层</li>
<li><code>col_fill</code>：对于多级索引，Index作为列添加时其他层级
的命名，默认xtts </li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li>Index作为新列的名称默认为”index”/“level_0”、
“level_1”等</li>
</ul>
</li>
</ul>
<h3 id="Index属性"><a href="#Index属性" class="headerlink" title="Index属性"></a>Index属性</h3><h4 id="swaplevel"><a href="#swaplevel" class="headerlink" title="swaplevel"></a><code>swaplevel</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DF = df.swaplevel(</span><br><span class="line">	i=-<span class="number">2</span>/<span class="built_in">int</span>/<span class="built_in">str</span>,</span><br><span class="line">	j=-<span class="number">1</span>/<span class="built_in">int</span>/<span class="built_in">str</span>,</span><br><span class="line">	axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>说明：交换i、j两层索引</li>
</ul>
<h4 id="rename"><a href="#rename" class="headerlink" title="rename"></a><code>rename</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DF = df.rename(</span><br><span class="line">	mapper=<span class="literal">None</span>/<span class="built_in">dict</span>/func,</span><br><span class="line">	index=<span class="literal">None</span>/<span class="built_in">dict</span>/func,</span><br><span class="line">	columns=<span class="literal">None</span>/<span class="built_in">dict</span>/func,</span><br><span class="line">	axis=<span class="number">0</span>/<span class="number">1</span>/<span class="string">&quot;index&quot;</span>/<span class="string">&quot;columns&quot;</span>,</span><br><span class="line">	copy=<span class="literal">True</span>,</span><br><span class="line">	inplace=<span class="literal">False</span>,</span><br><span class="line">	level=<span class="literal">None</span>/<span class="built_in">int</span>/<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：修改labels（行、列名）</p>
</li>
<li><p>参数</p>
<ul>
<li><code>mapper</code>：labels的重命名规则</li>
<li><code>index</code>/<code>columns</code>：行、列labels重命名规则<ul>
<li><code>mapper</code>+<code>axis</code></li>
<li><code>index</code></li>
<li><code>columns</code></li>
</ul>
</li>
<li><code>copy</code>：默认复制数据<ul>
<li><code>inplace</code>为<code>True</code>时，此参数无效</li>
</ul>
</li>
<li><code>level</code>：默认重命名所有level</li>
</ul>
</li>
</ul>
<h4 id="add-prefix"><a href="#add-prefix" class="headerlink" title="add_prefix"></a><code>add_prefix</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DF = df.add_prefix(</span><br><span class="line">	prefix(<span class="built_in">str</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>说明：为列labels添加前缀</li>
</ul>
<h2 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h2><h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><h4 id="unique"><a href="#unique" class="headerlink" title="unique"></a><code>unique</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> = ser1.is_unique</span><br><span class="line">	<span class="comment"># 无重复元素**属性**为`True`</span></span><br><span class="line">Ser = ser1.unique()</span><br><span class="line">	<span class="comment"># 返回非重复元素</span></span><br></pre></td></tr></table></figure>
<h4 id="duplicated"><a href="#duplicated" class="headerlink" title="duplicated"></a><code>duplicated</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ser(<span class="built_in">bool</span>) = df1.duplicated(</span><br><span class="line">	subset=<span class="literal">None</span>/label/[labels],</span><br><span class="line">	keep=<span class="string">&quot;First&quot;</span>/<span class="string">&quot;last&quot;</span>/<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：返回标识“副本（元素相同）”行的Ser(bool)</p>
</li>
<li><p>参数</p>
<ul>
<li><code>subset</code>：默认检查所有列，否则检查指定列</li>
<li><code>keep</code><ul>
<li><code>first</code>：重复者除第一个外标记为<code>True</code></li>
<li><code>last</code>：重复者除最后一个外标记为<code>True</code></li>
<li>False：重复者均标记为<code>True</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DF = df1.drop_duplicates(</span><br><span class="line">	subset=<span class="literal">None</span>/label/[labels],</span><br><span class="line">	keep=<span class="string">&quot;First&quot;</span>/<span class="string">&quot;last&quot;</span>/<span class="literal">False</span>,</span><br><span class="line">	inplace=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h3 id="空"><a href="#空" class="headerlink" title="空"></a>空</h3><h4 id="null"><a href="#null" class="headerlink" title="null"></a><code>null</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DF(<span class="built_in">bool</span>) = df1.isnull()</span><br><span class="line">DF(<span class="built_in">bool</span>) = df1.notnull()</span><br></pre></td></tr></table></figure>
<h4 id="dropna"><a href="#dropna" class="headerlink" title="dropna"></a><code>dropna</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DF = df1.dropna(</span><br><span class="line">	axis=<span class="number">0</span>/<span class="number">1</span>,</span><br><span class="line">	how=<span class="string">&quot;Any&quot;</span>/<span class="string">&quot;all&quot;</span>,</span><br><span class="line">	thresh=<span class="literal">None</span>/<span class="built_in">int</span>,</span><br><span class="line">	subset=<span class="literal">None</span>/label/[labels],</span><br><span class="line">	inplace=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：剔除空labels（及其数据）</p>
</li>
<li><p>参数</p>
<ul>
<li><code>how</code>：默认any NaN值存在剔除label</li>
<li><code>thresh</code>：剔除label的NaN值阈值</li>
<li><code>subset</code>：指定考虑的labels</li>
</ul>
</li>
</ul>
<h4 id="fillna"><a href="#fillna" class="headerlink" title="fillna"></a><code>fillna</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DF = df1.fillna(</span><br><span class="line">	value=<span class="literal">None</span>/scalar/<span class="built_in">dict</span>/Ser/DF,</span><br><span class="line">	method=<span class="literal">None</span>/<span class="string">&quot;backfill&quot;</span>/<span class="string">&quot;bfill&quot;</span>/<span class="string">&quot;pad&quot;</span>/<span class="string">&quot;ffill&quot;</span>,</span><br><span class="line">	axis=<span class="number">0</span>/<span class="number">1</span>/<span class="string">&quot;index&quot;</span>/<span class="string">&quot;columns&quot;</span>,</span><br><span class="line">	inplace=<span class="literal">False</span>,</span><br><span class="line">	limit=<span class="literal">None</span>/<span class="built_in">int</span>,</span><br><span class="line">	downcast=<span class="literal">None</span>/<span class="built_in">dict</span>,</span><br><span class="line">	**kwargs)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：填补NaN值</p>
</li>
<li><p>参数</p>
<ul>
<li><code>value</code>：用于填补NaN的值，dict-like时无法找到的NaN
不被填补</li>
<li><code>method</code><ul>
<li>“pad”/“ffill”：使用last（前一个）值填补</li>
<li>“bfill”/“backfill”：使用next（后一个）值填补</li>
</ul>
</li>
<li><code>limit</code>：填补允许的最大连续NaN值，超过部分保留NaN</li>
<li><code>downcast</code>：数据类型精度降级dict，或者<code>&quot;infer&quot;</code>由
自行推断</li>
</ul>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="any"><a href="#any" class="headerlink" title="any"></a><code>any</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ser = df1(<span class="built_in">bool</span>).<span class="built_in">any</span>(</span><br><span class="line">	axis=<span class="number">0</span>/<span class="number">1</span>/<span class="string">&quot;index&quot;</span>/<span class="string">&quot;columns&quot;</span>,</span><br><span class="line">	bool_only=<span class="literal">None</span>,</span><br><span class="line">	skipna=<span class="literal">True</span>,</span><br><span class="line">	level=<span class="literal">None</span>/<span class="built_in">int</span>/<span class="built_in">str</span>,</span><br><span class="line">	**kwargs)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明：label（行、列）对应值存在真返回True</p>
</li>
<li><p>参数</p>
<ul>
<li><code>skipna</code>：默认skip NA，如果全label为NA则结果为NA</li>
<li><code>level</code>：默认考虑整个索引</li>
<li><code>bool_only</code>：默认将所有转换为bool值再做判断</li>
</ul>
</li>
</ul>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">36</span></span></a><ul><li><a class="level is-mobile" href="/categories/Algorithm/Data-Structure/"><span class="level-start"><span class="level-item">Data Structure</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Heuristic/"><span class="level-start"><span class="level-item">Heuristic</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Issue/"><span class="level-start"><span class="level-item">Issue</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Problem/"><span class="level-start"><span class="level-item">Problem</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Specification/"><span class="level-start"><span class="level-item">Specification</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/C-C/"><span class="level-start"><span class="level-item">C/C++</span></span><span class="level-end"><span class="level-item tag">34</span></span></a><ul><li><a class="level is-mobile" href="/categories/C-C/Cppref/"><span class="level-start"><span class="level-item">Cppref</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/Cstd/"><span class="level-start"><span class="level-item">Cstd</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/MPI/"><span class="level-start"><span class="level-item">MPI</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/STL/"><span class="level-start"><span class="level-item">STL</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/CS/"><span class="level-start"><span class="level-item">CS</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/CS/Character/"><span class="level-start"><span class="level-item">Character</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Parallel/"><span class="level-start"><span class="level-item">Parallel</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Program-Design/"><span class="level-start"><span class="level-item">Program Design</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Storage/"><span class="level-start"><span class="level-item">Storage</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Daily-Life/"><span class="level-start"><span class="level-item">Daily Life</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/Daily-Life/Maxism/"><span class="level-start"><span class="level-item">Maxism</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Database/"><span class="level-start"><span class="level-item">Database</span></span><span class="level-end"><span class="level-item tag">27</span></span></a><ul><li><a class="level is-mobile" href="/categories/Database/Hadoop/"><span class="level-start"><span class="level-item">Hadoop</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Database/SQL-DB/"><span class="level-start"><span class="level-item">SQL DB</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Database/Spark/"><span class="level-start"><span class="level-item">Spark</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/Scala/"><span class="level-start"><span class="level-item">Scala</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">42</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Bash-Programming/"><span class="level-start"><span class="level-item">Bash Programming</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Configuration/"><span class="level-start"><span class="level-item">Configuration</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/File-System/"><span class="level-start"><span class="level-item">File System</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/IPC/"><span class="level-start"><span class="level-item">IPC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Process-Schedual/"><span class="level-start"><span class="level-item">Process Schedual</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Shell/"><span class="level-start"><span class="level-item">Shell</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Tool/"><span class="level-start"><span class="level-item">Tool</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Tool/Vi/"><span class="level-start"><span class="level-item">Vi</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Model/"><span class="level-start"><span class="level-item">ML Model</span></span><span class="level-end"><span class="level-item tag">21</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Model/Linear-Model/"><span class="level-start"><span class="level-item">Linear Model</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Model-Component/"><span class="level-start"><span class="level-item">Model Component</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Nolinear-Model/"><span class="level-start"><span class="level-item">Nolinear Model</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Unsupervised-Model/"><span class="level-start"><span class="level-item">Unsupervised Model</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/"><span class="level-start"><span class="level-item">ML Specification</span></span><span class="level-end"><span class="level-item tag">17</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/Click-Through-Rate/"><span class="level-start"><span class="level-item">Click Through Rate</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/Click-Through-Rate/Recommandation-System/"><span class="level-start"><span class="level-item">Recommandation System</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/Computer-Vision/"><span class="level-start"><span class="level-item">Computer Vision</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Specification/FinTech/"><span class="level-start"><span class="level-item">FinTech</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/FinTech/Risk-Control/"><span class="level-start"><span class="level-item">Risk Control</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/Graph-Analysis/"><span class="level-start"><span class="level-item">Graph Analysis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Specification/NLP/"><span class="level-start"><span class="level-item">NLP</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Technique/"><span class="level-start"><span class="level-item">ML Technique</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Technique/Feature-Engineering/"><span class="level-start"><span class="level-item">Feature Engineering</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Technique/Neural-Network/"><span class="level-start"><span class="level-item">Neural Network</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Theory/"><span class="level-start"><span class="level-item">ML Theory</span></span><span class="level-end"><span class="level-item tag">11</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Theory/Loss/"><span class="level-start"><span class="level-item">Loss</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Theory/Model-Enhencement/"><span class="level-start"><span class="level-item">Model Enhencement</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Theory/Optimization/"><span class="level-start"><span class="level-item">Optimization</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Algebra/"><span class="level-start"><span class="level-item">Math Algebra</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Algebra/Linear-Algebra/"><span class="level-start"><span class="level-item">Linear Algebra</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Algebra/Universal-Algebra/"><span class="level-start"><span class="level-item">Universal Algebra</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Analysis/"><span class="level-start"><span class="level-item">Math Analysis</span></span><span class="level-end"><span class="level-item tag">23</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Analysis/Fourier-Analysis/"><span class="level-start"><span class="level-item">Fourier Analysis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Functional-Analysis/"><span class="level-start"><span class="level-item">Functional Analysis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Optimization/"><span class="level-start"><span class="level-item">Optimization</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Real-Analysis/"><span class="level-start"><span class="level-item">Real Analysis</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Mixin/"><span class="level-start"><span class="level-item">Math Mixin</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Mixin/Statistics/"><span class="level-start"><span class="level-item">Statistics</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Mixin/Time-Series/"><span class="level-start"><span class="level-item">Time Series</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Probability/"><span class="level-start"><span class="level-item">Probability</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">89</span></span></a><ul><li><a class="level is-mobile" href="/categories/Python/Cookbook/"><span class="level-start"><span class="level-item">Cookbook</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Jupyter/"><span class="level-start"><span class="level-item">Jupyter</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Keras/"><span class="level-start"><span class="level-item">Keras</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Matplotlib/"><span class="level-start"><span class="level-item">Matplotlib</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Numpy/"><span class="level-start"><span class="level-item">Numpy</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Pandas/"><span class="level-start"><span class="level-item">Pandas</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Py3Ref/"><span class="level-start"><span class="level-item">Py3Ref</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Py3std/"><span class="level-start"><span class="level-item">Py3std</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Pywin32/"><span class="level-start"><span class="level-item">Pywin32</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Readme/"><span class="level-start"><span class="level-item">Readme</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/TensorFlow/"><span class="level-start"><span class="level-item">TensorFlow</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Twists/"><span class="level-start"><span class="level-item">Twists</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/RLang/"><span class="level-start"><span class="level-item">RLang</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Rust/"><span class="level-start"><span class="level-item">Rust</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Set/"><span class="level-start"><span class="level-item">Set</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/"><span class="level-start"><span class="level-item">Tool</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/Tool/Editor/"><span class="level-start"><span class="level-item">Editor</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Markup-Language/"><span class="level-start"><span class="level-item">Markup Language</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Web-Browser/"><span class="level-start"><span class="level-item">Web Browser</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Windows/"><span class="level-start"><span class="level-item">Windows</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/Web/CSS/"><span class="level-start"><span class="level-item">CSS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/NPM/"><span class="level-start"><span class="level-item">NPM</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/Proxy/"><span class="level-start"><span class="level-item">Proxy</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/Thrift/"><span class="level-start"><span class="level-item">Thrift</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://octodex.github.com/images/hula_loop_octodex03.gif" alt="UBeaRLy"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">UBeaRLy</p><p class="is-size-6 is-block">Protector of Proxy</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">392</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">93</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">522</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/xyy15926" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/xyy15926"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-04T15:07:54.896Z">2021-08-04</time></p><p class="title"><a href="/uncategorized/README.html"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-03T07:46:51.000Z">2021-08-03</time></p><p class="title"><a href="/Web/NPM/hexo_config.html">Hexo 建站</a></p><p class="categories"><a href="/categories/Web/">Web</a> / <a href="/categories/Web/NPM/">NPM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-03T02:32:45.000Z">2021-08-03</time></p><p class="title"><a href="/Web/NPM/config.html">NPM 总述</a></p><p class="categories"><a href="/categories/Web/">Web</a> / <a href="/categories/Web/NPM/">NPM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-02T08:11:11.000Z">2021-08-02</time></p><p class="title"><a href="/Python/Py3std/internet_data.html">互联网数据</a></p><p class="categories"><a href="/categories/Python/">Python</a> / <a href="/categories/Python/Py3std/">Py3std</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-29T13:55:00.000Z">2021-07-29</time></p><p class="title"><a href="/Linux/Shell/sh_apps.html">Shell 应用程序</a></p><p class="categories"><a href="/categories/Linux/">Linux</a> / <a href="/categories/Linux/Shell/">Shell</a></p></div></article></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">Advertisement</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5385776267343559" data-ad-slot="6995841235" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="https://api.follow.it/subscription-form/WWxwMVBsOUtoNTdMSlJ4Z1lWVnRISERsd2t6ek9MeVpEUWs0YldlZGxUdXlKdDNmMEZVV1hWaFZFYWFSNmFKL25penZodWx3UzRiaVkxcnREWCtOYUJhZWhNbWpzaUdyc1hPangycUh5RTVjRXFnZnFGdVdSTzZvVzJBcTJHKzl8aXpDK1ROWWl4N080YkFEK3QvbEVWNEJuQjFqdWdxODZQcGNoM1NqbERXST0=/8" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="UBeaRLy" height="28"></a><p class="is-size-7"><span>&copy; 2021 UBeaRLy</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/xyy15926/proxy"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>