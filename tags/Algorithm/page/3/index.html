<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Tag: Algorithm - UBeaRLy</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="UBeaRLy&#039;s Proxy"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="UBeaRLy&#039;s Proxy"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="UBeaRLy"><meta property="og:url" content="https://xyy15926.github.io/"><meta property="og:site_name" content="UBeaRLy"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://xyy15926.github.io/img/og_image.png"><meta property="article:author" content="UBeaRLy"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xyy15926.github.io"},"headline":"UBeaRLy","image":["https://xyy15926.github.io/img/og_image.png"],"author":{"@type":"Person","name":"UBeaRLy"},"publisher":{"@type":"Organization","name":"UBeaRLy","logo":{"@type":"ImageObject","url":"https://xyy15926.github.io/img/logo.svg"}},"description":""}</script><link rel="alternate" href="/atom.xml" title="UBeaRLy" type="application/atom+xml"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/darcula.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><script data-ad-client="ca-pub-5385776267343559" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="UBeaRLy" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Visit on GitHub" href="https://github.com/xyy15926/proxy"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">Tags</a></li><li class="is-active"><a href="#" aria-current="page">Algorithm</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-18T05:32:00.000Z" title="4/18/2019, 1:32:00 PM">2019-04-18</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-04-18T05:32:00.000Z" title="4/18/2019, 1:32:00 PM">2019-04-18</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Data-Structure/">Data Structure</a></span><span class="level-item">10 minutes read (About 1479 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Data-Structure/linear_list.html">Linear List</a></h1><div class="content"><h2 id="线性表综述"><a href="#线性表综述" class="headerlink" title="线性表综述"></a>线性表综述</h2><p>线性表：n个数据元素的有限序列</p>
<ul>
<li>元素个数n定义为线性表长度，n=0时称为空表</li>
<li>非空表中每个元素都有确定的位置</li>
</ul>
<h2 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h2><p>顺序存储结构/映像：使用一组地址连续的存储单元依次存储数据
元素</p>
<blockquote>
<ul>
<li>具体参见<em>algorithm/data_structure_intro</em></li>
</ul>
</blockquote>
<h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>顺序表：顺序存储结构的线性表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	ElemType *elem;</span><br><span class="line">	<span class="keyword">int</span> length;</span><br><span class="line">	<span class="keyword">int</span> listsize;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>以元素在计算机内<strong>物理位置相邻</strong>表示线性表中数据元素之间
的逻辑关系</p>
</li>
<li><p>每个数据元素存储位置和线性表起始位置，相差和其在线性表中
位序成正比常数，所以顺序表时一种<strong>随机存取</strong>存储结构</p>
<ul>
<li>高级程序语言中<strong>数组类型</strong>也有随机存取特点，因此通常
用数组描述</li>
</ul>
</li>
</ul>
<h4 id="时间效率"><a href="#时间效率" class="headerlink" title="时间效率"></a>时间效率</h4><ul>
<li>插入/删除：$O(n)$<ul>
<li>主要时间耗费在移动元素上</li>
</ul>
</li>
<li>求表长：$O(1)$</li>
<li>取第n个元素：$O(1)$</li>
</ul>
<h2 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h2><p>链式/非顺序存储结构/映像：用一组<strong>任意</strong>存储单元存储线性表
中数据元素，还需存储一个指示其直接后继的信息</p>
<blockquote>
<ul>
<li>具体参见<em>algorithm/data_structure_intro</em></li>
</ul>
</blockquote>
<h3 id="（线性-单）链表"><a href="#（线性-单）链表" class="headerlink" title="（线性/单）链表"></a>（线性/单）链表</h3><p>线性链表：n个节点链接而成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure>
<ul>
<li>链表中每个节点只包含一个指针域<ul>
<li>数据元素之间的逻辑关系由节点中指针指示，即指针为数据
元素之间的逻辑关系映像</li>
</ul>
</li>
<li>整个链表存取必须从头指针开始</li>
<li>单链表中任何两个元素存储位置之间没有固定联系，是非随机
存取存储结构</li>
</ul>
<blockquote>
<ul>
<li>头指针：指示链表中第一个节点的存储位置</li>
<li>头节点：在单链表第一个节点之前附设的节点，其数据域可以
  不存储信息，也可以存储线性表长度、尾指针等附加信息</li>
</ul>
</blockquote>
<h4 id="时间效率-1"><a href="#时间效率-1" class="headerlink" title="时间效率"></a>时间效率</h4><ul>
<li>插入、删除：$O(n)$<ul>
<li>已知插入、删除元素确切位置的情况下，仅需修改指针，
而不需要移动元素</li>
</ul>
</li>
<li>取第n个元素：$O(n)$<ul>
<li>访问时间依赖元素在列表中位置</li>
</ul>
</li>
</ul>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul>
<li><p>在很多场合下，链表是线性表的首选结构</p>
<ul>
<li>链表不需要事先分配任何存储空间，空间利用合理</li>
<li>插入、删除效率高，只需要重连相关指针</li>
</ul>
</li>
<li><p>但是存在一些实现问题</p>
<ul>
<li>求线性表长不如顺序存储结构</li>
</ul>
</li>
<li><p>链表中结点关系使用指针表示，数据元素在线性表中“位序”
概念淡化，被“位置”代替</p>
</li>
</ul>
<p>因此重新定义带头结点的线性链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;*Link, * Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Link head, tail;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单链表注意事项"><a href="#单链表注意事项" class="headerlink" title="单链表注意事项"></a>单链表注意事项</h4><ul>
<li><p>头结点/头指针：处理链表非常方便的技巧</p>
<ul>
<li>头指针指向链表首个结点：便于调整首个节点位置时，仍然
<strong>记住链表</strong></li>
<li>头指针不包含链表信息，本质不属于链表：有些情况下方便
统一代码，不需要特殊考虑链表首个节点</li>
</ul>
</li>
<li><p>对链表进行<strong>可能改变链表的遍历</strong>操作：一般使用两个标记
结点/指针</p>
<ul>
<li>头结点/指针<code>lstart</code>：记住链表</li>
<li>遍历标记指针<code>cur</code>：标记处理结点</li>
</ul>
</li>
<li><p>交换节点：标记指针需要指向<strong>当前处理节点的前一个结点</strong></p>
<ul>
<li>单链表中只有指向下个节点的指针，若标记指针指向当前
节点，则无法方便将链表同当前节点断开、重连</li>
<li>注意<strong>待交换两个节点为同一节点</strong>的情况：不同于值交换
，这种情况可能导致链表<strong>错误连接成环</strong></li>
</ul>
</li>
<li><p>无指针、纯引用对象语言（<code>python</code>）中：只能使用节点对象
遍历链表</p>
<ul>
<li>变量为<strong>链表中节点引用</strong>：使用类似普通指针，需要注意
别修改引用节点数据</li>
<li>变量为<strong>额外节点引用</strong>：内存类似普通指针，使用时注意
解析引用次数</li>
</ul>
</li>
</ul>
<h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>静态链表：使用数组描述的链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">int</span> cur;</span><br><span class="line">&#125;component, SLinkList[MAXSIZE];</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>数组分量表示节点</li>
<li>使用游标<code>cur</code>作为指针域指示节点在链表中的逻辑位置</li>
<li>第0个分量表示头节点，其指针域<code>cur</code>指向链表第一个节点</li>
</ul>
</blockquote>
<ul>
<li>方便在无指针高级语言中使用链式结构</li>
<li>为确定未使用的数组分量，可以将未被使用的、删除的分量用
游标链成备用边表</li>
</ul>
<h3 id="Circular-Linked-List"><a href="#Circular-Linked-List" class="headerlink" title="Circular Linked List"></a><em>Circular Linked List</em></h3><p>循环链表：表中最后一个节点指针域指向头节点，整个链表形成环</p>
<ul>
<li>循环链表和线性链表操作基本一致<ul>
<li>仅循环条件不再是指针域为空，而是是否等于头指针</li>
</ul>
</li>
</ul>
<h3 id="Double-Linked-List"><a href="#Double-Linked-List" class="headerlink" title="Double Linked List"></a><em>Double Linked List</em></h3><p>双向链表：链表中有两个指针域，分别指向直接后继、直接前驱</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	Struct DulNode * prior;</span><br><span class="line">	Struct DulNode * next;</span><br><span class="line">&#125;DuLNode, * DuLinkList;</span><br></pre></td></tr></table></figure>
<ul>
<li>双向链表克服线性链表寻找直接前驱时间$O(n)$的缺点</li>
<li>双向链表大部分操作和线性链表相同，指示有些操作需要同时
修改两个指针</li>
</ul>
<ul>
<li>字符串：数组实现的一种数据结构<ul>
<li>字符串常见操作不同于其他数组<ul>
<li>计算字符串长度</li>
<li>按照字典序确定字符串排序时位置</li>
<li>连接字符串构</li>
</ul>
</li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-12T08:01:20.000Z" title="4/12/2019, 4:01:20 PM">2019-04-12</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-04-12T08:01:20.000Z" title="4/12/2019, 4:01:20 PM">2019-04-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Problem/">Problem</a></span><span class="level-item">an hour read (About 9286 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Problem/graph.html">图算法</a></h1><div class="content"><h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><ul>
<li>图的遍历算法：如何一次访问到网络中所有节点</li>
<li>最短路线算法：两个城市间最佳路线</li>
<li>有向图拓扑排序：课程、预备课程是否有矛盾</li>
<li>All-Pairs Shortest-Paths Problem：完全最短路径问题，找到
每个顶点到其他所有顶点的距离</li>
</ul>
<h2 id="遍历算法"><a href="#遍历算法" class="headerlink" title="遍历算法"></a>遍历算法</h2><h3 id="Depth-First-Search"><a href="#Depth-First-Search" class="headerlink" title="Depth-First Search"></a>Depth-First Search</h3><p>深度优先查找（DFS）</p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>从<strong>任意顶点</strong>开始访问图顶点，然后标记为已访问</p>
</li>
<li><p>每次迭代时，紧接着处理与当前顶点<strong>邻接的未访问顶点</strong>，
直到遇到终点，该顶点所有邻接顶点均已访问过</p>
</li>
<li><p>在终点上，算法<strong>沿着来路</strong>后退一条边，继续从那里访问未
访问顶点</p>
</li>
<li><p>后退到<strong>起始点</strong>，且起始点也是终点时，算法停止，这样
起始点所在的连通分量的所有顶点均已访问过</p>
</li>
<li><p>若存在未访问顶点，则必须从其中任一顶点开始重复上述</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line">	<span class="comment">// 全局变量：访问次序（次数）</span></span><br><span class="line">DFS(G)</span><br><span class="line">	<span class="comment">// 对给定图的深度优先查找遍历</span></span><br><span class="line">	<span class="comment">// 输入：图G=&lt;V, E&gt;</span></span><br><span class="line">	<span class="comment">// 输出：图G顶点按照DFS遍历第一次访问到的先后次序，</span></span><br><span class="line">	<span class="comment">//       未访问到标记未0</span></span><br><span class="line">	<span class="keyword">for</span> each vertex v in V <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span> v is marked with <span class="number">0</span></span><br><span class="line">			dfs(v)</span><br><span class="line">dfs(v)</span><br><span class="line">	<span class="comment">// 递归访问所有和v相连接的未访问顶点，赋予count值</span></span><br><span class="line">	count = count+<span class="number">1</span></span><br><span class="line">	mark v with count</span><br><span class="line">	<span class="keyword">for</span> each vertex w in V adjecnt to v <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span> w is marked with <span class="number">0</span></span><br><span class="line">			dfs(w)</span><br></pre></td></tr></table></figure>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>算法效率非常高效，消耗时间和表示图的数据结构规模成正比</p>
<ul>
<li>邻接矩阵：遍历时间效率$\in \Theta(|V|^2)$</li>
<li>邻接链表：遍历时间效率$\in \Theta(|V|+|E|)$</li>
</ul>
</li>
<li><p>可以方便地用栈跟踪深度优先查找</p>
<ul>
<li>首次访问顶点，将顶点入栈</li>
<li>当顶点成为终点时，将其出栈</li>
<li>运行时就是实际上就是栈，所以深度优先可以直接利用递归
实现</li>
</ul>
</li>
<li><p><em>Depth-First Search Foreat</em>：参见
<em>algorithm/data_structure/graph</em></p>
</li>
<li><p>DFS产生两种节点排列顺序性质不同，有不同应用</p>
<ul>
<li>入栈（首次访问顶点）次序</li>
<li>出栈（顶点成为终点）次序</li>
</ul>
</li>
</ul>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul>
<li>检查图连通性：算法第一次停止后，是否所有顶点已经访问</li>
<li>检查图无环性：DFS是否包含回边</li>
<li>拓扑排序：见<em>键值法</em><ul>
<li>DFS节点出栈逆序就是拓扑排序的一个解（图中无回边，
即为有向无环图）</li>
<li>DAG中顶点v出栈前，不存在顶点u拥有到v的边，否则存在
回边，图不是DAG</li>
</ul>
</li>
</ul>
<h3 id="Broad-First-Search"><a href="#Broad-First-Search" class="headerlink" title="Broad-First Search"></a>Broad-First Search</h3><p>广度优先查找（BFS）</p>
<h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>首先访问所有和初始顶点邻接的顶点</p>
</li>
<li><p>然后是离它两条边的所有未访问顶点</p>
</li>
<li><p>以此类推，直到所有与初始顶点在同一连通分类顶点均已访问</p>
</li>
<li><p>若存在未访问顶点，从图其他连通分量任意顶点开始</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line">	<span class="comment">// 全局变量：访问次序（次数）</span></span><br><span class="line">BFS(G)</span><br><span class="line">	<span class="comment">// 给定图广度优先查找变量</span></span><br><span class="line">	<span class="comment">// 输入：图G=&lt;V, E&gt;</span></span><br><span class="line">	<span class="comment">// 输出：图G的顶点按照被BFS遍历第一次访问到次序，</span></span><br><span class="line">	<span class="comment">//       未访问顶点标记未0</span></span><br><span class="line">	<span class="keyword">for</span> each vertax v in V <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span> v is marked with <span class="number">0</span></span><br><span class="line">			bfs(v)</span><br><span class="line">bfs(v)</span><br><span class="line">	<span class="comment">// 访问所有和v相连接的顶点，赋count值</span></span><br><span class="line">	count = count+<span class="number">1</span></span><br><span class="line">	whilte <span class="built_in">queue</span> is <span class="keyword">not</span> empty <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">for</span> each vertex w in V adjcent to the front vertex <span class="keyword">do</span></span><br><span class="line">			<span class="keyword">if</span> w is marked with <span class="number">0</span></span><br><span class="line">				count = count+<span class="number">1</span></span><br><span class="line">				mark w with count</span><br><span class="line">				add w to the <span class="built_in">queue</span></span><br><span class="line">		remove the front vertex from the <span class="built_in">queue</span></span><br></pre></td></tr></table></figure>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>算法效率同DFS</p>
<ul>
<li>邻接矩阵：遍历时间效率$\in \Theta(|V|^2)$</li>
<li>邻接链表：遍历时间效率$\in \Theta(|V|+|E|)$</li>
</ul>
</li>
<li><p>使用队列可以方便地跟踪广度优先查找操作</p>
<ul>
<li>从遍历初始顶点开始，标记、入队</li>
<li>每次迭代时，算法查找所有和队头顶点邻接未访问，标记
、入队、将队头顶点出队</li>
</ul>
</li>
<li><p><em>Breadth-First Search Forest</em>：参见
<em>algorithm/data_struture/graph</em></p>
</li>
<li><p>BFS只产生顶点的一种排序，因为队列时FIFO结构，顶点入队、
出队次序相同</p>
</li>
</ul>
<h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><ul>
<li><p>和DFS一样可以检查图的连通性、无环性，但是无法用于比较
复杂的应用</p>
</li>
<li><p>求给定两个顶点间最短路径：从一顶点开始BFS遍历，访问到
另一节点结束（难以证明？）</p>
</li>
</ul>
<h2 id="有向图强连通分量"><a href="#有向图强连通分量" class="headerlink" title="有向图强连通分量"></a>有向图强连通分量</h2><h3 id="Kosaraju算法"><a href="#Kosaraju算法" class="headerlink" title="Kosaraju算法"></a>Kosaraju算法</h3><p>考虑有向图中强连通分量之间不连通的情况</p>
<ul>
<li><p>强连通分量之间没有边</p>
<ul>
<li><p>在任意连通分量中任意结点开始深度优先遍历</p>
</li>
<li><p>访问完所有结点需要DFS次数就是强连通分量数量，每轮
DFS访问的点就是强连通分量中的顶点</p>
</li>
</ul>
</li>
<li><p>强连通分量之间只有单向边</p>
<ul>
<li><p>将强连通分量视为<strong>单个结点</strong>，则整个图可以视为一个
靠连通分量间单向边连接的有向无环图</p>
</li>
<li><p>从最底层强连通分量中任选结点开始进行DFS，则此轮DFS
只能访问当前连通分量中结点</p>
</li>
<li><p>逆序依次在各强连通分量中选择结点进行DFS，则每轮DFS只
访问当前连通分量中结点（其下层连通分量已访问）</p>
</li>
<li><p>直至所有结点访问完毕，则得到所有强连通分量，即每轮
进行DFS访问的结点</p>
</li>
<li><p>以下图为例，从图中连通分量B中任意结点开始进行DFS，
则经过两轮DFS即能找所有强连通分量</p>
<p><img src="/imgs/strongly_connected_two_components.png" alt="strongly_connected_two_components"></p>
</li>
</ul>
</li>
</ul>
<p>由以上分析</p>
<ul>
<li><p>只需要保证<strong>底层强连通分量进行DFS优先搜索</strong></p>
</li>
<li><p>也即在结点搜索优先级中，底层强连通分量中至少有一个结点
在其上层连通分量所有结点之前</p>
</li>
<li><p>可以利用<strong>原图的反向</strong>的DFS<strong>逆后序排列</strong>得到满足条件
的结点优先级序列</p>
<p><img src="/imgs/strongly_connected_two_components_reversed.png" alt="strongly_connected_two_components_reversed"></p>
<ul>
<li><p>若从反向图中最底层强连通分量某结点开始，则只能遍历
自身，反向图中其余连通分量位于其所有结点之前</p>
</li>
<li><p>若从反向图中非最底层强连通分量某结点开始，则能依次
遍历其底层所有强连通分量中结点，且至少该结点位于其余
连通分量所有结点之前</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>逆后序排列参见<em>algorithm/data_structure/graph</em></li>
</ul>
</blockquote>
<h4 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h4><ul>
<li>对原图G每条路径求反，得到反向图$G^R$</li>
<li>对反向图$G^R$求解逆后序序列</li>
<li>按照逆序序列优先级，对原图G进行DFS，每棵DFS生成树就是
一个强连通分量</li>
</ul>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul>
<li>算法效率<ul>
<li>时间效率$\in O(|V| + |E|)$</li>
<li>算法需要对图进行两次DFS，速度较Tanjar算法更慢</li>
</ul>
</li>
</ul>
<h3 id="Tarjan算法"><a href="#Tarjan算法" class="headerlink" title="Tarjan算法"></a>Tarjan算法</h3><p>Tarjan算法：基于图深度优先搜索的算法</p>
<ul>
<li><p>为每个结点维护两个标记，通过此标记确定是否存在回路</p>
<ul>
<li><code>DFN</code>：深度优先搜索中搜索到次序</li>
<li><code>Low</code>：通过回边能访问到的前驱被搜索到的次序</li>
</ul>
<blockquote>
<ul>
<li>还可以维护一个<code>Flag</code>，判断结点是否仍在DFS栈中</li>
</ul>
</blockquote>
</li>
<li><p>对图进行深度优先搜索</p>
<ul>
<li><p>未处理结点入栈，设置其<code>DFN</code>、<code>Low</code>被搜索到的次序</p>
</li>
<li><p>对已处理结点，考虑到深度优先的搜索、退栈方式</p>
<ul>
<li><p>仍然在栈中，则肯定是栈顶元素前驱，连接边为回边，
存在<strong>栈顶节点到该前驱结点的回路</strong></p>
</li>
<li><p>不在栈中，该节点不是祖先结点，连接边为交叉边，
该结点已经在其他连通分量中出栈</p>
</li>
</ul>
</li>
<li><p>使用栈中前驱结点<code>Low/DFN</code>次序更新当前（栈顶）结点，
并递归更新，即使用<strong>子节点访问先驱次序更新父节点</strong></p>
</li>
</ul>
</li>
<li><p>DFS回溯、退栈，考虑栈中每个结点<code>DFN</code>、<code>Low</code></p>
<ul>
<li><p>若<code>DFN[u] &gt; Low[u]</code>：结点<code>u</code>和其<strong>前驱</strong>之间有回路，
即其属于同一个强连通分量</p>
</li>
<li><p>若<code>DFN[u] ==  Low[u]</code>：结点<code>u</code>和其前驱之间没有通路，
没有更多结点属于其所属强连通分量，以结点<code>u</code>为根子树
是一个强连通分量</p>
<ul>
<li>则从栈顶元素开始退栈直至结点<code>u</code>退栈，退栈的所有
元素构成强连通分量</li>
</ul>
</li>
</ul>
</li>
<li><p>每个强连通分量为深度优先搜索树中一个子树</p>
</li>
</ul>
<script type="math/tex; mode=display">
Low[v] = \min\{DFN[v], Low[w], DFN[k]\}</script><blockquote>
<ul>
<li>$w, (w, v) \in E$：顶点v的直接前驱</li>
<li>$k, (v, k) \in E$：顶点v的祖先（即栈中结点）</li>
</ul>
</blockquote>
<h4 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">S = initStack()</span><br><span class="line">DFN[MAX_VERTAX], Low[MAX_VERTEX]</span><br><span class="line">index = <span class="number">0</span></span><br><span class="line">QList = InitList(Queue())</span><br><span class="line"></span><br><span class="line">tarjan(u, E):</span><br><span class="line">	<span class="comment">// 比较DFS搜索次序、回边到达次序判断强连通分量</span></span><br><span class="line">	<span class="comment">// 输入：结点u，边集合E</span></span><br><span class="line">	<span class="comment">// 输出：强连通分量队列列表</span></span><br><span class="line">	DFN[u] = Low[u] = ++ index</span><br><span class="line">	S.push(u)</span><br><span class="line">	<span class="keyword">for</span> each (u, v) in E:</span><br><span class="line">		<span class="keyword">if</span> (v is <span class="keyword">not</span> visited):</span><br><span class="line">			tarjan(v)</span><br><span class="line">			Low[u] = min(Low[u], Low[v])</span><br><span class="line">			<span class="comment">// 使用v找到的前驱更新u能找到前驱，递归更新</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (v in S):</span><br><span class="line">			<span class="comment">// 判断边是否为回边</span></span><br><span class="line">			Low[u] = min(Low[u], DFN[v])</span><br><span class="line">			<span class="comment">// Low[u] = min(Low[u], Low[v])</span></span><br><span class="line">				<span class="comment">// 应该也行</span></span><br><span class="line">	<span class="keyword">if</span>(DFN[u] == Low[u]):</span><br><span class="line">		Q = QList.next()</span><br><span class="line">		repeat</span><br><span class="line">			v = S.pop()</span><br><span class="line">			Q.push(v)</span><br><span class="line">		until (u == v)</span><br></pre></td></tr></table></figure>
<h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><ul>
<li>算法效率<ul>
<li>时间效率$\in O(|V|+|E|)$</li>
</ul>
</li>
</ul>
<h2 id="关节点"><a href="#关节点" class="headerlink" title="关节点"></a>关节点</h2><h3 id="类Tarjan算法"><a href="#类Tarjan算法" class="headerlink" title="类Tarjan算法"></a>类Tarjan算法</h3><ul>
<li>类似Tarjan算法为每个节点维护<code>DFN</code>、<code>Low</code>两个次序<ul>
<li>对非根结点v，<strong>存在</strong>其直接后继w有<code>Low[w] &gt;= DFN[v]</code>
，则v为关节点</li>
<li>对根节点，有两棵以上子树则为关节点</li>
</ul>
</li>
</ul>
<h4 id="算法-4"><a href="#算法-4" class="headerlink" title="算法"></a>算法</h4><p>此算法具体实现和Tarjan算法细节有差异</p>
<ul>
<li>此算法中不需要使用栈保存访问过顶点中是前驱者<ul>
<li>连通无向图DFS只会有回边，已访问点必然是前驱结点</li>
</ul>
</li>
<li>需要对根结点额外判断是否为关节点</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">DFN[MAX_VERTAX], Low[MAX_VERTEX]</span><br><span class="line">index = <span class="number">0</span></span><br><span class="line">Q = InitQueue()</span><br><span class="line"></span><br><span class="line">FindArticul(G):</span><br><span class="line">	<span class="comment">// 输入：无向连通图G</span></span><br><span class="line">	<span class="comment">// 输出：关节点队列</span></span><br><span class="line">	vroot = G.V.pop()</span><br><span class="line">	TarjanArticul(vroot, G)</span><br><span class="line">	<span class="keyword">for</span>(v in G.V <span class="keyword">if</span> v <span class="keyword">not</span> visited)</span><br><span class="line">		<span class="comment">// 根节点有两棵及以上子树</span></span><br><span class="line">		TarjanAricul(vroot, G)</span><br><span class="line">		Q.push(vroot)</span><br><span class="line">		<span class="comment">// 根节点也是关节点</span></span><br><span class="line">	<span class="keyword">return</span> Q</span><br><span class="line"></span><br><span class="line">TarjanArticul(u, G):</span><br><span class="line">	<span class="comment">// 比较DFS搜索次序、回边到达次序判断关节点</span></span><br><span class="line">	<span class="comment">// 输入：结点u，无向连通图G</span></span><br><span class="line">	<span class="comment">// 输出：关节点队列</span></span><br><span class="line">	DFN[u] = Low[u] = ++ index</span><br><span class="line">	<span class="keyword">for</span> each (u, v) in G.E:</span><br><span class="line">		<span class="keyword">if</span> (v is <span class="keyword">not</span> visited):</span><br><span class="line">			tarjan(v)</span><br><span class="line">			Low[u] = min(Low[u], Low[v])</span><br><span class="line">			<span class="comment">// 使用v找到的前驱更新u能找到前驱，递归更新</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			Low[u] = min(Low[u], DFN[v])</span><br><span class="line">			<span class="comment">// Low[u] = min(Low[u], Low[v])</span></span><br><span class="line">				<span class="comment">// 应该也行</span></span><br><span class="line">	<span class="keyword">for</span>(v connected by u)</span><br><span class="line">		<span class="keyword">if</span>(Low[v] &lt;= DFN[u])</span><br><span class="line">			Q.push(u)</span><br><span class="line">	<span class="keyword">return</span> Q</span><br></pre></td></tr></table></figure>
<h2 id="无权路径"><a href="#无权路径" class="headerlink" title="无权路径"></a>无权路径</h2><h3 id="路径数量"><a href="#路径数量" class="headerlink" title="路径数量"></a>路径数量</h3><p>图中顶点i到顶点j之间长度为k的不同路径数量为$A^k[i, j]$</p>
<ul>
<li>A为图的邻接矩阵</li>
<li>可以使用数学归纳法证明</li>
<li>对无向、有向图均适用</li>
</ul>
<h3 id="Warshall算法"><a href="#Warshall算法" class="headerlink" title="Warshall算法"></a>Warshall算法</h3><p>Warshall算法：生成有向图传递闭包</p>
<ul>
<li><p>构造n+1个n阶布尔矩阵$R^{(k)}, k=0,1,\cdots, n$</p>
<ul>
<li><p>$R^{(k)}_{ij}=1$：顶点i、j直接存在中间顶点<strong>编号</strong>
不大于k的有效路径</p>
</li>
<li><p>$R^{(0)}$：邻接矩阵，顶点直接连接</p>
</li>
<li><p>$R^{(k)}, 0&lt;k&lt;n$：路径中间顶点编号最大为<code>k</code></p>
</li>
<li><p>$R^{(n)}$：传递闭包，允许所有类型路径</p>
</li>
<li><p>后继矩阵相对前趋，允许作为路径上顶点增加，可能包含
1数量更多</p>
</li>
</ul>
</li>
<li><p>考虑$R^{(k)}$通过直接前趋$R^{(k-1)}$计算得到</p>
<ul>
<li><p>$R^{(k-1)}$中已有路径在$R^{(k)}$保留</p>
</li>
<li><p>考虑$R^{(k)}$相较于$R^{(k-1)}$新增$r_{ij}=1$</p>
<ul>
<li><p>表示顶点i、j之间存在包含k的路径</p>
</li>
<li><p>若k在路径中出现多次，则将删除回路，得到新路径</p>
</li>
<li><p>则存在ik和kj之间路径满足中间顶点编号小于k，即在
$R^{(k-1)}$中有$r<em>{ik}=1, r</em>{kj}=1$</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="算法-5"><a href="#算法-5" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>若元素$r_{ij}$在$R^{(k-1)}$中为1，则在$R^{(k)}$也是1</p>
</li>
<li><p>若元素$r<em>{ij}$在$R^{(k-1)}$中为0，当且仅当存在v使得
$R^{(k-1)}$中$r</em>{iv}=1, r_{vj}=1$</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Warshall(A[<span class="number">1.</span>.n, <span class="number">1.</span>.n])</span><br><span class="line">	<span class="comment">// 计算传递闭包的Warshall算法</span></span><br><span class="line">	<span class="comment">// 输入：A[1..n, 1..n]包含n个顶点的有向图的邻接矩阵</span></span><br><span class="line">	<span class="comment">// 输出：A的传递闭包</span></span><br><span class="line">	R^<span class="number">0</span> = A</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">for</span> i = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">			<span class="keyword">for</span> j = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">				<span class="keyword">if</span> R^(k<span class="number">-1</span>)[i, j] == <span class="number">1</span> <span class="keyword">or</span></span><br><span class="line">					(R^(k<span class="number">-1</span>)[i, k] == <span class="number">0</span> <span class="keyword">and</span> R^(k<span class="number">-1</span>)[k, j] == <span class="number">0</span>)</span><br><span class="line">					R^k[i, j] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> R^n</span><br></pre></td></tr></table></figure>
<h4 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>算法效率</p>
<ul>
<li>时间效率$\in \Theta(n^3)$<ul>
<li>重新构造最内层循环，可以提高对某些输入的处理速度</li>
<li>将矩阵行视为位串，使用或运算也可以加速</li>
</ul>
</li>
<li>空间效率取决于如何处理布尔矩阵</li>
</ul>
</li>
<li><p>蛮力法：所有点分别作为起点作一次搜索，记录能够访问的顶点</p>
<ul>
<li>对有向图遍历多次</li>
<li>使用邻接链表表示稀疏图，蛮力法渐进效率好于Warshall算法</li>
</ul>
</li>
</ul>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><p>Prim算法：求解最小图最小生成树算法</p>
<ul>
<li>每次添加距离当前树距离最近顶点进树</li>
<li>不断迭代构造最小生成树</li>
</ul>
<h4 id="算法-6"><a href="#算法-6" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>从图顶点集V中任选单顶点作为序列中初始子树</p>
</li>
<li><p>对图中顶点维护两个标记：树中最近顶点、相应距离</p>
<ul>
<li>与树不直接相连顶点置：<code>NULL</code>、$\infty$</li>
<li>每次添加新节点更新两个标记</li>
<li>可使用优先队列维护提高效率</li>
</ul>
</li>
<li><p>以贪婪的方式扩张当前生成树，添加不在树中的<strong>最近顶点</strong></p>
</li>
<li><p>更新顶点和树距离最近的顶点、相应距离</p>
<ul>
<li>只需考察与新添加顶点直接相连顶点即可</li>
</ul>
</li>
<li><p>不断迭代直到所有点都在树中</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Prim(G):</span><br><span class="line">	<span class="comment">// 构造最小生成树Prim算法</span></span><br><span class="line">	<span class="comment">// 输入：加权连通图G=&lt;V, E&gt;</span></span><br><span class="line">	<span class="comment">// 输出：E_T, 组成G最小生成树的边集合</span></span><br><span class="line">	V_T = &#123;v_0&#125;</span><br><span class="line">		<span class="comment">// 使用任意顶点初始化树顶点集合</span></span><br><span class="line">	E_T = <span class="literal">NULL</span></span><br><span class="line">		<span class="comment">// 初始化生成树边为空集</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span> to |V|</span><br><span class="line">		<span class="keyword">if</span> i connect V_T</span><br><span class="line">			connect_V[i] = <span class="number">0</span></span><br><span class="line">			connect_D[i] = e(<span class="number">0</span>, i)</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			connect_V[i] = <span class="literal">NULL</span></span><br><span class="line">			connect_D[i] = \infty</span><br><span class="line">	<span class="comment">// 初始化节点和树最近节点列表、节点与树距离列表</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span> to |V|<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">		<span class="comment">// 重复n-1次，直到树包含所有顶点</span></span><br><span class="line">		edge = min(connect_D)</span><br><span class="line">			<span class="comment">// 寻找距离树最近的点</span></span><br><span class="line">		v = vertex(edge)</span><br><span class="line"></span><br><span class="line">		V_T = V_T <span class="keyword">union</span> &#123;v&#125;</span><br><span class="line">		E_T = E_T <span class="keyword">union</span> &#123;edge&#125;</span><br><span class="line"></span><br><span class="line">		connect_V[v] = <span class="literal">NULL</span></span><br><span class="line">		connect_D[v] = \infty</span><br><span class="line">		更新和v相连的顶点两个标记值</span><br><span class="line">	<span class="keyword">return</span> E_T</span><br></pre></td></tr></table></figure>
<h4 id="算法特点-1"><a href="#算法特点-1" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>算法时间效率依赖实现优先队列、存储图数据结构</p>
<ul>
<li>图权重矩阵、优先队列无序数组$\in \Theta(|V|^2)$</li>
<li>图邻接链表、二叉最小堆$\in O(|E|log|V|)$</li>
<li>图邻接链表、Fibonacci Heap $\in O(|E| + |V|log|V|)$</li>
</ul>
</li>
<li><p>对树进行扩展时用到的边的集合表示算法生成树</p>
</li>
<li><p>穷举查找构造生成树，生成树数量呈指数增长，且构造生成树
不容易</p>
</li>
</ul>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>Kruskal算法：把最小生成树看作是具有$|V|-1$条边、且边权重最小
的无环子图，通过对子图不断扩展构造最小生成树</p>
<h4 id="算法-7"><a href="#算法-7" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>按照权重非递减顺序对图中边排序</p>
</li>
<li><p>从空子图开始扫描有序列表，试图把列表中下条边加到当前子图
中，如果添加边导致回路则跳过</p>
</li>
<li><p>不断添加边直到达到$|V|-1$</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Kruskal(G)</span><br><span class="line">	<span class="comment">// 构造最小生成树的Kruskal算法</span></span><br><span class="line">	<span class="comment">// 输入：G=&lt;V, E&gt;加权连通图</span></span><br><span class="line">	<span class="comment">// 输出：E_T，组成G的最小生成树边集</span></span><br><span class="line">	reverse_sort([w(e_i)])</span><br><span class="line">		<span class="comment">// 按照边权非递减顺序对边集排序</span></span><br><span class="line">	E_T = <span class="literal">NULL</span></span><br><span class="line">	ecounter = <span class="number">0</span></span><br><span class="line">	k = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> ecounter &lt; |V|<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">		k += <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> E_T <span class="keyword">union</span> &#123;e_k&#125; 无回路</span><br><span class="line">			<span class="comment">// 常用并查算法检查`e_k`连接的两个顶点是否在</span></span><br><span class="line">			<span class="comment">// 同一棵树（并查集）中</span></span><br><span class="line">			E_T = E_T <span class="keyword">union</span> &#123;e_k&#125;</span><br><span class="line">			ecounter += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span>  E_T</span><br></pre></td></tr></table></figure>
<h4 id="算法特点-2"><a href="#算法特点-2" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>Kruskal每次迭代都需要检查添加新边是否会导致回路，其实
效率不一定比Prim算法高</p>
</li>
<li><p>Kruskal算法中间阶段会生成一系列无环子图（树）</p>
<ul>
<li>子图不总是联通的</li>
<li>可以看作是对包含给定图所有顶点、部分边的森林所作的
连续动作</li>
<li>初始森林由|V|棵普通树构成，包含单独顶点</li>
<li>最终森林为单棵树，包含图中所有顶点</li>
<li>每次迭代从图的边有序列表中取出下条边，找到包含其端点
的树，若不是同一棵树，则加入边生成一棵更大的树</li>
</ul>
</li>
<li><p>算法效率</p>
<ul>
<li>如果检查顶点是否位于同一棵树算法高效，则算法运行时间
取决于排序算法，时间效率$\in O(|E|log|E|)$</li>
</ul>
</li>
</ul>
<h3 id="Sollin算法"><a href="#Sollin算法" class="headerlink" title="Sollin算法"></a>Sollin算法</h3><p>Sollin算法：Prim算法、Kruskal算法的结合，将图每个顶点视为
子树，每次添加多条边合并子树直至得到最小生成树</p>
<h4 id="算法-8"><a href="#算法-8" class="headerlink" title="算法"></a>算法</h4><ul>
<li>将图中每个顶点视为一棵树，整个图表示森林$F^{(0)}$</li>
<li>为森林$F$中每棵树选择最小代价边<strong>合并</strong>两棵树</li>
<li>重复以上，直至所有树合并为一棵树</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Sollin(G):</span><br><span class="line">	<span class="comment">// 无向图最小生成树Sollin算法</span></span><br><span class="line">	<span class="comment">// 输入：无向图G</span></span><br><span class="line">	<span class="comment">// 输出：最小生成树边集</span></span><br><span class="line">	MST_E = <span class="literal">NULL</span></span><br><span class="line">	Forest = G.V</span><br><span class="line">	<span class="keyword">while</span> |MST_E| &lt; |G.V|:</span><br><span class="line">		<span class="keyword">for</span> tree in Forest:</span><br><span class="line">			e = find_min(G.E)</span><br><span class="line">			tree_b = get_tree(e)</span><br><span class="line">			MET_E.add(e)</span><br><span class="line">			tree.<span class="keyword">union</span>(tree_b)</span><br></pre></td></tr></table></figure>
<h1 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h1><h4 id="算法特点-3"><a href="#算法特点-3" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li>算法效率<ul>
<li>每轮子树数量减少一半，则最多重复<code>log|V|</code>轮算法终止</li>
<li>时间效率$\in O(|E|log|V|)$</li>
</ul>
</li>
</ul>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p>Dijkstra算法：求解单起点、<strong>权值非负</strong>最短路径算法</p>
<ul>
<li><p>按照从给定起点到图中各顶点的距离，<strong>顺序</strong>求出离起始点
最近的顶点、相应最短路径</p>
</li>
<li><p>第i次迭代前，算法已经确定了i-1条连接起点、离起点前i-1近
顶点的最短路径</p>
<ul>
<li>这些构成了给定图的一棵子树$T_i$</li>
<li>可以在同$T_i$顶点邻接的顶点中找到和起点最接近的顶点
（边权非负）</li>
</ul>
</li>
<li><p>算法类似于Prim算法，两个对代价评价标准不同</p>
<ul>
<li>Dijkstra算法是各条路径长度：有重复边，考虑整个路径</li>
<li>Prim算法是评价各边总和：无重复边，只考虑一条边</li>
</ul>
</li>
</ul>
<h4 id="算法-9"><a href="#算法-9" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>对顶点维护两个标记：起点到该顶点最短路径长度<code>d</code>、路径上
前个顶点<code>pre_v</code></p>
<ul>
<li>一般使用优先队列维护最短路径长度</li>
<li>对所有顶点维护：$\infty$、<code>NULL</code>标记不在树中、不与树
邻接顶点</li>
<li>仅对生成树中顶点、邻接顶点维护：每次迭代更新列表</li>
</ul>
</li>
<li><p>根据标记选择邻接顶点中和起始点距离<code>d</code>最小顶点，添加进树</p>
</li>
<li><p>更新顶点标记</p>
<ul>
<li>因为生成树只新添加一个顶点，只需要考虑与新添加顶点
直接相连、未在树中顶点</li>
<li>比较与起始点距离是否改变</li>
</ul>
</li>
<li><p>不断迭代直至所有点均在树中</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Dijkstra(G, s)</span><br><span class="line">	<span class="comment">// 单起点最短路径Dijkstra算法</span></span><br><span class="line">	<span class="comment">// 输入：G=&lt;V, E&gt;非负权重加权连通图，顶点s起始点</span></span><br><span class="line">	<span class="comment">// 输出：对V中每个顶点，从s到v的最短路径长度d_v</span></span><br><span class="line">	Initialize(Q)</span><br><span class="line">		<span class="comment">// 将顶点优先队列初始化为空</span></span><br><span class="line">	<span class="keyword">for</span> v in V</span><br><span class="line">		d_v = \infty</span><br><span class="line">		p_v = <span class="literal">NULL</span></span><br><span class="line">		Insert(Q, s, d_s)</span><br><span class="line">			<span class="comment">// 初始化有限队列中顶点优先级</span></span><br><span class="line">	d_s = <span class="number">0</span></span><br><span class="line">	Decrease(Q, s, d_s)</span><br><span class="line">		<span class="comment">// 更新s优先级为d_s</span></span><br><span class="line">	V_T = <span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span> to |V|<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">		u* = DeleteMin(Q)</span><br><span class="line">			<span class="comment">// 删除优先级最小元素</span></span><br><span class="line">		V_T = V_T \<span class="keyword">union</span> &#123;u*&#125;</span><br><span class="line">		<span class="keyword">for</span> v in V-V_T 中与u*邻接顶点 <span class="keyword">do</span></span><br><span class="line">			<span class="keyword">if</span> d_u* + w(u*, u) &lt; d_u</span><br><span class="line">				d_u = d_u* + w(u*, u)</span><br><span class="line">				p_u = u*</span><br><span class="line">				Decrease(Q, u, d_u)</span><br></pre></td></tr></table></figure>
<h4 id="算法特点-4"><a href="#算法特点-4" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li>算法时间效率同Prim算法</li>
</ul>
<h3 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h3><p>Bellman-Ford算法：求解单节点、权值正负无限制最短距离</p>
<ul>
<li>权值正负无限制意味着贪心策略不再有效</li>
<li>要求路径中不存在负权值回路</li>
<li>对n个顶点图，路径最长为n-1，否则删除回路路径长度不增加</li>
</ul>
<h4 id="算法-10"><a href="#算法-10" class="headerlink" title="算法"></a>算法</h4><p>考虑使用动态规划算法</p>
<ul>
<li><p>令$dist^{(l)}[u]$表示从起点v到节点u边数不超过l的最短
路径长度</p>
<ul>
<li><p>在不允许出现负权值回路的前提下，构造最短路算法过程
最多只需要考虑n-1条边</p>
</li>
<li><p>即$dist^{(n-1)}$是从v到u不限制路径中边数目的最短路径
长度</p>
</li>
</ul>
</li>
<li></li>
</ul>
<h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><p>Floyd算法：求解完全最短路径问题，有向、无向、加权图均适用
（边距离不为负，否则距离可以任意小）</p>
<ul>
<li><p>构造n+1个距离矩阵$D^{(k)}, k=0,1,\cdots,n$</p>
<ul>
<li><p>$D^{(k)}$中元素$d_{ij}$表示顶点i、j之间由编号小于k的
顶点作为中间顶点的距离</p>
</li>
<li><p>$D^{(0)}$：初始权重矩阵</p>
</li>
<li><p>$D^{(k)}, 0&lt;i&lt;n$：路径中顶点编号最大为<code>k</code></p>
</li>
<li><p>$D^{(n)}$：目标距离矩阵</p>
</li>
<li><p>后继矩阵相对前趋，允许作为路径上顶点增加，各顶点间
距离可能缩短</p>
</li>
</ul>
</li>
<li><p>考虑$D^{(k)}$通过直接前趋$D^{(k-1)}$计算得到，其中距离
（路径）分为两类</p>
<ul>
<li><p>$d^{(k)}<em>{ij} = d^{(k-1)}</em>{ij}$：不包含顶点k作为中间
节点的路径</p>
</li>
<li><p>$d^{(k)}<em>{ij} = d^{(k-1)}</em>{ik} + d^{(k-1)}<em>{kj} &lt; d^{(k-1)}</em>{ij}$：
包含顶点k作为中间节点的路径</p>
</li>
</ul>
</li>
</ul>
<h4 id="算法-11"><a href="#算法-11" class="headerlink" title="算法"></a>算法</h4><script type="math/tex; mode=display">
d^{(k)}_{ij} = \min \{ d^{(k-1)}_{ik} + d^{(k-1)}_{kj},
    d^{(k-1)}_{ij}, d^{(k-1)}_{ij} \}</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Floyd(W[<span class="number">1.</span>.n, <span class="number">1.</span>.n])</span><br><span class="line">	<span class="comment">// 计算完全最短路径的Floyd算法</span></span><br><span class="line">	<span class="comment">// 输入：W不包含负距离的距离矩阵</span></span><br><span class="line">	<span class="comment">// 输出：包含最短距离的距离矩阵</span></span><br><span class="line">	D^<span class="number">0</span> = W</span><br><span class="line">	<span class="keyword">for</span> k = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">for</span> i = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">			<span class="keyword">for</span> j = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">				D[i, j] = min(D[i, j], D[i, k] + D[k, j])</span><br><span class="line">	<span class="keyword">return</span> D</span><br></pre></td></tr></table></figure>
<h4 id="算法特点-5"><a href="#算法特点-5" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>算法效率</p>
<ul>
<li>时间效率同Warshall算法为立方级</li>
<li>如上伪码的空间效率为平方级（没有创建n+1距离矩阵）</li>
</ul>
</li>
<li><p>Floyd算法类似于Warshall算法</p>
</li>
<li><p>Floyd算法利用最优性原理，即最短路径中子路径也是最短</p>
</li>
</ul>
<h2 id="最大流量问题"><a href="#最大流量问题" class="headerlink" title="最大流量问题"></a>最大流量问题</h2><h3 id="Augmenting-Path-Method"><a href="#Augmenting-Path-Method" class="headerlink" title="Augmenting-Path Method"></a>Augmenting-Path Method</h3><h4 id="Shortest-Augmented-Path算法"><a href="#Shortest-Augmented-Path算法" class="headerlink" title="Shortest-Augmented-Path算法"></a>Shortest-Augmented-Path算法</h4><p>最短增益路径法（<em>first-labeled first-scanned algorithm</em>）</p>
<ul>
<li><p>对网络中顶点维护两个标记</p>
<ul>
<li>从源点到被标记顶点能增加流量数</li>
<li>路径中前个顶点名称<ul>
<li><code>+</code>：从前向边访问到当前顶点</li>
<li><code>-</code>：从后向边访问到当前顶点</li>
</ul>
</li>
</ul>
</li>
<li><p>对网络的每条边$(i, j)$，初始化流量为$x_{ij}=0$</p>
</li>
<li><p>从源点开始同时沿着前向边、后向边进行广度优先搜索</p>
<ul>
<li>先更新前向边</li>
<li>只有有增益空间边（顶点）才能被访问</li>
<li>更新搜索到顶点标记</li>
</ul>
</li>
<li><p>源点被标记表明得到一条增量路径，沿着标记反向更新边流量</p>
</li>
<li><p>若广度优先搜索无法达到源点，表明不存在流量增益路径，当前
流量值作为最大值返回</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">ShortestAugmentingPath(G)</span><br><span class="line">	<span class="comment">// 最短增量路径算法</span></span><br><span class="line">	<span class="comment">// 输入：流量网络G</span></span><br><span class="line">	<span class="comment">// 输出：最大流量x</span></span><br><span class="line">	对网络中每条边，设置x[i, j] = <span class="number">0</span></span><br><span class="line">	把源点标记为(\infty, -)，加入空队列Q中</span><br><span class="line">		<span class="comment">// 使用队列实现广度优先搜索</span></span><br><span class="line">	<span class="keyword">while</span> <span class="keyword">not</span> Empty(Q) <span class="keyword">do</span></span><br><span class="line">		i = Front(Q)</span><br><span class="line">		Dequeue(Q)</span><br><span class="line">		<span class="keyword">for</span> 从i到j的每条边 <span class="keyword">do</span></span><br><span class="line">			<span class="comment">// 遍历从i出发的边，前向边</span></span><br><span class="line">			<span class="keyword">if</span> j未被标记</span><br><span class="line">				r[i, j] = = u[i, j] - x[i, j]</span><br><span class="line">				<span class="keyword">if</span> r[i, j] &gt; <span class="number">0</span></span><br><span class="line">					l[j] = min&#123;l[i], r[i, j]&#125;</span><br><span class="line">					<span class="comment">/// 更新从源点到顶点j能增加的流量数</span></span><br><span class="line">					用l[j], i+标记j</span><br><span class="line">					Enqueue(Q, j)</span><br><span class="line">		<span class="keyword">for</span> 从j到i的每条边 <span class="keyword">do</span></span><br><span class="line">			<span class="comment">// 遍历到达i的边，后向边</span></span><br><span class="line">			<span class="keyword">if</span> j未被标记</span><br><span class="line">				<span class="keyword">if</span> x[j, i] &gt; <span class="number">0</span></span><br><span class="line">					l[j] = min&#123;l[i], x[j, i]&#125;</span><br><span class="line">					<span class="comment">// 更新源点到顶点j能增加的流量数</span></span><br><span class="line">					用l[j], i-标记j</span><br><span class="line">					Enqueue(Q, j)</span><br><span class="line">		<span class="keyword">if</span> 汇点被标记</span><br><span class="line">			<span class="comment">// 沿着找的增益路径进行增益</span></span><br><span class="line">			j = n</span><br><span class="line">			<span class="keyword">while</span> j != <span class="number">1</span></span><br><span class="line">				<span class="comment">// 反向更新到源点为止</span></span><br><span class="line">				<span class="keyword">if</span> 顶点j前个节点为i+</span><br><span class="line">					<span class="comment">// 通过前向边访问到顶点j</span></span><br><span class="line">					x[i, j] = x[i, j] + l[n]</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					x[j, i] -= l[n]</span><br><span class="line">				j = i</span><br><span class="line">		去除除源点外所有顶点标记</span><br><span class="line">		重新初始化化队列Q</span><br></pre></td></tr></table></figure>
<h4 id="算法特点-6"><a href="#算法特点-6" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>算法正确性可以（联合）最大流-最小割定理证明</p>
</li>
<li><p>算法时间效率</p>
<ul>
<li>可以证明最短增益路径算法用到的增益路径数量不超过
$|V||E|/2$</li>
<li>对使用邻接列表表示的网络，用广度优先查找找到一条增益
路径的时间$\int O(|V|+|E|)$</li>
<li>所有算法时间效率$\in O(|V||E|^2)$</li>
</ul>
</li>
<li><p>迭代算法</p>
</li>
</ul>
<h3 id="Preflow推进算法"><a href="#Preflow推进算法" class="headerlink" title="Preflow推进算法"></a>Preflow推进算法</h3><p>预流：满足容量约束，但是不满足流量守恒约束</p>
<ul>
<li>把过剩流量向汇点处移动，直到网络所有中间顶点都满足流量
守恒约束为止</li>
</ul>
<h4 id="算法特点-7"><a href="#算法特点-7" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li>算法时间效率<ul>
<li>这类算法中较快者最差效率可以接近$O(|V||E|)$</li>
</ul>
</li>
</ul>
<h3 id="Dinitz算法"><a href="#Dinitz算法" class="headerlink" title="Dinitz算法"></a>Dinitz算法</h3><h3 id="Karzanov算法"><a href="#Karzanov算法" class="headerlink" title="Karzanov算法"></a>Karzanov算法</h3><h3 id="Malhotra-Kamar-Maheshweari算法"><a href="#Malhotra-Kamar-Maheshweari算法" class="headerlink" title="Malhotra-Kamar-Maheshweari算法"></a>Malhotra-Kamar-Maheshweari算法</h3><h3 id="Goldberg-Tarjan算法"><a href="#Goldberg-Tarjan算法" class="headerlink" title="Goldberg-Tarjan算法"></a>Goldberg-Tarjan算法</h3><h3 id="单纯形法"><a href="#单纯形法" class="headerlink" title="单纯形法"></a>单纯形法</h3><p>此问题仍然是线性规划问题，可以使用单纯形法等通用解法求解</p>
<h2 id="最大匹配（二分图）"><a href="#最大匹配（二分图）" class="headerlink" title="最大匹配（二分图）"></a>最大匹配（二分图）</h2><h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><h4 id="算法-12"><a href="#算法-12" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>对U中每个顶点维护一个标记：与其匹配的对偶顶点</p>
</li>
<li><p>从V中的一个自由顶点v出发，按<strong>广度优先搜索</strong>找到U中自由
顶点u，寻找增益路径，搜索过程中</p>
<ul>
<li><p>V中顶点：按照广度优先搜索，得到不在匹配M中的边</p>
<ul>
<li>搜索到U中自由顶点，则停止<strong>得到增益路径</strong></li>
<li>搜索到U中被标记顶点，则连接上已有匹配</li>
</ul>
</li>
<li><p>U中顶点：直接找到其在V中的对偶顶点，得到在M中边</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>得到一个增益路径，沿着增益路径<strong>回溯</strong>，奇数边加入匹配</p>
</li>
<li><p>未找到自由顶点时，则无法得到增益路径</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">MaximumBipartiteMatching(G)</span><br><span class="line">	<span class="comment">// 用类似广度优先算法遍历求二分图的一个最大匹配</span></span><br><span class="line">	<span class="comment">// 输入：二分图G=&lt;V, U, E&gt;</span></span><br><span class="line">	<span class="comment">// 输出：输入图中一个最大基数匹配</span></span><br><span class="line">	初始边集合M包含某些合法的匹配（例如空集合）</span><br><span class="line">	初始队列Q包含V的所有自由顶点（任意序）</span><br><span class="line">	<span class="function"><span class="keyword">while</span> <span class="keyword">not</span> <span class="title">Empty</span><span class="params">(Q)</span> <span class="keyword">do</span></span></span><br><span class="line"><span class="function">		w </span>= Front(Q)</span><br><span class="line">		Dequeue(Q)</span><br><span class="line">		<span class="keyword">if</span> w \in V</span><br><span class="line">			<span class="keyword">for</span> 邻接w的每个顶点u <span class="keyword">do</span></span><br><span class="line">				<span class="comment">// 二分图性质保证u一定在U中</span></span><br><span class="line">				<span class="keyword">if</span> u是自由顶点</span><br><span class="line">					<span class="comment">// 增益</span></span><br><span class="line">					M = M \<span class="keyword">union</span> (w, u)</span><br><span class="line">						<span class="comment">// 首边进匹配</span></span><br><span class="line">					v = w</span><br><span class="line">					<span class="keyword">while</span> v已经被标记 <span class="keyword">do</span></span><br><span class="line">						<span class="comment">// 从增益路径回溯生成匹配</span></span><br><span class="line">						u = 以v标记的点</span><br><span class="line">						M -= (v, u)</span><br><span class="line">							<span class="comment">// 偶数边出匹配</span></span><br><span class="line">						v = 以u标记的点</span><br><span class="line">						M += (v, u)</span><br><span class="line">							<span class="comment">// 奇数边进匹配</span></span><br><span class="line">					删除所以顶点标记</span><br><span class="line">					用V中所有自由顶点重新初始化Q</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">						<span class="comment">// 增益后，重新搜索</span></span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="comment">// u已经匹配</span></span><br><span class="line">					<span class="keyword">if</span> (w, u) <span class="keyword">not</span> \in M <span class="keyword">and</span> u未标记</span><br><span class="line">						用w标记u</span><br><span class="line">						Enqueue(Q, u)</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="comment">// w \in U，此时w必然已经匹配</span></span><br><span class="line">			用w标记w的对偶v</span><br><span class="line">				<span class="comment">// 将已有匹配添加进增益路径中</span></span><br><span class="line">			Enqueue(Q, v)</span><br><span class="line">	<span class="keyword">return</span> M</span><br><span class="line">		<span class="comment">// 当前匹配已经是最大匹配</span></span><br></pre></td></tr></table></figure>
<h4 id="算法特点-8"><a href="#算法特点-8" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>注意：从自由顶点开始寻求匹配时，无论是否找到增益路径，
路径中中U中节点标记已经更新，匹配仅在得到增益路径才更新</p>
</li>
<li><p>算法时间效率</p>
<ul>
<li>每次迭代花费时间$\in O(|E|+|V|)$，迭代次数
$\in O(|V|/2 + 1)$</li>
<li>若每个顶点的信息（自由、匹配、对偶）能在常数时间内
得到（如存储在数组中）</li>
<li>则算法时间效率$\in O(|V|(|V| + |E|))$</li>
</ul>
</li>
<li><p>算法正确性参见图<em>graph_undirected</em>关于增益路径-最大匹配</p>
</li>
<li><p>迭代算法</p>
</li>
</ul>
<h3 id="霍普克罗夫-卡普算法"><a href="#霍普克罗夫-卡普算法" class="headerlink" title="霍普克罗夫-卡普算法"></a>霍普克罗夫-卡普算法</h3><h4 id="算法特点-9"><a href="#算法特点-9" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>对匈牙利算法的改进，把多次迭代在一个阶段完成，然后用一次
查找把最大数量边添加到匹配中</p>
</li>
<li><p>算法时间效率：$\in O(\sqrt {|V|}(|V| + |E|))$</p>
</li>
</ul>
<h2 id="稳定婚姻问题"><a href="#稳定婚姻问题" class="headerlink" title="稳定婚姻问题"></a>稳定婚姻问题</h2><h3 id="婚姻稳定算法"><a href="#婚姻稳定算法" class="headerlink" title="婚姻稳定算法"></a>婚姻稳定算法</h3><p>存在自由男士，任选<em>求婚</em>、<em>回应</em>之一执行，直至不存在自由男士</p>
<ul>
<li><p>求婚：自由男士m向女士w求婚，w为其优先级最大、之前未拒绝
过其女士（可以是已匹配）</p>
</li>
<li><p>回应：若女士w自由则接受男士m求婚，与之配对；女士w不自由
则把m同当前配偶匹配，选择其中优先级较高者</p>
</li>
</ul>
<h4 id="算法-13"><a href="#算法-13" class="headerlink" title="算法"></a>算法</h4><h4 id="算法特点-10"><a href="#算法特点-10" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>算法会在$n^2$次迭代内终止：至多每位男士向所有女士求婚</p>
</li>
<li><p><em>性别倾向</em>：总是生成<em>man-optimal</em>的稳定匹配，优先满足
男士偏好</p>
<ul>
<li>在任何稳定婚姻中，总是尽可能把优先级最高的女士分配给
男性</li>
<li>使用女士进行求婚也只会把性别偏见反向，而不能消除</li>
</ul>
</li>
<li><p>对给定的参与者优先选择集合而言，男士（女士）最优匹配唯一</p>
<ul>
<li>由性别性别倾向容易证明</li>
<li>所以算法的输出不取决于自由男士（女士）求婚顺序，可以
使用任何数据结构表示参与者集合而不影响结果</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>算法最终输出匹配M为稳定婚姻匹配证明参见<em>graph</em></li>
</ul>
</blockquote>
<h2 id="分配问题（二分图）"><a href="#分配问题（二分图）" class="headerlink" title="分配问题（二分图）"></a>分配问题（二分图）</h2><p>n个任务分配给n个人执行（一人一个），将任务j分配个人i的成本为
$C_{ijd}$，求最小成本分配方案</p>
<blockquote>
<ul>
<li>类似问题：最大权重匹配问题</li>
</ul>
</blockquote>
<h3 id="蛮力算法"><a href="#蛮力算法" class="headerlink" title="蛮力算法"></a>蛮力算法</h3><h4 id="算法-14"><a href="#算法-14" class="headerlink" title="算法"></a>算法</h4><ul>
<li>生成整数n的全部排列</li>
<li>根据成本矩阵计算每个分配方案总成本</li>
<li>选择和最小的方案</li>
</ul>
<h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><ul>
<li>算法排列次数为$n!$</li>
</ul>
<h3 id="分支界限法"><a href="#分支界限法" class="headerlink" title="分支界限法"></a>分支界限法</h3><ul>
<li><p>第i层节点下界可取：$lb = c + \sum_{k=i+1}^n min{c_k}$</p>
<ul>
<li>$c$：当前成本</li>
<li>$min{c_k}$：成本矩阵第k行最小值</li>
</ul>
</li>
</ul>
<h4 id="算法-15"><a href="#算法-15" class="headerlink" title="算法"></a>算法</h4><h4 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h4><h3 id="匈牙利算法-1"><a href="#匈牙利算法-1" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><h4 id="算法-16"><a href="#算法-16" class="headerlink" title="算法"></a>算法</h4><h4 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h4><h2 id="Topological-Sorting"><a href="#Topological-Sorting" class="headerlink" title="Topological Sorting"></a>Topological Sorting</h2><p>拓扑排序：按照次序列出有向图的顶点，使得对图中每条边，其
起始顶点总在结束顶点之前</p>
<h3 id="删点法"><a href="#删点法" class="headerlink" title="删点法"></a>删点法</h3><h4 id="算法-17"><a href="#算法-17" class="headerlink" title="算法"></a>算法</h4><ul>
<li>在有向图中求出源（没有输出边的顶点），然后把删除其和所有
从它出发的边</li>
<li>不断重复，直到不存在源，如果此时图中还有顶点，则图中存在
环，无解</li>
<li>则删除节点顺序即为拓扑排序可行解</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">TopologicalSort(G):</span><br><span class="line">	<span class="comment">// 从有向图中不断删除入度为0的点、入栈，判断有向图G是否</span></span><br><span class="line">		<span class="comment">// 为DAG，并给出拓扑排序栈</span></span><br><span class="line">	<span class="comment">// 输入：有向图G</span></span><br><span class="line">	<span class="comment">// 输出：拓扑排序栈T</span></span><br><span class="line">	InitStack(S)</span><br><span class="line">	indgree = [v.indegree <span class="keyword">for</span> v in G]</span><br><span class="line">	<span class="keyword">for</span> v in G:</span><br><span class="line">		<span class="keyword">if</span> v.indgree == <span class="number">0</span></span><br><span class="line">			S.push(v)</span><br><span class="line">		<span class="comment">// 存储0入度结点栈</span></span><br><span class="line">	count = <span class="number">0</span></span><br><span class="line">		<span class="comment">// 删除结点计数</span></span><br><span class="line">	<span class="keyword">while</span>(!S.empty())</span><br><span class="line">		v = S.pop()</span><br><span class="line">		T.push(v)</span><br><span class="line">		count++</span><br><span class="line">		<span class="keyword">for</span>(u connected to v)</span><br><span class="line">			<span class="keyword">if</span> --indgree.u == <span class="number">0</span></span><br><span class="line">				S.push(u)</span><br><span class="line">	<span class="keyword">if</span> count &lt; |G.V|</span><br><span class="line">		<span class="comment">// 结点未删除完毕，但无0入度结点</span></span><br><span class="line">		<span class="comment">// G中有回路，报错</span></span><br><span class="line">		<span class="keyword">return</span> ERROR</span><br><span class="line">	<span class="keyword">return</span> T</span><br></pre></td></tr></table></figure>
<h4 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a>特点</h4><ul>
<li>算法效率<ul>
<li>时间效率$\in O(|V|+|E|)$</li>
</ul>
</li>
<li>减常数法</li>
</ul>
<h3 id="DFS逆后序遍历"><a href="#DFS逆后序遍历" class="headerlink" title="DFS逆后序遍历"></a>DFS逆后序遍历</h3><p>图中<strong>无环</strong>时，由某点出发进行DFS</p>
<ul>
<li><p>最先退出DFS的为出度为0的点，即拓扑有序序列中最后顶点</p>
</li>
<li><p>按照DFS退出先后次序得到序列即为逆向拓扑有序序列</p>
<ul>
<li>使用逆后序方式存储DFS访问顶点，判断是否有环、出栈
次序即为正向拓扑有序序列</li>
</ul>
</li>
</ul>
<h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><ul>
<li>判断庞大项目中相互关联任务不矛盾，然后才能合理安排，使得
项目整体完成时间最短（需要CPM、PERT算法支持）</li>
</ul>
<h2 id="Cirtical-Path问题"><a href="#Cirtical-Path问题" class="headerlink" title="Cirtical Path问题"></a><em>Cirtical Path</em>问题</h2><p>找出使用AOE网表示的工程的中关键路径</p>
<ul>
<li>关键路径由关键活动构成</li>
<li>即耗费时间变动对工程整体完成时间有影响的活动</li>
</ul>
<h3 id="拓扑排序求解"><a href="#拓扑排序求解" class="headerlink" title="拓扑排序求解"></a>拓扑排序求解</h3><ul>
<li>最早、最晚开始时间检查是否为关键活动</li>
<li>建立活动（边）、事件（顶点）发生事时间关系</li>
<li>拓扑排序求解事件发生最早、最晚时间</li>
</ul>
<blockquote>
<ul>
<li>具体参见<em>algorithm/data_structure/graphdi_specials</em></li>
</ul>
</blockquote>
<h4 id="算法-18"><a href="#算法-18" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">TopologicalOrder(G):</span><br><span class="line">	<span class="comment">// 从有向图中不断删除入度为0的点、入栈，判断有向图G是否</span></span><br><span class="line">		<span class="comment">// 为DAG，并给出拓扑排序栈</span></span><br><span class="line">	<span class="comment">// 输入：有向图G</span></span><br><span class="line">	<span class="comment">// 输出：拓扑排序栈T、顶点事件最早发生事件ve</span></span><br><span class="line">	InitStack(S)</span><br><span class="line">	indgree = [v.indegree <span class="keyword">for</span> v in G]</span><br><span class="line">	ve[<span class="number">0.</span>.|G.V|] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> v in G:</span><br><span class="line">		<span class="keyword">if</span> v.indgree == <span class="number">0</span></span><br><span class="line">			S.push(v)</span><br><span class="line">		<span class="comment">// 存储0入度结点栈</span></span><br><span class="line">	count = <span class="number">0</span></span><br><span class="line">		<span class="comment">// 删除结点计数</span></span><br><span class="line">	<span class="keyword">while</span>(!S.empty())</span><br><span class="line">		v = S.pop()</span><br><span class="line">		T.push(v)</span><br><span class="line">		count++</span><br><span class="line">		<span class="keyword">for</span>(u connected by v)</span><br><span class="line">			ve[u] = max&#123;ve[u], ve[v] + len(v, u)&#125;</span><br><span class="line">				<span class="comment">// 若有更长路径，更新</span></span><br><span class="line">			<span class="keyword">if</span> --indgree[u] == <span class="number">0</span></span><br><span class="line">				S.push(u)</span><br><span class="line">	<span class="keyword">if</span> count &lt; |G.V|</span><br><span class="line">		<span class="comment">// 结点未删除完毕，但无0入度结点</span></span><br><span class="line">		<span class="comment">// G中有回路，报错</span></span><br><span class="line">		<span class="keyword">return</span> ERROR</span><br><span class="line">	<span class="keyword">return</span> T, ve</span><br><span class="line"></span><br><span class="line">CriticalPath(G, T, ve):</span><br><span class="line">	<span class="comment">// 逆序求顶点事件最晚发生时间，求出关键活动</span></span><br><span class="line">	<span class="comment">// 输入：有向无环图G，G拓扑排序</span></span><br><span class="line">	<span class="comment">// 输出：关键活动队列Q</span></span><br><span class="line">	vl[<span class="number">0.</span>.|G.V|] = ve</span><br><span class="line">	Q = InitQueue()</span><br><span class="line">	<span class="keyword">while</span>(!T.empty())</span><br><span class="line">		v = T.pop()</span><br><span class="line">		<span class="keyword">for</span> (u connect to v)</span><br><span class="line">			vl[u] = min&#123;vl[u], vl[v] - len(u, v)&#125;</span><br><span class="line">	<span class="keyword">for</span>(v in G.V)</span><br><span class="line">		<span class="keyword">for</span> (u connected by v)</span><br><span class="line">			ee = ve[v]</span><br><span class="line">			el = vl[u] - len(v)</span><br><span class="line">			<span class="keyword">if</span>(el == ee)</span><br><span class="line">				Q.push(G.edge(v, u))</span><br><span class="line">	<span class="keyword">return</span> Q</span><br></pre></td></tr></table></figure>
<ul>
<li><p>以上算法中在生成拓扑排序栈时同时得到各顶点事件最早发生
时间</p>
</li>
<li><p>可以只获取拓扑排序栈，然后处理其获得顶点事件最早发生时间
，将两个功能分离，只是处理一遍顶点而已</p>
</li>
<li><p>也可以使用其他算法获得拓扑排序栈</p>
<ul>
<li>DFS遍历甚至可以遍历顶点一遍，同时获得顶点事件最早、
最晚发生时间</li>
</ul>
</li>
</ul>
<h4 id="特点-8"><a href="#特点-8" class="headerlink" title="特点"></a>特点</h4><ul>
<li>算法效率<ul>
<li>时间效率$\in O(|V|+|E|)$</li>
</ul>
</li>
</ul>
<h2 id="哈密顿回路问题"><a href="#哈密顿回路问题" class="headerlink" title="哈密顿回路问题"></a>哈密顿回路问题</h2><p>确定给定图中是否在包含一条哈密顿回路</p>
<h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><h4 id="算法-19"><a href="#算法-19" class="headerlink" title="算法"></a>算法</h4><ul>
<li><p>对所有节点维护标记：是否位于当前路径中</p>
</li>
<li><p>选择某节点<em>a</em>作为哈密顿回路起点顶点，即回溯状态空间树根</p>
</li>
<li><p>从根节点开始处理</p>
<ul>
<li>若节点周围还有未标记节点，选择下个加入路径、标记</li>
<li>若节点周围没有未标记节点，回溯到之前节点重新处理</li>
</ul>
</li>
<li><p>直到所有节点都被标记，且当前节点和根节点相邻</p>
</li>
</ul>
<h4 id="特点-9"><a href="#特点-9" class="headerlink" title="特点"></a>特点</h4><h2 id="旅商问题"><a href="#旅商问题" class="headerlink" title="旅商问题"></a>旅商问题</h2><p>Traveling Salesman Problem：对相互之间距离已知为正整数的n座
城市，求最短漫游路径，使得在回到出发城市之前，对每个城市只
访问一次</p>
<ul>
<li>即：对权重为正整数的无向完全图寻找最短哈密顿回路</li>
</ul>
<h3 id="蛮力算法-1"><a href="#蛮力算法-1" class="headerlink" title="蛮力算法"></a>蛮力算法</h3><h4 id="算法-20"><a href="#算法-20" class="headerlink" title="算法"></a>算法</h4><ul>
<li>生成n-1个中间城市的组合得到所有旅行线路</li>
<li>计算线路长度，求得最短路径</li>
</ul>
<h4 id="特点-10"><a href="#特点-10" class="headerlink" title="特点"></a>特点</h4><ul>
<li>算法排序次数为$(n-1)!/2$</li>
</ul>
<h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><ul>
<li>线路成对出现，只是方向相反，可考虑任意两个相邻顶点，只
考虑包含其某个排序的线路</li>
</ul>
<h3 id="分支界限法-1"><a href="#分支界限法-1" class="headerlink" title="分支界限法"></a>分支界限法</h3><ul>
<li><p>第i层下界可取$lb = \sum<em>{k=i+1}^n d</em>{k1}$</p>
</li>
<li><p>更紧密、也不复杂的下界
$lb = \lceil \frac {\sum<em>{k=i+1}^n (d</em>{k1} + d_{k2})} 2 \rceil$</p>
<ul>
<li><p>$d<em>{k1}, d</em>{k2}$：城市$i+1$到最近的两个城市距离</p>
</li>
<li><p>最短路径为两个端点共享，至多只能有一个端点能够成为
该边起点</p>
</li>
<li><p>若要求所有哈密顿回路中必须包括某些边，则在考虑相应
边端点城市时，使用必须边（若不是节点最短边）替换其中
次短边</p>
</li>
</ul>
</li>
<li><p>只需要生成某对节点有序的路径：可以消去状态空间树中部分
分支</p>
</li>
</ul>
<h4 id="算法-21"><a href="#算法-21" class="headerlink" title="算法"></a>算法</h4><h4 id="特点-11"><a href="#特点-11" class="headerlink" title="特点"></a>特点</h4><h2 id="旅商问题非精确算法"><a href="#旅商问题非精确算法" class="headerlink" title="旅商问题非精确算法"></a>旅商问题非精确算法</h2><p>以下均是讨论TSP问题的欧几里得实例，不对称实例等已经证明更难
解决，对精确算法、启发式算法都是如此</p>
<h3 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h3><h4 id="Nearest-Neighbor算法"><a href="#Nearest-Neighbor算法" class="headerlink" title="Nearest-Neighbor算法"></a>Nearest-Neighbor算法</h4><ul>
<li>任意选择城市开始</li>
<li>每次访问和当前城市k最接近的城市，直到访问完所有城市</li>
<li>回到开始城市</li>
</ul>
<h4 id="Multifregment-Heuristic算法"><a href="#Multifregment-Heuristic算法" class="headerlink" title="Multifregment-Heuristic算法"></a>Multifregment-Heuristic算法</h4><p>求给定加权完全图的最小权重边集合，且每个顶点连通度均为2</p>
<ul>
<li><p>将边按权重升序排列，将要构造的旅途边集合开始时空集合</p>
</li>
<li><p>不断尝试将排序列表中下条边加入旅途边集合</p>
<ul>
<li>边加入不会使得某节点连通度大于2</li>
<li>不会产生长度小于n的回路</li>
<li>否则忽略这条边</li>
</ul>
</li>
<li><p>返回旅途集合</p>
</li>
</ul>
<h4 id="算法特点-11"><a href="#算法特点-11" class="headerlink" title="算法特点"></a>算法特点</h4><p>对属于<strong>欧几里得类型</strong>的旅商问题实例（大部分）</p>
<ul>
<li>此时虽然两个算法的精确性能比无法界定，但是满足
$\frac {f(s_a)} {f(s^{*})} \leqslant \frac 1 2 (\lceil log_2 n \rceil + 1)$</li>
</ul>
<h3 id="Minimum-Spaning-Tree-Based-Algorithm"><a href="#Minimum-Spaning-Tree-Based-Algorithm" class="headerlink" title="Minimum-Spaning-Tree-Based Algorithm"></a>Minimum-Spaning-Tree-Based Algorithm</h3><p>基于最小生成树的算法</p>
<ul>
<li>哈密顿回路中去掉一条边就能得到一棵生成树$T_h$</li>
<li>可以先构造一棵最小生成数$T^{*}$，然后在其基础上构造近似
最短路径</li>
</ul>
<h4 id="Twice-Around-The-Tree算法"><a href="#Twice-Around-The-Tree算法" class="headerlink" title="Twice-Around-The-Tree算法"></a>Twice-Around-The-Tree算法</h4><ul>
<li>对给定实例构造最小生成树$T^{<em>}$（</em>Prim, Kruskal*）</li>
<li>从任意顶点开始，（利用深度优先遍历）绕树散步一周，记录
经过顶点</li>
<li>扫描顶点列表，消去重复出现顶点（走捷径，直接去新城市），
除列表尾部重复起点，得到一条哈密顿回路</li>
</ul>
<blockquote>
<ul>
<li>可能是考虑到最小生成树能够选出部分最短路径？？？</li>
</ul>
</blockquote>
<h4 id="特点-12"><a href="#特点-12" class="headerlink" title="特点"></a>特点</h4><p>对属于<strong>欧几里得类型</strong>的旅商问题</p>
<ul>
<li><p>绕树两周算法是2近似算法：$2f(s^{*}) &gt; f(s_a)$</p>
<ul>
<li>$f(s^{<em>} &gt; w(T_h) \geqslant w(T^{</em>})$：最优哈密顿
回路去掉一条边后长度大于等于最小生成树长度</li>
<li>$f(s^{<em>}) &lt; 2w(T^{</em>})$：第二次扫描走捷径距离小于绕树
一周距离</li>
<li>这里限定了特点类型实例，并没有找到对所有旅商问题的
优先近似算法</li>
</ul>
</li>
</ul>
<h3 id="Christofides算法"><a href="#Christofides算法" class="headerlink" title="Christofides算法"></a>Christofides算法</h3><p>同样利用问题与最小生成树的出关系，但更复杂</p>
<h4 id="算法-22"><a href="#算法-22" class="headerlink" title="算法"></a>算法</h4><ul>
<li>对给定实例构造最小生成树$T^{*}$</li>
<li>构造包含包含$T^{*}$的欧拉回路<ul>
<li>找出最小生成树中所有连通度为奇数的顶点</li>
<li>求出这些顶点的最小权重匹配（匈牙利算法）</li>
<li>将最小权重匹配边加入树中得到多重图欧拉回路</li>
</ul>
</li>
<li>使用走捷径方法将欧拉回路转换为哈密顿回路</li>
</ul>
<h4 id="特点-13"><a href="#特点-13" class="headerlink" title="特点"></a>特点</h4><p>对属于<strong>欧几里得类型</strong>的旅商问题</p>
<ul>
<li><p>绕最小生成树一周得到的路径是多重图的一条欧拉回路，其中
多重图为将当前图每条边重复一遍得到</p>
<ul>
<li>绕树两周算法：直接原始欧拉回路上走捷径</li>
<li>Christofides算法：重新构建更短的欧拉回路，在此基础
上走捷径</li>
</ul>
</li>
<li><p>Christofides算法是1.5近似算法</p>
<ul>
<li>实际应用中，Christofides算法近似解明显好于绕树两周</li>
<li>可以对连通度大于2顶点尝试不同访问次序，即将<strong>回路</strong>
中邻接顶点分别<strong>两两组合</strong>，找到访问其的最佳路径</li>
</ul>
</li>
</ul>
<h3 id="迭代改进算法"><a href="#迭代改进算法" class="headerlink" title="迭代改进算法"></a>迭代改进算法</h3><p>Local Search Heuristics：本地查找启发法</p>
<ul>
<li><p>这类算法从某个初始旅途（随机或简单近似算法生成）开始</p>
</li>
<li><p>每次迭代把当前旅途一些边用其他边代替，试图得到和当前旅途
稍有差别的旅途</p>
<ul>
<li>若能得到优于当前旅途的新旅途，则替换当前旅途，继续
寻找</li>
<li>否则，返回当前旅途，停止</li>
</ul>
</li>
</ul>
<h4 id="2选算法"><a href="#2选算法" class="headerlink" title="2选算法"></a>2选算法</h4><p>删除旅途中2条非临边，把两条边端点用另一对边重新连接</p>
<ul>
<li>此操作称为<em>2改变</em></li>
<li>为保证重连后得到合法哈密顿回路，重连方法只有一种</li>
</ul>
<h4 id="3选算法"><a href="#3选算法" class="headerlink" title="3选算法"></a>3选算法</h4><p>删除3条非临边后重连</p>
<ul>
<li>重连方法有3种</li>
<li>事实上可以推广到k选，但是只有3改变被证明有意义</li>
</ul>
<h4 id="Lin-Kernighan算法"><a href="#Lin-Kernighan算法" class="headerlink" title="Lin-Kernighan算法"></a>Lin-Kernighan算法</h4><p>变选算法算法的一种</p>
<ul>
<li>可以视为在3选操作后进行一系列2选操作</li>
</ul>
<h4 id="算法特点-12"><a href="#算法特点-12" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li>迭代改进算法求得的近似解效果质量非常好</li>
<li>Lin-Kernighan算法是公认的求解高质量近似解的最佳算法</li>
</ul>
<h3 id="Held-Karp-Bound"><a href="#Held-Karp-Bound" class="headerlink" title="Held-Karp Bound"></a>Held-Karp Bound</h3><p>Held-Karp下界</p>
<ul>
<li>将TSP描述为线性规划问题求解（忽略整数约束）得到，计算
速度快</li>
<li>一般和最优旅途长度非常接近，误差不超过1%</li>
<li>可使用其代替最短旅途估计近似算法的精确度</li>
</ul>
<h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><ul>
<li>10000个随机点：坐标、距离取整</li>
<li>Comqaq ES40：500MHz的Alpha处理器、2GB内存</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>启发式算法</th>
<th>超过Held-Karp下界的%</th>
<th>运行时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>最近邻居</td>
<td>24.79</td>
<td>0.28</td>
</tr>
<tr>
<td>多片段</td>
<td>16.42</td>
<td>0.20</td>
</tr>
<tr>
<td>Christofides</td>
<td>9.81</td>
<td>1.04</td>
</tr>
<tr>
<td>2选</td>
<td>4.70</td>
<td>1.41</td>
</tr>
<tr>
<td>3选</td>
<td>2.88</td>
<td>1.50</td>
</tr>
<tr>
<td>Lin-Kernighan</td>
<td>2.00</td>
<td>2.06</td>
</tr>
</tbody>
</table>
</div>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-11T04:25:59.000Z" title="4/11/2019, 12:25:59 PM">2019-04-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-02T10:07:33.000Z" title="8/2/2021, 6:07:33 PM">2021-08-02</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Data-Structure/">Data Structure</a></span><span class="level-item">22 minutes read (About 3269 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Data-Structure/graph.html">图</a></h1><div class="content"><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>图$G=<V, E>$：由一些称为顶点的点构成的集合，其中某些顶点由
称为边的线段相连</p>
<ul>
<li>有限集合V：元素为顶点<em>vertex</em></li>
<li>有限集合E：元素为<strong>顶点二元组</strong>，称为边<em>edge</em>/弧<em>arc</em></li>
</ul>
<h3 id="边方向"><a href="#边方向" class="headerlink" title="边方向"></a>边方向</h3><h4 id="Undigraph-Undirected-Graph"><a href="#Undigraph-Undirected-Graph" class="headerlink" title="Undigraph/Undirected Graph"></a><em>Undigraph</em>/<em>Undirected Graph</em></h4><blockquote>
<ul>
<li>无向图：所有边都是无向边的图</li>
<li>无向边：若有序对$(u, v) \in E$，必有$(v, u) \in E$，
  即E是对称的，顶点对$(u, v)$等同于$(v, u)$，没有顺序</li>
</ul>
</blockquote>
<p>对无向边$(u, v)$</p>
<ul>
<li>则顶点u、v相互<em>adjcent</em></li>
<li>其通过<em>undirected edge</em>$(u, v)$相连接</li>
<li>顶点u、v称为边$(u, v)$的<em>endpoint</em></li>
<li>u、v和该边<em>incident</em>（相依附）</li>
</ul>
<h4 id="Digraph"><a href="#Digraph" class="headerlink" title="Digraph"></a><em>Digraph</em></h4><blockquote>
<ul>
<li>有向图：所有边都是有向边的图</li>
<li>有向边：若有序对对$(u, v) \in E$无法得到$(v, u) \in E$，
  即两者不等同，有顺序</li>
</ul>
</blockquote>
<p>对有向边$(u, v)$</p>
<ul>
<li>边$(u, v)$的方向是从顶点u到顶点v</li>
<li>u称为tail，v称为head</li>
</ul>
<h3 id="边权重"><a href="#边权重" class="headerlink" title="边权重"></a>边权重</h3><h4 id="Ordered-Graph"><a href="#Ordered-Graph" class="headerlink" title="Ordered Graph"></a><em>Ordered Graph</em></h4><p>有序图：各边地位有序</p>
<h4 id="Weighted-Graph-Network"><a href="#Weighted-Graph-Network" class="headerlink" title="Weighted Graph/Network"></a><em>Weighted Graph</em>/<em>Network</em></h4><p>加权图/网络：给边赋值的图</p>
<ul>
<li>值称为<em>weight</em>或<em>cost</em></li>
<li>有大量的现实应用</li>
</ul>
<h3 id="边数量"><a href="#边数量" class="headerlink" title="边数量"></a>边数量</h3><ul>
<li><em>complete graph</em>：任意两个顶点直接都有的边相连的图<ul>
<li>使用$K_{|v|}$表示有|V|个顶点的完全图</li>
</ul>
</li>
<li><em>dense graph</em>：图中所缺的边数量相对较少</li>
<li><em>sparse</em>：图中边相对顶点数量较少</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>不考虑<strong>loop</strong>（顶点连接自身边），则含有|V|个顶点无向图
包含边的数量|E|满足：
$ 0 \leq |E| \leq \frac {|V|(|V| - 1)} {2} $</p>
</li>
<li><p>对于稀疏图、稠密图可能会影响图的表示方法，影响设计、使用
算法的运行时间</p>
</li>
</ul>
<h2 id="图表示方法（存储结构）"><a href="#图表示方法（存储结构）" class="headerlink" title="图表示方法（存储结构）"></a>图表示方法（存储结构）</h2><h3 id="Adjacency-Matrix"><a href="#Adjacency-Matrix" class="headerlink" title="Adjacency Matrix"></a><em>Adjacency Matrix</em></h3><p>邻接矩阵：两个数组分别存储数据元素（顶点）信息、数据元素之间
关系（边）的信息</p>
<ul>
<li>n个顶点的图对应n * n的bool矩阵<ul>
<li>图中每个顶点使用一行和一列表示</li>
<li>i、j节点间有边，则矩阵第i行、j列元素为1，否则为0</li>
</ul>
</li>
<li>无向图邻接矩阵一定是对称的，有向图邻接矩阵不一定</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span>DG, DN&lt; UDG, UDN&#125; GraphKind;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcCell</span>&#123;</span></span><br><span class="line">	VRType adj;</span><br><span class="line">		<span class="comment">// 顶点关系类型：无权图0、1是否相邻，加权图权值类型</span></span><br><span class="line">	InfoType * info;</span><br><span class="line">		<span class="comment">// 弧相关信息</span></span><br><span class="line">&#125;ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	VertexType vexs[MAX_VERTEX_NUM];</span><br><span class="line">		<span class="comment">// 顶点向量</span></span><br><span class="line">	AdjMatrix arcs;</span><br><span class="line">	<span class="keyword">int</span> vexnum, arcnum;</span><br><span class="line">		<span class="comment">// 图当前顶点弧数</span></span><br><span class="line">	GraphKind kind;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Adjacency-List"><a href="#Adjacency-List" class="headerlink" title="Adjacency List"></a><em>Adjacency List</em></h3><p>邻接表：n条单链表代替邻接矩阵的n行，对应图G的n个顶点</p>
<ul>
<li><p>每个顶点用一个邻接表表示</p>
<ul>
<li>线性表的<em>header</em>表示对应的顶点</li>
<li>链表中结点表示依附于顶点的边</li>
</ul>
</li>
<li><p>无向图一条边在邻接链表中对应两条链，有向图对应一条</p>
<ul>
<li>有向图出度计算简单</li>
<li>计算入度则比较复杂，如果需要频繁计算入度，可以再存储
一个反向邻接表</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> adjvex;</span><br><span class="line">		<span class="comment">// 弧指向顶点信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span></span><br><span class="line">		<span class="comment">// 指向下条弧指针</span></span><br><span class="line">	InfoType * info;</span><br><span class="line">		<span class="comment">// 弧相关信息</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">	VertexType data;</span><br><span class="line">		<span class="comment">// 顶点信息</span></span><br><span class="line">	ArcNode * firstarc;</span><br><span class="line">		<span class="comment">// 首条依附该顶点的弧指针</span></span><br><span class="line">&#125;VNode, AdjList[MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	AdjList vertices;</span><br><span class="line">	<span class="keyword">int</span> vexnum, arcnum;</span><br><span class="line">	<span class="keyword">int</span> kind;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Orthogonal-List"><a href="#Orthogonal-List" class="headerlink" title="Orthogonal List"></a><em>Orthogonal List</em></h3><p>十字链表：将<strong>有向图</strong>的邻接表、逆邻接表结合起来</p>
<ul>
<li>有向图中每条弧、每个顶点对应一个结点</li>
<li>弧结点所在链表为非循环链表，<ul>
<li>结点之间相对位置自然形成，不一定按照顶点序号有序</li>
</ul>
</li>
<li>表头结点即顶点结点，顺序存储</li>
</ul>
<p><img src="/imgs/orthogonal_list_structure.png" alt="orthogonal_list_structure"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcBox</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> tailvex, headvex;</span><br><span class="line">		<span class="comment">// 头、尾顶点链域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ArcBox</span> *<span class="title">hlink</span>, *<span class="title">tlink</span>;</span></span><br><span class="line">		<span class="comment">// 头相同、尾相同弧链域</span></span><br><span class="line">	InfoType *info;</span><br><span class="line">		<span class="comment">// 弧相关信息</span></span><br><span class="line">&#125;ArcBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VexNode</span>&#123;</span></span><br><span class="line">	VertexType data;</span><br><span class="line">		<span class="comment">// 顶点信息</span></span><br><span class="line">	ArcBox *firstin, *firstout;</span><br><span class="line">		<span class="comment">// 顶点第一条出、入弧</span></span><br><span class="line">&#125;VexNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	VexNode xlist[MAX_VERTEX _NUM];</span><br><span class="line">		<span class="comment">// 表头</span></span><br><span class="line">	<span class="keyword">int</span> vexnum, arcnum;</span><br><span class="line">&#125;OLGraph;</span><br></pre></td></tr></table></figure>
<h3 id="Adjacency-Multilist"><a href="#Adjacency-Multilist" class="headerlink" title="Adjacency Multilist"></a><em>Adjacency Multilist</em></h3><p>邻接多重表：<strong>无向图</strong>的另一种存储形式</p>
<ul>
<li>一条边对应<strong>唯一结点</strong><ul>
<li>所有依附于同一顶点的串联在同一链表中</li>
<li>每个边界点同时链接在两个链表中</li>
<li>避免无向图邻接表中一条边两次出现</li>
</ul>
</li>
<li>类似十字链表，仅无需区分头尾结点</li>
</ul>
<p><img src="/imgs/adjacency_multilist_structure.png" alt="adjacency_multilist_structure"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EBox</span>&#123;</span></span><br><span class="line">	VisitIf mark;</span><br><span class="line">		<span class="comment">// 访问标记</span></span><br><span class="line">	<span class="keyword">int</span> ivex, jvex;</span><br><span class="line">		<span class="comment">// 边依附的两个顶点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">EBox</span> *<span class="title">ilink</span>, *<span class="title">jlink</span>;</span></span><br><span class="line">		<span class="comment">// 依附两个顶点的下条边</span></span><br><span class="line">	InfoType *info;</span><br><span class="line">		<span class="comment">// 边信息指针</span></span><br><span class="line">&#125;EBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VexBox</span>&#123;</span></span><br><span class="line">	VertexType data;</span><br><span class="line">	EBox *firstedge;</span><br><span class="line">		<span class="comment">// 第一条依附该顶点的边</span></span><br><span class="line">&#125;VexBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	VexBox adjmulist[MAX_VERTEX_NUM];</span><br><span class="line">	<span class="keyword">int</span> vexnum, edgenum;</span><br><span class="line">&#125;AMLGraph;</span><br></pre></td></tr></table></figure>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li><p>稀疏图：尽管链表指针会占用额外存储器，但是相对于邻接矩阵
占用空间依然较少</p>
</li>
<li><p>稠密图：邻接矩阵占用空间较少</p>
</li>
<li><p>邻接矩阵、邻接链表都可以方便的表示加权图</p>
<ul>
<li>邻接矩阵元素A[i, j]设置为有限值表示存在的边的权重，
设置为$\infty$表示不存在边，此时矩阵也称
<strong>weighted matrix</strong>或<strong>cost matrix</strong></li>
<li>邻接链表在节点中型跨同时包含节点名称和相应边权重</li>
</ul>
</li>
<li><p>任何可以存储顶点、边的数据结构（如集合）都可以表示图，
只是存储效率低、无法高效操作</p>
</li>
</ul>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><h4 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h4><ul>
<li><p><em>directed path</em>：有向图中顶点的一个序列，序列中每对连续
顶点都被边连接，边方向为一个顶点指向下一个顶点</p>
</li>
<li><p><em>directed cycle</em>：有向图中节点序列，起点、终点相同，每个
节点和其直接前趋之间，都有一条从前趋指向后继的边</p>
</li>
<li><p><em>directed acyclic graph</em>：DAG，有向无环图</p>
</li>
</ul>
<h4 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h4><ul>
<li><p><em>path</em>：（无向）图G中始于u而止于v的邻接顶点序列，即为顶点u
到顶点v的路径</p>
</li>
<li><p><em>simple path</em>：路径上所有点互不相同</p>
</li>
<li><p><em>cycle</em>：特殊的path</p>
<ul>
<li>起点、终点都是同一顶点</li>
<li>长度大于0</li>
<li>不包含同一条边两次</li>
</ul>
</li>
<li><p><em>acyclic</em>：不包含回路的图</p>
</li>
</ul>
<h4 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h4><ul>
<li><em>length</em>：路径中代表顶点序列中的顶点数目减1，等于路径中
包含的边数目</li>
<li><em>distance</em>：顶点间距离，顶点之间最短路径长度</li>
</ul>
<h3 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h3><h4 id="无向图-1"><a href="#无向图-1" class="headerlink" title="无向图"></a>无向图</h4><ul>
<li><p><em>connected</em>：顶点u、v连通，当且仅当存在u到v的路径</p>
</li>
<li><p><em>connected graph</em>：连通图，对图中的每对顶点$(u, v)$，
都有从u到v的路径</p>
</li>
<li><p><em>connected component</em>：连通分量，给定图的极大连通子图，
即没有可以添加的连通子图用于扩充</p>
<ul>
<li>非连通图中包含的几个自我连通的部分</li>
</ul>
</li>
<li><p><em>articulation point</em>：关节点，如果从连通图$G$中删除顶点
$v$、极其邻接边各点之后的的图$G^{‘}$至少有两个连通分量，
则称顶点$v$为关节点</p>
</li>
<li><p><em>biconnected graph</em>：重连通图，没有关节点的连通图</p>
</li>
<li><p><em>biconnected component</em>：重连通分量，连通图的最大重连通
子图，即不是其他重连通分量的真子图</p>
<ul>
<li>两个重连通分量不可能共享一个以上节点，即图的一条边
不可能同时出现在两个重连通分量中
（否则两个“重连通分量”可以合并）</li>
<li>所以可以说重连通分量是对原图的<strong>边的划分</strong></li>
</ul>
</li>
</ul>
<h4 id="有向图-1"><a href="#有向图-1" class="headerlink" title="有向图"></a>有向图</h4><ul>
<li>强连通图：对所有不同顶点u、v，都存在u到v、v到u的路径</li>
<li><em>strongly connected component</em>：强连通分量，有向图的
极大连通子图</li>
</ul>
<h5 id="源点、汇点"><a href="#源点、汇点" class="headerlink" title="源点、汇点"></a>源点、汇点</h5><ul>
<li><em>soruce</em>：源，没有输入边的顶点</li>
<li><em>sink</em>：汇点，没有输出边顶点</li>
</ul>
<h2 id="图遍历"><a href="#图遍历" class="headerlink" title="图遍历"></a>图遍历</h2><p>遍历图：实质是对每个顶点查找其邻接顶点的过程</p>
<blockquote>
<ul>
<li>具体算法参见<em>algorithm/problem/graph</em></li>
</ul>
</blockquote>
<h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><blockquote>
<ul>
<li>BFS：<em>Breadth First Search</em>：广度优先搜索，类似树的先序
  遍历</li>
<li><p>DFS：<em>Depth First Search</em>：深度优先搜索，类似树的按层次
  遍历</p>
</li>
<li><p>具体算法参见<em>algorithm/problem/graph</em></p>
</li>
</ul>
</blockquote>
<h3 id="结点处理顺序"><a href="#结点处理顺序" class="headerlink" title="结点处理顺序"></a>结点处理顺序</h3><blockquote>
<ul>
<li><em>post-order</em>：后序，先处理子节点，再处理当前结点</li>
<li><em>pre-order</em>：前序，先处理当前结点，再处理子节点</li>
</ul>
</blockquote>
<ul>
<li><p>搜索森林中<strong>仅有一棵树</strong>时</p>
<ul>
<li>前序、后序均满足处理顺序（后序为逆处理顺序）</li>
<li>前序、后序处理仅是处理顺序刚好相反</li>
</ul>
</li>
<li><p>搜索森林中<strong>有多棵树</strong>时，将每棵树视为一个结点考虑</p>
<ul>
<li>每个树内前序、后序顶点处理顺序相反</li>
<li><strong>不同树整体</strong>前序、后序处理顺序相反</li>
<li>此时前序不再满足处理顺序，后序仍为逆处理顺序，所以
前序不常用</li>
</ul>
</li>
<li><p>节点处理记录方式</p>
<ul>
<li>栈：出栈顺序同记录反向</li>
<li>队列：出队列顺序同记录顺序</li>
</ul>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p><em>Pre-Order</em>：正前序，先当前顶点、后子顶点，队列存储</p>
</li>
<li><p><em>Reverse Pre-Order</em>：逆前序，先子顶点、后当前顶点，
栈存储</p>
</li>
<li><p><em>Post-Order</em>：正后序，先当前顶点、后子顶点，队列存储</p>
</li>
<li><p><em>Reversed Post-Order</em>：逆后序，先子顶点、后当前顶点，
栈存储，也称为<strong>伪拓扑排序</strong></p>
<ul>
<li>可以用于得到DAG的拓扑有序序列</li>
<li>也可以用于得到有环有向图的<strong>伪拓扑序列</strong><ul>
<li>强连通分量整体看作结点，组成DAG</li>
<li>各强连通分量必然可以选出某个顶点，满足在伪拓扑
序列中次序<strong>先于DAG中先驱强连通分量所有顶点</strong></li>
</ul>
</li>
<li>用途最广<ul>
<li>有向图拓扑排序</li>
<li>Kosaraju算法中用到</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="BFS、DFS森林"><a href="#BFS、DFS森林" class="headerlink" title="BFS、DFS森林"></a>BFS、DFS森林</h3><p>广度优先、深度优先生成森林</p>
<ul>
<li>遍历的初始顶点可以作为森林中树的根</li>
<li>遇到新未访问的顶点，将其附加为<strong>直接前趋</strong>子女</li>
<li>其实<strong>仅有树向边</strong>才是符合森林定义（其他边都只是搜索过程
中遇到）</li>
</ul>
<blockquote>
<ul>
<li>DFS森林中边是<strong>从左到右</strong>逐渐生成</li>
<li>BFS森林中边是<strong>从上到下</strong>逐渐生成</li>
</ul>
</blockquote>
<h4 id="边类型"><a href="#边类型" class="headerlink" title="边类型"></a>边类型</h4><ul>
<li><em>tree edge</em>：树向边，连接父母、子女的边</li>
<li><em>back edge</em>：回边，连接非直接前驱的边<ul>
<li>对有向图包括连接父母的边</li>
<li>对无向图不存在连接父母边</li>
</ul>
</li>
<li><em>cross edge</em>：交叉边，连接非前驱、后继的边</li>
<li><em>forward edge</em>：前向边，连接非直接后代的边</li>
</ul>
<h4 id="边存在性"><a href="#边存在性" class="headerlink" title="边存在性"></a>边存在性</h4><ul>
<li>无向图<ul>
<li>DFS森林：只可能有回边</li>
<li>BFS森林：只可能有交叉边</li>
</ul>
</li>
<li>有向图<ul>
<li>DFS森林：可以都有</li>
<li>BFS森林：只可能有回边、交叉边</li>
</ul>
</li>
</ul>
<h3 id="Spanning-Tree"><a href="#Spanning-Tree" class="headerlink" title="Spanning Tree"></a><em>Spanning Tree</em></h3><p>生成树/极小连通子图：包含图中所有顶点的连通无环子图（树）</p>
<ul>
<li><p>n个顶点的生成树有且仅有n-1条边，反之不成立</p>
</li>
<li><p>在生成树添加一条边必定构成一个环，因为其实使得其依附的
两个顶点之间生成了第二条路径</p>
</li>
</ul>
<h4 id="Minimum-Cost-Spanning-Tree"><a href="#Minimum-Cost-Spanning-Tree" class="headerlink" title="Minimum Cost Spanning Tree"></a><em>Minimum Cost Spanning Tree</em></h4><p>最小生成树：图的一棵权重最小的生成树（权重指所有边权重之和）</p>
<h5 id="MST性质"><a href="#MST性质" class="headerlink" title="MST性质"></a>MST性质</h5><blockquote>
<ul>
<li>若$N=(V, {E})$是连通网，U是顶点集V的非空子集，若
  $(u, v), u \in U, v \in V-U$是一条具有最小权值（代价）边
  ，则图中<strong>存在</strong>最小生成树包含该边</li>
</ul>
</blockquote>
<ul>
<li><p>假设网N中最小生成树T不包含边$(u, v)$，将其加入T中</p>
</li>
<li><p>因为T为生成树，所以必存在边
$(u^{‘}, v^{‘}), u^{‘} \in U, v^{‘} \in V-U$，且
$u, u^{‘}$、$v, v^{‘}$之间均有路径连通</p>
</li>
<li><p>则删除$(u^{‘}, v^{‘})$可以消去上述回路，得到新生成树
$T^{‘}$，且代价不大于$T$，矛盾</p>
</li>
</ul>
<blockquote>
<ul>
<li><strong>存在</strong>是考虑到存在其他同权值边，若权值严格最小，则所有
  最小生成树必然包含</li>
<li>依此性质生成算法参见<em>algorithm/problems/graph</em></li>
</ul>
</blockquote>
<h3 id="连通性-1"><a href="#连通性-1" class="headerlink" title="连通性"></a>连通性</h3><ul>
<li>对图进行遍历是判断图连通性、求解连通分量的好方法</li>
</ul>
<h4 id="有向图-2"><a href="#有向图-2" class="headerlink" title="有向图"></a>有向图</h4><ul>
<li><p>连通图：从图中任意顶点出发，进行深度、广度优先搜索即可
访问到图中所有顶点</p>
<ul>
<li>利用DFS生成树可以找出图的重连通分量</li>
</ul>
</li>
<li><p>非连通图：需要从多个顶点起始进行搜索</p>
<ul>
<li>每次<strong>从新的起始点出发</strong>进行搜索过程中得到顶点访问
序列就是各个连通分量的顶点集</li>
</ul>
</li>
</ul>
<h4 id="无向图-2"><a href="#无向图-2" class="headerlink" title="无向图"></a>无向图</h4><ul>
<li>深度优先搜索是求有向图<strong>强连通分量</strong>的有效方法</li>
</ul>
<blockquote>
<ul>
<li>具体算法参见<em>algorithm/problem/graph</em></li>
</ul>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-11T01:47:57.000Z" title="4/11/2019, 9:47:57 AM">2019-04-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-04-11T01:47:57.000Z" title="4/11/2019, 9:47:57 AM">2019-04-11</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Data-Structure/">Data Structure</a></span><span class="level-item">14 minutes read (About 2063 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Data-Structure/graphdi_specials.html">有向图衍生</a></h1><div class="content"><h2 id="Directed-Acycline-Graph"><a href="#Directed-Acycline-Graph" class="headerlink" title="Directed Acycline Graph"></a><em>Directed Acycline Graph</em></h2><p>DAG：有向无环图</p>
<ul>
<li>描述含有公共子式的表达式的有效工具<ul>
<li>可以实现对相同子式的共享，节省存储空间</li>
</ul>
</li>
<li>描述一项工程、系统进行过程的有效工具<ul>
<li>拓扑排序：工程能否顺利进行</li>
<li>关键活动：整个工程完成必须的最短时间</li>
</ul>
</li>
</ul>
<h3 id="Dependence-Analysis"><a href="#Dependence-Analysis" class="headerlink" title="Dependence Analysis"></a><em>Dependence Analysis</em></h3><p>依赖性分析：由有向图判断、构造可行任务执行序列</p>
<h4 id="Topological-Sort"><a href="#Topological-Sort" class="headerlink" title="Topological Sort"></a><em>Topological Sort</em></h4><blockquote>
<ul>
<li>拓扑有序：由偏序得到的全序</li>
<li>拓扑排序：由偏序定义得到拓扑有序的操作</li>
</ul>
</blockquote>
<ul>
<li><p>构造有向图中顶点的拓扑有序序列</p>
<ul>
<li>得到可行任务执行顺序</li>
</ul>
</li>
<li><p>判断有向图AOV-网中是否存在环，即是否为DAG</p>
<ul>
<li>若图中所有顶点都在拓扑有序序列中，则有向图中不存在环</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>参见<em>algorithm/problems/graph</em></li>
<li>AOV网：<em>activity on vertex network</em>，顶点表示活动，弧
  表示活动间优先关系的有向图</li>
</ul>
</blockquote>
<h3 id="关键活动优化"><a href="#关键活动优化" class="headerlink" title="关键活动优化"></a>关键活动优化</h3><h4 id="Critical-Path"><a href="#Critical-Path" class="headerlink" title="Critical Path"></a><em>Critical Path</em></h4><p>关键路径：路径长度最长的路径</p>
<ul>
<li><p>对整个AOE网，开始点到结束点的关键路径长度即为完成工程
的最短时间</p>
</li>
<li><p>对事件$v_i$，从起始点$v_1$到其的关键路径长度即为，以
$v_i$为尾的活动的最早开始时间</p>
</li>
<li><p>关键路径上的所有活动均为关键活动</p>
<ul>
<li>分析关键路径目的就是找出关键活动</li>
<li>提高关键活动工效缩短工期</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>AOE网：<em>activity on edge network</em>，顶点表示事件，边表示
  活动持续事件的带权有向无环图<blockquote>
<ul>
<li>一般网络中只有一个源点、汇点，表示工程开始、完成</li>
<li>以上假设AOE网中活动可以并行进行</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="关键活动"><a href="#关键活动" class="headerlink" title="关键活动"></a>关键活动</h4><blockquote>
<ul>
<li>关键活动：记$ee<em>{ij}$为活动$a</em>{ij}$最早开始时间、
  $el<em>{ij}$为不推迟整个工程完成前提下$a</em>{ij}$最迟开始时间
  ，称$ee<em>{ij} = el</em>{ij}$称为关键活动</li>
</ul>
</blockquote>
<ul>
<li><p>$el<em>{ij} - ee</em>{ij}$表示完成活动$a_{ij}$的时间余量</p>
<ul>
<li>提前完成非关键活动不能加快工程进度</li>
<li>关键活动耗时一定范围变化影响工程整体完成时间</li>
</ul>
</li>
<li><p>考虑如下事件和活动发生关系有</p>
<script type="math/tex; mode=display">
\left \{ \begin{array}{l}
ee_{ij} & = ve_{i} \\
el_{ij} & = vl_{j} - a_{ij}
\end{array} \right.</script><blockquote>
<ul>
<li>$ve_i, vl_i$：事件（顶点）i最早、最晚发生的时间</li>
<li>$a<em>{ij}$：活动$a</em>{ij}$需要持续时间</li>
</ul>
</blockquote>
</li>
<li><p>对$ve_i, vl_i$，存在如下递推关系</p>
<script type="math/tex; mode=display">\left \{ \begin{array}{l}
ve_i = \max\{ve_m + a_{mi} \}, & \forall a_{mi} \in E \\
vl_i = \max\{vl_n - a_{in} \}, & \forall a_{in} \in E
\end{array} \right.</script><p>则依拓扑排序可计算得$ve_i$，逆拓扑排序可计算得$vl_i$</p>
</li>
</ul>
<blockquote>
<ul>
<li>参见<em>algorithm/problems/graph</em></li>
<li>为求解AOE网中活动$e<em>{ij}, l</em>{ij}$，应该首先求出事件</li>
</ul>
</blockquote>
<h2 id="Flow-Network"><a href="#Flow-Network" class="headerlink" title="Flow Network"></a>Flow Network</h2><p>流量网络</p>
<ul>
<li>包含一个源点：物质流唯一出发点</li>
<li>包含一个汇点：物质流唯一汇聚点</li>
<li>每条有向边权重为边capacity的正整数$u_{ij}$<ul>
<li>事实上，有理数总可以通过变换变为整数，所以只要容量为
有理数就可以</li>
<li>计算机无法真正处理无理数，无理数边权只具有理论意义</li>
</ul>
</li>
</ul>
<h3 id="流量约束"><a href="#流量约束" class="headerlink" title="流量约束"></a>流量约束</h3><h4 id="Capacity-Constraits"><a href="#Capacity-Constraits" class="headerlink" title="Capacity Constraits"></a>Capacity Constraits</h4><p>容量约束：通过边的流量不大于边容量$x<em>{ij} \leqslant u</em>{ij}$</p>
<h4 id="Flow-Conservation-Requirement"><a href="#Flow-Conservation-Requirement" class="headerlink" title="Flow-Conservation Requirement"></a>Flow-Conservation Requirement</h4><p>流量守恒要求：除源点、汇点外其余顶点只能改变流方向，进入、
流出物质总量不变，不能消耗、添加物质</p>
<script type="math/tex; mode=display">
\sum_{i:(i,j) \in E} x_{ij} = \sum_{k:(j,k) \in E} x_{jk}</script><ul>
<li>其中$x_{ij}$表示通过边$(i,j)$的流量（传输量）</li>
<li>等式左右为进入、离开顶点i的输入、输出流总和</li>
</ul>
<p>并且</p>
<script type="math/tex; mode=display">
\sum_{j:(1,j) \in E} x_{1j} = \sum_{i:(i,n) \in E} x_{in}</script><ul>
<li>流的值 = 源点输出流 = 汇点输入流</li>
<li>可通过流量守恒要求推出</li>
</ul>
<h3 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h3><p>最大流：分配流量网络中边权（实际流量），使得网络在满足流量
守恒、容量束情况下，最大的流的值（边容量都为正整数）</p>
<script type="math/tex; mode=display">
\max = \sum_{j:(1,j)} x_{i,j} \\
s.t. 0 \leqslant x_{ij} \leqslant u_{ij} \\
\sum_{j:(j,i) \in E) x_{ji} - \sum_{j:(i,j) \in E} x_{ij} = 0</script><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a><em>cut</em></h3><p>割：$C(X,\bar X)$=所有头在$X$、尾在$\bar X$边集合</p>
<ul>
<li>$X$；包含源点、不包含汇点的顶点V的子集</li>
<li>$\bar X$：$X$的补集，包含汇点</li>
<li>删除割中所有边，则不存在从源点的汇点的路径</li>
</ul>
<h3 id="Augmenting-Path-Method"><a href="#Augmenting-Path-Method" class="headerlink" title="Augmenting-Path Method"></a>Augmenting-Path Method</h3><h4 id="Augmenting-Path"><a href="#Augmenting-Path" class="headerlink" title="Augmenting-Path"></a>Augmenting-Path</h4><p><strong>流量增益</strong>路径：当前流情况下，可以传输更多流量、从源点到
汇点路径，考虑路径$i \rightarrow j \leftarrow k$中顶点j边</p>
<ul>
<li><p><em>forward edge</em>：前向边$(i, j)$，同流量网络中边$(i, j)$
方向相同</p>
<ul>
<li>具有正的未使用容量$r<em>{ij} = u</em>{ij} - x_{ij}$</li>
<li>可以把该边流量增加最多$r_{ij}$</li>
</ul>
</li>
<li><p><em>backward edge</em>：后向边$(j, k)$，同流量网络中边$(k, j)$
方向相反</p>
<ul>
<li>具有正流量$x_{kj}$</li>
<li>可以把该边流量减少最多$x_{kj}$</li>
</ul>
</li>
</ul>
<h4 id="增益路径法"><a href="#增益路径法" class="headerlink" title="增益路径法"></a>增益路径法</h4><ul>
<li><p>寻找网络中增益路径，设$r$为路径中各前向边未使用容量
$r<em>{ij}$、后向边流量$x</em>{jk}$最小值</p>
</li>
<li><p>每条前向边流量加r、后向边流量减r，可以得到新的可行流量，
且流量值增加r，不断迭代</p>
</li>
<li><p>基于边容量、流量都为正整数假设</p>
<ul>
<li><p>r也为正整数，每次迭代流量值至少增加1</p>
</li>
<li><p>流量最大值有上界为源点为起点边容量和，则增益路径法
在<strong>有限步迭代后会停止</strong></p>
</li>
</ul>
</li>
<li><p>联合最大流-最小割定律可以证明</p>
<ul>
<li>最终流量一定是最大化的，等于最小割容量</li>
<li>和增量路径选择无关</li>
</ul>
</li>
<li><p>最后一步迭代中</p>
<ul>
<li>所有已标记顶点和未标记顶点之间边就构成最小割</li>
<li>这样边流量要么满（标记到未标记）、要么空（反）</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>增益路径法具体实现参见<em>graph</em></li>
<li>算法主要问题在于如何寻找增益路径，生成路径的顺序对算法
  有巨大影响</li>
</ul>
</blockquote>
<h3 id="Max-Flow-Min-Cut-Theorem"><a href="#Max-Flow-Min-Cut-Theorem" class="headerlink" title="Max-Flow Min-Cut Theorem"></a>Max-Flow Min-Cut Theorem</h3><p>最大流-最小割定理：网络中最大流量值等于其最小割容量</p>
<h4 id="Theorem1"><a href="#Theorem1" class="headerlink" title="Theorem1"></a>Theorem1</h4><p>网络中最大流量值小于任意割容量</p>
<ul>
<li><p>设可行流量x值为v，割$C(X, \bar_X)$容量为c</p>
</li>
<li><p>通过该割的流量为：<em>$X$到$\bar_X$的流量之和</em>与
<em>$\bar_X$到$X$的流量之和</em>的差值（可由流量守恒推导）</p>
<script type="math/tex; mode=display">
v = \sum_{i \in X, j \in \bar_X} x_{ij} -
   \sum{j \in \bar_X, i \in X} x_{ji}</script></li>
<li><p>由流量非负可得</p>
<script type="math/tex; mode=display">
v \leqslant \sum_{i \in X, j \in \bar_X} x_{ij}
   \leqslant \sum_{i \in X, j \in \bar_x} u_{ij}</script><p>即网络上任何可行流值不能超过网络上任意割容量</p>
<script type="math/tex; mode=display">v \leqslant c</script></li>
</ul>
<h4 id="Theorem2"><a href="#Theorem2" class="headerlink" title="Theorem2"></a>Theorem2</h4><p>网络中最大流量等于最小割容量，可以使用增益路径法证明</p>
<ul>
<li><p>设$v^{<em>}$为通过路径增益法得到的最终流$x^{</em>}$的值</p>
</li>
<li><p>对增益路径法最终流量情况下，考虑顶点集合$X^{*}$</p>
<ul>
<li>包含源点</li>
<li>其他顶点可由源点出发，经未使用的容量大于0的前向边、
流量大于0的后向边组成路径到达</li>
</ul>
</li>
<li><p>则汇点不属于$X^{*}$，否则存在一条流量增益路径，不是流量
增益法最终流情况</p>
</li>
<li><p>考虑割$C(X^{<em>}, \bar_{X^{</em>}})$</p>
<ul>
<li><p>$X^{<em>}, \bar_{X^{</em>}}$之间任意边$(i,j)$：
$x<em>{ij} = u</em>{ij}$，没有未使用容量</p>
</li>
<li><p>$\bar<em>{X^{<em>}}, X^{</em>}$之间任意边$(j,i)$：$x</em>{ji}=0$，
没有流量</p>
</li>
<li><p>否则顶点j$\in X^{*}$</p>
</li>
</ul>
</li>
<li><p>则有</p>
<script type="math/tex; mode=display">\begin{align}{c}
v* & = \sum_{i \in X^{*}, j \in \bar_{X^{*}} x_{ij} -
   \sum{j \in \bar_{X^{*}, i \in X^{*}} x_{ji} \\

& = \sum_{i \in X^{*}, j \in \bar_{X^{*}}} u_{ij} - 0 \\

& = C(X^{*}, \bar_{X^{*}})
\end{align}</script><p>即存在某个割容量等于流量增益法得到最终流量值</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-05T13:50:53.000Z" title="4/5/2019, 9:50:53 PM">2019-04-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-04-05T13:50:53.000Z" title="4/5/2019, 9:50:53 PM">2019-04-05</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">10 minutes read (About 1573 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/twists.html">代码</a></h1><div class="content"><h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><h3 id="整形值"><a href="#整形值" class="headerlink" title="整形值"></a>整形值</h3><h4 id="无额外空交换"><a href="#无额外空交换" class="headerlink" title="无额外空交换"></a>无额外空交换</h4><ul>
<li><p>异或</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a^b</span><br><span class="line">b = a^b</span><br><span class="line">a = a^b</span><br></pre></td></tr></table></figure>
</li>
<li><p>加减</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a+b</span><br><span class="line">b = a-b</span><br><span class="line">a = a-b</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<ul>
<li>当然，对某些语言可以同时交换，如：python</li>
</ul>
</blockquote>
<h4 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h4><ul>
<li>向下取整：<code>mid = (left + right) // 2</code></li>
<li>向上取整：<code>mid = (left + right + 1) // 2</code></li>
</ul>
<h4 id="运算溢出"><a href="#运算溢出" class="headerlink" title="运算溢出"></a>运算溢出</h4><ul>
<li>正数：边界值<code>1</code>、<code>0x7FFF FFFF</code>、<code>0xFFFF FFFF</code></li>
<li>负数：边界值<code>0x8000 0000</code>、<code>0xFFFF FFFF</code></li>
<li>忽略语言特性：如<code>long</code>类型常量不加<code>LL</code></li>
</ul>
<h4 id="初值选取"><a href="#初值选取" class="headerlink" title="初值选取"></a>初值选取</h4><h4 id="0值未考虑"><a href="#0值未考虑" class="headerlink" title="0值未考虑"></a>0值未考虑</h4><h3 id="浮点值"><a href="#浮点值" class="headerlink" title="浮点值"></a>浮点值</h3><ul>
<li><p>浮点取整：尽量避免混用使用向上取整、向下取整，容易混淆</p>
</li>
<li><p>浮点型相等比较：不应使用<code>==</code>，应该使用相差<code>&lt;</code>某常数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a, b = <span class="number">1.11111</span>, <span class="number">1.11111111</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">abs</span>(a - b) &lt; <span class="number">0.00001</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;equal&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><ul>
<li><p>常用初值</p>
<ul>
<li>数值型：<code>0</code>、<code>-1</code>、<code>sys.maxsize</code>、<code>float(&#39;inf&#39;)</code></li>
<li>字符串型：<code>&quot;&quot;</code></li>
<li>迭代过程中可能取值：输出列表首个元素</li>
</ul>
</li>
<li><p>判断条件</p>
<ul>
<li>是否为初值</li>
<li>是否越界</li>
</ul>
</li>
<li><p>对比迭代技巧</p>
<ul>
<li>从左至右、从右至左分别遍历</li>
<li>原始列表、排序后列表分别遍历</li>
</ul>
</li>
<li><p>边界条件限制</p>
<ul>
<li>判断语句中：先列出边界条件，利用<strong>短路求值</strong>简化代码</li>
</ul>
</li>
</ul>
<h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><ul>
<li><p>迭代操作注意事项</p>
<ul>
<li>保证退出循环</li>
<li>所有值均被检验</li>
<li>数据处理、移动指针的顺序</li>
</ul>
</li>
<li><p>相向双指针：两指针均向中间靠拢不断缩小搜索空间</p>
<ul>
<li>明确切片范围：是否包括端点，并尽量保持不变</li>
<li>据此明确搜索空间范围，则搜索空间为空时结束循环</li>
</ul>
</li>
<li><p>滑动窗口：两指针同时向一侧移动，检验窗口内切片</p>
<ul>
<li>分类<ul>
<li>固定间隔双指针</li>
<li>不同条件移动双指针</li>
</ul>
</li>
<li>示例</li>
</ul>
</li>
<li><p>快慢指针：两指针同时迭代、但运动速度不同</p>
<ul>
<li>示例<ul>
<li>判断单链表是否成环</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="端点利用"><a href="#端点利用" class="headerlink" title="端点利用"></a>端点利用</h4><ul>
<li><p>两端限位器：在数据端点添加<strong>标记</strong>数据，便于</p>
<ul>
<li>指示“指针”已经到达数据端点</li>
<li>简化特殊情况代码<ul>
<li>将循环中的判断条件合并</li>
<li>端点标记数据符合一般情况，无需特殊处理</li>
</ul>
</li>
<li>示例<ul>
<li>数组末尾添加查找键（查询问题）：在顺序查找中可以
将判断数组越界、查找键比较合并</li>
</ul>
</li>
</ul>
</li>
<li><p>末端点为空闲位置：存储有效值</p>
<ul>
<li>队列、栈插入元素：末端点处为空闲位置，可直接使用</li>
<li>数组迭代比较：末端点处存储有效值，先比较再更新指针</li>
</ul>
</li>
<li><p>末端点为非空闲位置</p>
<ul>
<li>队列、栈：可以直接使用其末尾元素作为上次添加的元素，
简化代码</li>
</ul>
</li>
</ul>
<h4 id="链表特性"><a href="#链表特性" class="headerlink" title="链表特性"></a>链表特性</h4><ul>
<li><p>头指针/节点：添加链表头，保证特殊情况链表正常工作</p>
<ul>
<li>示例<ul>
<li>删除只包含一个元素的链表</li>
</ul>
</li>
</ul>
</li>
<li><p>自设外部指针</p>
<ul>
<li><p>使用时<strong>注意有时会改变内部节点值</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 修改链表内节点值</span><br><span class="line">outer.<span class="built_in">next</span>.val = <span class="number">4</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="HashXXX"><a href="#HashXXX" class="headerlink" title="HashXXX"></a>HashXXX</h3><ul>
<li><p>hash数据结构查询是常数时间，非常合适缓冲记录结果</p>
<ul>
<li>HashSet：常数时间判断元素存在性</li>
<li>HashDict：键元素、值元素出现次数，记录次数</li>
</ul>
</li>
<li><p>特殊、常用键</p>
<ul>
<li>有重复元素：有序tuple、字符串</li>
<li>无重复元素：frozen set</li>
</ul>
</li>
</ul>
<h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li><p>注意运算符优先级</p>
</li>
<li><p><code>=</code>结合不等号</p>
<ul>
<li>同时使用<code>&lt;=</code>、<code>&gt;=</code>，容易造成死循环、遗漏等</li>
<li>尽量只使用<code>&gt;=</code>号，不再使用<code>&lt;=</code>号</li>
</ul>
</li>
</ul>
<h3 id="递归终止条件"><a href="#递归终止条件" class="headerlink" title="递归终止条件"></a>递归终止条件</h3><p>递归终止条件主要有两种设计方案</p>
<ul>
<li><p>最后元素：判断元素是否是最后元素，终止递归调用</p>
</li>
<li><p>空（无效）元素：判断元素是空（无效）元素，终止递归调用</p>
<ul>
<li>需要确保最终能够进入该分支，而不是停止在最后一步</li>
</ul>
</li>
</ul>
<h2 id="预处理方法"><a href="#预处理方法" class="headerlink" title="预处理方法"></a>预处理方法</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul>
<li><strong>预排序</strong>是简化问题的好方法</li>
</ul>
<h4 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h4><ul>
<li>缩小搜索空间：按特征排序后，根据该特征是否满足条件
即可缩小搜索空间</li>
</ul>
<h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><ul>
<li>组合后剔除重复：可重复组合排序后唯一，方便剔除重复元素</li>
<li>组合前保证唯一：对组合候选集“预排序”，保证取用元素位序
不减（可重复）、单增（不可重复）<ul>
<li>相当于提前对结果排序，保证得到组合结果唯一</li>
<li>“预排序”指候选集中顺序有意义，无需真正排序</li>
</ul>
</li>
</ul>
<h2 id="特殊测试用例"><a href="#特殊测试用例" class="headerlink" title="特殊测试用例"></a>特殊测试用例</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul>
<li>空字符串</li>
<li>长度1字符串、长度2字符串</li>
<li>字符相同字符串</li>
</ul>
<h3 id="普通列表"><a href="#普通列表" class="headerlink" title="普通列表"></a>普通列表</h3><ul>
<li><p>空列表</p>
<ul>
<li>若在循环外即已取值，应该提前判断列表是否空</li>
</ul>
</li>
<li><p>长度1列表、长度2列表</p>
</li>
<li><p>元素相同列表</p>
</li>
</ul>
<h3 id="树、二叉树"><a href="#树、二叉树" class="headerlink" title="树、二叉树"></a>树、二叉树</h3><ul>
<li><p>空树、只有根元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node.val = value;</span><br><span class="line">	# 未考虑空树</span><br></pre></td></tr></table></figure>
</li>
<li><p>只有左子树、右子树</p>
</li>
</ul>
<h3 id="文件边界条件"><a href="#文件边界条件" class="headerlink" title="文件边界条件"></a>文件边界条件</h3><ul>
<li>首个字符</li>
<li>最末字符、倒数第二个字符</li>
</ul>
<h2 id="代码优化考量"><a href="#代码优化考量" class="headerlink" title="代码优化考量"></a>代码优化考量</h2><ul>
<li>保持程序设计风格：把经常使用的工具性代码编辑成已验证</li>
<li>用规范的格式处理、保存数据</li>
<li>区分代码与数据：与代码无关的数据应该尽可能区分开来，尽量
把数据保存在常量数组中</li>
</ul>
<h3 id="代码执行速度"><a href="#代码执行速度" class="headerlink" title="代码执行速度"></a>代码执行速度</h3><ul>
<li>输入输出方式过慢：<code>cin</code>等高级输入、输出方式比较慢</li>
</ul>
<h3 id="程序结构优化"><a href="#程序结构优化" class="headerlink" title="程序结构优化"></a>程序结构优化</h3><ul>
<li>栈溢出：数组等大局部变量保存到栈，少量递归即会发生栈溢出</li>
</ul>
<h3 id="输入、输出"><a href="#输入、输出" class="headerlink" title="输入、输出"></a>输入、输出</h3><p>将输入、输出流重定向到文件中，避免频繁测试时频繁输入</p>
<ul>
<li>输入放在<code>in.txt</code>文件中</li>
<li>输出到<code>out.txt</code>中</li>
<li>输出执行时间</li>
</ul>
<h4 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SUBMIT</span></span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="comment">// input data</span></span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">	<span class="comment">// output</span></span><br><span class="line"><span class="keyword">long</span> _begin_time = <span class="built_in">clock</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// put code here</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SUBMIT</span></span><br><span class="line"><span class="keyword">long</span> _end_time = <span class="built_in">clock</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;time = %ld ms\n&quot;</span>, _end_time - begin_time);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">sys.stdin = <span class="built_in">open</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">sys.stdout = <span class="built_in">open</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">__tstart = time.time()</span><br><span class="line"></span><br><span class="line"> <span class="comment"># code here</span></span><br><span class="line"></span><br><span class="line">__trange = time.time() - __tstart</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;time used: %f&quot;</span> % __trange)</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-04T17:01:03.000Z" title="4/5/2019, 1:01:03 AM">2019-04-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-04-04T17:01:03.000Z" title="4/5/2019, 1:01:03 AM">2019-04-05</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Problem/">Problem</a></span><span class="level-item">10 minutes read (About 1521 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Problem/game_theory.html">博弈论</a></h1><div class="content"><h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><h2 id="约瑟夫斯问题"><a href="#约瑟夫斯问题" class="headerlink" title="约瑟夫斯问题"></a>约瑟夫斯问题</h2><p>n个人围成圈编号{0..n-1}，从1号开始每次消去第m个人直到最后一个
人，计算最后人编号$J(n)$。</p>
<h3 id="减1法"><a href="#减1法" class="headerlink" title="减1法"></a>减1法</h3><p>考虑每次消去1人后剩余人的编号情况</p>
<ul>
<li><p>还剩k人时，消去1人后，以下个人编号为0开始，将剩余人重新
编号，得到每个人在剩k-1人时的编号</p>
</li>
<li><p>相较于剩k人时，剩k-1人时每个人编号都减少m，即每个人在剩
k人时编号满足</p>
<script type="math/tex; mode=display">J_k = (J_{k-1} + m) \% k</script></li>
<li><p>考虑只剩1人时，其编号为0，则可以递推求解</p>
</li>
</ul>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Joseph_1(n, m):</span><br><span class="line">	<span class="comment">// 减1法求解Joseph问题</span></span><br><span class="line">	<span class="comment">// 输入：人数n、消去间隔m</span></span><br><span class="line">	<span class="comment">// 输出：最后留下者编号</span></span><br><span class="line">	j_n = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> k from <span class="number">2</span> to n:</span><br><span class="line">		j_n = (j_n + m) % k</span><br></pre></td></tr></table></figure>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>算法效率<ul>
<li>时间效率$\in O(n)$</li>
</ul>
</li>
</ul>
<h3 id="减常因子"><a href="#减常因子" class="headerlink" title="减常因子"></a>减常因子</h3><p>剩余人数$k &gt;= m$时考虑所有人都报数一次后剩余人的编号变化情况</p>
<ul>
<li><p>还剩k人时，报数一圈后消去<code>k//m</code>人，以最后被消去人的下个人
编号为0开始，将剩余人重新编号，得到剩<code>k-k/m</code>人时的编号</p>
</li>
<li><p>相较于剩k人时，剩<code>k-k//m</code>人时每个人编号满足</p>
<script type="math/tex; mode=display">\begin{align*}
J_k & = \left \{ \begin{array}{l}
   J_{k - d} + d * m, & J_{k - d} < n\%m \\
   J_{k - d} // (m-1) * m + (J_{k - d} - n\%m)
       \% (m - 1), & J_{k - d} > n\%m
\end{array} \right. \\
& = \left \{ \begin{array}{l}
   s + n, & s < 0 \\
   s + s // (m-1), & s >= 0
\end{array} \right.
\end{align*}</script><blockquote>
<ul>
<li>$d = k // m$</li>
<li>$s = J_{k - d} - n\%m$</li>
</ul>
</blockquote>
</li>
<li><p>$k &lt; m$时，使用减1法计算</p>
<ul>
<li>m很大时，以$k &lt; m$作为调用减1法很容易使得递归超出
最大值</li>
<li>另外$m &lt; k &lt;= d * m$时，每轮也不过消去$d$个人，而
递推式复杂许多、需要递归调用</li>
<li>所以具体代码实现中应该选择较大的$d$值，如5</li>
</ul>
</li>
</ul>
<h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Joseph_factor(n, m):</span><br><span class="line">	<span class="comment">// 减常因子法求解Joseph问题</span></span><br><span class="line">	<span class="comment">// 输入：人数n、消去间隔m</span></span><br><span class="line">	<span class="comment">// 输出：最后留下者编号</span></span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">5</span> * m:</span><br><span class="line">		j_n = <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> k from <span class="number">2</span> to n</span><br><span class="line">			j_n = (j_n + m) % k</span><br><span class="line">		<span class="keyword">return</span> j_n</span><br><span class="line"></span><br><span class="line">	s = Joseph(n-n/m, m) - k % m</span><br><span class="line">	<span class="keyword">if</span> s &lt; <span class="number">0</span>:</span><br><span class="line">		retrun s + n</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> s + s <span class="comment">// (m-1)</span></span><br><span class="line">	<span class="keyword">return</span> j_n</span><br></pre></td></tr></table></figure>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>算法效率</p>
<ul>
<li>时间效率$\in O(log n) + m$</li>
</ul>
</li>
<li><p>特别的，对$m=2$时</p>
<ul>
<li>$n=2k$为偶数时，$J(2k)=2J(k)-1$</li>
<li>$n=2k+1$为奇数时，$J(2k+1)=2J(k)+1$</li>
</ul>
</li>
</ul>
<h3 id="任意第k个"><a href="#任意第k个" class="headerlink" title="任意第k个"></a>任意第k个</h3><ul>
<li><p>考虑报数不重置，则第k个被消去的人报数为$k * m - 1$</p>
</li>
<li><p>对报数为$p = k * m + a, 0 \leq a &lt; m$的人</p>
<ul>
<li><p>此时已经有k个人被消去，剩余n-k个人</p>
</li>
<li><p>则经过$n - k$个剩余人报数之后，该人才继续报数，则
其下次报数为$q = p + n - k = n + k*(m-1) + a$</p>
</li>
</ul>
</li>
<li><p>若该人报数$p$时未被消去，则$a \neq m-1$，则可以得到
$p = (q - n) // (m-1) * m +  (q-n) \% (m-1)$</p>
</li>
</ul>
<h4 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Joseph_k(n, m, k):</span><br><span class="line">	<span class="comment">// 计算Joseph问题中第k个被消去人编号</span></span><br><span class="line">	<span class="comment">// 输入：人数n、间隔m、被消去次序k</span></span><br><span class="line">	<span class="comment">// 输出：第k个被消去人编号</span></span><br><span class="line">	j_k = k*m - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> j_k &gt;= n:</span><br><span class="line">		j_k = (j_k-n) <span class="comment">// (m-1) * m - (j_k-n)%(m-1)</span></span><br><span class="line">	<span class="keyword">return</span> j_k</span><br></pre></td></tr></table></figure>
<h4 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h4><ul>
<li><p>算法效率</p>
<ul>
<li>时间效率$\in O(log n)$</li>
</ul>
</li>
<li><p>特别的，m=2时对n做一次<strong>向左循环移位</strong>就是最后者编号</p>
</li>
</ul>
<h2 id="双人游戏"><a href="#双人游戏" class="headerlink" title="双人游戏"></a>双人游戏</h2><ul>
<li>双人游戏中往往涉及两个概念<ul>
<li><em>state</em>：状态，当前游戏状态、数据</li>
<li><em>move</em>：走子，游戏中所有可能发生的状态改变</li>
</ul>
</li>
<li>状态、走子彼此之间相互“调用”<ul>
<li>状态调用走子<strong>转化</strong>为下个状态</li>
<li>走子调用状态<strong>评价</strong>当前状态</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">make_move(state, move):</span><br><span class="line">	<span class="keyword">switch</span> move:</span><br><span class="line">		<span class="keyword">case</span> move_1:</span><br><span class="line">			state = move_1(state)</span><br><span class="line">			evaluate_state(state)</span><br><span class="line">		...other cases...</span><br><span class="line"></span><br><span class="line">evaluate_state(state):</span><br><span class="line">	<span class="keyword">switch</span> state:</span><br><span class="line">		<span class="keyword">case</span> state_1:</span><br><span class="line">			make_move(state, move_1)</span><br><span class="line">		...other cases...</span><br><span class="line">	end game</span><br></pre></td></tr></table></figure>
<h3 id="拈游戏"><a href="#拈游戏" class="headerlink" title="拈游戏"></a>拈游戏</h3><p>同样局面，每个玩家都有同样可选走法，每种步数有限的走法都能
形成游戏的一个较小实例，最后能移动的玩家就是胜者。</p>
<ul>
<li>拈游戏（单堆版）：只有一堆棋子n个，两个玩家轮流拿走最少
1个，最多m个棋子</li>
<li>拈游戏（多堆版）：有I堆棋子，每堆棋子个数分别为
${n_1,\cdots,n_I}$，可以从任意一堆棋子中拿走任意允许数量
棋子，甚至拿走全部一堆</li>
</ul>
<h4 id="减可变规模算法"><a href="#减可变规模算法" class="headerlink" title="减可变规模算法"></a>减可变规模算法</h4><h5 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h5><p>（单堆）从较小的n开始考虑胜负（标准流程）</p>
<ul>
<li>n=0：下个人失败</li>
<li>1&lt;=n&lt;=m：下个人胜利（可以拿走全部）</li>
<li>n=m+1：下个人失败（无论拿走几个，对方符合1&lt;=n&lt;=m
胜利条件）</li>
<li>数学归纳法可以证明：n=k(m+1)时为败局，其余为胜局</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个函数轮流递归调用</span></span><br><span class="line">find_good_move(coins):</span><br><span class="line">	<span class="comment">// 判断当前是否有成功步骤</span></span><br><span class="line">	<span class="comment">// 输入：棋子数目</span></span><br><span class="line">	<span class="comment">// 输出：成功策略或没有成功策略</span></span><br><span class="line">	<span class="keyword">for</span> taken=<span class="number">1</span> to limit <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span>(is_bad_position(coins-taken))</span><br><span class="line">			<span class="comment">// 对手没有成功策略</span></span><br><span class="line">			<span class="keyword">return</span> taken</span><br><span class="line">	<span class="keyword">return</span> NO_GOOD_MOVE</span><br><span class="line"></span><br><span class="line">is_bad_position(coins):</span><br><span class="line">	<span class="comment">// 判断当前是否是good position</span></span><br><span class="line">	<span class="comment">// 输入：棋子数量</span></span><br><span class="line">	<span class="comment">// 输出：是否有成功策略</span></span><br><span class="line">	<span class="keyword">if</span> (coins == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	<span class="keyword">return</span> find_good_move(coins) == NO_GOOD_MOVE</span><br><span class="line">		<span class="comment">// 没有成功策略</span></span><br></pre></td></tr></table></figure>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>堆为2时，需要对两堆是否相同分别考虑</p>
</li>
<li><p>对更一般的I堆时</p>
<ul>
<li>对每堆数量的位串计算<em>二进制数位和</em></li>
<li>结果中包含至少一个1则对下个人为胜局，全为0则为负局</li>
<li><p>则玩家下步要拿走的棋子数量要使得位串二进制数位和全0
，则对方陷入负局</p>
</li>
<li><h1 id="todo又是二进制？？？和约瑟夫斯问题一样了"><a href="#todo又是二进制？？？和约瑟夫斯问题一样了" class="headerlink" title="todo又是二进制？？？和约瑟夫斯问题一样了"></a>todo又是二进制？？？和约瑟夫斯问题一样了</h1></li>
<li>但是这里没有涉及最多能拿几个啊，不一定能够成功拿到
使拈和全为0啊</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>二进制数位和（拈和）：每位求和并忽略进位（奇或）</li>
</ul>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-24T01:03:52.000Z" title="3/24/2019, 9:03:52 AM">2019-03-24</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-03-24T01:03:52.000Z" title="3/24/2019, 9:03:52 AM">2019-03-24</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Data-Structure/">Data Structure</a></span><span class="level-item">15 minutes read (About 2182 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Data-Structure/graphundi_specials.html">无向图衍生</a></h1><div class="content"><h2 id="Bipartite-Graph"><a href="#Bipartite-Graph" class="headerlink" title="Bipartite Graph"></a>Bipartite Graph</h2><p>二分图：所有顶点可以分为两个不相交集合U、V，两个集合大小不定
相等，但每条边都连接两个集合中各一顶点</p>
<ul>
<li><p>可以证明：<strong>当且仅当</strong>图中不存在奇数长度回路时，为二分图</p>
</li>
<li><p>二分图中顶点可以可以染成两种颜色，使得每条边两头顶点颜色
不同</p>
</li>
<li><p>矩阵存储二分图时，因为U、V内部节点之间无边，大部分场景
只需要$|V| * |U|$的矩阵（对有序、加权适用）</p>
</li>
<li><p>性质</p>
<ul>
<li>二分图匹配意义：同类型（集合内部）之间没有连接</li>
</ul>
</li>
</ul>
<h3 id="Augmenting-Path"><a href="#Augmenting-Path" class="headerlink" title="Augmenting-Path"></a>Augmenting-Path</h3><p>（二分图）增益路径：对合法匹配M，简单<strong>路径两端</strong>连接V、U中
的自由顶点，路径中<strong>边</strong>交替出现在$E-M, M$中，称M的增益路径</p>
<ul>
<li><p>增益路径长度总为奇数，为M中匹配两倍+1</p>
</li>
<li><p>则路径中奇数边组成新的匹配，比M多一条边</p>
</li>
</ul>
<h3 id="增益路径-最大匹配证明"><a href="#增益路径-最大匹配证明" class="headerlink" title="增益路径-最大匹配证明"></a>增益路径-最大匹配证明</h3><p>当且仅当G中不存在M增益路径时，M为G最大匹配</p>
<p>必要性</p>
<ul>
<li>若M存在增益路径，则可以扩展M得到更多匹配，M不是最大匹配</li>
</ul>
<p>充分性</p>
<ul>
<li><p>若存在M无增益路径，但不为最大匹配，设$M{<em>}$是G中的最大
匹配，则$M{</em>}$中边至少比M中边数量大1，有
$|M^{<em>}| &gt; |M|, |M^{</em>} - M| &gt; |M - M^{*}|$</p>
</li>
<li><p>则两者对称差集为
$M \bigoplus M^{<em>} = (M - M^{</em>}) \cup (M^{*} - M)$</p>
</li>
<li><p>设$G^{‘} \subseteq G$为二者差集中所有边、点，根据匹配
定义，$G^{‘}$中任何<strong>单个点</strong>和$M, M^{*}$相连接不会超过
一条边</p>
</li>
<li><p>则$G^{‘}$中顶点连通度不大于2，其中连通分量为</p>
<ul>
<li><p>偶数长度回路，其中边交替属于
$|M^{<em>} - M|, |M - M^{</em>}|$，在两者中数量相同</p>
<ul>
<li><p>若不交替，则说明连续两条边在同个匹配中，有交点，
和匹配定义冲突</p>
</li>
<li><p>若不为偶数长度，同样的首、尾两条边在同一匹配中，
和匹配定义冲突</p>
</li>
</ul>
</li>
<li><p>交替路径（无环）</p>
<ul>
<li><p>因为$|M^{<em>} - M| &gt; |M - M^{</em>}|$，所以$G^{*}$中
不可能仅有回路</p>
</li>
<li><p>所以至少存在一条具有交替边路径，起点终点都是
$M^{*} - M$同一条边（如单边路径），M具有增益路径
，矛盾</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>最大匹配求解匈牙利算法实现详见<em>graph</em></li>
</ul>
</blockquote>
<h3 id="Konig-Theorem"><a href="#Konig-Theorem" class="headerlink" title="Konig Theorem"></a>Konig Theorem</h3><p>Konig定理：二分图中最大匹配数|M| = 最小点覆盖数|C|</p>
<ul>
<li><p>已经通过匈牙利算法求出最大匹配M</p>
</li>
<li><p>从集合V中<strong>每个未被匹配</strong>点开始，走一条<strong>类似</strong>增益路径
的交替路径，标记路径中的所有点</p>
<ul>
<li><p>只是因为已经找到了最大匹配，所以路径另外一端不可能
是自由顶点</p>
</li>
<li><p><strong>允许重复</strong>走过同一条边</p>
</li>
</ul>
</li>
<li><p>路径中V到U的均为非匹配边、U到V均为匹配边</p>
</li>
</ul>
<blockquote>
<ul>
<li>当然也可以从U的所有未匹配顶点开始</li>
</ul>
</blockquote>
<p>记集合V中中未被访问、U集合中已被访问的已匹配顶点点集为C，则
$顶点数目|C| = 最大匹配数 = 最小点覆盖数$
<img src="/imgs/bipartite_konig.png" alt="biparttite_konig"></p>
<ul>
<li><p>因为每个点都是M中某边端点，且V中已标记同U中未标记、V中
未标记顶点同U中已标记一一对应，为匹配边两端点，所以</p>
<script type="math/tex; mode=display">
顶点数 = V中未被访问 + U中已访问 = \\
V中未访问 + V中已访问 = （最大）匹配数</script></li>
<li><p>在最大匹配情况下，所有边至少有一个端点为已匹配点</p>
<ul>
<li><p>对于匹配边，肯定被C中顶点覆盖</p>
</li>
<li><p>若非匹配顶点在V中，则一定在某个路径中被访问，则被U
中某个已访问匹配顶点覆盖</p>
</li>
<li><p>若非匹配顶点在U中，则被V中未访问顶点覆盖的</p>
</li>
<li><p>或者说不存在这样的边：其左端点没有标记、而右端点有
标记</p>
<ul>
<li>匹配边肯定不是起点，不可能</li>
<li>非匹配边，右端有标记则能直接访问左端，标记左端
（通样广度优先搜索遍历所有邻接有顶点点）</li>
</ul>
</li>
</ul>
</li>
<li><p>而要覆盖匹配边需要至少$|M|$个点，所以$|M|$是最小覆盖点数</p>
</li>
</ul>
<h4 id="推论-1"><a href="#推论-1" class="headerlink" title="推论 1"></a>推论 1</h4><p>二分图中：最小边覆盖|W| = 图中顶点数|V| - 最小点覆盖数|C|</p>
<script type="math/tex; mode=display">
|W| = |V| - |M| = |V| - |C|</script><h2 id="Ordered-Bipartite-Graph"><a href="#Ordered-Bipartite-Graph" class="headerlink" title="Ordered Bipartite Graph"></a>Ordered Bipartite Graph</h2><p>有序二分图：以同一顶点作为端点的边的有优先级（独立于其他点）</p>
<ul>
<li>即：V中顶点对U中顶点都有优先级排序，U中顶点对V中顶点也有
优先级排序</li>
</ul>
<h3 id="Marriage-Matching"><a href="#Marriage-Matching" class="headerlink" title="Marriage Matching"></a>Marriage Matching</h3><p>婚姻匹配问题可以使用特殊的<strong>完全有序二分图</strong>代表</p>
<ul>
<li><p>集合V（男士集合）、U（女士集合）大小相同为n</p>
</li>
<li><p>任意男士、女士都有之间都有边连接，即任意男士、女士都需要
给出所有女士、男士优先级</p>
</li>
</ul>
<h4 id="存储、表示方法"><a href="#存储、表示方法" class="headerlink" title="存储、表示方法"></a>存储、表示方法</h4><ul>
<li><p>优先列表：各男士、女士按照异性优先级排序列表，共2n个</p>
<ul>
<li>对实现匹配算法而言效率更高</li>
</ul>
</li>
<li><p>等级矩阵：男士、女士为分别作为矩阵行、列，矩阵元素$P_ij$
为男士$m_i$对女士$w_j$优先级排序、女士$w_j$对男士$m_i$
优先级排序元组</p>
<ul>
<li>更容易看出集合元素匹配</li>
<li>只需要$n * n$阶方阵</li>
</ul>
</li>
</ul>
<h4 id="Stable-Marriage-Matching"><a href="#Stable-Marriage-Matching" class="headerlink" title="Stable Marriage Matching"></a>Stable Marriage Matching</h4><p>对包含n个对的婚姻匹配M</p>
<ul>
<li><p><em>Block Pair</em>：受阻对，满足$m \in V, w \in U$，而$(m, w)$
更倾向于对方，而不是匹配M中对象</p>
</li>
<li><p><em>Stable Marriage Matching</em>：稳定婚姻匹配，不存在受阻对的
婚姻匹配</p>
</li>
</ul>
<h4 id="稳定婚姻存在性"><a href="#稳定婚姻存在性" class="headerlink" title="稳定婚姻存在性"></a>稳定婚姻存在性</h4><p>V中存在自由男士时，任选<em>求婚</em>、<em>回应</em>之一执行，直至不存在
自由男士</p>
<blockquote>
<ul>
<li><p>求婚：自由男士m向女士w求婚，w为其优先级最大、之前未拒绝
  过其女士（可以是已匹配）</p>
</li>
<li><p>回应：若女士w自由则接受男士m求婚，与之配对；女士w不自由
  则把m同当前配偶匹配，选择其中优先级较高者</p>
</li>
</ul>
</blockquote>
<p>当不存在自由男士时，得到匹配M就是稳定匹配</p>
<ul>
<li><p>若M是不稳定的，设存在受阻对$(m, w)$</p>
</li>
<li><p>因为m按照降序求婚，所以m必然在某次迭代向w求过婚，则w当前
对偶必然比m拥有更高优先级，和受阻对假设矛盾</p>
</li>
</ul>
<blockquote>
<ul>
<li>稳定婚姻问题求解算法参见<em>graph</em></li>
</ul>
</blockquote>
<h2 id="Weighted-Bipartite-Graph"><a href="#Weighted-Bipartite-Graph" class="headerlink" title="Weighted Bipartite Graph"></a>Weighted Bipartite Graph</h2><p>加权二分图；每条边都有权重的二分图</p>
<h3 id="Distribution-Problem"><a href="#Distribution-Problem" class="headerlink" title="Distribution Problem"></a>Distribution Problem</h3><p>分配问题可以使用特殊的<strong>完全加权二分图</strong>代表</p>
<ul>
<li><p>集合V（人员集合）、U（任务集合）大小相同为n</p>
</li>
<li><p>任意人员、任务有边相连，人员、任务内部之间无边</p>
</li>
</ul>
<h4 id="存储方法"><a href="#存储方法" class="headerlink" title="存储方法"></a>存储方法</h4><ul>
<li><p>使用$n * n$阶成本矩阵C存储，其元素$c_{ij}$表示人员$i$
完成任务$j$的成本</p>
</li>
<li><p>则问题转化为：从成本矩阵中每行分别选择元素，且元素不属于
同一行，使得和最小</p>
</li>
</ul>
<blockquote>
<ul>
<li>（最小成本）分配问题算法参见<em>graph</em></li>
</ul>
</blockquote>
<h2 id="Biconnected-Graph"><a href="#Biconnected-Graph" class="headerlink" title="Biconnected Graph"></a><em>Biconnected Graph</em></h2><blockquote>
<ul>
<li><p><em>articulation point</em>：关节点，删除顶点v、与v相连的各边
  之后，将图一个连通分量分割成 两个、两个以上连通分量，则
  称顶点v为图的一个关节点</p>
</li>
<li><p><em>biconnected graph</em>：重连通图，没有关节点的连通图</p>
</li>
</ul>
</blockquote>
<ul>
<li><p>重连通图中任意一对结点之间至少存在两条路径</p>
</li>
<li><p>若在重连通图中至少删除k个顶点才能破坏图的连通性，则称图
的<strong>连通度</strong>为k</p>
</li>
</ul>
<h3 id="求解关节点"><a href="#求解关节点" class="headerlink" title="求解关节点"></a>求解关节点</h3><p>利用DFS可以求出图的关节点，判断图是否是重连通的，对DFS生成树</p>
<ul>
<li>生成树有两棵及以上子树，则根节点为关节点<ul>
<li>因为不同子树之间不存在连通不同子树顶点的边</li>
</ul>
</li>
<li>非叶子顶点v<strong>某棵子树</strong>中没有指向v前驱的回边，则v为关节点</li>
</ul>
<blockquote>
<ul>
<li>算法参见<em>algorithm/problems/graph</em></li>
</ul>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-23T15:43:02.000Z" title="3/23/2019, 11:43:02 PM">2019-03-23</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-03-23T15:43:02.000Z" title="3/23/2019, 11:43:02 PM">2019-03-23</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Data-Structure/">Data Structure</a></span><span class="level-item">4 minutes read (About 670 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Data-Structure/graph_set.html">无向图</a></h1><div class="content"><h2 id="点集"><a href="#点集" class="headerlink" title="点集"></a>点集</h2><h3 id="点覆盖集"><a href="#点覆盖集" class="headerlink" title="点覆盖集"></a>点覆盖集</h3><ul>
<li><p><em>Vertex Covering Set</em>：点覆盖（集），顶点子集$S \subseteq V$
，满足每条边至少有一个顶点在集合中</p>
</li>
<li><p><em>Minimum Vertex Covering Set</em>：最小顶点覆盖集，最少顶点的
点覆盖集</p>
</li>
</ul>
<h3 id="点支配集"><a href="#点支配集" class="headerlink" title="点支配集"></a>点支配集</h3><ul>
<li><p><em>Vertex Dominating Set</em>：点支配集，顶点子集$D \subseteq V$
，满足$\forall u \in V-D, \exists v \in D, (u, v) \in E$</p>
<ul>
<li>即V中顶点要么是D中元素，要么同D中一个顶点相邻</li>
</ul>
</li>
<li><p><em>Minimum Vertext Dominating Set</em>：最小支配集，顶点数目
最小支配集</p>
</li>
<li><p>极小支配集：真子集都不是支配集的支配集</p>
</li>
</ul>
<h3 id="点独立集"><a href="#点独立集" class="headerlink" title="点独立集"></a>点独立集</h3><ul>
<li><p><em>Vertext Independent Set</em>：（点）独立集，顶点子集
$I \subseteq V$，满足I中任意两顶点不相邻</p>
</li>
<li><p><em>Maximum Vertext Independent Set</em>：最大独立点集，顶点数
最多的独立点集</p>
</li>
<li><p>极大点独立集：超集都不是独立集的独立集</p>
</li>
</ul>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><h4 id="Thoerem-1"><a href="#Thoerem-1" class="headerlink" title="Thoerem 1"></a>Thoerem 1</h4><p>若无向图$G(V, E)$中无孤立顶点，则G的极大点独立集都是G的极小
支配集（反之不成立）</p>
<h4 id="Thoerem-2"><a href="#Thoerem-2" class="headerlink" title="Thoerem 2"></a>Thoerem 2</h4><p>一个独立集是极大独立集，当前且仅当其为支配集</p>
<h4 id="Thoerem-3"><a href="#Thoerem-3" class="headerlink" title="Thoerem 3"></a>Thoerem 3</h4><p>若无向图$G=(V, E)$中无孤立点，顶点集$C \subseteq V$为G点覆盖
，当且仅当$V - C$是G的点独立集</p>
<h2 id="边集"><a href="#边集" class="headerlink" title="边集"></a>边集</h2><h3 id="边覆盖"><a href="#边覆盖" class="headerlink" title="边覆盖"></a>边覆盖</h3><ul>
<li><p><em>Edge Covering Set</em>：边覆盖（集），边子集$W \subseteq E$，
满足$\forall v \in V, \exists e \in W$，使得v是e端点</p>
<ul>
<li>即G中所有点都是便覆盖W的邻接顶点</li>
</ul>
</li>
<li><p><em>Minimum Edge Covering Set</em>：边数最少的边覆盖集</p>
</li>
<li><p>极小边覆盖集：任意真子集都不是边覆盖集的边覆盖</p>
</li>
</ul>
<h3 id="边独立集"><a href="#边独立集" class="headerlink" title="边独立集"></a>边独立集</h3><ul>
<li><p><em>Matching/Edge Indepdent Set</em>：匹配（边独立集），边子集
$I \subseteq E$，满足I中所有边没有公共顶点</p>
</li>
<li><p><em>Maximum (Cardinality) Matching</em>：最大（基数）匹配，包含
最多边的匹配</p>
</li>
<li><p>极大匹配：任意超集都不是匹配的匹配</p>
</li>
<li><p><em>Perfect Matching</em>：完美匹配，匹配所有点的最大匹配</p>
</li>
<li><p><em>Mate</em>：对偶，匹配中相互连接的一对顶点</p>
</li>
</ul>
<h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><h4 id="Thoerem-1-1"><a href="#Thoerem-1-1" class="headerlink" title="Thoerem 1"></a>Thoerem 1</h4><p>M为G一个最大匹配，对G中每个M未覆盖点v，选取一条与v关联边组成
集合N，则边集$W = M \cup N$为G中最小边覆盖</p>
<h4 id="Thoerem-2-1"><a href="#Thoerem-2-1" class="headerlink" title="Thoerem 2"></a>Thoerem 2</h4><p>若W为G最小边覆盖，其中每存在相邻边就移去其中一条，设移去边集
为N，则边集$M = W - N$为G中一个最大匹配</p>
<h4 id="Thoerem-3-1"><a href="#Thoerem-3-1" class="headerlink" title="Thoerem 3"></a>Thoerem 3</h4><p>最大匹配、最小边覆盖满足：$|M| + |W|= |V|$</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-23T11:23:37.000Z" title="3/23/2019, 7:23:37 PM">2019-03-23</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-02T10:07:44.000Z" title="8/2/2021, 6:07:44 PM">2021-08-02</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Data-Structure/">Data Structure</a></span><span class="level-item">3 minutes read (About 501 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Data-Structure/graph_derived.html">图衍生</a></h1><div class="content"><h2 id="度"><a href="#度" class="headerlink" title="度"></a>度</h2><h3 id="Laplacian矩阵"><a href="#Laplacian矩阵" class="headerlink" title="Laplacian矩阵"></a>Laplacian矩阵</h3><p>$L=D-A$：Laplacian矩阵，其中</p>
<ul>
<li>$A$：邻接矩阵</li>
<li>$D$：度矩阵（对角线为各个顶点度）</li>
</ul>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul>
<li>若$c$为图中各个节点权重，则$c^T L C$为各个节点与其
邻接节点差值平方和<ul>
<li>展开即可证明</li>
</ul>
</li>
</ul>
<h2 id="边数量"><a href="#边数量" class="headerlink" title="边数量"></a>边数量</h2><h3 id="Multigraph"><a href="#Multigraph" class="headerlink" title="Multigraph"></a>Multigraph</h3><p>多重图：含有平行边，即顶点之间边数大于1</p>
<ul>
<li>允许顶点通过边和自己相连</li>
</ul>
<h2 id="边权"><a href="#边权" class="headerlink" title="边权"></a>边权</h2><h3 id="欧几里得类型加权图"><a href="#欧几里得类型加权图" class="headerlink" title="欧几里得类型加权图"></a>欧几里得类型加权图</h3><p>欧几里得类型加权图：权重满足欧式几何条件</p>
<ul>
<li><p>三角不等式：任意3点$i,j,k, d<em>{ij} \leqslant d</em>{ik}+d{kj}</p>
</li>
<li><p>对称性：任意两个点$i,j, d_{ij}=d{ji}$</p>
</li>
</ul>
<h2 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h2><h3 id="Transitive-closure"><a href="#Transitive-closure" class="headerlink" title="Transitive closure"></a><em>Transitive closure</em></h3><p>传递闭包：表示所有节点两两直接连通性的n阶布尔矩阵T</p>
<ul>
<li>$T={t<em>{ij}}$，若节点i到节点j直接存在有效（长度&gt;0）有向
路径，则$t</em>{ij}=1$，否则为0</li>
</ul>
<h3 id="Hamiltonian-Circuit"><a href="#Hamiltonian-Circuit" class="headerlink" title="Hamiltonian Circuit"></a>Hamiltonian Circuit</h3><p>哈密顿回路：对图每个顶点只穿过一次的回路</p>
<ul>
<li><p>可以理解为：n+1个相邻顶点的一个排列，其中首尾顶点相同，
而其余顶点互不相同</p>
<ul>
<li>因为是回路，可以不失一般性的假定回路开始、结束于相同
顶点，这样不影响回路性质</li>
</ul>
</li>
</ul>
<h3 id="Eular-Circuit"><a href="#Eular-Circuit" class="headerlink" title="Eular Circuit"></a>Eular Circuit</h3><p>欧拉回路：将给定图每条边都只遍历一次的回路</p>
<ul>
<li><p>无向图：当且仅当连通多重图的每个顶点连通度都为偶数时，
才具有欧拉回路</p>
</li>
<li><p>有向图：当且仅当图中所有顶点是否出度、入度相等时，才存在
欧拉回路</p>
</li>
<li><p>在$\O(n^)$内解决问题</p>
</li>
</ul>
<h2 id="State-Space-Graph"><a href="#State-Space-Graph" class="headerlink" title="State-Space Graph"></a>State-Space Graph</h2><p>状态空间图：把问题化简为标准图问题</p>
<ul>
<li>顶点：表示问题可能状态</li>
<li>边：表示状态之间的可能转换</li>
<li>原问题转换为求初始状态到目标状态顶点路径问题</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-03-21T09:27:37.000Z" title="3/21/2019, 5:27:37 PM">2019-03-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-02T10:09:32.000Z" title="8/2/2021, 6:09:32 PM">2021-08-02</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/Data-Structure/">Data Structure</a></span><span class="level-item">10 minutes read (About 1498 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Algorithm/Data-Structure/linear_general.html">数组和广义表</a></h1><div class="content"><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><ul>
<li>数组、广义表可以看作是线性表的扩展：线性表中数据元素本身
也是抽象数据结构</li>
</ul>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a><em>Array</em></h2><p>对各维界分别为$b_i$的n维数组</p>
<ul>
<li><p>数组中含有$\prod_{i=1}^n b_i$个数据元素，每个元素都受n个
关系约束</p>
<ul>
<li>每个关系中，元素都有直接后继</li>
<li>就单个关系而言，这个n个关系仍然是线性关系</li>
</ul>
</li>
<li><p>n维数组可看作是线性表的推广，n=1时，数组退化为定长线性表</p>
<ul>
<li>和线性表一样，所有数据元素必须为同一数据类型</li>
</ul>
</li>
<li><p>数组一旦被定义，其维数、维界就不再改变</p>
<ul>
<li>除了初始化、销毁之外，数组只有存储、修改元素值的操作</li>
<li>采用顺序存储结构表示数组是自然的</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>几乎所有程序设计语言都把数组类型设定为固有类型</li>
</ul>
</blockquote>
<h3 id="顺序存储表示"><a href="#顺序存储表示" class="headerlink" title="顺序存储表示"></a>顺序存储表示</h3><ul>
<li><p>存储单元是一维结构，数组是多维结构，所有使用连续存储单元
存储数组的数据元素需要约定次序</p>
<ul>
<li>BASIC、PL/1、COBOL、PASCAL、C语言中，以行序作主序</li>
<li>FORTRAN中，以列序作主序</li>
</ul>
</li>
<li><p>数组元素存储地址</p>
<script type="math/tex; mode=display">\begin{align*}
LOC(j_1, j_2, \cdots, j_n) & = LOC(0, 0, \cdots, 0)
   + (\sum_{i=1}^{n-1} j_i (\prod_{k=i+1}^n b_k + j_n))L
& = LOC(0, 0, \cdots, 0) + \sum_{i=1}^n c_i_i
\end{align}</script><blockquote>
<ul>
<li>$c<em>n=L, c</em>{i-1} = b_ic_i$</li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	Elemtype * base;</span><br><span class="line">	<span class="keyword">int</span> dim;</span><br><span class="line">		<span class="comment">// 数组维数</span></span><br><span class="line">	<span class="keyword">int</span> * bounds;</span><br><span class="line">		<span class="comment">// 数组各维界（各维度长度）</span></span><br><span class="line">	<span class="keyword">int</span> * constants;</span><br><span class="line">		<span class="comment">// 数组各维度单位含有的数组元素数量，由`bounds`累乘</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="矩阵压缩"><a href="#矩阵压缩" class="headerlink" title="矩阵压缩"></a>矩阵压缩</h3><p>压缩存储：为多个值相同元只分配一个存储空间，对0元不分配空间</p>
<h4 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h4><p>特殊矩阵：值相同元素、0元素在矩阵的分布有一定规律，将其压缩
至一维数组中，并找到每个非零元在一维数组中的对应关系</p>
<ul>
<li>对称矩阵：为每对对称元分配一个存储空间<ul>
<li>一般以行序为主序存储其下三角（包括对角线）中的元</li>
</ul>
</li>
<li>上/下三角矩阵：类似对称矩阵只存储上/下三角中的元，附加
存储下/三角常数</li>
<li>对角矩阵：同样可以按照行、列、对角线优先压缩存储</li>
</ul>
<h4 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h4><p>稀疏矩阵：稀疏因子$\sigma = \frac t {mn} \leq 0.05$的矩阵</p>
<ul>
<li>使用三元组（非零元值、其所属的行列位置）表示非零元</li>
</ul>
<h5 id="三元组顺序表"><a href="#三元组顺序表" class="headerlink" title="三元组顺序表"></a>三元组顺序表</h5><p>三元组顺序表/有序双下标法：以顺序结构表示三元组表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	ElemType e;</span><br><span class="line">&#125;Triple;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	Triple data[MAXSIZE+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> mu, nu, tu;</span><br><span class="line">		<span class="comment">// 行、列、非零元数</span></span><br><span class="line">&#125;TSMatrix;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>data</code>域中非零元的三元组以行序为主序顺序排列，有利于进行
  依行顺序处理的矩阵运算</li>
</ul>
</blockquote>
<h5 id="行逻辑链接的顺序表"><a href="#行逻辑链接的顺序表" class="headerlink" title="行逻辑链接的顺序表"></a>行逻辑链接的顺序表</h5><p>行逻辑链接的顺序表：带行链接信息的三元组表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	Triple data[MAXSIZE+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> rpos[MAXRC+<span class="number">1</span>];</span><br><span class="line">		<span class="comment">// 各行首个非零元的位置表</span></span><br><span class="line">	<span class="keyword">int</span> mu, nu, tu;</span><br><span class="line">&#125;RLSMatrix;</span><br></pre></td></tr></table></figure>
<ul>
<li>为了便于随机存取任意行非零元，需要知道每行首个去非零元
在三元组表中的位置，即<code>rpos</code></li>
</ul>
<h5 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h5><p>十字链表：采用链式存储结构表示三元组的线性表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">		<span class="comment">// 该非零元行、列下标</span></span><br><span class="line">	ElemType e;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span>, *<span class="title">right</span>, *<span class="title">down</span>;</span></span><br><span class="line">		<span class="comment">// 该非零元所在行表、列表的后继链域</span></span><br><span class="line">&#125;OLNode, *OLink;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	OLink *rhead, *chead;</span><br><span class="line">		<span class="comment">// 行、列链表表头指针向量基址</span></span><br><span class="line">	<span class="keyword">int</span> mu, nu, tu;</span><br><span class="line">&#125;CrossList;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>同一行非零元通过<code>right</code>域链接成一个线性链表</li>
<li>同一列非零元通过<code>down</code>域链接成一个线性链表</li>
</ul>
</blockquote>
<ul>
<li>适合矩阵非零元个数、位置在操作过程中变化较大的情况</li>
</ul>
<h2 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a><em>Lists</em></h2><p>广义表/列表：线性表的推广</p>
<script type="math/tex; mode=display">
LS = (\alpha_1, \alpha_2, \cdots, \alpha_n)</script><blockquote>
<ul>
<li>$\alpha_i$：可以时单个元素，也可以是广义表，分别称为LS
  的原子、子表</li>
<li><em>head</em>：表头，LS非空时的首个元素$\alpha$</li>
<li><em>tail</em>：表尾，LS除表头外的其余元素组成的表，必然是列表</li>
</ul>
</blockquote>
<ul>
<li>列表是一个多层次结构：列表的元素可以是子表，子表元素
也可以是子表</li>
<li>列表可以为其他列表所共享</li>
<li>列表可以是一个递归的表：即列表自身作为其本身子表</li>
</ul>
<blockquote>
<ul>
<li>广义表长度：广义表中元素个数</li>
<li>广义表深度：广义表中最大括弧重数</li>
</ul>
</blockquote>
<h3 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><p>广义表中数据元素可以具有不同结构，难以用顺序存储结构表示，
通常采用链式存储结构</p>
<h4 id="头尾链表"><a href="#头尾链表" class="headerlink" title="头尾链表"></a>头尾链表</h4><ul>
<li>数据元素可能是原子、列表，因此需要两种结构的结点<ul>
<li>表节点：表示列表，包括：标志域、指示表头的指针域、
指示表尾的指针域</li>
<li>原子节点：表示原子，包括：标志域，值域</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span>ATOM, LIST&#125; ElemTag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span>&#123;</span></span><br><span class="line">	ElemTag tag;</span><br><span class="line">		<span class="comment">// 标志域，公用</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">		<span class="comment">// 原子节点、表节点联合部分</span></span><br><span class="line">		AtomType atom;</span><br><span class="line">			<span class="comment">// 值域，原子节点</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> *<span class="title">hp</span>, *<span class="title">tp</span>;</span></span><br><span class="line">				<span class="comment">// 两个指针域，表节点</span></span><br><span class="line">		&#125;ptr;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;*GList;</span><br></pre></td></tr></table></figure>
<ul>
<li>除空表的表头指针为空外，任何非空列表的表头指针均指向
表节点，且该表节点<ul>
<li><code>hp</code>指针域指向列表表头</li>
<li><code>tp</code>指针域指向列表表尾，除非表尾为空，否则指向表节点</li>
</ul>
</li>
<li>容易分清列表中原子、子表所属层次</li>
<li>最高层的表节点个数即为列表长度</li>
</ul>
<h4 id="扩展线性链表"><a href="#扩展线性链表" class="headerlink" title="扩展线性链表"></a>扩展线性链表</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>ATOM, LIST&#125; ElemTag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span>&#123;</span></span><br><span class="line">	ElemTag tag;</span><br><span class="line">	<span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">		AtomType atom;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> *<span class="title">hp</span>;</span></span><br><span class="line">		&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> *<span class="title">tp</span>;</span></span><br><span class="line">&#125;*GList;</span><br></pre></td></tr></table></figure>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/tags/Algorithm/page/2/">Previous</a></div><div class="pagination-next"><a href="/tags/Algorithm/page/4/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/tags/Algorithm/">1</a></li><li><a class="pagination-link" href="/tags/Algorithm/page/2/">2</a></li><li><a class="pagination-link is-current" href="/tags/Algorithm/page/3/">3</a></li><li><a class="pagination-link" href="/tags/Algorithm/page/4/">4</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">36</span></span></a><ul><li><a class="level is-mobile" href="/categories/Algorithm/Data-Structure/"><span class="level-start"><span class="level-item">Data Structure</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Heuristic/"><span class="level-start"><span class="level-item">Heuristic</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Issue/"><span class="level-start"><span class="level-item">Issue</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Problem/"><span class="level-start"><span class="level-item">Problem</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Specification/"><span class="level-start"><span class="level-item">Specification</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/C-C/"><span class="level-start"><span class="level-item">C/C++</span></span><span class="level-end"><span class="level-item tag">34</span></span></a><ul><li><a class="level is-mobile" href="/categories/C-C/Cppref/"><span class="level-start"><span class="level-item">Cppref</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/Cstd/"><span class="level-start"><span class="level-item">Cstd</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/MPI/"><span class="level-start"><span class="level-item">MPI</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/STL/"><span class="level-start"><span class="level-item">STL</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/CS/"><span class="level-start"><span class="level-item">CS</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/CS/Character/"><span class="level-start"><span class="level-item">Character</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Parallel/"><span class="level-start"><span class="level-item">Parallel</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Program-Design/"><span class="level-start"><span class="level-item">Program Design</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Storage/"><span class="level-start"><span class="level-item">Storage</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Daily-Life/"><span class="level-start"><span class="level-item">Daily Life</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/Daily-Life/Maxism/"><span class="level-start"><span class="level-item">Maxism</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Database/"><span class="level-start"><span class="level-item">Database</span></span><span class="level-end"><span class="level-item tag">27</span></span></a><ul><li><a class="level is-mobile" href="/categories/Database/Hadoop/"><span class="level-start"><span class="level-item">Hadoop</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Database/SQL-DB/"><span class="level-start"><span class="level-item">SQL DB</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Database/Spark/"><span class="level-start"><span class="level-item">Spark</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/Scala/"><span class="level-start"><span class="level-item">Scala</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">42</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Bash-Programming/"><span class="level-start"><span class="level-item">Bash Programming</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Configuration/"><span class="level-start"><span class="level-item">Configuration</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/File-System/"><span class="level-start"><span class="level-item">File System</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/IPC/"><span class="level-start"><span class="level-item">IPC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Process-Schedual/"><span class="level-start"><span class="level-item">Process Schedual</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Shell/"><span class="level-start"><span class="level-item">Shell</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Tool/"><span class="level-start"><span class="level-item">Tool</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Tool/Vi/"><span class="level-start"><span class="level-item">Vi</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Model/"><span class="level-start"><span class="level-item">ML Model</span></span><span class="level-end"><span class="level-item tag">21</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Model/Linear-Model/"><span class="level-start"><span class="level-item">Linear Model</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Model-Component/"><span class="level-start"><span class="level-item">Model Component</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Nolinear-Model/"><span class="level-start"><span class="level-item">Nolinear Model</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Unsupervised-Model/"><span class="level-start"><span class="level-item">Unsupervised Model</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/"><span class="level-start"><span class="level-item">ML Specification</span></span><span class="level-end"><span class="level-item tag">17</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/Click-Through-Rate/"><span class="level-start"><span class="level-item">Click Through Rate</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/Click-Through-Rate/Recommandation-System/"><span class="level-start"><span class="level-item">Recommandation System</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/Computer-Vision/"><span class="level-start"><span class="level-item">Computer Vision</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Specification/FinTech/"><span class="level-start"><span class="level-item">FinTech</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/FinTech/Risk-Control/"><span class="level-start"><span class="level-item">Risk Control</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/Graph-Analysis/"><span class="level-start"><span class="level-item">Graph Analysis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Specification/NLP/"><span class="level-start"><span class="level-item">NLP</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Technique/"><span class="level-start"><span class="level-item">ML Technique</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Technique/Feature-Engineering/"><span class="level-start"><span class="level-item">Feature Engineering</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Technique/Neural-Network/"><span class="level-start"><span class="level-item">Neural Network</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Theory/"><span class="level-start"><span class="level-item">ML Theory</span></span><span class="level-end"><span class="level-item tag">11</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Theory/Loss/"><span class="level-start"><span class="level-item">Loss</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Theory/Model-Enhencement/"><span class="level-start"><span class="level-item">Model Enhencement</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Theory/Optimization/"><span class="level-start"><span class="level-item">Optimization</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Algebra/"><span class="level-start"><span class="level-item">Math Algebra</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Algebra/Linear-Algebra/"><span class="level-start"><span class="level-item">Linear Algebra</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Algebra/Universal-Algebra/"><span class="level-start"><span class="level-item">Universal Algebra</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Analysis/"><span class="level-start"><span class="level-item">Math Analysis</span></span><span class="level-end"><span class="level-item tag">23</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Analysis/Fourier-Analysis/"><span class="level-start"><span class="level-item">Fourier Analysis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Functional-Analysis/"><span class="level-start"><span class="level-item">Functional Analysis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Optimization/"><span class="level-start"><span class="level-item">Optimization</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Real-Analysis/"><span class="level-start"><span class="level-item">Real Analysis</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Mixin/"><span class="level-start"><span class="level-item">Math Mixin</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Mixin/Statistics/"><span class="level-start"><span class="level-item">Statistics</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Mixin/Time-Series/"><span class="level-start"><span class="level-item">Time Series</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Probability/"><span class="level-start"><span class="level-item">Probability</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">89</span></span></a><ul><li><a class="level is-mobile" href="/categories/Python/Cookbook/"><span class="level-start"><span class="level-item">Cookbook</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Jupyter/"><span class="level-start"><span class="level-item">Jupyter</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Keras/"><span class="level-start"><span class="level-item">Keras</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Matplotlib/"><span class="level-start"><span class="level-item">Matplotlib</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Numpy/"><span class="level-start"><span class="level-item">Numpy</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Pandas/"><span class="level-start"><span class="level-item">Pandas</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Py3Ref/"><span class="level-start"><span class="level-item">Py3Ref</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Py3std/"><span class="level-start"><span class="level-item">Py3std</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Pywin32/"><span class="level-start"><span class="level-item">Pywin32</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Readme/"><span class="level-start"><span class="level-item">Readme</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/TensorFlow/"><span class="level-start"><span class="level-item">TensorFlow</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Twists/"><span class="level-start"><span class="level-item">Twists</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/RLang/"><span class="level-start"><span class="level-item">RLang</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Rust/"><span class="level-start"><span class="level-item">Rust</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Set/"><span class="level-start"><span class="level-item">Set</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/"><span class="level-start"><span class="level-item">Tool</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/Tool/Editor/"><span class="level-start"><span class="level-item">Editor</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Markup-Language/"><span class="level-start"><span class="level-item">Markup Language</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Web-Browser/"><span class="level-start"><span class="level-item">Web Browser</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Windows/"><span class="level-start"><span class="level-item">Windows</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/Web/CSS/"><span class="level-start"><span class="level-item">CSS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/NPM/"><span class="level-start"><span class="level-item">NPM</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/Proxy/"><span class="level-start"><span class="level-item">Proxy</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/Thrift/"><span class="level-start"><span class="level-item">Thrift</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://octodex.github.com/images/hula_loop_octodex03.gif" alt="UBeaRLy"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">UBeaRLy</p><p class="is-size-6 is-block">Protector of Proxy</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">392</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">93</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">522</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/xyy15926" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/xyy15926"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-04T15:07:54.896Z">2021-08-04</time></p><p class="title"><a href="/uncategorized/README.html"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-03T07:46:51.000Z">2021-08-03</time></p><p class="title"><a href="/Web/NPM/hexo_config.html">Hexo 建站</a></p><p class="categories"><a href="/categories/Web/">Web</a> / <a href="/categories/Web/NPM/">NPM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-03T02:32:45.000Z">2021-08-03</time></p><p class="title"><a href="/Web/NPM/config.html">NPM 总述</a></p><p class="categories"><a href="/categories/Web/">Web</a> / <a href="/categories/Web/NPM/">NPM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-02T08:11:11.000Z">2021-08-02</time></p><p class="title"><a href="/Python/Py3std/internet_data.html">互联网数据</a></p><p class="categories"><a href="/categories/Python/">Python</a> / <a href="/categories/Python/Py3std/">Py3std</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-29T13:55:00.000Z">2021-07-29</time></p><p class="title"><a href="/Linux/Shell/sh_apps.html">Shell 应用程序</a></p><p class="categories"><a href="/categories/Linux/">Linux</a> / <a href="/categories/Linux/Shell/">Shell</a></p></div></article></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">Advertisement</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5385776267343559" data-ad-slot="6995841235" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="UBeaRLy" height="28"></a><p class="is-size-7"><span>&copy; 2021 UBeaRLy</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/xyy15926/proxy"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>