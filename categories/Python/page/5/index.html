<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Category: Python - UBeaRLy</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="UBeaRLy&#039;s Proxy"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="UBeaRLy&#039;s Proxy"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="UBeaRLy"><meta property="og:url" content="https://xyy15926.github.io/"><meta property="og:site_name" content="UBeaRLy"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://xyy15926.github.io/img/og_image.png"><meta property="article:author" content="UBeaRLy"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xyy15926.github.io"},"headline":"UBeaRLy","image":["https://xyy15926.github.io/img/og_image.png"],"author":{"@type":"Person","name":"UBeaRLy"},"publisher":{"@type":"Organization","name":"UBeaRLy","logo":{"@type":"ImageObject","url":"https://xyy15926.github.io/img/logo.svg"}},"description":""}</script><link rel="alternate" href="/atom.xml" title="UBeaRLy" type="application/atom+xml"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/darcula.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><script data-ad-client="pub-5385776267343559" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><meta name="follow_it-verification-code" content="SVBypAPPHxjjr7Y4hHfn"><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="UBeaRLy" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Visit on GitHub" href="https://github.com/xyy15926/proxy"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">Categories</a></li><li class="is-active"><a href="#" aria-current="page">Python</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-06-09T15:24:56.000Z" title="6/9/2019, 11:24:56 PM">2019-06-09</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-06-05T16:01:44.000Z" title="6/6/2019, 12:01:44 AM">2019-06-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Py3std/">Py3std</a></span><span class="level-item">7 minutes read (About 1063 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Py3std/func_programming.html">Funtioncal Programming Tools</a></h1><div class="content"><h2 id="builtins"><a href="#builtins" class="headerlink" title="builtins"></a><code>builtins</code></h2><ul>
<li><code>filter(iterable, func)</code>：过滤<code>func</code>返回布尔否值元素</li>
<li><code>enumerate(iterable)</code>：添加索引迭代</li>
<li><code>zip(*iterables)</code>：打包迭代元素</li>
<li><code>map(func, *iterables)</code>：<code>func</code>接受各迭代器中元素作为
参数调用（类似<code>zip</code>）</li>
<li><code>iter</code>：两种产生迭代器的模式<ul>
<li><code>iter(iterable)</code>：返回迭代器</li>
<li><code>iter(callable, sentinel)</code>：调用<code>callable</code>直到返回
<code>sentinel</code>停止迭代（不包括）<ul>
<li>可用于替代<code>while</code>循环</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a><code>itertools</code></h2><p><code>itertools</code>：包含为高效循环而创建迭代器的函数</p>
<blockquote>
<ul>
<li>参考<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/itertools.html">https://docs.python.org/zh-cn/3/library/itertools.html</a></li>
</ul>
</blockquote>
<h3 id="无穷迭代器"><a href="#无穷迭代器" class="headerlink" title="无穷迭代器"></a>无穷迭代器</h3><ul>
<li><code>count(start, step=1)</code>：步长累加</li>
<li><code>cycle(p)</code>：循环<code>p</code>中元素</li>
<li><code>repeat(elem, n=None)</code>：重复<code>elem</code></li>
</ul>
<h3 id="迭代元素处理"><a href="#迭代元素处理" class="headerlink" title="迭代元素处理"></a>迭代元素处理</h3><ul>
<li><code>accumulate(p, func=None)</code>：累加<code>p</code>中元素</li>
<li><code>chain(*iters)</code>：链接迭代器</li>
<li><code>chain.from_iterable(iterable)</code>：链接可迭代对象中迭代器</li>
<li><code>compress(data, selelctors)</code>：根据<code>selectors</code>选取<code>data</code></li>
<li><code>dropwhile(pred, seq)</code>：保留首个满足<code>pred</code>之后所有元素</li>
<li><code>takewhile(pred, seq)</code>：保留首个不满足<code>pred</code>之前元素</li>
<li><code>filterfalse(pred, seq)</code>：反<code>filter</code></li>
<li><code>groupby(iterable, key=None)</code>：根据<code>key(v)</code>值分组迭代器</li>
<li><code>islice(seq, start=0, stop=None, step=1)</code>：切片</li>
<li><code>starmap(func, seq)</code>：迭代对<code>seq</code>中执行<code>func(*elem)</code></li>
<li><code>tee(iterable, n=2)</code>：复制迭代器，默认2个</li>
<li><code>zip_longes(*iters, fillvalue)</code>：依最长迭代器<code>zip</code>，较短
循环填充或<code>fillvalue</code>填充</li>
</ul>
<h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><ul>
<li><code>product(*iters, repeat=1)</code>：笛卡尔积</li>
<li><code>permutations(p, r=None)</code>：<code>r</code>长度的排列，缺省全排列</li>
<li><code>combinations(p, r)</code>：<code>r</code>长度组合</li>
<li><code>combinations_with_replacement(p,r)</code>：可重复组合</li>
</ul>
<h2 id="functools"><a href="#functools" class="headerlink" title="functools"></a><code>functools</code></h2><p><code>functools</code>：包含高阶函数，即参数、返回值为其他函数的函数</p>
<blockquote>
<ul>
<li>参见<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/functools.html">https://docs.python.org/zh-cn/3/library/functools.html</a></li>
</ul>
</blockquote>
<h3 id="函数转换"><a href="#函数转换" class="headerlink" title="函数转换"></a>函数转换</h3><ul>
<li><p><code>cmp_to_key(func)</code>：将旧式比较函数转换新式<em>key function</em></p>
<ul>
<li>常用在以下函数<code>key</code>参数中转换旧式比较函数<ul>
<li><code>sorted</code></li>
<li><code>min</code></li>
<li><code>max</code></li>
<li><code>heapq.nlargest</code></li>
<li><code>heapq.nsmallest</code></li>
<li><code>itertools.groupby</code></li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><em>key function</em>：接收参数，返回可以用于排序的值</li>
</ul>
</blockquote>
</li>
<li><p><code>partial(func, *args, **kwargs)</code>：返回partial对象，其
调用时类似使用<code>args</code>、<code>kwargs</code>调用<code>func</code></p>
</li>
<li><p><code>partial.method(func, *args, **kwargs)</code>：适合类命名空间
中函数、描述器</p>
</li>
<li><p><code>update_wrapper(wrapper, wrapped, assigned=WRAPPER_ASSIGNMENTS, udpated=WRAPPER_UPDATES)</code>：
更新<code>wrapper</code>函数信息为<code>wrapped</code>函数信息</p>
</li>
</ul>
<h3 id="函数应用"><a href="#函数应用" class="headerlink" title="函数应用"></a>函数应用</h3><ul>
<li><code>reduce(func, iterable[, initializer])</code>：使用<code>func</code>接受
两个参数，reduce处理<code>iterable</code></li>
</ul>
<h3 id="函数装饰器"><a href="#函数装饰器" class="headerlink" title="函数装饰器"></a>函数装饰器</h3><ul>
<li><p><code>@lru_cache(maxsize=128, typed=False)</code>：缓存函数执行结果</p>
<ul>
<li>字典存储缓存：函数固定参数、关键字参数必须可哈希</li>
<li>不同参数调用模式（如仅参数顺序不同）可能被视为不同
，从而产生多个缓存项</li>
</ul>
<blockquote>
<ul>
<li>可以用于方便实现动态规划</li>
</ul>
</blockquote>
</li>
<li><p><code>@singledispatch</code>：转换函数为单分派范型函数，实现python
的重载（接口多态）</p>
<blockquote>
<ul>
<li><em>single dispatch</em>：单分派，基于单个参数类型分派的
 范型函数分派形式</li>
</ul>
</blockquote>
</li>
<li><p><code>@wraps(wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES)</code>：
等价于<code>partial(update_wrapper, wrapped, assigned, updated)</code></p>
</li>
</ul>
<h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><ul>
<li><code>@total_ordering</code>：根据类中已定义比较方法实现剩余方法<ul>
<li>类必须实现<code>__eq__</code>、其他富比较方法中任意一种</li>
</ul>
</li>
</ul>
<h2 id="operator"><a href="#operator" class="headerlink" title="operator"></a><code>operator</code></h2><p><code>operator</code>：提供与python内置运算符对应的高效率函数</p>
<ul>
<li>为向后兼容，保留双下划线版本函数名（同特殊方法名）</li>
</ul>
<h3 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h3><ul>
<li><code>lt(a,b)</code>/<code>__lt__(a,b)</code></li>
<li><code>le(a,b)</code></li>
<li><code>eq(a,b)</code></li>
<li><code>ne(a,b)</code></li>
<li><code>ge(a,b)</code></li>
<li><code>gt(a,b)</code></li>
</ul>
<h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><ul>
<li><code>not(obj)</code></li>
<li><code>truth(obj)</code>：等价于使用bool构造器</li>
<li><code>is_(a,b)</code></li>
<li><code>is_not(a,b)</code></li>
</ul>
<h3 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h3><ul>
<li><code>add(a,b)</code></li>
<li><code>sub(a,b)</code></li>
<li><code>mul(a,b)</code></li>
<li><code>div(a,b)</code></li>
<li><code>pow(a,b)</code></li>
<li><code>mod(a,b)</code></li>
<li><code>floordiv(a,b)</code></li>
<li><code>truediv(a,b)</code></li>
<li><code>matmul(a,b)</code></li>
<li><code>abs(obj)</code></li>
<li><code>neg(obj)</code></li>
<li><code>pos(obj)</code></li>
</ul>
<h4 id="在位赋值"><a href="#在位赋值" class="headerlink" title="在位赋值"></a>在位赋值</h4><blockquote>
<ul>
<li>在位运算对可变数据类型才会更新参数，否则只返回结果</li>
</ul>
</blockquote>
<ul>
<li><code>iadd(a,b)</code>：等价于<code>a += b</code></li>
<li><code>isub(a,b)</code></li>
<li><code>imul(a,b)</code></li>
<li><code>idiv(a,b)</code></li>
<li><code>ipow(a,b)</code></li>
<li><code>imod(a,b)</code></li>
<li><code>ifloordiv(a,b)</code></li>
<li><code>itruediv(a,b)</code></li>
<li><code>imatmul(a,b)</code></li>
</ul>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><ul>
<li><code>and_(a,b)</code></li>
<li><code>or_(a,b)</code></li>
<li><code>xor(a,b)</code></li>
<li><code>inv(obj)</code>/<code>invert(obj)</code></li>
<li><code>lshift(a,b)</code></li>
<li><code>shift(a,b)</code></li>
</ul>
<h4 id="在位运算"><a href="#在位运算" class="headerlink" title="在位运算"></a>在位运算</h4><ul>
<li><code>iand(a,b)</code></li>
<li><code>ior(a,b)</code></li>
<li><code>ixor(a,b)</code></li>
</ul>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul>
<li><code>index(a)</code></li>
</ul>
<h3 id="序列运算"><a href="#序列运算" class="headerlink" title="序列运算"></a>序列运算</h3><ul>
<li><code>concat(a,b)</code></li>
<li><code>contains(a,b)</code></li>
<li><code>countOf(a,b)</code></li>
<li><code>delitem(a,b)</code></li>
<li><code>getitem(a,b)</code></li>
<li><code>indexOf(a,b)</code></li>
<li><code>setitem(a,b,c)</code></li>
<li><code>length_hint(obj, default=0)</code></li>
</ul>
<h3 id="访问函数"><a href="#访问函数" class="headerlink" title="访问函数"></a>访问函数</h3><ul>
<li><code>attrgetter(attr)</code>/<code>attrgetter(*attrs)</code>：返回函数，函数
返回值为参数属性<code>attr</code></li>
<li><code>itemgetter(item)</code>/<code>itemgetter(*items)</code>：类似</li>
<li><code>methodcaller(name[, args...])</code>：类似</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-06-09T15:24:42.000Z" title="6/9/2019, 11:24:42 PM">2019-06-09</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-06-09T15:24:35.000Z" title="6/9/2019, 11:24:35 PM">2019-06-09</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Py3std/">Py3std</a></span><span class="level-item">a few seconds read (About 12 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Py3std/data_types.html">Python数据类型</a></h1><div class="content"><h2 id="collections"><a href="#collections" class="headerlink" title="collections"></a><code>collections</code></h2><h2 id="array"><a href="#array" class="headerlink" title="array"></a><code>array</code></h2><h2 id="headq"><a href="#headq" class="headerlink" title="headq"></a><code>headq</code></h2><h2 id="bisect"><a href="#bisect" class="headerlink" title="bisect"></a><code>bisect</code></h2><h2 id="weakref"><a href="#weakref" class="headerlink" title="weakref"></a><code>weakref</code></h2><h2 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a><code>datetime</code></h2><h2 id="calender"><a href="#calender" class="headerlink" title="calender"></a><code>calender</code></h2><h2 id="types"><a href="#types" class="headerlink" title="types"></a><code>types</code></h2><h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a><code>copy</code></h2><h2 id="pprint"><a href="#pprint" class="headerlink" title="pprint"></a><code>pprint</code></h2><h2 id="reprlib"><a href="#reprlib" class="headerlink" title="reprlib"></a><code>reprlib</code></h2><h2 id="enum"><a href="#enum" class="headerlink" title="enum"></a><code>enum</code></h2></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-06-09T09:23:02.000Z" title="6/9/2019, 5:23:02 PM">2019-06-09</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-06-09T09:23:02.000Z" title="6/9/2019, 5:23:02 PM">2019-06-09</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Py3Ref/">Py3Ref</a></span><span class="level-item">10 minutes read (About 1499 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Py3Ref/py3ref_abstract.html">Python概述</a></h1><div class="content"><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><ul>
<li>语言的具体实现可能发生改变、其他实现可能使用不同方式</li>
<li>在语言的参考文档中加入过多细节实现很危险</li>
</ul>
<h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><p>python只是一种语言，其具体解释器实现有很多种</p>
<ul>
<li><p><em>CPython</em>：C语言实现，最原始版本</p>
<ul>
<li>通常就被称为Python，其他实现区分时才强调为CPython</li>
<li>新语言特性通常较早出现</li>
</ul>
</li>
<li><p><em>Jython</em>：Java实现</p>
<ul>
<li>将Python代码编译为Java字节码</li>
<li>可以左线Java应用的脚本语言、创建需要Java类库支持的
应用</li>
<li>在JVM上运行</li>
</ul>
</li>
<li><p><em>Python for .NET</em>：实际上使用CPython实现，但是属于.NET
托管应用，可以引入.NET类库</p>
</li>
<li><p><em>IronPython</em>：.NET实现</p>
<ul>
<li>生成IL的完全Python实现，将Python代码直接编译为.NET
程序集</li>
</ul>
</li>
<li><p>PyPy：RPython（Python语言子集）实现</p>
<ul>
<li>JIT编译器，执行效率高于CPython</li>
<li>非栈式支持</li>
<li>允许方便修改解释器，鼓励对语言本身进行实验</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>CPython是解释器实现版本，<code>cython</code>是将Python代码翻译为
  C插件的项目/包</li>
</ul>
</blockquote>
<h2 id="Notation说明"><a href="#Notation说明" class="headerlink" title="Notation说明"></a><em>Notation</em>说明</h2><p>标注：词法、句法解析的描述使用修改过的BNF语法标注</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name ::= lc_letter(lc_letter | &quot;_&quot;)*</span><br><span class="line">lc_letter ::= &quot;a&quot;...&quot;z&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>::=</code>：声明规则，左侧为规则名称</li>
<li><code>|</code>：分隔可选项</li>
<li><code>*</code>：前一项的零次、多次重复</li>
<li><code>+</code>：前一项的一次、多次重复</li>
<li><code>[]</code>：括起内容可选，即出现零次、一次</li>
<li><code>()</code>：分组</li>
<li><code>&quot;&quot;</code>：固定字符串包含在引号内</li>
<li><code> </code>：空格仅用于分隔<em>token</em></li>
<li><code>...</code>：三个点分割的本义字符表示在指定区间范围内的任意
  单个字符</li>
<li><code>&lt;&gt;</code>：对所定义符号的非常描述，在必要时用于说明“控制字符”
  意图</li>
</ul>
</blockquote>
<ul>
<li>每条规则通常为一行，多个可选项规则可用<code>|</code>为界分为多行</li>
<li>词法定义：作用域输入源中的单独字符</li>
<li>句法定义：作用于词法分析生成的<em>token stream</em></li>
</ul>
<h2 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h2><ul>
<li>实例方法：定义在类命名空间中、未因访问而绑定函数</li>
<li>绑定方法：已绑定实例方法</li>
<li>静态方法</li>
<li>类方法</li>
<li>[类]实例：类实例化所得对象</li>
<li>对象：泛指所有python对象，包括类、实例</li>
</ul>
<h2 id="Global-Intepretor-Lock"><a href="#Global-Intepretor-Lock" class="headerlink" title="Global Intepretor Lock"></a><em>Global Intepretor Lock</em></h2><p>全局内存锁：<em>GIL</em>，任何python字节码执行前必须获得的解释器锁</p>
<ul>
<li>在任何时刻，只能有一个线程处于工作状态</li>
<li>避免多个线程同时操作变量导致内存泄漏、错误释放</li>
</ul>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li><p>GIL实现简单，只需要管理一把解释器锁就能保证线程内存安全</p>
<ul>
<li>当然GIL只能保证引用计数正确，避免由此导致内存问题</li>
<li>还需要原子操作、对象锁避免并发更新问题</li>
</ul>
</li>
<li><p>GIL单线程情况下性能更好、稳定，若通过给所有对象引用计数
加锁来实现线程安全</p>
<ul>
<li>容易出现死锁</li>
<li>性能下降很多</li>
</ul>
</li>
<li><p>方便兼容C遗留库，这也是python得以发展的原因</p>
<ul>
<li>很多python需要的C库扩展要求线程安全的内存管理</li>
</ul>
</li>
</ul>
<h3 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h3><ul>
<li><p>Python线程是真正的操作系统线程</p>
<ul>
<li>在准备好之后必须获得一把共享锁才能运行</li>
<li>每个线程都会在执行一定机器指令和后切换到无锁状态，
暂停运行</li>
<li>事实上程序在开始时已经在运行“主线程”</li>
</ul>
<blockquote>
<ul>
<li>解释器检查线程切换频率<code>sys.getcheckinterval()</code></li>
</ul>
</blockquote>
</li>
<li><p>Python线程无法在多核CPU间分配，对CPU-Bound程序基本没有
提升效果，对于IO-Bound的程序性能仍然有巨大帮助</p>
</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li><p>多进程</p>
<ul>
<li>进程分支：<code>os.fork</code></li>
<li>派生进程：<code>multiprocessing.Process</code>、
<code>concurrent.futures</code></li>
</ul>
</li>
<li><p>C语言库封装线程：<code>ctypes</code>、<code>cython</code></p>
<ul>
<li>C扩展形式实现任务线程可在python虚拟机作用域外运行
可以并行运行任意数量线程</li>
<li>在运行时释放GIL、结束后继续运行python代码时重新获取
GIL，真正实现独立运行</li>
</ul>
</li>
<li><p>使用其他版本Python解释器：只有原始Python版本CPython使用
GIL实现</p>
<ul>
<li>Jython</li>
<li>IronPython</li>
<li>PyPy</li>
</ul>
</li>
</ul>
<h2 id="Python最高层级组件"><a href="#Python最高层级组件" class="headerlink" title="Python最高层级组件"></a>Python最高层级组件</h2><h3 id="完整的Python程序"><a href="#完整的Python程序" class="headerlink" title="完整的Python程序"></a>完整的Python程序</h3><ul>
<li><p>完整的python程序会在最小初始化环境中被执行</p>
<ul>
<li>所有内置、标准模块均可用，但均处于未初始化状态</li>
<li>只有<code>sys</code>、<code>builtins</code>、<code>__main__</code>已经初始化</li>
<li><code>__main__</code>模块为完整程序的执行提供局部、全局命名空间</li>
</ul>
</li>
<li><p>完整程序可通过三种形式传递给解释器</p>
<ul>
<li><code>-c</code>命令行选项传递字符串</li>
<li>文件作为第一个命令行参数</li>
<li>标准输入</li>
</ul>
<blockquote>
<ul>
<li>若文件、标准输入是tty设备，解释器进入交互模式，否则
 将文件当作完整程序执行</li>
</ul>
</blockquote>
</li>
<li><p>解释器也可以通过交互模式被发起调用</p>
<ul>
<li>每次读取执行一条语句，语句会在<code>__main__</code>命名空间中
被执行</li>
<li>初始环境同完整程序</li>
</ul>
</li>
</ul>
<h3 id="输入类型"><a href="#输入类型" class="headerlink" title="输入类型"></a>输入类型</h3><h4 id="文件输入"><a href="#文件输入" class="headerlink" title="文件输入"></a>文件输入</h4><p>文件输入：从非交互式文件读取的输入，具有相同形式</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_input ::= (NEWLINE|statement)*</span><br></pre></td></tr></table></figure>
<ul>
<li><p>适合以下几种情况</p>
<ul>
<li>解析完整的python程序（从文件、字符串）</li>
<li>解析模块</li>
<li>解析传递给<code>exec()</code>函数的字符串</li>
</ul>
</li>
</ul>
<h4 id="交互式输入"><a href="#交互式输入" class="headerlink" title="交互式输入"></a>交互式输入</h4><p>交互式输入：从tty设备读取输入</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interactive_input ::= [stmt_list] NEWLINE | compound_stmt NEWLINE</span><br></pre></td></tr></table></figure>
<ul>
<li>注意<ul>
<li>交互模式中（最高层级）复合语句后必须带有空行，帮助
解释器确定输入的结束</li>
</ul>
</li>
</ul>
<h4 id="表达式输入"><a href="#表达式输入" class="headerlink" title="表达式输入"></a>表达式输入</h4><p>表达式输入</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval_input ::= expression_list NEWLINE*</span><br></pre></td></tr></table></figure>
<ul>
<li><code>eval</code>被用于表达式输入</li>
<li>忽略开头空白</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-06-09T08:54:21.000Z" title="6/9/2019, 4:54:21 PM">2019-06-09</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-06-09T08:54:21.000Z" title="6/9/2019, 4:54:21 PM">2019-06-09</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Py3Ref/">Py3Ref</a></span><span class="level-item">36 minutes read (About 5403 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Py3Ref/import_system.html">Python包、模块</a></h1><div class="content"><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><h3 id="导入方式"><a href="#导入方式" class="headerlink" title="导入方式"></a>导入方式</h3><p><em>importing</em>操作可以使得模块能够访问其他模块中代码</p>
<ul>
<li><p><code>import</code>：结合了以下两个操作，发起导入调机制最常用方式</p>
<ul>
<li>搜索指定名称模块：对<code>__import__()</code>带有适当参数调用</li>
<li>将搜索结果绑定到当前作用域中名称：<code>__import__</code>返回值
被用于执行名称绑定操作</li>
</ul>
</li>
<li><p><code>__import__()</code>：只执行模块搜索、找到模块后创建<code>module</code></p>
<ul>
<li>可能产生某些副作用<ul>
<li>导入父包</li>
<li>更新各种缓存：<code>sys.modules</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>importlib.import_module()</code></p>
<ul>
<li>可能会选择绕过<code>__import__</code>，使用其自己的解决方案实现
导入机制</li>
<li>用于为动态模块导入提供支持</li>
</ul>
<blockquote>
<ul>
<li><code>importlib</code>模块参见标准库</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h4><ul>
<li>任意机制加载子模块时，父模块命名空间中会添加对子模块对象
的绑定</li>
</ul>
<h3 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a><em>Packages</em></h3><ul>
<li><p>python只有一种模块对象类型：所有模块都属于该类型，C、
Python语言实现均是</p>
</li>
<li><p>包：为帮助组织模块、并提供名称层次结构引入</p>
<ul>
<li>可将包<strong>视为</strong>文件系统中目录、模块视为目录中文件，
但<strong>包、模块不是必须来自文件系统</strong></li>
<li>类似文件系统，包通过层次结构进行组织：包内包括模块、
子包</li>
</ul>
</li>
<li><p><strong>所有包都是模块，但并非所有模块都是包</strong></p>
<ul>
<li>包是一种特殊的模块</li>
<li>特别的，任何具有<code>__path__</code>属性的模块都被当作包</li>
</ul>
</li>
<li><p>所有模块都有自己的名字</p>
<ul>
<li>子包名与其父包名以<code>.</code>分隔，同python标准属性访问语法</li>
</ul>
</li>
</ul>
<h4 id="Regular-Packages"><a href="#Regular-Packages" class="headerlink" title="Regular Packages"></a><em>Regular Packages</em></h4><p>正规包：通常以包含<code>__init__.py</code>文件的目录形式出现</p>
<ul>
<li><p><code>__init__.py</code>文件可以包含和其他模块中包含python模块相似
的代码</p>
</li>
<li><p>正规包被导入时</p>
<ul>
<li><code>__init__.py</code>文件会隐式被执行，其中定义对象被绑定到
该包命名空间中名称</li>
<li>python会为模块添加额外属性</li>
</ul>
</li>
</ul>
<h4 id="Namespace-Packages"><a href="#Namespace-Packages" class="headerlink" title="Namespace Packages"></a><em>Namespace Packages</em></h4><p>命名空间包：由多个部分构成，每个部分为父包增加一个子包</p>
<ul>
<li><p>包各部分可以物理不相邻，不一定直接对应到文件系统对象，
可能是无实体表示的虚拟模块</p>
<ul>
<li>可能处于文件系统不同位置</li>
<li>可能处于zip文件、网络上，或在导入期间其他可搜索位置</li>
</ul>
</li>
<li><p><code>__path__</code>属性不是普通列表，而是定制的可迭代类型</p>
<ul>
<li>若父包、或最高层级包<code>sys.path</code>路径发生改变，对象会
在包内的下次导入尝试时，自动执行新的对包部分的搜索</li>
</ul>
</li>
<li><p>命名空间包中没有<code>__init__.py</code>文件</p>
<ul>
<li>毕竟可能有多个父目录提供包不同部分，彼此物理不相邻</li>
<li>python会在包、子包导入时为其创建命名空间包</li>
</ul>
</li>
</ul>
<h3 id="导入相关模块属性"><a href="#导入相关模块属性" class="headerlink" title="导入相关模块属性"></a>导入相关模块属性</h3><blockquote>
<ul>
<li>以下属性在加载时被设置，参见
  <em>cs_python/py3ref/import_system</em></li>
</ul>
</blockquote>
<ul>
<li><p><code>__name__</code>：模块完整限定名称，唯一标识模块</p>
</li>
<li><p><code>__loader__</code>：导入系统加载模块时使用的加载器对象</p>
<ul>
<li>主要用于内省</li>
<li>也可用于额外加载器专用功能</li>
</ul>
</li>
<li><p><code>__package__</code>：取代<code>__name__</code>用于主模块计算显式相对
导入</p>
<ul>
<li>模块为包：应设置为<code>__name__</code></li>
<li>模块非包：最高层级模块应设为空字符串，否则为父包名</li>
</ul>
<blockquote>
<ul>
<li>预期同<code>__spec__.parent</code>值相同，未定义时，以
 <code>__spec__.parent</code>作为回退项</li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li><code>python &lt;PYSCIRPT&gt;</code>直接执行脚本时<code>__name__</code>被设置为
  <code>__main__</code>、<code>__package__</code>设置为<code>None</code>，此时导入器无法
  解释相对导入中<code>.</code>，相对导入报错</li>
<li><code>python -m &lt;PYSCIRPT&gt;</code>则会按模块逻辑设置<code>__name__</code>、
  <code>__package__</code>，相对导入可以正常执行</li>
</ul>
</blockquote>
<h4 id="spec"><a href="#spec" class="headerlink" title="__spec__"></a><code>__spec__</code></h4><p><code>__spec__</code>：导入模块时要使用的<strong>模块规格说明</strong></p>
<ul>
<li>对<code>__spec__</code>正确设置将同时作用于解释器启动期间
初始化的模块</li>
<li>仅<code>__main__</code>某些情况下被设置为<code>None</code></li>
</ul>
<h4 id="path"><a href="#path" class="headerlink" title="__path__"></a><code>__path__</code></h4><ul>
<li><p><strong>具有该属性模块即为包</strong>：包模块必须设置<code>__path__</code>属性，
非包模块不应设置</p>
</li>
<li><p>在导入子包期间被使用，在导入机制内部功能同<code>sys.path</code>，
即用于提供模块搜索位置列表</p>
<ul>
<li>但受到更多限制，其必须为字符串组成可迭代对象，但若其
没有进一步用处可以设置为空</li>
<li>适用作用于<code>sys.path</code>的规则</li>
<li><code>sys.path_hooks</code>会在遍历包的<code>__path__</code>时被查询</li>
</ul>
</li>
<li><p>可在包的<code>__init__.py</code>中设置、更改</p>
<ul>
<li>在<em>PEP420</em>引入之后，命名空间包不再需要提供仅包含操作
<code>__path__</code>代码的<code>__init__.py</code>文件，导入机制会自动为
命名空间包正确设置<code>__path__</code></li>
<li>在之前其为实现命名空间包的典型方式</li>
</ul>
</li>
</ul>
<h4 id="repr"><a href="#repr" class="headerlink" title="__repr__"></a><code>__repr__</code></h4><ul>
<li><p>若模块具有<code>__spec__</code>，导入机制将尝试使用其中规格信息生成
repr</p>
<ul>
<li><code>name</code></li>
<li><code>loader</code></li>
<li><code>origin</code></li>
<li><code>has_location</code></li>
</ul>
</li>
<li><p>若模块具有<code>__file__</code>属性，将被用作repr的一部分</p>
</li>
<li><p>否则若模块具有<code>__loader__</code>属性且非<code>None</code>，则加载器repr
将被用作模块repr的一部分</p>
</li>
<li><p>其他情况下，仅在repr中适用模块的<code>__name__</code></p>
</li>
</ul>
<blockquote>
<ul>
<li>可以在模块规则说明中显式控制模块对象repr</li>
</ul>
</blockquote>
<h4 id="file-cached"><a href="#file-cached" class="headerlink" title="__file__/__cached__"></a><code>__file__</code>/<code>__cached__</code></h4><blockquote>
<ul>
<li><code>__file__</code>：模块对应的被加载文件的路径名</li>
<li><code>__cached__</code>：编译版本代码（字节码文件）路径</li>
</ul>
</blockquote>
<ul>
<li><p><code>__file__</code>为可选项，须为字符串</p>
<ul>
<li>可以在其无语法意义时不设置</li>
<li>对从共享库动态加载的扩展模块，应为共享库文件路径名</li>
</ul>
</li>
<li><p><code>__cached__</code></p>
<ul>
<li>不要求编译文件已经存在，可以表示<strong>应该存放</strong>编译文件
的位置</li>
<li>不要求<code>__file__</code>已经设置<ul>
<li>有时加载器可以从缓存加载模块但是无法从文件加载</li>
<li>加载静态链接至解释器内部的C模块</li>
</ul>
</li>
</ul>
</li>
<li><p>从<code>.pyc</code>文件加载缓存字节码前会检查其是否最新</p>
<ul>
<li>默认通过比较缓存文件中保存的源文件修改时间戳实现</li>
<li>也支持基于哈希的缓冲文件，此时<code>.pyc</code>文件中保存源文件
哈希值<ul>
<li>检查型：求源文件哈希值再和缓存文件中哈希值比较</li>
<li>非检查型：只要缓存文件存在就直接认为缓存文件有效</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><code>--check-hash-based-pycs</code>命名行选项设置基于哈希的
 <code>.pyc</code>文件有效性</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="执行相关模块属性"><a href="#执行相关模块属性" class="headerlink" title="执行相关模块属性"></a>执行相关模块属性</h3><ul>
<li><code>__doc__</code>：模块文档字符串</li>
<li><code>__annotaion__</code>：包含变量标注的字典<ul>
<li>在模块体执行时获取</li>
</ul>
</li>
<li><code>__dict__</code>：以字典对象表示的模块命名空间</li>
</ul>
<blockquote>
<ul>
<li>CPython：由于CPython清理模块字典的设定，模块离开作用域时
  模块字典将被清理，即使字典还有活动引用，可以复制该字典、
  保持模块状态以直接使用其字典</li>
</ul>
</blockquote>
<h3 id="sys-modules模块缓存"><a href="#sys-modules模块缓存" class="headerlink" title="sys.modules模块缓存"></a><code>sys.modules</code>模块缓存</h3><p><code>sys.modules</code>映射：缓存之前导入的所有模块（包括中间路径）
（即导入子模块会注册父模块条目）</p>
<ul>
<li><p>其中每个键值对就是限定名称、模块对象</p>
</li>
<li><p>在其中查找模块名称</p>
<ul>
<li>若存在需要导入模块，则导入完成</li>
<li>若名称对应值为<code>None</code>则<code>raise ModuleNotFoundError</code></li>
<li>若找不到指定模块名称，python将继续搜索</li>
</ul>
</li>
<li><p>映射可写，可删除其中键值对</p>
<ul>
<li>不一定破坏关联模块，因为其他模块可能保留对其引用</li>
<li>但是会使<strong>命名模块</strong>缓存条目无效，导致下次导入时重新
搜索命名模块，得到两个不同的两个模块对象</li>
</ul>
<blockquote>
<ul>
<li><code>importlib.reload</code>将重用相同模块对象，通过重新运行
 模块代码重新初始化模块内容</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="Finders-And-Loaders"><a href="#Finders-And-Loaders" class="headerlink" title="Finders And Loaders"></a><em>Finders And Loaders</em></h2><blockquote>
<ul>
<li><em>Finders</em>：查找器，确定能否使用所知策略找到指定名称模块</li>
<li><em>Loaders</em>：加载器，加载找到的指定模块</li>
<li><em>Importer</em>：导入器，同时实现两种接口的对象，在确定能加载
  所需模块时会返回自身</li>
</ul>
</blockquote>
<ul>
<li><p>导入机制通过<em>import hooks</em>实现扩展</p>
<ul>
<li>可以加入新的查找器以扩展模块搜索范围、作用域</li>
</ul>
</li>
<li><p>工作流程：在<code>sys.modules</code>缓存中无法找到指定名称模块时</p>
<ul>
<li>查找器若能找到指定名称模块，返回模块规格说明<em>spec</em></li>
<li>加载器将利用查找器返回的模块规格说明加载模块</li>
</ul>
</li>
</ul>
<h3 id="Import-Path"><a href="#Import-Path" class="headerlink" title="Import Path"></a><em>Import Path</em></h3><p>导入路径：文件系统路径、zip文件等<em>path term</em>组成的位置列表</p>
<ul>
<li><p>其中元素不局限于文件系统位置，可扩展为字符串指定的任意
可定位资源</p>
<ul>
<li>URL指定资源</li>
<li>数据库查询</li>
</ul>
</li>
<li><p>位置条目来源</p>
<ul>
<li>通常为<code>sys.path</code></li>
<li>对次级包可能来自上级包的<code>__path__</code>属性</li>
</ul>
</li>
<li><p>其中每个路径条目指定一个用于搜索模块的位置</p>
<ul>
<li><em>path based finder</em>将在其中查找导入目标</li>
</ul>
</li>
</ul>
<h4 id="sys-path"><a href="#sys-path" class="headerlink" title="sys.path"></a><code>sys.path</code></h4><p><code>sys.path</code>：模块、包搜索位置的字符串列表</p>
<ul>
<li><p>初始化自<code>PYTHONPATH</code>环境变量、特定安装和实现的默认设置、
执行脚本目录（或当前目录）</p>
</li>
<li><p>其中条目可以指定文件系统中目录、zip文件、可用于搜索模块
的潜在位置</p>
</li>
<li><p>只能出现字符串、字节串，其他数据类型被忽略</p>
<ul>
<li>字节串条目使用的编码由导入路径钩子、
<em>path entry finder</em>确定</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>所以可以修改<code>sys.path</code>值定制导入路径，CPython实现参见
  <em>cs_python/py3ref/import_system</em></li>
</ul>
</blockquote>
<h4 id="sys-path-import-cache"><a href="#sys-path-import-cache" class="headerlink" title="sys.path_import_cache"></a><code>sys.path_import_cache</code></h4><p><code>sys.path_importer_cache</code>：存放路径条目到路径条目查找器映射
的缓存</p>
<ul>
<li><p>减少查找路径条目对应路径条目查找器的消耗，对特定路径条目
查找对应路径条目查找只需进行一次</p>
</li>
<li><p>可从中移除缓存条目，以强制基于路径查找器执行路径条目搜索</p>
</li>
</ul>
<h3 id="Import-Hooks"><a href="#Import-Hooks" class="headerlink" title="Import Hooks"></a><em>Import Hooks</em></h3><ul>
<li><p><em>meta hooks</em>：元[路径]钩子</p>
<ul>
<li>导入过程开始时被调用，此时仅<code>sys.modules</code>缓存查找
发生，其他导入过程未发生</li>
<li>所以允许元钩子重载<code>sys.path</code>过程、冻结模块甚至内置
模块</li>
</ul>
<blockquote>
<ul>
<li><strong>元钩子即导入器/元路径查找器</strong></li>
<li><code>sys.meta_path</code>为元路径查找器列表，可在其中注册定制
 元钩子</li>
</ul>
</blockquote>
</li>
<li><p><em>path[ entry] hooks</em>：导入路径钩子</p>
<ul>
<li>是<code>sys.path</code>、<code>package.__path__</code>处理的一部分</li>
<li>基于路径的查找器调用其处理路径条目，以获取路径条目
查找器</li>
</ul>
<blockquote>
<ul>
<li><strong>导入路径钩子返回路径条目查找器</strong></li>
<li><code>sys.path_hooks</code>为导入路径钩子列表，可在其中注册
 定制导入路径钩子</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="默认元路径查找器-导入器"><a href="#默认元路径查找器-导入器" class="headerlink" title="默认元路径查找器/导入器"></a>默认元路径查找器/导入器</h3><p>python默认实现<code>sys.meta_path</code>有以下导入器（元路径查找器）</p>
<ul>
<li><code>BuiltinImporter</code>：定位、导入内置模块</li>
<li><code>FrozenImporter</code>：定位、导入冻结模块</li>
<li><code>PathFinder</code>：定位、导入来自<em>import path</em>中模块</li>
</ul>
<blockquote>
<ul>
<li>尝试导入模块时，内置模块、冻结模块导入器优先级较高，所以
  解释器首先搜索<strong>内置</strong>模块</li>
</ul>
</blockquote>
<h2 id="Finder"><a href="#Finder" class="headerlink" title="Finder"></a><em>Finder</em></h2><ul>
<li><p>指定名称模块在<code>sys.modules</code>找不到时，python继续搜索
<code>sys.meta_path</code>，按顺序调用其中元路径查找器</p>
</li>
<li><p>若<code>sys.meta_path</code>处理到列表末尾仍未返回说明对象，则
<code>raise ModuleNotFoundError</code></p>
</li>
</ul>
<blockquote>
<ul>
<li>导入过程中引发的任何异常直接向上传播，并放弃导入过程</li>
<li>对非最高层级模块的导入请求可能会多次遍历元路径</li>
</ul>
</blockquote>
<h3 id="Meta-Path-Finders"><a href="#Meta-Path-Finders" class="headerlink" title="Meta Path Finders"></a><em>Meta Path Finders</em></h3><p>元路径查找器：</p>
<ul>
<li><p>元路径查找器可使用任何策略确定其是否能处理给定名称模块</p>
<ul>
<li>若知道如何处理指定名称的模块，将返回模块规格说明</li>
<li>否则返回<code>None</code></li>
</ul>
</li>
<li><p>模块规格协议：元路径查找器应实现<code>find_spec()</code>方法</p>
<ul>
<li>接受名称、导入路径、目标模块作为参数</li>
<li>返回模块规格说明</li>
</ul>
</li>
</ul>
<h3 id="Spec"><a href="#Spec" class="headerlink" title="Spec"></a><em>Spec</em></h3><ul>
<li><p>模块规格[说明]：基于每个模块封装的模块导入相关信息</p>
<ul>
<li>模块规格中大部分信息对所有模块是公用的</li>
<li>模块规格说明作为模块对象的<code>__spec__</code>属性对外公开</li>
</ul>
</li>
<li><p>用途</p>
<ul>
<li>允许状态在导入系统各组件间传递，如：查询器和加载器</li>
<li>允许导入机制执行加载的样板操作，否则该由加载器负责</li>
</ul>
</li>
</ul>
<h3 id="find-spec"><a href="#find-spec" class="headerlink" title="find_spec"></a><code>find_spec</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">finder</span>.<span class="title">find_spec</span>(<span class="params">fullname, path=<span class="literal">None</span>, target=<span class="literal">None</span></span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>fullname</code>：被导入模块的完整限定名称</li>
<li><code>path</code>：供模块搜索使用的路径条目<ul>
<li>对最高层级模块应为<code>None</code></li>
<li>对子模块、子包应为父包<code>__path__</code>属性值，若
相应<code>__path__</code>属性无法访问将
<code>raise ModuleNotFoundError</code></li>
</ul>
</li>
<li><code>target</code>：将被作为稍后加载目标的现有模块对象<ul>
<li>导入系统仅在重加载期间传入目标模块</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>导入器的<code>find_spec()</code>返回模块规格说明中加载器为<code>self</code></li>
<li>有些元路径查找器仅支持顶级导入，<code>path</code>参数不为<code>None</code>时
  总返回<code>None</code></li>
</ul>
</blockquote>
<h2 id="Loaders"><a href="#Loaders" class="headerlink" title="Loaders"></a><em>Loaders</em></h2><ul>
<li>模块规格说明被找到时，导入机制将在加载该模块时使用<ul>
<li>其中包含的加载器将被使用，若存在</li>
</ul>
</li>
</ul>
<h3 id="加载流程"><a href="#加载流程" class="headerlink" title="加载流程"></a>加载流程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">module = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> spec.loader <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="built_in">hasattr</span>(spec.loader, <span class="string">&#x27;create_module&#x27;</span>):</span><br><span class="line">	<span class="comment"># 模块说明中包含加载器，使用加载器创建模块</span></span><br><span class="line">	module = spec.loader.create_module(spec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> module <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">	<span class="comment"># 否则创建空模块</span></span><br><span class="line">	module = types.ModuleType(spec.name)</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 设置模块导入相关属性</span></span><br><span class="line">_init_module_attrs(spec, module)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> spec.loader <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">	<span class="comment"># 模块说明中不包含加载器</span></span><br><span class="line">	<span class="comment"># 检查模块是否为为命名空间包</span></span><br><span class="line">	<span class="keyword">if</span> spec.submodule_search_locations <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">		<span class="comment"># 设置`sys.modules`</span></span><br><span class="line">		sys.modules[spec.name] = module</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">raise</span> ImportError</span><br><span class="line"><span class="keyword">elif</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(spec.loader, <span class="string">&quot;exec_module&quot;</span>):</span><br><span class="line">	<span class="comment"># 向下兼容现有`load_module`</span></span><br><span class="line">	module = spec.loader.load_module(spec.name)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	sys.modules[spec.name] = module</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		<span class="comment"># 模块执行</span></span><br><span class="line">		spec.loader.exec_module(module)</span><br><span class="line">	<span class="keyword">except</span> BaseException:</span><br><span class="line">		<span class="keyword">try</span>:</span><br><span class="line">			<span class="comment"># 加载模块失败则从`sys.modules`中移除</span></span><br><span class="line">			<span class="keyword">del</span> sys.modules[spec.name]</span><br><span class="line">		<span class="keyword">except</span> KeyError:</span><br><span class="line">			<span class="keyword">pass</span></span><br><span class="line">		<span class="keyword">raise</span></span><br><span class="line"><span class="keyword">return</span> sys.modules[spec.name]</span><br></pre></td></tr></table></figure>
<ul>
<li>创建模块对象</li>
<li>设置模块导入相关属性：在执行模块代码前设置</li>
<li><code>sys.modules</code>注册模块</li>
<li>模块执行：模块导入关键，填充模块命名空间</li>
</ul>
<h4 id="create-module创建模块对象"><a href="#create-module创建模块对象" class="headerlink" title="create_module创建模块对象"></a><code>create_module</code>创建模块对象</h4><ul>
<li><p>模块加载器可以选择通过实现<code>create_module</code>方法在加载
期间创建模块对象</p>
<ul>
<li>其应接受模块规格说明作为参数</li>
</ul>
</li>
<li><p>否则导入机制使用<code>types.ModuleType</code>自行创建模块对象</p>
</li>
</ul>
<h4 id="sys-modules注册模块"><a href="#sys-modules注册模块" class="headerlink" title="sys.modules注册模块"></a><code>sys.modules</code>注册模块</h4><ul>
<li>在加载器执行代码前注册，避免模块代码导入自身导致无限
递归、多次加载</li>
<li>若模块为命名空间包，直接注册空模块对象</li>
</ul>
<h4 id="exec-module模块执行"><a href="#exec-module模块执行" class="headerlink" title="exec_module模块执行"></a><code>exec_module</code>模块执行</h4><ul>
<li><p>导入机制调用<code>importlib.abc.Loader.exec_module()</code>方法执行
模块对象</p>
<blockquote>
<ul>
<li>CPython：<code>exec_module</code>不定返回传入模块，其返回值将被
 忽略<blockquote>
<ul>
<li><code>importlib</code>避免直接使用返回值，而是通过在
<code>sys.modules</code>中查找模块名称获取模块对象</li>
<li>可能会间接导致被导入模块可能在<code>sys.modules</code>中
替换其自身</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p>加载器应该该满足</p>
<ul>
<li><p>若模块是python模块（非内置、非动态加载），加载器应该
在模块全局命名空间<code>module.__dict__</code>中执行模块代码</p>
</li>
<li><p>若加载器无法执行指定模块，则应<code>raise ImportError</code>，
在<code>exec_module</code>期间引发的任何其他异常同样被传播</p>
</li>
</ul>
</li>
<li><p>加载失败时作为附带影响被成功加载的模块仍然保留</p>
<blockquote>
<ul>
<li>重新加载模块会保留加载失败模块（最近成功版本）</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="Path-Based-Finder—PathFinder"><a href="#Path-Based-Finder—PathFinder" class="headerlink" title="Path Based Finder—PathFinder"></a><em>Path Based Finder</em>—<code>PathFinder</code></h2><p>基于路径的查找器：在特定<em>path entry</em>中查找、加载指定的python
模块、包</p>
<ul>
<li><p>基于路径查找器只是遍历<em>import path</em>中的路径条目，将其
关联至处理特定类型路径的<em>path entry finder</em></p>
</li>
<li><p>默认路径条目查找器集合实现了在文件系统中查找模块的所有
语义，可以处理多种文件类型</p>
<ul>
<li>python源码<code>.py</code></li>
<li>python字节码<code>.pyc</code></li>
<li>共享库<code>.so</code></li>
<li>zip包装的上述文件类型（需要<code>zipimport</code>模块支持）</li>
</ul>
</li>
<li><p>作为元路径查找器</p>
<ul>
<li>实现有<code>find_spec</code>协议</li>
<li>并提供额外的钩子、协议以便能扩展、定制可搜索路径条目
的类型，定制模块从<em>import path</em>的查找、加载</li>
</ul>
</li>
</ul>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>导入机制调用基于路径的查找器的<code>find_spec()</code>迭代搜索
<em>import path</em>的路径条目，查找对应路径条目查找器</p>
<ul>
<li><p>先在<code>sys.path_impporter_cache</code>缓存中查找对应路径条目
查找器</p>
</li>
<li><p>若没有在缓存中找到，则迭代调用<code>sys.path_hooks</code>中
<em>Path Entry Hook</em></p>
</li>
<li><p>迭代结束后若没有返回路径条目查找器，则</p>
<ul>
<li>置<code>sys.path_importer_cache</code>对应值为<code>None</code></li>
<li>返回<code>None</code>，表示此元路径查找器无法找到该模块</li>
</ul>
</li>
</ul>
<h4 id="当前目录"><a href="#当前目录" class="headerlink" title="当前目录"></a>当前目录</h4><p>对空字符串表示的当前工作目录同<code>sys.path</code>中其他条目处理方式
有所不同</p>
<ul>
<li><p>若当前工作目录不存在，则<code>sys.path_importer_cache</code>
中不存放任何值</p>
</li>
<li><p>模块查找回对当前工作目录进行全新查找</p>
</li>
<li><p><code>sys.path_importer_cache</code>使用、
<code>importlib.machinery.PathFinder.find_spec()</code>返回路径将是
实际当前工作目录而非空字符串</p>
</li>
</ul>
<h3 id="Path-Entry-Hook"><a href="#Path-Entry-Hook" class="headerlink" title="Path Entry Hook"></a><em>Path Entry Hook</em></h3><p>路径条目钩子：根据路径条目查找对应路径条目查找器的可调用对象</p>
<ul>
<li><p>参数：字符串、字节串，表示要搜索的目录条目</p>
<ul>
<li>字节串的编码由钩子自行决定</li>
<li>若钩子无法解码参数，应<code>raise ImportError</code></li>
</ul>
</li>
<li><p>路径条目钩子返回值</p>
<ul>
<li>可处理路径条目的路径条目查找器</li>
<li><code>raise ImportError</code>：表示钩子无法找到与路径条目对应
路径条目查找器<ul>
<li>该异常会被忽略，并继续对<em>import path</em>迭代</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Path-Entry-Finder—PathEntryFinder"><a href="#Path-Entry-Finder—PathEntryFinder" class="headerlink" title="Path Entry Finder—PathEntryFinder"></a><em>Path Entry Finder</em>—<code>PathEntryFinder</code></h3><p>路径条目查找器：</p>
<blockquote>
<ul>
<li>元路径查找器作用于导入过程的开始，遍历<code>sys.meta_path</code>时</li>
<li>路径条目查找器某种意义上是<strong>基于路径查找器的实现细节</strong></li>
</ul>
</blockquote>
<h4 id="find-spec-1"><a href="#find-spec-1" class="headerlink" title="find_spec"></a><code>find_spec</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PathEntryFinder</span>.<span class="title">find_spec</span>(<span class="params">fullname, target=<span class="literal">None</span></span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>路径条目查找器协议：目录条目查找器需实现<code>find_spec</code>方法</p>
<ul>
<li>以支持模块、已初始化包的导入</li>
<li>给命名空间包提供组成部分</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><code>fullname</code>：要导入模块的完整限定名称</li>
<li><code>target</code>：目标模块</li>
</ul>
</li>
<li><p>返回值：完全填充好的模块规格说明</p>
<ul>
<li>模块规格说明总是包含加载器集合</li>
<li>但命名空间包的规格说明中<code>loader</code>会被设置为<code>None</code>，
并将<code>submodule_search_locations</code>设置为包含该部分的
列表，以告诉导入机制该规格说明为命名空间包的portion</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><em>Portion</em>：构成命名空间包的单个目录内文件集合</li>
<li>替代旧式<code>find_loader()</code>、<code>find_module()</code>方法</li>
</ul>
</blockquote>
<h3 id="替换标准导入系统"><a href="#替换标准导入系统" class="headerlink" title="替换标准导入系统"></a>替换标准导入系统</h3><ul>
<li><p>替换<code>sys.meta_path</code>为自定义元路径钩子</p>
<ul>
<li>替换整个导入系统最可靠机制</li>
</ul>
</li>
<li><p>替换内置<code>__import__()</code>函数</p>
<ul>
<li>仅改变导入语句行为而不影响访问导入系统其他接口</li>
<li>可以在某个模块层级替换，只改变某块内部导入语句行为</li>
</ul>
</li>
<li><p>替换<code>find_spec()</code>，引发<code>ModuleNotFoundError</code></p>
<ul>
<li>选择性的防止在元路径钩子导入某些模块</li>
</ul>
</li>
</ul>
<h3 id="main"><a href="#main" class="headerlink" title="__main__"></a><code>__main__</code></h3><ul>
<li><code>__main__</code>模块是在解释器启动时直接初始化，类似<code>sys</code>、
<code>builtins</code>，但是不被归类为内置模块，因为其初始化的方式
取决于启动解释器的旗标（命令行参数）</li>
</ul>
<h4 id="spec-1"><a href="#spec-1" class="headerlink" title="__spec__"></a><code>__spec__</code></h4><p>根据<code>__main__</code>被初始化的方式，<code>__main__.__spec__</code>被设置为
<code>None</code>或相应值</p>
<ul>
<li><p><code>-m</code>选项启动：以脚本方式执行模块</p>
<ul>
<li><p>此时<code>__spec__</code>被设置为相应模块、包规格说明</p>
</li>
<li><p><code>__spec__</code>会在<code>__main__</code>模块作为执行某个目录、zip
文件、其他<code>sys.path</code>条目的一部分加载时被填充</p>
</li>
<li><p>此时<code>__main__</code>对应可导入模块和<code>__main__</code>被视为不同
模块</p>
</li>
</ul>
</li>
<li><p>其余情况</p>
<ul>
<li><p><code>__spec__</code>被设置为<code>None</code></p>
</li>
<li><p>因为用于填充<code>__main__</code>的代码不直接与可导入模块相对应</p>
<ul>
<li>交互型提示</li>
<li><code>-c</code>选项</li>
<li>从stdin运行</li>
<li>从源码、字节码文件运行</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><code>-m</code>执行模块时<code>sys.path</code>首个值为空字符串，而直接执行脚本
  时首个值为脚本所在目录</li>
</ul>
</blockquote>
<h2 id="Import-Search-Path定制"><a href="#Import-Search-Path定制" class="headerlink" title="Import[ Search] Path定制"></a><em>Import[ Search] Path</em>定制</h2><h3 id="动态增加路径"><a href="#动态增加路径" class="headerlink" title="动态增加路径"></a>动态增加路径</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.insert(<span class="number">1</span>, /path/to/fold/contains/module)</span><br><span class="line">	<span class="comment"># 临时生效，对不经常使用的模块较好</span></span><br></pre></td></tr></table></figure>
<h3 id="修改PYTHONPATH环境变量"><a href="#修改PYTHONPATH环境变量" class="headerlink" title="修改PYTHONPATH环境变量"></a>修改<code>PYTHONPATH</code>环境变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"> #</span><span class="bash"> .bashrc</span></span><br><span class="line">export PYTHONPATH=$PYTHONPATH:/path/to/fold/contains/module</span><br></pre></td></tr></table></figure>
<ul>
<li>对许多程序都使用的模块可以采取此方式</li>
<li>会改变所有Python应用的搜索路径</li>
</ul>
<h3 id="增加-pth文件"><a href="#增加-pth文件" class="headerlink" title="增加.pth文件"></a>增加<code>.pth</code>文件</h3><p>在<code>/path/to/python/site-packages</code>（或其他查找路径目录）下
添加<code>.pth</code>配置文件，内容为需要添加的路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> # extras.pth</span><br><span class="line">/path/to/fold/contains/module</span><br></pre></td></tr></table></figure>
<ul>
<li>简单、推荐</li>
<li>python在遍历已知库文件目录过程中，遇到<code>.pth</code>文件会将其中
路径加入<code>sys.path</code>中</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-06-05T16:04:02.000Z" title="6/6/2019, 12:04:02 AM">2019-06-06</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-06-05T16:04:02.000Z" title="6/6/2019, 12:04:02 AM">2019-06-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Py3Ref/">Py3Ref</a></span><span class="level-item">42 minutes read (About 6291 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Py3Ref/expressions.html">表达式</a></h1><div class="content"><h2 id="Atoms"><a href="#Atoms" class="headerlink" title="Atoms"></a><em>Atoms</em></h2><p>原子：表达式最基本元素</p>
<ul>
<li><p>最简单原子</p>
<ul>
<li>标识符</li>
<li>字面值</li>
</ul>
</li>
<li><p>以圆括号、方括号、花括号包括的形式在语法上也被归为原子</p>
</li>
</ul>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">atom      ::=  identifier | literal | enclosure</span><br><span class="line">enclosure ::=  parenth_form | list_display | dict_display | set_display | generator_expression | yield_atom</span><br></pre></td></tr></table></figure>
<h3 id="Indentifiers-Names"><a href="#Indentifiers-Names" class="headerlink" title="Indentifiers/Names"></a><em>Indentifiers/Names</em></h3><p>名称：作为原子出现的标识符</p>
<ul>
<li>名称被绑定到对象时：对原子求值将返回相应对象</li>
<li>名称未绑定时：对原子求值将<code>raise NameError</code></li>
</ul>
<h4 id="Private-Name-Mangling"><a href="#Private-Name-Mangling" class="headerlink" title="Private Name Mangling"></a><em>Private Name Mangling</em></h4><blockquote>
<ul>
<li>类的私有名称：文本形式出现在类定义中以两个、更多下划线
  开头且不以两个、更多下划线结尾的标识符</li>
</ul>
</blockquote>
<p>私有名称转换：在为私有名称生成代码前，其被转换为更长形式</p>
<ul>
<li><p>转换方式：在名称前插入类名、下划线</p>
<ul>
<li>若转换后名称太长（超过255字符），<strong>某些实现中</strong>可能
发生截断</li>
</ul>
</li>
<li><p>转换独立于标识符使用的句法</p>
</li>
<li><p>若类名仅由下划线组成，则不会进行转换</p>
</li>
</ul>
<h3 id="Literals"><a href="#Literals" class="headerlink" title="Literals"></a><em>Literals</em></h3><p>字面值：</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">literal ::=  stringliteral | bytesliteral | integer | floatnumber | imagnumber</span><br></pre></td></tr></table></figure>
<ul>
<li><p>对字面值求值将返回改值对应类型的对象</p>
<ul>
<li>对浮点数、复数，值可能为近似值</li>
</ul>
</li>
<li><p>所有字面值都对应不可变数据类型</p>
<ul>
<li>所以对象标识的重要性不如其实际值</li>
</ul>
</li>
<li><p>多次对具有相同值的字面值求值，可能得到相同对象、或具有
相同值的不同对象</p>
<ul>
<li>元组是不可变对象，适用字面值规则：两次出现的空元组
产生对象可能相同、也可能不同<h1 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h1></li>
</ul>
</li>
</ul>
<h3 id="Parenthesized-Forms"><a href="#Parenthesized-Forms" class="headerlink" title="Parenthesized Forms"></a><em>Parenthesized Forms</em></h3><p>带括号形式：包含在<code>()</code>的<strong>可选表达式列表</strong></p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parenth_form ::= <span class="string">&quot;(&quot;</span> [starred_expression] <span class="string">&quot;)&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>带圆括号表达式列表将返回表达式所产生的任何东西</p>
<ul>
<li>内容为空的圆括号返回空元组对象</li>
<li>列表包含至少一个逗号，产生元组</li>
<li>否则，产生表达式列表对应的单一表达式</li>
</ul>
</li>
<li><p>元组不是由圆括号构建，实际是<code>,</code>逗号操作符起作用</p>
<ul>
<li>空元组是例外，此时圆括号必须，因为表达式中不带圆括号
的“空”会导致歧义</li>
</ul>
</li>
</ul>
<h3 id="List-Set-Dict-Generator-Tuple"><a href="#List-Set-Dict-Generator-Tuple" class="headerlink" title="List/Set/Dict/Generator-Tuple"></a><em>List/Set/Dict/Generator-Tuple</em></h3><blockquote>
<ul>
<li><em>display</em>：显式列出容器内容</li>
<li><em>comprehension</em>：推导式，通过循环、筛选指令计算</li>
</ul>
</blockquote>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">comprehension ::=  expression comp_for</span><br><span class="line">comp_for      ::=  [<span class="string">&quot;async&quot;</span>] <span class="string">&quot;for&quot;</span> target_list <span class="string">&quot;in&quot;</span> or_test [comp_iter]</span><br><span class="line">comp_iter     ::=  comp_for | comp_if</span><br><span class="line">comp_if       ::=  <span class="string">&quot;if&quot;</span> expression_nocond [comp_iter]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>推导式结构：单独表达式后加至少一个<code>for</code>子句以及零个、或
多个<code>for</code>或<code>if</code>子句</p>
<ul>
<li><code>for</code>、<code>if</code>子句视为代码块，按<strong>从左到右顺序嵌套</strong>
（类似<code>for</code>循环嵌套）</li>
<li>每次<strong>到达最内层代码块时</strong>对表达式求值以产生元素</li>
</ul>
</li>
<li><p>除最左边<code>for</code>子句中可迭代表达式，推导式在另一个隐式嵌套
作用域内执行</p>
<ul>
<li>确保赋给目标列表的名称不会“泄露”到外层作用域</li>
<li>最左边<code>for</code>子句中可迭代表达式直接在外层作用域中被
求值，然后作为参数传递给隐式嵌套作用域</li>
<li>后续<code>for</code>子句、最左侧<code>for</code>子句中任何筛选条件不能在
外层作用域中被求值，因为其可能依赖于从最左侧可迭代
对象中获得的值</li>
</ul>
</li>
<li><p>为确保推导式总能得到类型正确的容器，隐式嵌套作用域内禁止
使用<code>yield</code>、<code>yield from</code>表达式，因为其会对外层作用域
造成附加影响</p>
</li>
<li><p>若推导式包含<code>async for</code>子句、<code>await</code>表达式，则为异步
推导式</p>
</li>
</ul>
<h4 id="List-Displays"><a href="#List-Displays" class="headerlink" title="List Displays"></a><em>List Displays</em></h4><p>列表显式：用<code>[]</code>方括号括起的、可能为空的表达式系列</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_display ::= <span class="string">&quot;[&quot;</span> [starred_list | comprehesion] <span class="string">&quot;]&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>列表显式会产生新的列表对象，内容通过表达式、推导式指定</li>
<li>提供逗号分隔的表达式时：元素从左至右求值，按此顺序放入
列表对象</li>
<li>提供推导式时：根据推导式产生结果元素进行构建</li>
</ul>
<h4 id="Set-Displays"><a href="#Set-Displays" class="headerlink" title="Set Displays"></a><em>Set Displays</em></h4><p>集合显式：用<code>&#123;&#125;</code>花括号标明，与字典区别在于没有冒号分隔键值</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_display ::=  <span class="string">&quot;&#123;&quot;</span> (starred_list | comprehension) <span class="string">&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>集合显式产生可变集合对象，内容通过表达式、推导式指定</li>
<li>提供逗号分隔的表达式时：元素从左至右求值，按此顺序放入
列表对象</li>
<li>提供推导式时：根据推导式产生结果元素进行构建</li>
</ul>
<blockquote>
<ul>
<li>空集合不能使用<code>&#123;&#125;</code>构建，此构建的是空字典</li>
</ul>
</blockquote>
<h4 id="Dict-Displays"><a href="#Dict-Displays" class="headerlink" title="Dict Displays"></a><em>Dict Displays</em></h4><p>字典显式：用<code>&#123;&#125;</code>花括号括起来的、可能为空的键值对</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dict_display       ::=  <span class="string">&quot;&#123;&quot;</span> [key_datum_list | dict_comprehension] <span class="string">&quot;&#125;&quot;</span></span><br><span class="line">key_datum_list     ::=  key_datum (<span class="string">&quot;,&quot;</span> key_datum)* [<span class="string">&quot;,&quot;</span>]</span><br><span class="line">key_datum          ::=  expression <span class="string">&quot;:&quot;</span> expression | <span class="string">&quot;**&quot;</span> or_expr</span><br><span class="line">dict_comprehension ::=  expression <span class="string">&quot;:&quot;</span> expression comp_for</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>**</code>：映射拆包，操作数必须是映射</li>
</ul>
</blockquote>
<ul>
<li><p>字典显式产生新的字典对象</p>
</li>
<li><p>提供<code>,</code>分隔键值对序列</p>
<ul>
<li>从左至右被求值以定义字典条目</li>
<li>可多次指定相同键，最终值由最后给出键值对决定</li>
</ul>
</li>
<li><p>提供字典推导式</p>
<ul>
<li>以冒号分隔的两个表达式，后者带上标准<code>for</code>、<code>if</code>子句</li>
<li>作为结果键值对按产生顺序被加入新字典</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>键类型需要为hashable</li>
</ul>
</blockquote>
<h3 id="Generator-Expression"><a href="#Generator-Expression" class="headerlink" title="Generator Expression"></a><em>Generator Expression</em></h3><p>生成器表达式：用圆括号括起来的紧凑形式生成器（迭代器）标注</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">generator_expression ::=  <span class="string">&quot;(&quot;</span> expression comp_for <span class="string">&quot;)&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>生成器表达式会产生新的生成器（迭代器）对象</p>
<ul>
<li>句法同推导式，但使用圆括号括起</li>
<li>圆括号在只附带一个参数（省略<code>expression</code>）的调用中
可以被省略</li>
</ul>
</li>
<li><p>生成器表达式中使用的变量在生成器对象调用<code>__next__</code>方法
时以惰性方式被求值，同普通生成器</p>
<ul>
<li>最左侧<code>for</code>子句内可迭代对象会被立即求值，则其造成的
错误会在生成器表达式<strong>被定义时被检测到</strong></li>
</ul>
</li>
</ul>
<h3 id="Yield-Expression"><a href="#Yield-Expression" class="headerlink" title="Yield Expression"></a><em>Yield Expression</em></h3><p>yield表达式：将控制权交还给调度程序</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yield_atom       ::=  <span class="string">&quot;(&quot;</span> yield_expression <span class="string">&quot;)&quot;</span></span><br><span class="line">yield_expression ::=  <span class="string">&quot;yield&quot;</span> [expression_list | <span class="string">&quot;from&quot;</span> expression]</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>yield</code>：返回其后表达式求值</li>
<li>yield表达式是赋值语句右侧唯一表达式时，括号可以省略</li>
</ul>
</blockquote>
<ul>
<li><p>在定义生成器函数、异步生成器函数时才会用到，也只能在函数
定义内部使用yield表达式，将函数变为（异步）生成器函数</p>
</li>
<li><p>yield表达式会对外层作用域造成附带影响，不允许作为实现
推导式、生成器表达式隐式作用域的一部分</p>
</li>
</ul>
<blockquote>
<ul>
<li>生成器、异步生成器参见<em>cs_python/py3ref/dm_gfuncs</em></li>
</ul>
</blockquote>
<h4 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a><code>yield from</code></h4><p><code>yield from</code>：其后表达式视为子迭代器，将控制流委托给其</p>
<ul>
<li><p>类似<strong>管道</strong>，迭代器参数、异常都被传递给子迭代器</p>
<ul>
<li><strong>子迭代器依次迭代结果</strong>被传递给生成器方法调用者</li>
<li><code>.send</code>传递值、<code>.throw</code>生成异常被传递给子迭代器</li>
</ul>
</li>
<li><p><code>.send</code>传入值、<code>.throw</code>传入异常如果有适当方法将被传递给
下层迭代器，否则</p>
<ul>
<li><code>send</code>将<code>raise AttributeError</code>、<code>raise TypeError</code></li>
<li><code>throw</code>将立即引发传入异常</li>
</ul>
</li>
<li><p>子迭代器完成后引发的<code>StopIteration</code>实例的<code>value</code>属性将
作为yield表达式值</p>
<ul>
<li>可以在引发<code>StopIteration</code>时被显式设置#todo</li>
<li>在子迭代器是生成器时通过从子生成器返回值自动设置</li>
</ul>
</li>
<li><p>用途</p>
<ul>
<li>展开嵌套序列</li>
</ul>
</li>
</ul>
<h2 id="Primaries"><a href="#Primaries" class="headerlink" title="Primaries"></a><em>Primaries</em></h2><p>原型：代表编程语言中最紧密绑定的操作（优先级最高）</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">primary ::= atom | attributeref | subscription | slicing | call</span><br></pre></td></tr></table></figure>
<h3 id="Attributeref"><a href="#Attributeref" class="headerlink" title="Attributeref"></a><em>Attributeref</em></h3><p>属性引用：后面带有句点加名称的原型</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">attributeref ::= primary <span class="string">&quot;.&quot;</span> identifier</span><br></pre></td></tr></table></figure>
<ul>
<li>要求值为支持属性引用类型的对象（多数对象支持）</li>
<li>对象会被要求产生以指定标识符为名称的属性<ul>
<li>产生过程可以通过重载<code>__getattr__()</code>方法自定义</li>
</ul>
</li>
</ul>
<h3 id="Subscriptions"><a href="#Subscriptions" class="headerlink" title="Subscriptions"></a><em>Subscriptions</em></h3><p>抽取：在序列（字符串、元组、列表）、映射（字典）对象中选择
一项</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscription ::= primary <span class="string">&quot;[&quot;</span> expression_list <span class="string">&quot;]&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>要求值必须为支持抽取操作的对象</p>
<ul>
<li>可以定义<code>__getitem__()</code>方法支持抽取操作</li>
</ul>
</li>
<li><p>映射：表达式列表求值须为键值</p>
<ul>
<li>抽取操作选择映射中键对应值</li>
<li>表达式列表为元组，除非其中只有一项</li>
</ul>
</li>
<li><p>序列：表达式列表求值须为整数、或切片</p>
<ul>
<li>正式句法规则没有要求实现对负标号值处理，但内置序列
<code>__getitem__()</code>方法结合序列长度解析负标号</li>
<li>重载<code>__getitem__</code>的子类需要显式添加对负标号、切片
支持</li>
</ul>
</li>
</ul>
<h3 id="Slicings"><a href="#Slicings" class="headerlink" title="Slicings"></a><em>Slicings</em></h3><p>切片：在序列对象（字符串、元组、列表）中选择某个范围内的项</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slicing      ::=  primary <span class="string">&quot;[&quot;</span> slice_list <span class="string">&quot;]&quot;</span></span><br><span class="line">slice_list   ::=  slice_item (<span class="string">&quot;,&quot;</span> slice_item)* [<span class="string">&quot;,&quot;</span>]</span><br><span class="line">slice_item   ::=  expression | proper_slice</span><br><span class="line">proper_slice ::=  [lower_bound] <span class="string">&quot;:&quot;</span> [upper_bound] [ <span class="string">&quot;:&quot;</span> [stride] ]</span><br><span class="line">lower_bound  ::=  expression</span><br><span class="line">upper_bound  ::=  expression</span><br><span class="line">stride       ::=  expression</span><br></pre></td></tr></table></figure>
<ul>
<li><p>可以用作表达式赋值、<code>del</code>语句的目标</p>
</li>
<li><p>形似表达式列表的东西同样形似切片列表，所以任何抽取操作
都可以被解析为切片</p>
<ul>
<li>通过定义将此情况解析为抽取优先于切片以消除歧义</li>
</ul>
</li>
<li><p>原型使用<code>__getitem__</code>、根据切片列表构造的键进行索引</p>
<ul>
<li>切片列表包含逗号：键将为包含切片项转换的元组</li>
<li>否则：键为单个切片项的转换</li>
<li>切片项若为表达式：切片的转换即为切片对象</li>
</ul>
</li>
</ul>
<h3 id="Calling"><a href="#Calling" class="headerlink" title="Calling"></a><em>Calling</em></h3><p>调用：附带可能为空的一系列参数来执行可调用对象</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">call                 ::=  primary <span class="string">&quot;(&quot;</span> [argument_list [<span class="string">&quot;,&quot;</span>] | comprehension] <span class="string">&quot;)&quot;</span></span><br><span class="line">argument_list        ::=  positional_arguments [<span class="string">&quot;,&quot;</span> starred_and_keywords]</span><br><span class="line">                            [&quot;,&quot; keywords_arguments]</span><br><span class="line">                          | starred_and_keywords [&quot;,&quot; keywords_arguments]</span><br><span class="line">                          | keywords_arguments</span><br><span class="line">positional_arguments ::=  [<span class="string">&quot;*&quot;</span>] expression (<span class="string">&quot;,&quot;</span> [<span class="string">&quot;*&quot;</span>] expression)*</span><br><span class="line">starred_and_keywords ::=  (<span class="string">&quot;*&quot;</span> expression | keyword_item)</span><br><span class="line">                          (&quot;,&quot; &quot;*&quot; expression | &quot;,&quot; keyword_item)*</span><br><span class="line">keywords_arguments   ::=  (keyword_item | <span class="string">&quot;**&quot;</span> expression)</span><br><span class="line">                          (&quot;,&quot; keyword_item | &quot;,&quot; &quot;**&quot; expression)*</span><br><span class="line">keyword_item         ::=  identifier <span class="string">&quot;=&quot;</span> expression</span><br></pre></td></tr></table></figure>
<ul>
<li><p>要求值为可调用对象</p>
<ul>
<li>用户定义函数</li>
<li>内置函数</li>
<li>内置对象方法</li>
<li>类对象</li>
<li>类实例方法</li>
<li>任何具有<code>__call__()</code>方法的对象</li>
</ul>
</li>
<li><p>调用流程</p>
<ul>
<li>参数表达式在尝试调用前被求值</li>
<li>所有参数表达式被转换为参数列表</li>
<li>代码块将形参绑定到对应参数表达式值</li>
</ul>
</li>
<li><p>除非引发异常，调用总有返回值</p>
<ul>
<li>返回值可能为<code>None</code></li>
<li>返回值计算方式取决于可调用类型<ul>
<li>用户定义函数、实例方法、类实例：函数返回值</li>
<li>内置函数：依赖于编译器</li>
<li>内置对象方法：类新实例</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>在位置参数、关键字参数后加上括号不影响语义</li>
</ul>
</blockquote>
<h4 id="关键字实参转位置实参"><a href="#关键字实参转位置实参" class="headerlink" title="关键字实参转位置实参"></a>关键字实参转位置实参</h4><p>若存在关键字实参，会通过以下操作被转换为位置参数</p>
<ul>
<li>为正式参数创建<strong>未填充空位的列表</strong></li>
<li>若有N个位置参数：将其放入前N个空位</li>
<li>对每个关键字参数<ul>
<li>使用标识符确定对应的空位：若标识符与第k个正式
参数名相同，使用第k个空位</li>
<li>若空位已被填充：则<code>raise TypeError</code></li>
<li>否则将参数值放入空位进行填充</li>
</ul>
</li>
<li>所有参数处理完毕后，未填充空位使用默认值填充</li>
<li>若仍有未填充空位，则<code>raise TypeError</code>；否则<strong>填充完毕</strong>
列表被作为调用的参数列表</li>
</ul>
<h4 id="多余实参"><a href="#多余实参" class="headerlink" title="多余实参"></a>多余实参</h4><ul>
<li><p>若有关键字参数没有与之对应的正式参数名称，将
<code>raise TypeError</code>，除非有形参使用<code>**indentifier</code>句法</p>
<ul>
<li><code>identifier</code>将被初始化新的有序映射接收任何额外关键字
参数</li>
<li>若没有多余关键字实参，则为相同类型空映射</li>
</ul>
</li>
<li><p>若位置实参数目多余位置形参数目，将<code>raise TypeError</code>，
除非有形参使用<code>*identifier</code>句法</p>
<ul>
<li><code>identifier</code>将初始化为元组接受任何额外位置参数</li>
<li>没有多余位置实参，则为空元组</li>
</ul>
</li>
</ul>
<h4 id="实参解包"><a href="#实参解包" class="headerlink" title="实参解包"></a>实参解包</h4><ul>
<li><p>若实参中出现<code>*expression</code>句法</p>
<ul>
<li><code>expression</code>求值须为<code>iterable</code></li>
<li>来自该可迭代对象的元素被当作额外位置实参</li>
<li><p><code>*expression</code>可以放在关键字实参后而没有语法错误</p>
<ul>
<li><code>expression</code>会优先被迭代，元素用于填充参数列表</li>
<li>可能和关键字参数冲突，导致关键字参数对应空位被
填充</li>
</ul>
<blockquote>
<ul>
<li>一般位置实参必须位于关键字实参前，否则有语法错误</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>若实参中出现<code>**expresion</code>句法</p>
<ul>
<li><code>expression</code>求值须为<code>mapping</code></li>
<li>其内容被当作额外关键字参数<ul>
<li>若关键字已存在，将<code>raise TypeError</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li><p>运算符优先级：从低到高</p>
<p>|运算符|描述|
|——-|——-|
|<code>lambda</code>|lambda表达式|
|<code>if--else</code>|条件表达式|
|<code>or</code>|布尔逻辑或|
|<code>and</code>|布尔逻辑与|
|<code>not</code>|布尔逻辑非|
|<code>in</code>、<code>not in</code>、<code>is</code>、<code>is not</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>=&gt;</code>、<code>!=</code>、<code>==</code>|比较运算，包括成员检测、标识号检测|
|<code>|</code>|按位或|
|<code>^</code>|按位异或|
|<code>&amp;</code>|按位与|
|<code>&lt;&lt;</code>、<code>&gt;&gt;</code>|移位|
|<code>+</code>、<code>-</code>|加、减|
|<code>*</code>、<code>@</code>、<code>/</code>、<code>//</code>、<code>%</code>|乘、矩阵乘、除、整除、取余（字符串格式化）|
|<code>+x</code>、<code>-x</code>、<code>~x</code>|正、负、按位取反|
|<code>**</code>|幂次|
|<code>await</code>|await表达式|
|<code>x[index]</code>、<code>x[start:end]</code>、<code>x(arguments...)</code>|抽取、切片、调用、属性调用|
|<code>(expression...)</code>、<code>[expressions...]</code>、<code>&#123;key:value&#125;</code>、<code>&#123;expressions...&#125;</code>|绑定或元组、列表、字典、集合显示|</p>
</li>
<li><p>求值顺序：从左至右对表达式求值</p>
<ul>
<li>但赋值操作时，右侧先于左侧求值</li>
</ul>
</li>
<li><p>算术类型转换</p>
<ul>
<li>若任意参数为复数，另一参数转换为复数</li>
<li>否则，若任意参数为浮点数，另一参数为浮点数</li>
<li>否则，二者均为整数，不需要转换</li>
</ul>
</li>
</ul>
<h3 id="await"><a href="#await" class="headerlink" title="await"></a><code>await</code></h3><p><code>await</code>：挂起coroutine执行以等待awaitable对象</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await_expr ::= <span class="string">&quot;await&quot;</span> primary</span><br></pre></td></tr></table></figure>
<ul>
<li>只能在协程函数中使用</li>
</ul>
<h3 id="幂运算符"><a href="#幂运算符" class="headerlink" title="幂运算符"></a>幂运算符</h3><p>幂运算符</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">power ::= (await_expr | primary) [<span class="string">&quot;**&quot;</span> u_expr]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>优先级高于左侧一元运算符、低于右侧一元运算符</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">1</span> ** <span class="number">2</span> == -<span class="number">1</span></span><br><span class="line"><span class="number">0</span> ** <span class="number">0</span> == <span class="number">1</span></span><br><span class="line">	<span class="comment"># 编程语言得普遍做法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>语义同两个参数调用内置<code>power</code>函数</p>
<ul>
<li>左参数进行右参数所指定的幂次乘方运算</li>
<li>数值参数会转换为相同类型，返回转换后类型<ul>
<li><code>int</code>类型做负数幂次：参数转换为<code>float</code></li>
<li><code>0</code>进行负数幂次：<code>raise ZeroDivisionError</code></li>
<li>负数进行分数次幂次：返回<code>complex</code>类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="一元算术、位运算"><a href="#一元算术、位运算" class="headerlink" title="一元算术、位运算"></a>一元算术、位运算</h3><p>一元算术、位运算</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u_expr ::= power | <span class="string">&quot;-&quot;</span> u_expr | <span class="string">&quot;+&quot;</span> u_expr | <span class="string">&quot;~&quot;</span> u_expr</span><br></pre></td></tr></table></figure>
<ul>
<li>一元算数、位运算具有相同优先级</li>
<li>若参数类型不正确将<code>raise TypeError</code><ul>
<li><code>+</code>：产生数值参数相同的值</li>
<li><code>-</code>：产生数值参数的负值</li>
<li><code>~</code>：只作用于整数，对整数参数按位取反，返回<code>-(x+1)</code>
（即负值使用补码存储）</li>
</ul>
</li>
</ul>
<h3 id="二元算术运算符"><a href="#二元算术运算符" class="headerlink" title="二元算术运算符"></a>二元算术运算符</h3><p>二元算术运算符</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m_expr ::=  u_expr | m_expr <span class="string">&quot;*&quot;</span> u_expr | m_expr <span class="string">&quot;@&quot;</span> m_expr |</span><br><span class="line">            m_expr &quot;//&quot; u_expr | m_expr &quot;/&quot; u_expr |</span><br><span class="line">            m_expr &quot;%&quot; u_expr</span><br><span class="line">a_expr ::=  m_expr | a_expr <span class="string">&quot;+&quot;</span> m_expr | a_expr <span class="string">&quot;-&quot;</span> m_expr</span><br></pre></td></tr></table></figure>
<ul>
<li><p>二元算术运算符遵循传统优先级，除幂运算符外只有两个优先
级别</p>
<ul>
<li>乘法型</li>
<li>加法型</li>
</ul>
</li>
<li><p>python支持混合算术，二元运算符可以用于不同类型操作数</p>
<ul>
<li>精度较低者会被扩展为另一个操作数类型</li>
</ul>
</li>
</ul>
<h4 id="算符说明"><a href="#算符说明" class="headerlink" title="算符说明"></a>算符说明</h4><ul>
<li><p><code>@</code>：目标是用于矩阵乘法，没有内置类型实现此运算符</p>
</li>
<li><p><code>%</code>：模，输出第1个参数除以第2个参数的余数</p>
<ul>
<li>参数可以是浮点数</li>
<li>结果正负总是与第2个操作数一致、或为0</li>
<li>结果绝对值一定小于第2个操作数绝对值（数学上必然真，
但对浮点数而言由于舍入误差存在，数值上未必真）</li>
</ul>
</li>
<li><p><code>//</code>：整除，结果就是<code>floor</code>函数处理算术除法<code>/</code>的结果</p>
<ul>
<li>整除、模语义同内置函数<code>divmod(x,y) == (x//y, x%y)</code></li>
<li>若<code>x</code>接近<code>y</code>的整数倍，由于舍入误差的存在，<code>x//y</code>可能
大于<code>(x-x%y)//y</code>，此时python返回后一个结果，保证
<code>divmod(x,y)[0]*y + x % y</code>尽量接近<code>x</code></li>
</ul>
</li>
<li><p>某些运算符也作用于特定非数字类型</p>
<ul>
<li><code>*</code>：两个参数分别为整数、序列，执行<strong>序列重复</strong></li>
<li><code>%</code>：被字符串对象重载，用于执行旧式字符串格式化/插值</li>
<li><code>+</code>：两个参数为相同类型序列，执行序列拼接操作</li>
</ul>
</li>
</ul>
<h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><p>移位运算</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shift_expr ::= a_expr | shift_expr (<span class="string">&quot;&lt;&lt;&quot;</span> | <span class="string">&quot;&gt;&gt;&quot;</span>) a_expr</span><br></pre></td></tr></table></figure>
<ul>
<li>优先级低于算术运算</li>
<li>运算符接受整数参数<ul>
<li>将第一个参数左移、右移第二个参数指定的bit数</li>
<li>右移：<code>x &gt;&gt; n == x // power(2, n)</code></li>
<li>左移：<code>x &lt;&lt; n == x * power(2, n)</code></li>
</ul>
</li>
</ul>
<h3 id="二元位运算"><a href="#二元位运算" class="headerlink" title="二元位运算"></a>二元位运算</h3><p>二元位运算</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">and_expr ::=  shift_expr | and_expr <span class="string">&quot;&amp;&quot;</span> shift_expr</span><br><span class="line">xor_expr ::=  and_expr | xor_expr <span class="string">&quot;^&quot;</span> and_expr</span><br><span class="line">or_expr  ::=  xor_expr | or_expr <span class="string">&quot;|&quot;</span> xor_expr</span><br></pre></td></tr></table></figure>
<ul>
<li><p>三种位运算符具有不同的优先级</p>
</li>
<li><p>两个参数须为整数</p>
<ul>
<li><code>&amp;</code>：对两个参数进行按位<em>AND</em>运算</li>
<li><code>^</code>：对两个参数进行按位<em>XOR</em>运算</li>
<li><code>|</code>：对两个参数进行按位<em>OR</em>运算</li>
</ul>
</li>
</ul>
<h3 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h3><p>比较运算</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">comparison    ::=  or_expr (comp_operator or_expr)*</span><br><span class="line">comp_operator ::=  <span class="string">&quot;&lt;&quot;</span> | <span class="string">&quot;&gt;&quot;</span> | <span class="string">&quot;==&quot;</span> | <span class="string">&quot;&gt;=&quot;</span> | <span class="string">&quot;&lt;=&quot;</span> | <span class="string">&quot;!=&quot;</span></span><br><span class="line">                   | &quot;is&quot; [&quot;not&quot;] | [&quot;not&quot;] &quot;in&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>所有比较运算优先级相同（与C不同）</p>
<ul>
<li>低于任何算术、移位、位运算</li>
</ul>
</li>
<li><p>比较运算可以任意串联<code>a  op1 b op2 c ... y opN z</code>等价于
<code>a op1 b and b op2 c and ... and y opN z</code></p>
<ul>
<li><p>只是后者中每个表达式最多只被求值一次</p>
</li>
<li><p>例：<code>a &lt; b &gt;= c</code>类似表达式会被按照传统比较法则解读</p>
<ul>
<li>等价<code>a &lt; b and b &gt;= c</code></li>
<li>仍具有短路求值特性，<code>a &lt; b == false</code>时，<code>c</code>不会
被求值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="值比较"><a href="#值比较" class="headerlink" title="值比较"></a>值比较</h4><ul>
<li><p><code>&gt;</code>、<code>&lt;</code>、<code>==</code>、<code>!=</code>、<code>&lt;=</code>、<code>&gt;=</code>比较两个对象值</p>
<ul>
<li>不要求两个对象为相同类型</li>
</ul>
<blockquote>
<ul>
<li>比较运算符实现了<strong>特定对象值概念</strong>，可以认为是通过
 实现对象比较间接定义对象值</li>
</ul>
</blockquote>
</li>
<li><p>所有类型继承于<code>object</code>，从其继承了默认比较行为</p>
<ul>
<li><p><code>=</code>、<code>!=</code>：一致性比较，基于对象标识<code>id</code></p>
<ul>
<li>具有相同标识的实例一致性比较结果相等</li>
<li>此默认行为动机：希望对象都应该是自反射，即
<code>x is y</code>就意味着<code>x == y</code></li>
</ul>
</li>
<li><p><code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>：没有默认值提供</p>
<ul>
<li>尝试比较<code>raise TypeError</code></li>
<li>此默认行为动机：缺少一致性比较类似固定值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h5><p>数字类型：<code>int</code>、<code>float</code>、<code>complex</code>以及标准库类型
<code>fractions.Fraction</code>、<code>decimal.Decimal</code></p>
<ul>
<li><p>可进行类型内部、跨类型比较</p>
<ul>
<li>类型相关限制内按数学（算法）规则正确进行比较，且不会
有精度损失</li>
<li>复数不支持次序比较</li>
</ul>
</li>
<li><p>非数字值<code>float(&#39;NaN&#39;)</code>、<code>decimal.Decimal(&#39;NaN&#39;)</code></p>
<ul>
<li>同任何其他数字值比较均返回<code>False</code></li>
<li><strong>不等于自身</strong>，但是是同一个对象（标识相同）</li>
</ul>
<blockquote>
<ul>
<li>具体实现参见<em>cs_python/py3ref/#todo</em></li>
</ul>
</blockquote>
</li>
</ul>
<h5 id="二进制码序列"><a href="#二进制码序列" class="headerlink" title="二进制码序列"></a>二进制码序列</h5><p>二进制码序列：<code>bytes</code>、<code>bytearray</code></p>
<ul>
<li>可以进行类型内部、跨类型比较</li>
<li>使用元素数字值按字典序进行比较</li>
</ul>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>字符串：<code>str</code></p>
<ul>
<li>使用字符的Unicode码位数字值、按字典序比较</li>
<li>字符串、二进制码序列不能直接比较</li>
</ul>
<h5 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h5><p>序列：<code>tuple</code>、<code>list</code>、<code>range</code></p>
<ul>
<li><p>只能进行类型内部比较</p>
<ul>
<li>跨类型：一致性比较结果为否、次序比较将
<code>raise TypeError</code></li>
<li><code>range</code>不支持次序比较</li>
</ul>
</li>
<li><p>序列元素通过相应元素进行字典序比较</p>
<ul>
<li>序列相等：相同类型、相同长度，每对相应元素必须 相等</li>
<li>对支持次序比较序列：排序同第一个不相等元素排序，若
对应元素不同，较短序列排序较小</li>
</ul>
</li>
<li><p>强制规定元素自反射性：序列元素<code>x</code>，<code>x==x</code>总为真</p>
<ul>
<li><p>即序列元素比较比较时：须首先比较元素标识，仅会对不同
元素执行<code>==</code>严格比较运算</p>
</li>
<li><p>若序列元素为自反射元素，结果与严格比较相同；若序列
元素为非自反射元素，结果与严格比较不同</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nan = <span class="built_in">float</span>(<span class="string">&quot;NaN&quot;</span>)</span><br><span class="line">(nan <span class="keyword">is</span> nan) == <span class="literal">True</span></span><br><span class="line">(nan == nan) == <span class="literal">False</span></span><br><span class="line">([nan] == [nan]) == <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h5 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h5><p>映射：<code>dict</code></p>
<ul>
<li>映射相等：当且进行具有相同键值对<ul>
<li>键、值一致性比较强制规定自反射性</li>
</ul>
</li>
</ul>
<h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5><p>集合：<code>set</code>、<code>frozenset</code></p>
<ul>
<li><p>可进行类型内部、跨类型比较</p>
</li>
<li><p>比较运算符定义为子集、超集检测</p>
<ul>
<li>这类关系没有定义完全排序，如：<code>&#123;1,2&#125;</code>、<code>&#123;2,3&#125;</code>集合
不相等，也没有大小比较关系</li>
<li>所以，集合不应作为依赖完全排序的函数参数，如：
<code>min</code>、<code>max</code>、<code>sorted</code>，将产生未定义结果</li>
</ul>
</li>
<li><p>集合强制规定其元素自反射性</p>
</li>
</ul>
<h5 id="自定比较行为"><a href="#自定比较行为" class="headerlink" title="自定比较行为"></a>自定比较行为</h5><blockquote>
<ul>
<li>其他内置类型没有实现比较方法，继承<code>object</code>默认比较行为</li>
<li>可以通过实现<strong>富比较方法</strong>自定义类型的比较行为，最好
  遵守一些一致性规则（不强制）</li>
</ul>
</blockquote>
<ul>
<li><p>自反射：相同对象比较应该相等</p>
<ul>
<li><code>x is y</code>有<code>x == y</code></li>
</ul>
</li>
<li><p>对称性</p>
<ul>
<li><code>x == y</code>有<code>y == x</code></li>
<li><code>x != y</code>有<code>y != x</code></li>
<li><code>x &lt; y</code>有<code>y &gt; x</code></li>
<li><code>x &lt;= y</code>有<code>y &gt;= x</code></li>
</ul>
</li>
<li><p>可传递</p>
<ul>
<li><code>x &gt; y and y &gt; z</code>有<code>x &gt; z</code></li>
<li><code>x &lt; y and y &lt;= z</code>有<code>x &lt; z</code></li>
</ul>
</li>
<li><p>反向比较应该导致布尔取反</p>
<ul>
<li><code>x == y</code>有<code>not x != y</code></li>
<li><code>x &lt; y</code>有<code>not x &gt;= y</code>（对完全排序）</li>
<li><code>x &gt; y</code>有<code>not x &lt;= y</code>（对完全排序）</li>
</ul>
</li>
<li><p>相等对象应该具有相同hash值，或标记为不可hash</p>
</li>
</ul>
<blockquote>
<ul>
<li>具体实现参见<em>cs_python/py3ref/#todo</em></li>
</ul>
</blockquote>
<h4 id="成员检测"><a href="#成员检测" class="headerlink" title="成员检测"></a>成员检测</h4><p><code>in</code>、<code>not in</code>：成员检测，后者为前者取反</p>
<ul>
<li><p>对<code>list</code>、<code>tuple</code>、<code>set</code>、<code>frozenset</code>、<code>dict</code>、
<code>collections.deque</code>等<strong>内置</strong>容器类型</p>
<ul>
<li><code>x in y</code>同<code>any(x is e or x == e for e in y)</code></li>
<li>映射检测是否有给定键</li>
</ul>
</li>
<li><p>对字符串、字节串</p>
<ul>
<li>当且进当<code>x</code>为<code>y</code>其子串时<code>x in y</code>返回<code>True</code>，空字符串
总被视为其他字符串子串</li>
<li><code>x in y</code>等价于<code>y.find(x) != -1</code></li>
</ul>
</li>
<li><p>自定义类型可以自定义成员检测</p>
<ul>
<li><code>__contains__</code>方法返回值即为<code>x in y</code>返回值</li>
<li>未定义<code>__contains__</code>方法但定义<code>__iter__</code>，若迭代<code>y</code>
得到值<code>z == x</code>，则<code>x in y == True</code>，出现异常等同于
<code>in</code>引发异常</li>
</ul>
<blockquote>
<ul>
<li>具体实现参见<em>cs_python/py3ref/#todo</em></li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="标识号比较"><a href="#标识号比较" class="headerlink" title="标识号比较"></a>标识号比较</h4><p><code>is</code>、<code>is not</code>：对象标识号检测，后者为前者取反</p>
<ul>
<li>当且仅当<code>x</code>、<code>y</code>为同一对象<code>x is y == True</code></li>
</ul>
<h3 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h3><p>布尔运算</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">or_test  ::=  and_test | or_test <span class="string">&quot;or&quot;</span> and_test</span><br><span class="line">and_test ::=  not_test | and_test <span class="string">&quot;and&quot;</span> not_test</span><br><span class="line">not_test ::=  comparison | <span class="string">&quot;not&quot;</span> not_test</span><br></pre></td></tr></table></figure>
<ul>
<li><p>执行布尔运算、表达式用于流程控制语句时，以下值被解析为
假值，其余值被解析为真值</p>
<ul>
<li><code>False</code></li>
<li><code>None</code></li>
<li>所有数值类型的数值0</li>
<li>空字符串</li>
<li>空容器</li>
</ul>
</li>
<li><p><code>and</code>、<code>or</code><strong>返回最终求值参数</strong>而不是<code>False</code>、<code>True</code></p>
<ul>
<li><p><code>x and y</code>：首先对<code>x</code>求值</p>
<ul>
<li>对<code>x</code>求值，若为假直接返回<code>x</code><strong>求值</strong></li>
<li>否则对<code>y</code><strong>求值并返回</strong></li>
</ul>
</li>
<li><p><code>x or y</code>：首先对<code>x</code>求值</p>
<ul>
<li>对<code>x</code>求值，若为真直接返回<code>x</code><strong>求值</strong></li>
<li>否则对<code>y</code><strong>求值并返回结果值</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><code>not</code>必须创建新值，无论参数为和类型均范围布尔值<code>True</code>、
<code>False</code></p>
</li>
<li><p>可以通过自定义<code>__bool__</code>方法定制逻辑值</p>
<blockquote>
<ul>
<li>具体实现参见<em>cs_python/py3ref/#todo</em></li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><p>条件表达式：三元运算符</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conditional_expression ::=  or_test [<span class="string">&quot;if&quot;</span> or_test <span class="string">&quot;else&quot;</span> expression]</span><br><span class="line">expression             ::=  conditional_expression | lambda_expr</span><br><span class="line">expression_nocond      ::=  or_test | lambda_expr_nocond</span><br></pre></td></tr></table></figure>
<ul>
<li>在所有python运算中具有最低优先级</li>
<li><code>x if C else y</code><ul>
<li>首先对条件<code>C</code>求值</li>
<li>若<code>C</code>为真，<code>x</code>被求值并返回</li>
<li>否则将对<code>y</code>求值并返回</li>
</ul>
</li>
</ul>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a><code>lambda</code>表达式</h3><p><code>lambda</code>表达式：创建匿名函数</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lambda_expr        ::=  <span class="string">&quot;lambda&quot;</span> [parameter_list] <span class="string">&quot;:&quot;</span> expression</span><br><span class="line">lambda_expr_nocond ::=  <span class="string">&quot;lambda&quot;</span> [parameter_list] <span class="string">&quot;:&quot;</span> expression_nocond</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>lambda parameters: expression</code>返回函数对象，同</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> &lt;<span class="title">lambda</span>&gt;(<span class="params">parameters</span>):</span></span><br><span class="line">	<span class="keyword">return</span> expression</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<ul>
<li><code>lambda</code>表达式只是简单函数定义的简单写法</li>
</ul>
</blockquote>
<h3 id="表达式列表"><a href="#表达式列表" class="headerlink" title="表达式列表"></a>表达式列表</h3><p>表达式列表：除作为列表、集合显示的一部分，包含至少一个逗号
的列表表达式将生成元组</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expression_list    ::=  expression (<span class="string">&quot;,&quot;</span> expression)* [<span class="string">&quot;,&quot;</span>]</span><br><span class="line">starred_list       ::=  starred_item (<span class="string">&quot;,&quot;</span> starred_item)* [<span class="string">&quot;,&quot;</span>]</span><br><span class="line">starred_expression ::=  expression | (starred_item <span class="string">&quot;,&quot;</span>)* [starred_item]</span><br><span class="line">starred_item       ::=  expression | <span class="string">&quot;*&quot;</span> or_expr</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>末尾逗号仅在创建单独元组时需要，在其他情况下可选</li>
</ul>
</blockquote>
<ul>
<li><p>元组长度就是列表中表达式的数量</p>
<ul>
<li>表达式将从左至右被求值</li>
</ul>
</li>
<li><p><code>*</code>表示可迭代拆包：操作数必须为<em>iterable</em>（同实参调用）</p>
<ul>
<li>可迭代对象将被拆解为迭代项序列，并被包含于新建的元组
、列表、集合中</li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-06-05T12:46:24.000Z" title="6/5/2019, 8:46:24 PM">2019-06-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-06-05T12:46:24.000Z" title="6/5/2019, 8:46:24 PM">2019-06-05</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Py3std/">Py3std</a></span><span class="level-item">a few seconds read (About 67 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Py3std/README.html">Python标准库</a></h1><div class="content"><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><ul>
<li>内置类型相关参见<em>cs_python/py3ref/dm_basics</em></li>
</ul>
<h2 id="常用参数说明"><a href="#常用参数说明" class="headerlink" title="常用参数说明"></a>常用参数说明</h2><h3 id="Functional-Programming"><a href="#Functional-Programming" class="headerlink" title="Functional Programming"></a><em>Functional Programming</em></h3><ul>
<li><p><code>key=None/callable</code></p>
<ul>
<li>含义：key函数，接受一个参数，返回用于排序的值</li>
<li>默认：<code>None</code>，不处理</li>
</ul>
</li>
<li><p><code>iterable=iterable</code></p>
<ul>
<li>含义：可迭代对象</li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-06-05T03:05:43.000Z" title="6/5/2019, 11:05:43 AM">2019-06-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-08-02T03:44:48.000Z" title="8/2/2021, 11:44:48 AM">2021-08-02</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Py3Ref/">Py3Ref</a></span><span class="level-item">36 minutes read (About 5341 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Py3Ref/dm_basics.html">数据模型--基本数据类型</a></h1><div class="content"><h2 id="对象、值、类型"><a href="#对象、值、类型" class="headerlink" title="对象、值、类型"></a>对象、值、类型</h2><p>对象：python中对数据的抽象</p>
<ul>
<li><p>python中所有数据都是由对象、对象间关系表示</p>
<ul>
<li>按冯诺依曼“存储程序计算机”，代码本身也是由对象表示</li>
</ul>
</li>
</ul>
<h3 id="编号、类型、值"><a href="#编号、类型、值" class="headerlink" title="编号、类型、值"></a>编号、类型、值</h3><p>每个对象都有各自<strong>编号</strong>、<strong>类型</strong>、<strong>值</strong></p>
<ul>
<li><p>编号：可以视为对象在内存中地址，对象创建后不变</p>
<ul>
<li><code>id()</code>函数：获取代表对象编号的整形</li>
<li><code>is</code>算符：比较对象编号判断是否为同一对象</li>
</ul>
</li>
<li><p>类型：决定对象支持的操作、可能取值</p>
<ul>
<li>类型会影响对象行为几乎所有方面，甚至对象编号重要性
也受到影响，如：对于会得到新值的运算<ul>
<li>不可变类型：可能返回同类型、同取值现有对象引用<ul>
<li><code>a = b = 1</code>：<code>a</code>、<code>b</code>可能指向相同对象<code>1</code>
（取决于具体实现）</li>
</ul>
</li>
<li>可变类型：不允许返回已存在对象<ul>
<li><code>c=[];d=[]</code>：会保证<code>c</code>、<code>d</code>指向不同、单独
空列表（<code>c=d=[]</code>将同一对象赋给<code>c</code>、<code>d</code>）</li>
</ul>
</li>
</ul>
</li>
<li>对象创建后保持不变</li>
<li><code>type</code>：返回对象类型</li>
</ul>
<blockquote>
<ul>
<li>CPython：相同整形值都引用同一个对象</li>
</ul>
</blockquote>
</li>
<li><p>值：通过一些特征行为表征的抽象概念</p>
<ul>
<li><p>对象值在python中是抽象概念</p>
<ul>
<li>对象值没有规范的访问方法</li>
<li>不要求具有特定的构建方式，如：值由其全部数据
属性组成</li>
</ul>
</li>
<li><p>对象值可变性由其类型决定</p>
<ul>
<li>可变的：值可以改变的对象</li>
<li>不可变的：值（直接包含对象编号）不可改变的对象</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>比较运算符实现了<strong>特定对象值概念</strong>，可以认为是
 通过实现对象比较间接定义对象值</li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>CPython：<code>id(x)</code>返回存放<code>x</code>的地址</li>
</ul>
</blockquote>
<h3 id="对象销毁"><a href="#对象销毁" class="headerlink" title="对象销毁"></a>对象销毁</h3><p>对象不会被显式销毁（<code>del</code>仅是移除名称绑定）</p>
<ul>
<li><p>无法访问时<strong>可能</strong>被作为垃圾回收</p>
<ul>
<li>允许具体实现推迟垃圾回收或完全省略此机制</li>
<li>实现垃圾回收是质量问题，只要可访问对象不会被回收
即可</li>
<li>不要依赖不可访问对象的立即终结机制，应当总是显式
关闭外部资源引用</li>
</ul>
</li>
<li><p>以下情况下，正常应该被回收的对象可能继续存活</p>
<ul>
<li>使用实现的跟踪、调试功能</li>
<li>通过<code>try...except...</code>语句捕捉异常</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>CPython：使用带有（可选）<strong>延迟检测循环链接垃圾</strong>的
  引用计数方案<blockquote>
<ul>
<li>对象<strong>不可访问</strong>时立即回收其中大部分，但不保证
 回收包含<strong>循环引用</strong>的垃圾</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="标准类型层级结构"><a href="#标准类型层级结构" class="headerlink" title="标准类型层级结构"></a>标准类型层级结构</h3><blockquote>
<ul>
<li>以下是python内置类型的列表，扩展模块可以定义更多类型</li>
<li>以下有些类型有特殊属性，这些特殊属性不应用作通常使用，
  其定义在未来可能改变</li>
</ul>
</blockquote>
<h2 id="None"><a href="#None" class="headerlink" title="None"></a><code>None</code></h2><p><code>NoneType</code>：只有一种取值，<code>None</code>是具有此值的唯一对象</p>
<ul>
<li>通过内置名称<code>None</code>访问</li>
<li>多数情况表示空值，如<ul>
<li>未显式指明返回值函数返回<code>None</code></li>
</ul>
</li>
<li>逻辑值：假</li>
</ul>
<h2 id="NotImplemented"><a href="#NotImplemented" class="headerlink" title="NotImplemented"></a><code>NotImplemented</code></h2><p><code>NotImplementedType</code>：只有一种取值，<code>NotImplemented</code>是具有
此值的唯一对象</p>
<ul>
<li>通过内置名称<code>NotImplemented</code>访问</li>
<li>数值、富比较方法在操作数没有该实现操作时应返回此值<ul>
<li>返回<code>NotImplemented</code>前，解释器会依据运算符尝试反射
方法、委托回退方法</li>
</ul>
</li>
<li>逻辑值：真</li>
</ul>
<h2 id="Ellipsis"><a href="#Ellipsis" class="headerlink" title="Ellipsis"></a><code>Ellipsis</code></h2><p><code>ellipsis</code>：只有一种取值，<code>Ellipsis</code>是具有此值的唯一对象</p>
<ul>
<li>通过字面值<code>...</code>、内置名称<code>Ellipsis</code>访问</li>
<li>逻辑值：真</li>
</ul>
<h2 id="numbers-Number"><a href="#numbers-Number" class="headerlink" title="numbers.Number"></a><code>numbers.Number</code></h2><p><code>number.Number</code>：由数字字面值创建，被作为算法运算符、算数
内置函数返回结果</p>
<ul>
<li>不可变：一旦创建其值不再改变</li>
<li>类似数学中数字，但也受限于计算机对数字的表示方法</li>
</ul>
<h3 id="numbers-Integral"><a href="#numbers-Integral" class="headerlink" title="numbers.Integral"></a><code>numbers.Integral</code></h3><p><code>numbers.Integral</code>：表示数学中整数集合</p>
<ul>
<li><p><code>int</code>：整形，表示<strong>任意大小数字，仅受限于可用内存</strong></p>
<ul>
<li>变换、掩码运算中以二进制表示</li>
<li>负数以2的补码表示（类似符号位向左延伸补满空位）</li>
</ul>
</li>
<li><p><code>bool</code>：布尔型，表示逻辑值真、假</p>
<ul>
<li><code>True</code>、<code>False</code>是唯二两个布尔对象</li>
<li>整形子类型：在各类场合中行为类似整形<code>1</code>、<code>0</code>，仅在
转换为字符串时返回<code>&quot;True&quot;</code>、<code>&quot;False&quot;</code></li>
</ul>
</li>
</ul>
<h4 id="方法、函数"><a href="#方法、函数" class="headerlink" title="方法、函数"></a>方法、函数</h4><ul>
<li><code>int.bit_length()</code>：不包括符号位、开头0位长</li>
<li><code>int.to_bytes(length, byteorder, *, signed=False)</code></li>
<li><code>class int.from_bytes(bytes, byteorder, *, signed=False)</code></li>
</ul>
<blockquote>
<ul>
<li>详细说明参见<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#additional-methods-on-integer-types">https://docs.python.org/zh-cn/3/library/stdtypes.html#additional-methods-on-integer-types</a></li>
</ul>
</blockquote>
<h3 id="numbers-Real-float"><a href="#numbers-Real-float" class="headerlink" title="numbers.Real(float)"></a><code>numbers.Real(float)</code></h3><p><code>float</code>：表示机器级<strong>双精度浮点数</strong></p>
<ul>
<li>接受的取值返回、溢出处理取决于底层结构、python实现</li>
<li>python不支持单精度浮点</li>
</ul>
<blockquote>
<ul>
<li>没必要因为节省处理器、内存消耗而增加语言复杂度</li>
</ul>
</blockquote>
<h4 id="特殊取值"><a href="#特殊取值" class="headerlink" title="特殊取值"></a>特殊取值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">infty = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">neg_infty = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line">	<span class="comment"># 正/负无穷大</span></span><br><span class="line">nan = <span class="built_in">float</span>(<span class="string">&quot;nan&quot;</span>)</span><br><span class="line">	<span class="comment"># Not a Number</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>特殊取值根据定义<code>==</code>、<code>is</code>肯定返回<code>False</code></p>
<ul>
<li><code>float.__eq__</code>内部应该有做检查，保证<code>==</code>返回<code>False</code></li>
<li>每次会创建“新”的<code>nan/infty</code></li>
</ul>
<blockquote>
<ul>
<li>连续执行<code>id(float(&quot;nan&quot;))</code>返回值可能相等，这是因为
 每次生成的<code>float(&quot;nan&quot;)</code>对象被回收，不影响</li>
</ul>
</blockquote>
</li>
<li><p><code>np.nan is np.nan</code>返回<code>True</code>，应该是<code>numpy</code>初始化的时候
创建了一个<code>float(&quot;nan&quot;)</code>，每次都是使用同一个<em>nan</em></p>
</li>
</ul>
<h4 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h4><blockquote>
<ul>
<li>详细参考<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#additional-methods-on-float">https://docs.python.org/zh-cn/3/library/stdtypes.html#additional-methods-on-float</a></li>
<li>更多数字运算参考<code>math</code>、<code>cmath</code>模块</li>
</ul>
</blockquote>
<ul>
<li><code>float.as_integer_ratio()</code></li>
<li><code>float.is_integer()</code></li>
<li><code>float.hex()</code></li>
<li><code>classmethod float.fromhex(s)</code></li>
<li><code>round(f[,n])</code></li>
<li><code>math.trunc(f)</code></li>
<li><code>math.floor(f)</code></li>
<li><code>math.ceil(f)</code></li>
</ul>
<h3 id="numbers-Complex-complex"><a href="#numbers-Complex-complex" class="headerlink" title="numbers.Complex(complex)"></a><code>numbers.Complex(complex)</code></h3><p><code>complex</code>：以一对机器级双精度浮点数表示复数值</p>
<ul>
<li>实部、虚部：可通过只读属性<code>z.real</code>、<code>z.imag</code>获取</li>
</ul>
<h2 id="Iterators"><a href="#Iterators" class="headerlink" title="Iterators"></a><em>Iterators</em></h2><p>迭代器类型</p>
<ul>
<li>迭代器对象需要自身支持以下两个方法，其共同组成迭代器协议<ul>
<li><code>iterator.__iter__()</code></li>
<li><code>iterator.__next__()</code></li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>方法详细参考<em>cs_python/py3ref/cls_special_method</em></li>
</ul>
</blockquote>
<h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a><em>Generator</em></h3><p>生成器类型：提供了实现迭代器协议的便捷形式</p>
<ul>
<li>将容器对象的<code>__iter__()</code>方法实现为生成器，方便实现容器对
迭代器支持</li>
</ul>
<blockquote>
<ul>
<li>创建、使用参见<em>cs_python/py3ref/dm_gfuncs</em></li>
</ul>
</blockquote>
<h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><p>序列：表示以非负整数作为索引的<strong>有限有序集</strong></p>
<ul>
<li><p>不可变序列类型：对象一旦创建不能改变</p>
<ul>
<li>若包含其他可变对象引用，则可变对象“可改变”</li>
<li>但不可变对象所<strong>直接引用的对象集是不可变的</strong></li>
<li>包括<ul>
<li><code>str</code></li>
<li><code>tuple</code></li>
<li><code>bytes</code></li>
<li><code>range</code>：非基本序列类型</li>
</ul>
</li>
</ul>
</li>
<li><p>可变序列：创建后仍可被改变值</p>
<ul>
<li><code>list</code></li>
<li><code>bytesarray</code></li>
</ul>
</li>
</ul>
<h3 id="通用序列操作"><a href="#通用序列操作" class="headerlink" title="通用序列操作"></a>通用序列操作</h3><ul>
<li><p><code>x in s</code>、<code>x not in s</code></p>
<ul>
<li><code>str</code>、<code>bytes</code>、<code>bytearray</code>支持子序列检测</li>
</ul>
</li>
<li><p><code>s + t</code>：拼接</p>
<ul>
<li>拼接不可变总会生成新对象</li>
<li>重复拼接构建序列的运行时开销将基于序列总长度乘方</li>
</ul>
</li>
<li><p><code>s * n</code>、<code>n * s</code>：<code>s</code>自身拼接<code>n</code>次</p>
<ul>
<li><code>n&lt;0</code>被当作<code>0</code>处理</li>
<li><code>s</code>中项不会被复制，而是被多次引用</li>
</ul>
</li>
<li><p><code>s[i]</code>、<code>s[i:j]</code>、<code>s[i:j:step]</code></p>
<ul>
<li><code>i&lt;0</code>索引为负值：索引顺序相对于序列<code>s</code>末尾，等价于
对序列长度取模</li>
<li>序列切片：与序列类型相同的新序列<ul>
<li>索引从0开始</li>
<li>左闭右开</li>
</ul>
</li>
<li>某些序列支持<code>a[i:j:step]</code>扩展切片</li>
</ul>
</li>
<li><p><code>s.index(x[, i[, j]])</code></p>
<ul>
<li>仅部分序列支持</li>
<li>类似<code>s[i:j].index(x)</code>，但返回值是相对序列开头</li>
</ul>
</li>
<li><p><code>s.count(x)</code>：序列中元素<code>x</code>数目</p>
</li>
<li><p><code>len(s)</code>：返回序列条目数量</p>
</li>
<li><p><code>min(s)</code>、<code>max(s)</code>：序列最小、最大值</p>
</li>
</ul>
<blockquote>
<ul>
<li>序列比较运算默认实现参见<em>cs_python/py3ref/expressions</em></li>
<li>以上运算自定义实现参见
  <em>cs_python/py3ref/cls_special_methods</em></li>
</ul>
</blockquote>
<h4 id="不可变序列"><a href="#不可变序列" class="headerlink" title="不可变序列"></a>不可变序列</h4><p>不可变序列普遍实现而可变序列未实现的操作</p>
<ul>
<li><code>hash()</code>内置函数</li>
</ul>
<h4 id="可变序列"><a href="#可变序列" class="headerlink" title="可变序列"></a>可变序列</h4><ul>
<li><code>s[i]=x</code>、<code>s[i:j]=t</code>、<code>s[i:j:k]=t</code>：下标、切片被赋值<ul>
<li><code>s[i:j:k]=t</code>中<code>t</code>长度必须和被替换切片长度相同</li>
</ul>
</li>
<li><code>del s[i:j]</code>、<code>del s[i:j:k]</code>：移除元素<ul>
<li>作为<code>del</code>语句的目标</li>
<li>等同于<code>s[i:j]=[]</code></li>
</ul>
</li>
<li><code>s.append()</code>：添加元素<ul>
<li>等同于<code>s[len(s):len(s)] = [x]</code></li>
</ul>
</li>
<li><code>s.clear()</code>：移除所有项<ul>
<li>等同于<code>del s[:]</code></li>
</ul>
</li>
<li><code>s.copy()</code>：浅拷贝<ul>
<li>等同于<code>s[:]</code></li>
</ul>
</li>
<li><code>s.extend(t)</code>：扩展（合并）序列<ul>
<li>基本上等于<code>s += t</code></li>
</ul>
</li>
<li><code>s.insert(i, x)</code>：向序列中插入元素<ul>
<li>等同于<code>s[i:i] = [x]</code></li>
</ul>
</li>
<li><code>s.pop(i=-1)</code>：弹出序列中元素</li>
<li><code>s.remove(x)</code>：删除序列中首个值为<code>x</code>的项</li>
<li><code>s.reverse()</code>：反转序列<ul>
<li>反转大尺寸序列时，会原地修改序列</li>
<li>为提醒用户此操作通过间接影响进行，不会返回反转后序列</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><code>array</code>、<code>collections</code>模块提供额外可变序列类型</li>
<li>可利用<code>collections.abc.MutableSequence</code>抽象类简化自定义
  序列操作</li>
</ul>
</blockquote>
<h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a><code>tuple</code></h3><p>元组</p>
<ul>
<li>元组中条目可以是任意python对象</li>
<li>元组创建<ul>
<li>一对圆括号创建空元组</li>
<li>逗号分隔<ul>
<li>单项元组：后缀逗号<code>a,</code>、<code>(a,)</code></li>
<li>多项元组：<code>a,b,c</code>、<code>(a,b,c)</code></li>
</ul>
</li>
<li>内置构建器：<code>tuple</code>、<code>tuple(iterable)</code></li>
</ul>
</li>
</ul>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a><code>list</code></h3><p>列表</p>
<ul>
<li>列表中条目可以是任意python对象</li>
<li>构建方式<ul>
<li>方括号括起、项以逗号分隔：<code>[]</code>、<code>[a]</code>、<code>[a,b]</code></li>
<li>列表推导式：<code>[x for x in iterable]</code></li>
<li>类型构造器：<code>list(iterable)</code></li>
</ul>
</li>
</ul>
<h4 id="相关操作-1"><a href="#相关操作-1" class="headerlink" title="相关操作"></a>相关操作</h4><h5 id="sort"><a href="#sort" class="headerlink" title=".sort"></a><code>.sort</code></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list</span>.<span class="title">sort</span>(<span class="params">*, key=<span class="literal">None</span>, reverse=<span class="literal">False</span></span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：对列表<strong>原地排序</strong></p>
<ul>
<li>使用<code>&lt;</code>进行各项之间比较</li>
<li>不屏蔽异常：若有比较操作失败，整个排序操作将失败，
此时列表可能处于<strong>部分被修改状态</strong></li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><code>key</code>：带参数函数，遍历处理每个元素提取比较键<ul>
<li><code>None</code>：默认，直接使用列表项排序</li>
</ul>
</li>
</ul>
</li>
<li><p>说明</p>
<ul>
<li><code>.sort</code>保序，有利于多重排序</li>
<li>为提醒用户此方法原地修改序列保证空间经济性，其不返回
排序后序列（可考虑使用<code>sorted</code>显式请求）</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>CPython：列表排序期间尝试改变、检测会造成未定义影响，
  CPython将列表排序期间显式为空，若列表排序期间被改变将
  <code>raise ValueError</code></li>
</ul>
</blockquote>
<h3 id="str"><a href="#str" class="headerlink" title="str"></a><code>str</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">str</span>(<span class="params"><span class="built_in">object</span>=<span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line"><span class="class">	# 返回`<span class="title">object</span>.<span class="title">__str__</span>()`、`<span class="title">object</span>.<span class="title">__repr__</span>()`</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">str</span>(<span class="params"><span class="built_in">object</span>=<span class="string">b&quot;&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>, errors=<span class="string">&quot;strict&quot;</span></span>)</span></span><br><span class="line"><span class="class">	# 给出`<span class="title">encoding</span>`、`<span class="title">errors</span>`之一，须为<span class="title">bytes</span>-<span class="title">like</span>对象</span></span><br><span class="line"><span class="class">	# 等价于`<span class="title">bytes</span>.<span class="title">decode</span>(<span class="params">encoding, errors</span>)`</span></span><br></pre></td></tr></table></figure>
<p>字符串：由Unicode码位值组成不可变序列（应该是<em>UTF16-bl</em>编码）</p>
<ul>
<li>范围在<code>U+0000~U+10FFFF</code>内所有码位值均可在字符串中使用</li>
<li>不存在单个“字符”类型<ul>
<li>字符串中单个字符为长度为1字符串</li>
</ul>
</li>
<li>不存在可变字符串类型<ul>
<li>可以用<code>str.join()</code>、<code>io.StringIO</code>高效连接多个字符串
片段</li>
</ul>
</li>
<li>字符串构建<ul>
<li>字符串字面值：<em>cs_python/py3ref/lexical_analysis</em></li>
<li>内置构造器<code>str()</code></li>
</ul>
</li>
</ul>
<h4 id="相关操作-2"><a href="#相关操作-2" class="headerlink" title="相关操作"></a>相关操作</h4><blockquote>
<ul>
<li>参见<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#string-methods">https://docs.python.org/zh-cn/3/library/stdtypes.html#string-methods</a></li>
</ul>
</blockquote>
<ul>
<li><code>ord()</code>：转换单个字符字符串为（整形）码位</li>
<li><code>chr()</code>：转换（整形）码位为单个字符字符串</li>
</ul>
<h5 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h5><ul>
<li><code>str.isalnum()</code></li>
<li><code>str.isalpha()</code></li>
<li><code>str.isascii()</code></li>
<li><code>str.isdecimal()</code></li>
<li><code>str.isdigit()</code></li>
<li><code>str.isidentifier()</code></li>
<li><code>str.islower()</code></li>
<li><code>str.isnumeric()</code></li>
<li><code>str.isprintable()</code></li>
<li><code>str.isspace()</code></li>
<li><code>str.istitle()</code></li>
<li><code>str.isupper()</code></li>
</ul>
<h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><ul>
<li><code>str.rfind(sub[, start[, end]])</code></li>
<li><code>str.rindex(sub[, start[, end]])</code></li>
<li><code>str.startswith(prefix[, start[, end]])</code></li>
<li><code>str.endwith(suffix[, start[, end]])</code></li>
<li><code>str.count(sub[, start[, end]])</code>：子串出现次数</li>
<li><code>str.find(sub[, start[, end]])</code><ul>
<li>仅检查<code>sub</code>是否为子串，应使用<code>in</code></li>
<li>找不到子串时返回<code>-1</code></li>
</ul>
</li>
<li><code>str.index(sub[, start[, end]])</code><ul>
<li>类似<code>str.find</code>，但找不到子串时<code>raise ValueError</code></li>
</ul>
</li>
</ul>
<h5 id="分隔"><a href="#分隔" class="headerlink" title="分隔"></a>分隔</h5><ul>
<li><code>str.partition(sep)</code></li>
<li><code>str.rpartition(sep)</code></li>
<li><code>str.rsplit(sep=None, maxsplit=-11)</code></li>
<li><code>str.split(sep=None, maxsplit=-1)</code></li>
<li><code>str.splitline([keepends])</code></li>
</ul>
<h5 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h5><ul>
<li><code>str.join(iterable)</code></li>
<li><code>str.strip([chars])</code></li>
<li><code>str.lstrip([chars])</code></li>
<li><code>str.rstrip([chars])</code></li>
<li><code>str.rstrip([chars])</code></li>
</ul>
<h5 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h5><ul>
<li><code>str.lower()</code></li>
<li><code>str.upper()</code></li>
<li><code>str.swapcase()</code></li>
<li><code>str.translate(table)</code></li>
<li><code>str.replace(old, new[, count])</code></li>
<li><code>static str.maketrans(x[, y[, z]])</code></li>
<li><code>str.encode(encoding=&quot;utf-8&quot;, errors=&quot;strict&quot;)</code>：使用
指定编码方案编码为<code>bytes</code></li>
<li><code>str.expandtabs(tabsize=8)</code></li>
<li><code>str.capitalize()</code>：首字符大写副本</li>
<li><code>str.casefold()</code>：消除大小写副本</li>
<li><code>str.center(width[, fillchar])</code>：字符串位于中间的字符串</li>
<li><code>str.title()</code></li>
</ul>
<h5 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h5><ul>
<li><code>str.ljust(width[, fillchar])</code></li>
<li><code>str.rjust(width[, fillchar])</code></li>
<li><code>str.zfill(width)</code></li>
<li><code>str.format(*args, **kwargs)</code></li>
<li><code>str.format_map(mapping)</code><ul>
<li>类似<code>str.format(**mapping)</code>，但<code>mapping</code>不会被复制
到<code>dict</code>中<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Default</span>(<span class="params"><span class="built_in">dict</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__missing__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">		<span class="keyword">return</span> key</span><br><span class="line"><span class="string">&quot;&#123;name&#125; was born in &#123;country&#125;&quot;</span>.format_map(Default(name=<span class="string">&quot;Guido&quot;</span>))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h5 id="printf风格字符串格式化"><a href="#printf风格字符串格式化" class="headerlink" title="printf风格字符串格式化"></a><em>printf</em>风格字符串格式化</h5><ul>
<li><p><code>format % values</code>中：<code>format</code>中<code>%</code>转换标记符将被转换
为<code>values</code>中条目</p>
<ul>
<li>效果类似于<code>sprintf</code></li>
<li><code>values</code>为与<code>format</code>中指定转换符数量等长元组、或映射
对象，除非<code>format</code>要求单个参数</li>
</ul>
</li>
<li><p>转换标记符按以下顺序构成</p>
<ul>
<li><code>%</code>字符：标记转换符起始</li>
<li>映射键：可选，圆括号<code>()</code>括起字符序列<ul>
<li><code>values</code>为映射时，映射键必须</li>
</ul>
</li>
<li>转换旗标：可选，影响某些类型转换效果<ul>
<li><code>#</code>：值转换使用“替代形式”</li>
<li><code>0</code>：为数字值填充<code>0</code>字符</li>
<li><code>-</code>：转换值左对齐（覆盖<code>0</code>）</li>
<li><code> </code>：符号位转换产生整数（空字符串）将留出空格</li>
<li><code>+</code>：符号字符显示在开头（覆盖<code> </code>）</li>
</ul>
</li>
<li>最小字段宽度：可选<ul>
<li><code>*</code>：从<code>values</code>读取下个元素</li>
</ul>
</li>
<li>精度：可选，<code>.</code>之后加精度值<ul>
<li><code>*</code>：从<code>values</code>读取下个元素</li>
</ul>
</li>
<li>长度修饰符：可选</li>
<li>转换类型<ul>
<li><code>d</code>/<code>u</code>/<code>i</code>：十进制整形</li>
<li><code>o</code>：8进制整形<ul>
<li><code>#</code>替代形式，前端添加<code>0o</code></li>
</ul>
</li>
<li><code>x</code>/<code>X</code>：小/大写16进制整形<ul>
<li><code>#</code>替代形式，前端添加<code>0x/0X</code></li>
</ul>
</li>
<li><code>e</code>/<code>E</code>：小/大写浮点指数<ul>
<li><code>#</code>替代形式，总是包含小数点</li>
</ul>
</li>
<li><code>f</code>/`F：浮点10进制<ul>
<li><code>#</code>替代形式，总是包含小数点</li>
</ul>
</li>
<li><code>g</code>/<code>G</code>：指数小于-4、不小于精度使用指数格式<ul>
<li><code>#</code>替代形式，总是包含小数点，末尾<code>0</code>不移除</li>
</ul>
</li>
<li><code>c</code>：单个字符（接收整数、单个字符字符串）</li>
<li><code>r</code>/<code>s</code>/<code>a</code>：字符串（<code>repr</code>/<code>str</code>/<code>ascii</code>转换）<ul>
<li>按输出精度截断</li>
</ul>
</li>
<li><code>%</code>：输出<code>%</code>字符</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h4><ul>
<li>快速字符串拼接<ul>
<li>构建包含字符串的列表，利用<code>str.join()</code>方法</li>
<li>写入<code>io.StringIO</code>实例，结束时获取值</li>
</ul>
</li>
</ul>
<h3 id="bytes-bytearray"><a href="#bytes-bytearray" class="headerlink" title="bytes/bytearray"></a><code>bytes</code>/<code>bytearray</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bytes</span>(<span class="params">[source[, encoding[, errors]]]</span>)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>字节串：单个字节构成的不可变序列</li>
<li>字节数组：字节串可变对应版本，其他同不可变<code>bytes</code></li>
</ul>
</blockquote>
<ul>
<li><p>字节串构建</p>
<ul>
<li>字节串字面值：<em>cs_python/py3ref/lexical_analysis</em></li>
<li>内置构造器<code>bytes()</code><ul>
<li>指定长度零值填充：<code>bytes(10)</code></li>
<li>整数组成可迭代对象：<code>bytes(range(20))</code></li>
<li>通过缓冲区协议复制现有二进制数据：<code>bytes(obj)</code></li>
</ul>
</li>
</ul>
</li>
<li><p>字节数组构建</p>
<ul>
<li>字节数组没有字面值语法，只能通过构造器构造</li>
<li>可变，构建空字节数组有意义</li>
</ul>
</li>
<li><p>类似整数构成序列</p>
<ul>
<li>每个条目都是8位字节</li>
<li>取值范围<code>0~255</code>，但只允许ASCII字符<em>0~127</em></li>
<li><code>b[0]</code>产生整数，切片返回<code>bytes</code>对象</li>
<li>可通过<code>list(bytes)</code>将<code>bytes</code>对象转换为整数构成列表</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>由<code>memeoryview</code>提供支持</li>
</ul>
</blockquote>
<h4 id="相关函数、方法"><a href="#相关函数、方法" class="headerlink" title="相关函数、方法"></a>相关函数、方法</h4><ul>
<li><code>bytes.decode</code>：解码为相关字符串</li>
<li><code>classmethod bytes.fromhex(string)</code></li>
<li><code>bytes.hex()</code></li>
</ul>
<blockquote>
<ul>
<li>其他类似字符串，包括<em>printf</em>风格格式化</li>
<li>参见<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes-and-bytearray-operations">https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes-and-bytearray-operations</a></li>
</ul>
</blockquote>
<h4 id="技巧-1"><a href="#技巧-1" class="headerlink" title="技巧"></a>技巧</h4><ul>
<li>快速字节串拼接<ul>
<li>构建包含字节串的列表，利用<code>bytes.join()</code>方法</li>
<li>写入<code>io.BytesIO</code>实例，结束时获取值</li>
<li>使用<code>betaarray</code>对象进行原地拼接</li>
</ul>
</li>
</ul>
<h3 id="memoryview"><a href="#memoryview" class="headerlink" title="memoryview"></a><code>memoryview</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">memoryview</span>(<span class="params">obj</span>)</span></span><br></pre></td></tr></table></figure>
<p>内存视图：允许python代码访问对象内部数据</p>
<ul>
<li><p>若对象支持缓冲区协议，则无需拷贝</p>
<ul>
<li>支持缓冲区协议的内置对象包括<code>bytes</code>、<code>bytesarray</code></li>
</ul>
</li>
<li><p>内存视图元素：原始对象<code>obj</code>处理的基本内存单元</p>
<ul>
<li>对简单<code>bytes</code>、<code>bytesarray</code>对象，一个元素就是一字节</li>
<li><code>array.array</code>等类型可能有更大元素</li>
</ul>
</li>
<li><p>内存视图支持索引抽取、切片</p>
<ul>
<li>若下层对象可选，则支持赋值，但切片赋值不允许改变大小</li>
</ul>
</li>
</ul>
<h4 id="相关操作-3"><a href="#相关操作-3" class="headerlink" title="相关操作"></a>相关操作</h4><blockquote>
<ul>
<li>参见<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#memory-views">https://docs.python.org/zh-cn/3/library/stdtypes.html#memory-views</a></li>
</ul>
</blockquote>
<ul>
<li><code>mv.__eq__(exporter)</code></li>
<li><code>mv.__len__()</code></li>
<li><code>mv.tobyte()</code></li>
<li><code>mv.hex()</code></li>
<li><code>mv.tolist()</code></li>
<li><code>mv.release()</code></li>
<li><code>mv.cast(format[, shape])</code>：将内存视图转换新格式形状</li>
</ul>
<h4 id="可用属性"><a href="#可用属性" class="headerlink" title="可用属性"></a>可用属性</h4><p>以下属性均只读</p>
<ul>
<li><code>mv.obj</code>：内存视图的下层对象</li>
<li><code>mv.nbytes</code><ul>
<li><code>== product(shape) * itemsize = len(mv.tobytes())</code></li>
</ul>
</li>
<li><code>mv.readonly</code></li>
<li><code>mv.format</code>：内存视图中元素格式<ul>
<li>表示为<code>struct</code>模块格式</li>
</ul>
</li>
<li><code>mv.itemsize</code></li>
<li><code>mv.ndim</code></li>
<li><code>mv.shape</code></li>
<li><code>mv.strides</code></li>
<li><code>mv.suboffsets</code></li>
<li><code>mv.c_contiguous</code></li>
<li><code>mv.f_contiguous</code></li>
<li><code>mv.contiguous</code></li>
</ul>
<h3 id="Slices-Object"><a href="#Slices-Object" class="headerlink" title="Slices Object"></a><em>Slices Object</em></h3><p>切片对象：表示<code>__getitem__()</code>方法得到的切片</p>
<ul>
<li>可以使用内置的<code>slice()</code>函数创建</li>
<li><code>a[start: stop]</code>形式的调用被转换为
<code>a[slice(start, stop, None)]</code></li>
</ul>
<blockquote>
<ul>
<li>切片对象是内部类型，参见<em>cs_python/py3ref/dm_exec</em>，也
  不是序列类型</li>
</ul>
</blockquote>
<h4 id="特殊只读属性"><a href="#特殊只读属性" class="headerlink" title="特殊只读属性"></a>特殊只读属性</h4><ul>
<li><code>start</code>：下界</li>
<li><code>stop</code>：上界</li>
<li><code>step</code>：步长值</li>
</ul>
<blockquote>
<ul>
<li>属性可以具有任意类型</li>
</ul>
</blockquote>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li><code>.indices(self, length)</code>：计算切片对象被应用到<code>length</code>
长度序列时切片相关信息<ul>
<li>返回值：<code>(start, stop, step)</code>三元组</li>
<li>索引号缺失、越界按照正规连续切片方式处理</li>
</ul>
</li>
</ul>
<h3 id="range"><a href="#range" class="headerlink" title="range"></a><code>range</code></h3><p><code>range</code>：不可变数字序列类型（非不是基本序列类型）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">range</span>(<span class="params">stop</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">range</span>(<span class="params">start=<span class="number">0</span>, stop[, step=<span class="number">1</span>]</span>)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数：必须均为整数（<code>int</code>或实现<code>__index__</code>方法）</p>
<ul>
<li><code>step &gt; 0</code>：对range对象<code>r[i]=start + step * i</code>，其中
<code>i &gt;= 0, r[i] &lt; stop</code></li>
<li><code>step &lt; 0</code>：对range对象<code>r[i]=start + step * i</code>，其中
<code>i &gt;= 0, r[i] &gt; stop</code></li>
<li><code>step = 0</code>：<code>raise ValueError</code></li>
</ul>
</li>
<li><p>说明</p>
<ul>
<li>允许元素绝对值大于<code>sys.maxsize</code>，但是某些特性如：
<code>len()</code>可能<code>raise OverflowError</code></li>
<li><code>range</code>类型根据需要计算单项、切片值<ul>
<li>相较于常规<code>list</code>、<code>tuple</code>占用内存较小，且和表示
范围大小无关</li>
<li>只能表示符合严格模式的序列</li>
</ul>
</li>
<li><code>range</code>类型实现了<code>collections.abc.Sequence</code>抽象类<ul>
<li>基本实现序列所有操作：检测、索引查找、切片等</li>
<li>除拼接、重复：拼接、重复通常会违反严格模式</li>
</ul>
</li>
<li><code>!=</code>、<code>==</code>将<code>range</code>对象视为序列比较，即提供相同值即
认为相等</li>
</ul>
</li>
</ul>
<h2 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h2><ul>
<li><p>表示<strong>不重复</strong>、<strong>不可变</strong>对象组成的无序、有限集合</p>
<ul>
<li>不能通过下标索引</li>
<li>可以迭代</li>
<li>可以通过内置函数<code>len</code>返回集合中条目数量</li>
</ul>
</li>
<li><p>常用于</p>
<ul>
<li>快速成员检测、去除序列中重复项</li>
<li>进行交、并、差、对称差等数学运算</li>
</ul>
</li>
</ul>
<h3 id="公用操作"><a href="#公用操作" class="headerlink" title="公用操作"></a>公用操作</h3><blockquote>
<ul>
<li>参见<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#set-types-set-frozenset">https://docs.python.org/zh-cn/3/library/stdtypes.html#set-types-set-frozenset</a></li>
</ul>
</blockquote>
<ul>
<li><code>len(s)</code></li>
<li><code>x [not ]in s</code></li>
<li><code>s.isdisjoint(other)</code></li>
<li><code>s.issubset(other)</code>/<code>s &lt;= other</code></li>
<li><code>s &lt; other</code></li>
<li><code>s.issuperset(other)</code>/<code>s &gt;= other</code></li>
<li><code>s &gt; other</code></li>
<li><code>s.union(*others)</code>/<code>s | other |...</code></li>
<li><code>s.intersection(*others)</code>/<code>s &amp; other &amp;...</code></li>
<li><code>s.difference(*other)</code>/<code>s - other - other</code></li>
<li><code>s.symmetric_difference(other)</code>/<code>s ^ other</code></li>
<li><code>s.copy()</code></li>
</ul>
<blockquote>
<ul>
<li>集合比较仅定义偏序，集合列表排序无意义</li>
</ul>
</blockquote>
<h4 id="可变集合独有"><a href="#可变集合独有" class="headerlink" title="可变集合独有"></a>可变集合独有</h4><ul>
<li><code>s.update(*others)</code>/<code>s |= other |...</code></li>
<li><code>s.intersection_update(*others)</code>/<code>s &amp;= other &amp;...</code></li>
<li><code>s.difference_udpate(*others)</code>/<code>s -= other |...</code></li>
<li><code>s.symmetric_difference_update(other)</code>/<code>set ^= other</code></li>
<li><code>s.add(elem)</code></li>
<li><code>s.remove(elem)</code></li>
<li><code>s.discard(elem)</code></li>
<li><code>s.pop()</code></li>
<li><code>s.clear()</code></li>
</ul>
<h3 id="set-frozenset"><a href="#set-frozenset" class="headerlink" title="set/frozenset"></a><code>set</code>/<code>frozenset</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">set</span>(<span class="params">[iterable]</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">frozenset</span>(<span class="params">[iterable]</span>)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>集合：由具有唯一性的<em>hashable</em>对象组成的多项无序集</li>
<li>冻结集合：不可变集合，可哈希，可以用作集合元素、字典键</li>
</ul>
</blockquote>
<ul>
<li><p>创建集合</p>
<ul>
<li><code>set()</code>内置构造器</li>
<li>花括号包括、逗号分隔元组列表：<code>&#123;a, b&#125;</code></li>
</ul>
</li>
<li><p>创建冻结集合</p>
<ul>
<li><code>frozenset()</code>内置构造器</li>
</ul>
</li>
<li><p>python中集合类似<code>dict</code>通过hash实现</p>
<ul>
<li>集合元素须遵循同字典键的不可变规则</li>
<li>数字：相等的数字<code>1==1.0</code>，同一集合中只能包含一个</li>
</ul>
</li>
</ul>
<h4 id="操作说明"><a href="#操作说明" class="headerlink" title="操作说明"></a>操作说明</h4><ul>
<li><p><code>.remove</code>、<code>.__contains__</code>、<code>discard</code>等可以接收<code>set</code>类型
参数，其将被转换为临时<code>frozenset</code>对象</p>
</li>
<li><p>非运算符版本操作可以接受任意可迭代对象作为参数，运算符
版本只能接受集合类型作为参数</p>
</li>
</ul>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>映射：表示任何索引集合所索引的对象的集合</p>
<ul>
<li>通过下标<code>a[k]</code>可在映射<code>a</code>中选择索引为<code>k</code>的条目<ul>
<li>可在表达式中使用</li>
<li>可以作为赋值语句、<code>del</code>语句的目标</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><code>dbm.ndbm</code>、<code>dbm.gnu</code>、<code>collections</code>模块提供额外映射类型</li>
</ul>
</blockquote>
<h3 id="通用操作"><a href="#通用操作" class="headerlink" title="通用操作"></a>通用操作</h3><blockquote>
<ul>
<li>参见<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#mapping-types-dict">https://docs.python.org/zh-cn/3/library/stdtypes.html#mapping-types-dict</a></li>
</ul>
</blockquote>
<ul>
<li><code>len(d)</code></li>
<li><code>d[key]</code></li>
<li><code>key [not ]in d</code></li>
<li><code>iter(d)</code></li>
<li><code>d.keys()</code>：返回字典视图对象</li>
<li><code>d.values()</code>：返回字典视图对象</li>
<li><code>d.items()</code>：返回字典视图对象</li>
<li><code>d.get(key[, default])</code></li>
<li><code>d.copy()</code></li>
<li><code>classmethod fromkey(iterable[, value])</code></li>
</ul>
<h4 id="可变映射独有"><a href="#可变映射独有" class="headerlink" title="可变映射独有"></a>可变映射独有</h4><ul>
<li><code>d[key]=value</code></li>
<li><code>del d[key]</code></li>
<li><code>d.clear()</code></li>
<li><code>d.setdefault(key[, default])</code></li>
<li><code>d.pop()</code></li>
<li><code>d.popitem()</code></li>
<li><code>d.copy()</code></li>
<li><code>d.update()</code></li>
</ul>
<h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a><code>dict</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dict</span>(<span class="params">**kwargs</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">dict</span>(<span class="params">mapping, **kwargs</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">dict</span>(<span class="params">iterable, **kwargs</span>)</span></span><br></pre></td></tr></table></figure>
<p>字典：可由<strong>几乎任意值作为索引</strong>的有限个对象可变集合</p>
<ul>
<li><p>字典的高效实现要求使用键hash值以保持一致性</p>
<ul>
<li>不可作为键的值类型<ul>
<li>包含列表、字典的值</li>
<li>其他通过对象编号而不是值比较的可变对象</li>
</ul>
</li>
<li>数字：相等的数字<code>1==1.0</code>索引相同字典条目</li>
</ul>
</li>
<li><p>创建字典</p>
<ul>
<li>花括号括起、逗号分隔键值对：<code>&#123;key:value,&#125;</code></li>
<li>内置字典构造器：<code>dict()</code></li>
</ul>
</li>
</ul>
<h4 id="字典视图对象"><a href="#字典视图对象" class="headerlink" title="字典视图对象"></a>字典视图对象</h4><p>字典视图对象：提供字典条目的<strong>动态视图</strong>，随字典改变而改变</p>
<ul>
<li><code>len(dictview)</code></li>
<li><code>iter(dictview)</code></li>
<li><code>x in dictview</code></li>
</ul>
<blockquote>
<ul>
<li>参见<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#dictionary-view-objects">https://docs.python.org/zh-cn/3/library/stdtypes.html#dictionary-view-objects</a></li>
</ul>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-06-03T16:55:56.000Z" title="6/4/2019, 12:55:56 AM">2019-06-04</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-06-03T16:55:56.000Z" title="6/4/2019, 12:55:56 AM">2019-06-04</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Py3Ref/">Py3Ref</a></span><span class="level-item">an hour read (About 10552 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Py3Ref/cls_special_methods.html">Special Methods</a></h1><div class="content"><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>特殊方法：python类中具有特殊名称的方法，实现<strong>由特殊语法</strong>
所引发的特定操作</p>
<ul>
<li><p>python实现<strong>操作符重载</strong>的方式</p>
<ul>
<li>允许每个类自行定义基于操作符的特定行为</li>
<li>特定操作包括python内置的<strong>钩子函数</strong></li>
</ul>
</li>
<li><p>钩子函数不能简单的看作<strong>直接调用</strong>特殊方法</p>
<ul>
<li>尝试调用备用实现：<code>iter</code>、<code>reversed</code></li>
<li>修改方法返回值：<code>dir</code></li>
</ul>
</li>
<li><p>大部分情况下，若没有定义适当方法，尝试<strong>执行操作</strong>将
<code>raise AttributeError</code>、<code>raise TypeError</code></p>
<ul>
<li><p>但<code>__hash__</code>、<code>__iter__</code>、<code>__reversed__</code>、
<code>__contains__</code>等方法即使未定义，其<strong>对应钩子函数</strong>
实现会尝试调用可能的其他方法完成操作
（直接<code>obj.__xxx__</code>调用方法仍然报错）</p>
</li>
<li><p>将特殊方法设为<code>None</code>表示对应操作不可用，此时即使以上
<code>hash</code>、<code>iter</code>、<code>reversed</code>、<code>in</code>等操作也不会尝试调用
备用方法</p>
</li>
</ul>
</li>
</ul>
<h2 id="实例创建、销毁"><a href="#实例创建、销毁" class="headerlink" title="实例创建、销毁"></a>实例创建、销毁</h2><p>调用类时，元属性方法执行顺序</p>
<ul>
<li><code>__prepare__()</code>：创建命名空间</li>
<li>依次执行类定义语句</li>
<li><code>__new__()</code>：创建类实例</li>
<li><code>__init__()</code>：初始化类<ul>
<li><code>__new__</code><strong>返回的新实例</strong>的<code>__init__</code>方法将被调用</li>
<li>用户定义<code>__new__</code>返回对象不一定期望类实例，调用的
<code>__init__</code>随之不一定是期望方法</li>
</ul>
</li>
<li>返回<code>__new__</code>返回类实例</li>
</ul>
<h3 id="prepare"><a href="#prepare" class="headerlink" title="__prepare__"></a><code>__prepare__</code></h3><ul>
<li>在所有类定义开始执行前被调用，用于创建类命名空间</li>
<li>一般这个方法只是简单的返回一个字典或其他映射对象</li>
</ul>
<h3 id="new"><a href="#new" class="headerlink" title="__new__"></a><code>__new__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">classmethod</span> <span class="built_in">object</span>.__new__(cls[, *args, **kwargs]):</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：创建、返回<code>cls</code>类新实例</p>
<ul>
<li><code>super().__new__(cls[,...])</code>调用超类方法创建类实例，
然后根据需要修改新创建实例再返回</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><code>cls</code>：待实例化类</li>
<li>其余参数：类构造器表达式参数</li>
</ul>
</li>
<li><p>返回值：<code>cls</code>类新实例</p>
<ul>
<li><code>__new__</code>返回值就是类构造器的返回值，有绝对控制权</li>
</ul>
</li>
</ul>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul>
<li><p><code>__new__</code>：<em>builtin_function_or_method</em></p>
</li>
<li><p><code>__new__</code>是静态方法：以需实例化类作为第一个参数</p>
<ul>
<li><code>__new__</code>方法绑定当前<strong>类对象</strong></li>
<li>特例，不需要显式声明为静态方法</li>
</ul>
</li>
<li><p>原生有两个<code>__new__</code>函数，二者C实现不同</p>
<ul>
<li><code>type.__new__</code>：元类继承，用于创建类对象</li>
<li><code>object.__new__</code>：其他类继承，用于创建实例</li>
</ul>
</li>
</ul>
<h3 id="init"><a href="#init" class="headerlink" title="__init__"></a><code>__init__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__init__</span>(<span class="params">self[, *args, *kwargs]</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：初始化类实例</p>
<ul>
<li>类构造器中<code>__new__</code>返回类实例调用此方法初始化</li>
<li>若基类有用户定义<code>__init__</code>方法，则其派生类<code>__init__</code>
应该<strong>显式调用</strong>基类<code>__init__</code>保证基类部分正确初始化</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><code>self</code>：当前类实例</li>
<li>其余参数：类构造器表达式参数</li>
</ul>
</li>
<li><p>返回值：<code>None</code>，否则<code>raise TypeError</code></p>
</li>
</ul>
<h3 id="del"><a href="#del" class="headerlink" title="__del__"></a><code>__del__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__del__</span>(<span class="params">self</span>)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用途：实例销毁时（引用计数变为0）被调用<ul>
<li>若基类有<code>__del__</code>方法，则其派生类<code>__del__</code>方法中
需要<strong>显式调用</strong>基类<code>__del__</code>保证基类部分正确清除</li>
<li>对象重生：在其中创建该实例的新引用推迟其销毁<ul>
<li>不推荐</li>
<li>重生对象被销毁时<code>__del__</code>是否会被再次调用取决于
具体实现</li>
<li>当前CPython实现中只会调用一次</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><ul>
<li>解释器退出时不会确保为仍然存在的对象调用<code>__del__</code>方法</li>
<li>“钩子函数”：<code>del</code><ul>
<li><code>del x</code>不直接调用<code>x.__del__()</code></li>
<li><code>del x</code>仅将<code>x</code>的引用计数减一</li>
</ul>
</li>
</ul>
<h2 id="输出属性"><a href="#输出属性" class="headerlink" title="输出属性"></a>输出属性</h2><h3 id="repr"><a href="#repr" class="headerlink" title="__repr__"></a><code>__repr__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：输出对象的“官方”字符串表示</p>
<ul>
<li>如果可能，应类似有效的python表达式，可以用于重建具有
相同取值的对象（适当环境下）</li>
<li>若不可能，返回形如<code>&lt;...some useful description...&gt;</code>
的字符串</li>
<li>常用于调试，确保内容丰富、信息无歧义很重要</li>
</ul>
</li>
<li><p>返回值：字符对象</p>
<ul>
<li>内置钩子函数：<code>repr</code></li>
<li><strong>交互环境</strong>下直接“执行”变量的结果</li>
</ul>
</li>
</ul>
<h3 id="str"><a href="#str" class="headerlink" title="__str__"></a><code>__str__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：生成对象“非正式”、格式良好的字符串表示</p>
<ul>
<li>返回较方便、准确的描述信息</li>
</ul>
</li>
<li><p>返回值：字符串对象</p>
<ul>
<li>内置钩子函数：<code>str</code></li>
</ul>
</li>
</ul>
<h4 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h4><ul>
<li><p><code>object.__str__</code>方法默认实现调用<code>object.__repr__</code></p>
<ul>
<li>所以若未定义<code>__str__</code>，需要实例“非正式”字符串表示时
也会使用<code>__repr__</code></li>
</ul>
</li>
<li><p><code>format</code>、<code>print</code>函数会隐式调用对象<code>__str__</code>方法</p>
<ul>
<li>此时若<code>__str__</code>返回非字符串会<code>raise TypeError</code></li>
</ul>
</li>
</ul>
<h3 id="bytes"><a href="#bytes" class="headerlink" title="__bytes__"></a><code>__bytes__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__bytes__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：生成对象的字节串表示</p>
</li>
<li><p>返回值：<code>bytes</code>对象</p>
<ul>
<li>内置钩子函数：<code>bytes</code></li>
</ul>
</li>
</ul>
<h3 id="format"><a href="#format" class="headerlink" title="__format__"></a><code>__format__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__format__</span>(<span class="params">self, format_spec</span>)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：生成对象的“格式化”字符串表示</p>
<ul>
<li>内部常调用<code>format</code>、<code>str.format</code>实现格式化</li>
<li><code>object.__format__(x, &#39;&#39;)</code>等同于<code>str(x)</code></li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><code>fomrat_spec</code>：包含所需格式选项描述的字符串<ul>
<li>参数解读由实现<code>__format__</code>的类型决定</li>
<li>大多数类将格式化委托给内置类型、或使用相似格式化
语法</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：字符串对象</p>
<ul>
<li>内置钩子函数：<code>format</code></li>
</ul>
</li>
</ul>
<h3 id="hash"><a href="#hash" class="headerlink" title="__hash__"></a><code>__hash__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__hash__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：计算对象hash值返回</p>
<ul>
<li>相等的对象（即使类型不同）<strong>理应</strong>具有相同hash值</li>
<li>建议把参与比较的对象的全部组件的hash值打包为元组，
对元组做hash运算<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__hash__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">hash</span>((self.name, self.nick, self.color))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>返回值：整数</p>
<ul>
<li>内置钩子函数：<code>hash()</code></li>
</ul>
</li>
</ul>
<h4 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h4><ul>
<li><p><code>hash()</code>会从对象自定义的<code>__hash__()</code>方法返回值中截断为
<code>Py_ssize_t</code>大小</p>
<ul>
<li>64bits编译平台通常为8bytes、32bits为4bytes</li>
<li>若对象<code>__hash__()</code>需要在不同位大小的平台上互操作，
需要检查支持的平台位宽</li>
</ul>
<blockquote>
<ul>
<li>查看<code>sys.hash_info.width</code></li>
</ul>
</blockquote>
</li>
<li><p><code>set</code>、<code>frozenset</code>、<code>dict</code>这3个hash集类型中成员的操作
会调用相应<code>__hash__()</code></p>
</li>
<li><p>类的<code>__hash__</code>方法设置为<code>None</code>时</p>
<ul>
<li>尝试获取实例hash值时将<code>raise TypeError</code></li>
<li><code>isinstance(obj, collecitons.abc.Hashable)</code>返回
<code>False</code></li>
<li>单纯在<code>__hash__</code>中显式<code>raise TypeError</code>会被错误
认为是可hash</li>
</ul>
</li>
</ul>
<h4 id="关联-eq"><a href="#关联-eq" class="headerlink" title="关联__eq__"></a>关联<code>__eq__</code></h4><p>hash绝大部分应用场景是比较是否相等，所以<code>__hash__</code>、<code>__eq__</code>
密切相关</p>
<ul>
<li><p>类未定义<code>__eq__</code></p>
<ul>
<li>也不应该定义<code>__hash__</code>，单独hash结果无法保证比较结果</li>
</ul>
</li>
<li><p>类实现<code>__eq__</code></p>
<ul>
<li>未定义<code>__hash__</code>：其实例将不可被用作hash集类型的项</li>
<li>类中定义了可变对象：不应该实现<code>__hash__</code>，因为hash集
实现要求键hash值不可变</li>
</ul>
</li>
<li><p>类重载<code>__eq__</code>方法</p>
<ul>
<li>默认其<code>__hash__</code>被隐式设为<code>None</code></li>
<li>否则须设置<code>__has__ = &lt;ParentClass&gt;.__hash__</code>显式保留
来自父类<code>__hash__</code>实现</li>
</ul>
</li>
</ul>
<h4 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h4><ul>
<li><p><code>float</code>、<code>integer</code>、<code>decimal.Decimal</code>等数字类型hash运算
是基于为任意有理数定义的统一数学函数</p>
<blockquote>
<ul>
<li>详细参考<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/stdtypes.html#hashing-of-numeric-types">https://docs.python.org/zh-cn/3/library/stdtypes.html#hashing-of-numeric-types</a></li>
</ul>
</blockquote>
</li>
<li><p><code>str</code>、<code>bytes</code>、<code>datetime</code>对象<code>__hash__</code>值会使用不可预知
值<strong>随机加盐</strong></p>
<ul>
<li>盐在单独python进程中保持不变，但在重复执行的python
进程之间是不可预测的</li>
<li>目的是为了防止某种形式的DDos服务攻击</li>
</ul>
</li>
<li><p>改变hash值会影响集合迭代次序</p>
<ul>
<li>python也不保证次序不会改变</li>
</ul>
</li>
</ul>
<h3 id="bool"><a href="#bool" class="headerlink" title="__bool__"></a><code>__bool__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__bool__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：返回<code>True</code>、<code>False</code>实现真值检测</p>
<ul>
<li>未定义：调用<code>__len__</code>返回非0值时对象逻辑为真</li>
<li><code>__len__</code>、<code>__bool__</code>均未定义：所有实例逻辑为真</li>
</ul>
</li>
<li><p>返回值：<code>False</code>、<code>True</code></p>
<ul>
<li>内置构造函数：<code>bool()</code></li>
</ul>
</li>
</ul>
<h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">		self.x = x</span><br><span class="line">		self.y = y</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="comment"># 返回实例代码表示形式</span></span><br><span class="line">		<span class="comment"># 通常用于重新构造实例</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Pair(&#123;0.x!r&#125;, &#123;0.y!r&#125;)&quot;</span>.<span class="built_in">format</span>(self)</span><br><span class="line">			<span class="comment"># 格式化代码`!r`指明输出使用`__repr__`而不是默认</span></span><br><span class="line">				<span class="comment"># 的`__str___`</span></span><br><span class="line">			<span class="comment"># 格式化代码`0.x`表示第一个参数`x`属性</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;(&#123;0.x!s&#125;, &#123;0.y!s&#125;)&quot;</span>.<span class="built_in">format</span>(self)</span><br><span class="line">			<span class="comment"># 格式化代码`!s`指明使用默认`__str__`</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__format__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">if</span> self.x == <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">return</span> self.y</span><br><span class="line">		<span class="keyword">elif</span> self.y == <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">return</span> self.x</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&#123;0.x!r&#125;, &#123;0.y!r&#125;&quot;</span>.<span class="built_in">format</span>(self)</span><br></pre></td></tr></table></figure>
<h2 id="Rich-Comparison-Methods"><a href="#Rich-Comparison-Methods" class="headerlink" title="Rich Comparison Methods"></a><em>Rich Comparison Methods</em></h2><p>富比较方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__lt__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__le__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__eq__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__ne__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__gt__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__ge__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：比较运算符重载</p>
<ul>
<li><code>x &lt; y</code>：调用<code>x.__lt__(y)</code></li>
<li><code>x &lt;= y</code>：调用<code>x.__le__(y)</code></li>
<li><code>x == y</code>：调用<code>x.__eq__(y)</code></li>
<li><code>x != y</code>：调用<code>x.__ne__(y)</code></li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>成功比较返回<code>False</code>、<code>True</code></li>
<li>若指定方法没有相应实现，富比较方法会返回单例对象
<code>NotImplemented</code></li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>比较运算默认实现参见<em>cs_python/py3ref/expressions</em></li>
</ul>
</blockquote>
<h3 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h3><ul>
<li><p>默认情况下，<code>__ne__</code>会委托给<code>__eq__</code>，并将结果取反，除非
结果为<code>NotImplemented</code></p>
</li>
<li><p>比较运算符之间没有其他隐含关系</p>
<ul>
<li><code>x &lt; y or x == y</code>为真不意味着<code>x &lt;= y</code></li>
<li>要根据单个运算自动生成排序操作可以利用
<code>functools.total_ordering()</code>装饰器简化实现</li>
</ul>
</li>
<li><p>以上方法没有对调参数版本（左边参数不支持该操作，右边参数
支持该操作）</p>
<ul>
<li>若两个操作数类型不同、且右操作数是左操作数直接或间接
子类，优先选择右操作数的<strong>反射方法</strong>，否则左操作数
方法（不考虑虚拟子类）</li>
<li>反射方法<ul>
<li><code>__lt__</code>、<code>__gt__</code>互为反射</li>
<li><code>__le__</code>、<code>__ge__</code>互为反射</li>
<li><code>__eq__</code>、<code>__ne__</code>各为自身反射</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="内部信息"><a href="#内部信息" class="headerlink" title="内部信息"></a>内部信息</h2><h3 id="dict"><a href="#dict" class="headerlink" title="__dict__"></a><code>__dict__</code></h3><ul>
<li><p>钩子函数：<code>vars</code>、<code>dir</code>（部分）</p>
<ul>
<li><code>vars</code>是真正对应的钩子函数，返回键值对</li>
<li><code>dir</code>执行过程中会访问<code>__dict__</code>、<code>__class__</code>，而且
只返回keys</li>
</ul>
</li>
<li><p><strong>对象</strong>底层字典，存储对象属性、方法</p>
<ul>
<li>注意区分开：实例属性、类属性、基类属性，<code>__dict__</code>
只包括<strong>当前实例</strong>属性、方法</li>
<li>返回结果是<code>dir</code>结果的子集</li>
</ul>
</li>
<li><p>调用实例<code>obj</code>的属性时，按照以下顺序查找</p>
<ul>
<li><code>obj.__dict__</code>：当前实例的<code>__dict__</code>中</li>
<li><code>type(obj).__dict__</code>：实例所属类的<code>__dict__</code>中</li>
<li><code>type(obj).mro().__dict__</code>：基类的<code>__dict__</code>中</li>
</ul>
</li>
<li><p>在大部分情况下<code>__dict__</code>会自动更新，如<code>setattr</code>函数时，
或说实例的属性、方法更新就是<code>__dict__</code>的变动</p>
<ul>
<li><p>一般情况下不要直接访问<code>__dict__</code>，除非真的清楚所有
细节，如果类使用了<code>cls.__slots__</code>、<code>@property</code>、
描述器类等高级技术时代码可能会被破坏</p>
</li>
<li><p>尽量使用<code>setattr</code>函数，让python控制其更新</p>
</li>
</ul>
</li>
</ul>
<h3 id="class"><a href="#class" class="headerlink" title="__class__"></a><code>__class__</code></h3><ul>
<li><p>用途：返回实例所属类</p>
</li>
<li><p>返回值：实例（狭义）返回类、类返回元类</p>
<ul>
<li>钩子函数：<code>type</code></li>
</ul>
</li>
</ul>
<h3 id="objclass"><a href="#objclass" class="headerlink" title="__objclass__"></a><code>__objclass__</code></h3><ul>
<li>用途：被<code>inspect</code>模块解读为<strong>指定实例所在的类</strong><ul>
<li>合适的设置可以有助于动态类属性的运行时检查</li>
<li>对于可调用对象：指明第一个位置参数应为特定类型的
实例、子类<ul>
<li>描述器类：<code>instance</code>参数<h1 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h1></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="slots"><a href="#slots" class="headerlink" title="__slots__"></a><code>__slots__</code></h3><ul>
<li><p>用途：显式声明数据成员、特征属性，限制实例添加属性</p>
<ul>
<li><p>可赋值为：字符串、可迭代对象、实例使用的变量名构成的
字符串序列</p>
<ul>
<li>可迭代对象中元素可以是任何类型</li>
<li>还可以映射类型，未来可能会分别赋给每个键特殊含义
的值</li>
</ul>
</li>
<li><p><code>__slots__</code>会为已声明变量保留空间</p>
<ul>
<li>直接访问将<code>raise AttributeError</code></li>
<li><code>dir</code>可以找到<code>__slots__</code>中声明的变量</li>
</ul>
</li>
</ul>
</li>
<li><p>阻止默认为每个实例创建<code>__dict__</code>、<code>__weakref__</code>的
行为，除非在<code>__slots__</code>中显式声明、或在父类中可用</p>
<ul>
<li><p>无<code>__dict__</code>属性实例无法给未在<code>__slots__</code>中列出
的新变量赋值</p>
<ul>
<li>但是python很多特性依赖于普通的依赖字典实现，定义
<code>__slots__</code>的类不再支持普通类某些特性</li>
<li>大多数情况下，应该只在经常使用到作为数据结构的
类上定义<code>__slots__</code></li>
<li>不应该把<code>__slots__</code>作为防止用户给实例增加新属性
的封装工具</li>
</ul>
</li>
<li><p>无<code>__weakref__</code>属性实例不支持对实例的弱引用</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>是阻止给实例创建<code>__dict__</code>，类本身仍然有<code>__dict__</code>属性
  （<code>dir</code>返回值中无<code>__dict__</code>，<code>__dir__</code>返回值中有）</li>
</ul>
</blockquote>
<h4 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h4><ul>
<li><p><code>__slots__</code>声明的行为不只限于定义其的类</p>
<ul>
<li><p>父类中声明<code>__slots__</code>可以在子类中使用，但子类将获得
<code>__dict__</code>、<code>__weakref__</code>，除非其也定义了<code>__slots__</code></p>
</li>
<li><p>子类<code>__slots__</code>中定义的slot将覆盖父类中同名slot</p>
<ul>
<li>需要直接从基类直接获取描述器才能访问</li>
<li>这会导致程序未定义，以后增加检查避免</li>
</ul>
</li>
<li><p>多重继承中只允许一个父类具有非空<code>__slots__</code>，否则
<code>raise TypeError</code></p>
</li>
</ul>
</li>
<li><p><code>__slots__</code>是在类层次上的实现：为每个变量创建描述器</p>
<ul>
<li>类属性不能被用于给在<code>__slots__</code>中定义变量设置默认值</li>
<li>否则类属性会覆盖描述器赋值，变成只读属性</li>
</ul>
</li>
<li><p>非空的<code>__slots__</code>不适用于派生自“可变长度”内置类型，如
<code>int</code>、<code>bytes</code>、<code>tuple</code></p>
</li>
<li><p>定义类属性<code>__slots__</code>后，python会为实例属性使用紧凑内部
表示</p>
<ul>
<li>实例属性使用固定大小、很小的数组构建，而不是为每个
实例定义字典</li>
<li>在<code>__slots__</code>列出的属性名在内部映射到数组指定下标上</li>
<li>类似于R中<code>factor</code>类型、C中<code>enum</code>类型</li>
<li>相比<code>__dict__</code>可以显著节省空间、提升属性查找速度</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>:</span></span><br><span class="line">	__slots__ = [<span class="string">&quot;year&quot;</span>, <span class="string">&quot;month&quot;</span>, <span class="string">&quot;day&quot;</span>]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, year, month, day</span>):</span></span><br><span class="line">		self.year = year</span><br><span class="line">		self.month = month</span><br><span class="line">		self.day = day</span><br></pre></td></tr></table></figure>
<ul>
<li><p>继承自未定义<code>__slots__</code>类时，实例中<code>__dict__</code>、
<code>__weakref__</code>属性将总是可访问的</p>
</li>
<li><p><code>__class__</code>赋值仅在两个类具有相同<code>__slots__</code>值时才有用</p>
</li>
</ul>
<h2 id="自定义属性访问"><a href="#自定义属性访问" class="headerlink" title="自定义属性访问"></a>自定义属性访问</h2><h3 id="getattr"><a href="#getattr" class="headerlink" title="__getattr__"></a><code>__getattr__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__getattr__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：<code>.</code>默认属性访问引发<code>AttributeError</code>而失败时调用</p>
<ul>
<li>如果属性通过正常机制找到，<code>__getattr__</code>不会被调用<ul>
<li>在<code>__getattr__</code>、<code>__setattr__</code>之间故意设置的
不对称性</li>
<li>出于效率考虑</li>
</ul>
</li>
<li>对实例变量而言，无需在实例属性字典中插入值，就可以
模拟对其的完全控制</li>
</ul>
</li>
<li><p>返回值：计算后的属性值、或<code>raise AttributeError</code></p>
</li>
</ul>
<h4 id="说明-6"><a href="#说明-6" class="headerlink" title="说明"></a>说明</h4><ul>
<li><p>可能引发<code>AttributeError</code></p>
<ul>
<li>调用<code>__getattribute__</code>时因为<code>name</code>不是实例属性、
或是类关系树中属性</li>
<li>对调用<code>__get__</code>获取<code>name</code>描述器</li>
</ul>
</li>
<li><p>调用<code>__getattr__</code>是<code>.</code>运算符中逻辑</p>
<ul>
<li><code>__getattribute__</code>显式调用<code>raise AtttributeError</code>
不会调用<code>__getattr__</code></li>
</ul>
</li>
<li><p><code>__getattr__</code>甚至不是<code>object</code>具有的
<code>&lt;wrapper_descriptor&gt;</code></p>
</li>
<li><p>相较于<code>__getattribute__</code>其实更常用，因为修改<strong>所有</strong>对
对对象的访问逻辑没啥价值</p>
</li>
</ul>
<h3 id="getattribute"><a href="#getattribute" class="headerlink" title="__getattribute__"></a><code>__getattribute__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">	<span class="string">&quot;Emulate type_getattro() in Objects/typeobject.c&quot;</span></span><br><span class="line">	v = <span class="built_in">object</span>.__getattribute__(self, key)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">hasattr</span>(v, <span class="string">&quot;__get__&quot;</span>):</span><br><span class="line">		<span class="keyword">return</span> v.__get__(<span class="literal">None</span>, self)</span><br><span class="line">	<span class="keyword">return</span> v</span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：访问对象属性时无条件被调用</p>
<ul>
<li><strong>判断访问属性类型、做对应操作</strong><ul>
<li>描述器：调用描述器方法</li>
<li>实例方法：为类中函数绑定实例</li>
<li>类方法：为类中函数绑定类</li>
<li>静态方法：不绑定</li>
<li>普通属性</li>
</ul>
</li>
<li>作为<strong>通过特定语法、内置函数隐式调用的结果</strong>情况下，
查找特殊方法时仍可能被跳过</li>
</ul>
</li>
<li><p>返回值：找到的属性值、或<code>raise AttributeError</code></p>
</li>
</ul>
<blockquote>
<ul>
<li><code>__getattribute__</code>仅对继承自<code>object</code>的新式类实例可用</li>
</ul>
</blockquote>
<h4 id="说明-7"><a href="#说明-7" class="headerlink" title="说明"></a>说明</h4><ul>
<li><p>内置类型均有各自<code>__getattribute__</code>函数实例</p>
<ul>
<li>其均为<code>wrapper_descriptor</code>类型（C实现的函数）</li>
<li>各函数实例标识符不同，若其均“继承自<code>object</code>”，其
应为同一个函数实例</li>
<li>自定义类真继承自<code>object</code>类，其<code>__getattribute__</code>同
<code>object.__getattribute__</code></li>
</ul>
</li>
<li><p>自定义实现</p>
<ul>
<li>为<strong>避免方法中无限递归</strong>，实现总应该调用具有相同名称
基类方法访问所需要的属性</li>
</ul>
</li>
</ul>
<h4 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h4><ul>
<li><p><code>.</code>运算符：首先调用<code>__getattribute__</code>，若无访问结果，
调用<code>__getattr__</code></p>
<blockquote>
<ul>
<li><code>.</code>运算符说明参见<em>cs_python/py3ref/cls_basics</em></li>
</ul>
</blockquote>
</li>
<li><p><code>getattr</code>：基本同<code>.</code>运算符，除可捕获异常，设置默认返回值</p>
</li>
<li><p><code>hasattr</code>：内部调用<code>getattr</code>，根据<code>raise Exception</code>判断
属性是否存在</p>
<ul>
<li>可以通过<code>@property.getter</code>中<code>raise AttributeError</code>
使得属性看起来不存在</li>
<li>内部有更多<code>boilerplate</code>相较于<code>getattr</code>更慢</li>
<li>则按照字面意思使用不需要考虑过多</li>
</ul>
</li>
</ul>
<h3 id="setattr"><a href="#setattr" class="headerlink" title="__setattr__"></a><code>__setattr__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__setattr__</span>(<span class="params">self, name, value</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：<strong>属性被尝试赋值时被调用</strong></p>
<ul>
<li>默认实现：将值保存到实例字典</li>
<li>若<code>__setattr__</code>要赋值给实例属性，应该调用同名基类
方法</li>
</ul>
</li>
<li><p>返回指：<code>None</code></p>
<ul>
<li>钩子函数：<code>setattr</code></li>
</ul>
</li>
</ul>
<h3 id="delattr"><a href="#delattr" class="headerlink" title="__delattr__"></a><code>__delattr__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__delattr__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：<strong>删除实例属性时被调用</strong></p>
<ul>
<li>默认实现：从实例字典中删除对应项</li>
<li>应该在<code>del obj.name</code>对该对象有意义时才实现</li>
</ul>
</li>
<li><p>返回值：<code>None</code></p>
<ul>
<li>内置钩子函数：<code>delattr</code>、<code>del</code></li>
</ul>
</li>
</ul>
<h3 id="dir"><a href="#dir" class="headerlink" title="__dir__"></a><code>__dir__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__dir__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：返回实例中“可访问”名称的字符串列表</p>
<ul>
<li>默认实现：返回实例、类、祖先类所有属性</li>
<li>交互式解释器就是在<code>__dir__</code>/<code>dir</code>返回列表中进行查询
进行补全</li>
</ul>
</li>
<li><p>返回值：序列</p>
<ul>
<li>内置钩子函数：<code>dir</code><ul>
<li><code>dir()</code>获取<code>__dir__</code>返回序列，转换为列表、排序</li>
<li><code>dir()</code>会剔除<code>__dir__</code>返回值中部分值</li>
<li>若<code>__dir__</code>返回值不可迭代，报错</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="自定义模块属性访问"><a href="#自定义模块属性访问" class="headerlink" title="自定义模块属性访问"></a>自定义模块属性访问</h3><ul>
<li><p><code>__getattr__</code>、<code>__dir__</code>可以用于自定义对模块属性的访问</p>
<ul>
<li>模块层次<code>__getattr__</code>类似普通类<ul>
<li>接受属性名作为参数</li>
<li>返回计算后结果、或<code>raise AttributeError</code></li>
<li>若正常查找<code>__getattribute__</code>无法在模块中找到某个
属性，调用<code>__getattr__</code></li>
</ul>
</li>
<li>模块层次<code>__dir__</code>类似普通类<ul>
<li>不接受参数</li>
<li>返回模块中可访问名称的字符串列表</li>
</ul>
</li>
</ul>
</li>
<li><p>可以将模块的<code>__class__</code>属性设置为<code>types.ModuleType</code>子类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> types <span class="keyword">import</span> ModuleType</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VersboseModule</span>(<span class="params">ModuleType</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">f&quot;verbose <span class="subst">&#123;self.__name__&#125;</span>&quot;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span>(<span class="params">self, attr, value</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">f&quot;settting <span class="subst">&#123;attr&#125;</span>&quot;</span>)</span><br><span class="line">		<span class="built_in">super</span>().__setattr__(attr, value)</span><br><span class="line"></span><br><span class="line">sys.modules[__name__].__class__ = VerboseModule</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<ul>
<li>设置模块<code>__getattr__</code>、<code>__class__</code>只影响使用<strong>属性访问</strong>
  语法进行查找，直接访问模块全局变量（通过模块内代码、对
  模块全局字典引用）不受影响</li>
</ul>
</blockquote>
<h2 id="描述器类"><a href="#描述器类" class="headerlink" title="描述器类"></a>描述器类</h2><p>描述器：<strong>具有“绑定行为”</strong>的对象属性</p>
<ul>
<li><p>类中定义其中任意一个方法，则其实例被称为描述器</p>
<ul>
<li><code>__set__</code></li>
<li><code>__get__</code></li>
<li><code>__delete__</code></li>
</ul>
</li>
<li><p>所有对描述器属性的访问会被<code>__get__</code>、<code>__set__</code>、
<code>__delete__</code>方法捕获/重载</p>
<ul>
<li>如果只是想简单的自定义某个类的属性处理逻辑，使用
<code>@porperty</code>装饰器简化实现</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><code>@property</code>参见<em>cs_python/py3ref/cls_basics</em></li>
</ul>
</blockquote>
<h3 id="描述器协议"><a href="#描述器协议" class="headerlink" title="描述器协议"></a>描述器协议</h3><ul>
<li>以下方法仅包含其的类的实例出现在类属性中才有效<ul>
<li>即以下方法必须在（祖先）类<code>__dict__</code>中出现，而不是
实例<code>__dict__</code>中</li>
<li>即描述器只能定义为类属性，不能定义为实例属性</li>
</ul>
</li>
</ul>
<h4 id="get"><a href="#get" class="headerlink" title="__get__"></a><code>__get__</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__get__</span>(<span class="params">self, instance, owner=<span class="literal">None</span></span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：访问描述器属性时调用，重载实例属性访问</p>
<ul>
<li>若描述器未定义<code>__get__</code>，则访问属性会返回描述器对象
自身，除非实例字典<code>__dict__</code>中有同名属性</li>
<li>若仅仅只是从底层实例字典中获取属性值，<code>__get__</code>方法
不用实现</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><code>instance</code>：用于方法属性的实例</li>
<li><code>owner</code>：实例所属类，若通过类获取属性则为<code>None</code></li>
</ul>
</li>
<li><p>返回值：计算后属性值、或<code>raise AttributeError</code></p>
</li>
<li><p>示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, cls</span>):</span></span><br><span class="line">	<span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">		<span class="comment"># 装饰器类一般作为类属性，需要考虑通过类直接访问</span></span><br><span class="line">			<span class="comment"># 描述器类属性，此时`instance is None`</span></span><br><span class="line">		<span class="comment"># 常用操作是返回当前实例</span></span><br><span class="line">		<span class="keyword">return</span> self</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> instance.__dict__[self.name]</span><br><span class="line"></span><br><span class="line">	<span class="comment"># self：描述器类当前实例</span></span><br><span class="line">	<span class="comment"># instance：定义描述器作为类属性的类的实例</span></span><br><span class="line">	<span class="comment"># cls：定义描述器作为类属性的类</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="set"><a href="#set" class="headerlink" title="__set__"></a><code>__set__</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__set__</span>(<span class="params">self, instance, name, value</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：设置实例<code>instance</code>的“描述器属性”值为<code>value</code>，重载
实例属性赋值</p>
<ul>
<li>常用实现：操作实例<code>instance.__dict__</code>存储值，使得
看起来是设置普通实例属性</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, name, value</span>):</span></span><br><span class="line">	<span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> instance(value, <span class="built_in">int</span>):</span><br><span class="line">			<span class="keyword">raise</span> TypeError(<span class="string">&quot;expect an int&quot;</span>)</span><br><span class="line">		instance.__dict__[self.name] = value</span><br><span class="line">		<span class="comment"># 操作实例底层`__dict__`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># `value`：赋给描述器类属性的值</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="delete"><a href="#delete" class="headerlink" title="__delete__"></a><code>__delete__</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__delete__</span>(<span class="params">self, instance</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用于：“删除”实例<code>instance</code>的“描述器属性”，重载实例属性
删除</p>
<ul>
<li>具体实现应取决于<code>__set__</code>实现</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self, instance</span>):</span></span><br><span class="line">	<span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">del</span> instance.__dict__[self.name]</span><br><span class="line">		<span class="comment"># 操作实例底层`__dict__`</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="set-name"><a href="#set-name" class="headerlink" title="__set_name__"></a><code>__set_name__</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__set_name__</span>(<span class="params">self, owner, name</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用途：类<code>owner</code>被创建时调用，描述器被赋给<code>name</code></li>
</ul>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul>
<li><p>描述器的实现依赖于<code>object.__getattribute__()</code>方法</p>
<ul>
<li>可以通过重写类的<code>__getattribute__</code>方法改变、关闭
描述器行为</li>
</ul>
</li>
<li><p>描述器调用：描述器<code>x</code>定义在类<code>A</code>中、<code>a = A()</code></p>
<ul>
<li>直接调用：<code>x.__get__(a)</code></li>
<li>实例绑定：<code>a.x</code><ul>
<li>转换为：<code>type(a).__dict__[&#39;x&#39;].__get__(a)</code></li>
</ul>
</li>
<li>类绑定：<code>A.x</code><ul>
<li>转换为：<code>A.__dict__[&#39;x&#39;].__get__(None,A)</code></li>
</ul>
</li>
<li>超绑定：<code>super(a, A).x</code><ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="实例绑定—资料描述器"><a href="#实例绑定—资料描述器" class="headerlink" title="实例绑定—资料描述器"></a>实例绑定—资料描述器</h4><blockquote>
<ul>
<li>资料描述器：定义了<code>__set__</code>、<code>__delete__</code>方法</li>
<li>非资料描述器：只定义了<code>__get__</code>方法</li>
</ul>
</blockquote>
<ul>
<li><p>访问对象属性时，描述器调用的<strong>优先级</strong>取决于描述器定义的方法</p>
<ul>
<li>优先级：资料描述器 &gt; 实例字典属性 &gt; 非资料描述器</li>
<li>实例属性会重载非资料描述器</li>
<li>实例属性和资料描述器同名时，优先访问描述器，否则优先
访问属性</li>
</ul>
</li>
<li><p>只读资料描述器：<code>__set__</code>中<code>raise AttributeError</code>得到</p>
</li>
</ul>
<h4 id="描述器调用"><a href="#描述器调用" class="headerlink" title="描述器调用"></a>描述器调用</h4><h1 id="todo-1"><a href="#todo-1" class="headerlink" title="todo"></a>todo</h1><h4 id="Python设计"><a href="#Python设计" class="headerlink" title="Python设计"></a>Python设计</h4><ul>
<li><p><code>function</code>类中定义有<code>__get__</code>方法，则其实例（即函数）
都为非资料描述器</p>
<ul>
<li>所以实例可以覆盖、重载方法</li>
<li><code>__getattribute__</code>会根据不同方法类型选择绑定对象<ul>
<li><code>staticmethod</code>：静态方法</li>
<li><code>classmethod</code>：类方法</li>
<li>实例方法</li>
</ul>
</li>
</ul>
</li>
<li><p><code>super</code>类中定义有<code>__get__</code>方法，则其实例也为描述器</p>
</li>
<li><p><code>@property</code>方法被实现为资料描述器</p>
</li>
</ul>
<h3 id="特殊描述器类"><a href="#特殊描述器类" class="headerlink" title="特殊描述器类"></a>特殊描述器类</h3><h1 id="todo-2"><a href="#todo-2" class="headerlink" title="todo"></a>todo</h1><ul>
<li><p><code>wrapper_descripter</code>：<code>&lt;slot wrapper&gt;</code>，封装C实现的函数</p>
<ul>
<li>等价于CPython3中函数</li>
<li>调用<code>__get__</code>绑定后得到<code>&lt;method-wrapper&gt;</code></li>
<li><code>object</code>的方法全是<code>&lt;slot wrapper&gt;</code></li>
</ul>
</li>
<li><p><code>method-wrapper</code>：<code>&lt;method-wrapper&gt;</code>，封装C实现的绑定方法</p>
<ul>
<li>等价于CPython3中绑定方法</li>
</ul>
</li>
</ul>
<h4 id="function描述器类"><a href="#function描述器类" class="headerlink" title="function描述器类"></a><code>function</code>描述器类</h4><p><code>function</code>描述器类：实例化即得到函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">function</span>:</span></span><br><span class="line">	function(code, <span class="built_in">globals</span>[, name[, argdefs[, closure]]])</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, /, *args, **kwargs</span>):</span></span><br><span class="line">		<span class="comment"># 作为一个函数调用自身</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, owner, /</span>):</span></span><br><span class="line">		<span class="comment"># 返回`owner`类型实例`instance`的属性</span></span><br><span class="line">		<span class="comment"># 即返回绑定方法</span></span><br></pre></td></tr></table></figure>
<h4 id="method描述器类"><a href="#method描述器类" class="headerlink" title="method描述器类"></a><code>method</code>描述器类</h4><p><code>method</code>描述器类：实例化即得到<em>(bound )method</em>，绑定方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">method</span>:</span></span><br><span class="line">	method(function, instance)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, /, *args, **kwargs</span>):</span></span><br><span class="line">		<span class="comment"># 作为函数调用自身</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, owner, /</span>):</span></span><br><span class="line">		<span class="comment"># 返回自身</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><em>(bound )method</em>：绑定方法，（首个参数）绑定为具体实例
  的函数，即实例属性</li>
</ul>
</blockquote>
<h4 id="XXmethod描述类"><a href="#XXmethod描述类" class="headerlink" title="XXmethod描述类"></a><code>XXmethod</code>描述类</h4><blockquote>
<ul>
<li>代码是C实现，这里是python模拟，和<code>help</code>结果不同</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classmethod</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, method</span>):</span></span><br><span class="line">		self.method = method</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, obj, cls</span>):</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">lambda</span> *args, **kw: self.method(cls,*args,**kw)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">staticmethod</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, <span class="built_in">callable</span></span>):</span></span><br><span class="line">		self.f = <span class="built_in">callable</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, obj, cls=<span class="literal">None</span></span>):</span></span><br><span class="line">		<span class="keyword">return</span> self.f</span><br><span class="line"><span class="meta">	@property</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__func__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> self.f</span><br></pre></td></tr></table></figure>
<ul>
<li><p>类中静态方法、类方法就是以上类型的描述器</p>
<ul>
<li>静态方法：不自动传入第一个参数</li>
<li>类方法：默认传递类作为第一个参数</li>
<li>描述器用途就是避免默认传入实例为第一个参数的行为</li>
</ul>
</li>
<li><p>静态方法、类方法均是非资料描述器，所以和实例属性重名时
会被覆盖</p>
</li>
<li><p>所以类静态方法、类方法不能直接通过<code>__dict__</code>获取、调用，
需要调用<code>__get__</code>方法返回绑定方法才能调用</p>
<ul>
<li>直接访问属性则由<code>__getattribute__</code>方法代劳</li>
</ul>
</li>
</ul>
<h3 id="例-1"><a href="#例-1" class="headerlink" title="例"></a>例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span>:</span></span><br><span class="line">	<span class="comment"># 描述器类</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">		self.name = name</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, cls</span>):</span></span><br><span class="line">		<span class="comment"># 描述器的每个方法会接受一个操作实例`instance`</span></span><br><span class="line">		<span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">			<span class="comment"># 描述器只能定义为类属性，在这里处理直接使用类</span></span><br><span class="line">				<span class="comment"># 访问描述器类的逻辑</span></span><br><span class="line">			<span class="keyword">return</span> self</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">return</span> instance.__dict__(self.name)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> instance(value, <span class="built_in">int</span>):</span><br><span class="line">			rasie TypeError(<span class="string">&quot;expect an int&quot;</span>)</span><br><span class="line">		instance.__dict__[self.name] = value</span><br><span class="line">			<span class="comment"># 描述器方法会操作实例底层`__dict__`属性</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self, instance</span>):</span></span><br><span class="line">		<span class="keyword">del</span> instance.__dict__[self.name]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">	x = Integer(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">	y = Integer(<span class="string">&quot;y&quot;</span>)</span><br><span class="line">		<span class="comment"># 需要将描述器的实例作为类属性放在类的定义中使用</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">		self.x = x</span><br><span class="line">		self.y = y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">	p = Point(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">	<span class="built_in">print</span>(p.x)</span><br><span class="line">		<span class="comment"># 调用`Point.x.__get__(p, Point)`</span></span><br><span class="line">	<span class="built_in">print</span>(Point.x)</span><br><span class="line">		<span class="comment"># 调用`Point.x.__get__(None, Point)`</span></span><br><span class="line">	p.y = <span class="number">5</span></span><br><span class="line">		<span class="comment"># 调用`Point.y.__set__(p, 5)`</span></span><br></pre></td></tr></table></figure>
<h2 id="自定义类创建"><a href="#自定义类创建" class="headerlink" title="自定义类创建"></a>自定义类创建</h2><h3 id="init-subclass"><a href="#init-subclass" class="headerlink" title="__init_subclass__"></a><code>__init_subclass__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">classmethod</span> <span class="built_in">object</span>.__init_subclass__(cls):</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用途：派生类继承父类时，基类的<code>__init_subclas__</code>被调用<ul>
<li>可以用于编写能够改变子类行为的类</li>
<li>类似类装饰器，但是类装饰其影响其应用的类，而
<code>__init_subclass__</code>影响基类所有派生子类</li>
<li>默认实现：无行为、只有一个参数<code>cls</code></li>
<li>方法默认、隐式为类方法，不需要<code>classmethod</code>封装</li>
</ul>
</li>
</ul>
<ul>
<li><p>参数</p>
<ul>
<li><code>cls</code>：指向新的子类</li>
<li>默认实现无参数，可以覆盖为自定义参数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init_subclass__</span>(<span class="params">self, default_name, **kwargs</span>):</span></span><br><span class="line">		<span class="built_in">super</span>().__init_subclass__(**kwrags)</span><br><span class="line">		cls.default_name = default_name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AstraliaPhilosopher</span>(<span class="params">Philosopher, default_name=<span class="string">&quot;Bruce&quot;</span></span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定义派生类时需要注意传递参数</li>
<li>元类参数<code>metaclass</code>会被其他类型机制消耗，不会被传递
给<code>__init_subclass__</code></li>
</ul>
</li>
</ul>
<h3 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h3><ul>
<li><p>默认情况下，类使用<code>type</code>构建</p>
<ul>
<li>类体在新的命名空间中执行，类名被局部绑定到
元类创建结果<code>type(name, bases, namespace)</code></li>
</ul>
</li>
<li><p>可在类定义部分传递<code>metaclass</code>关键字参数，自定义类创建
过程</p>
<ul>
<li>类继承同样继承父类元类参数</li>
<li>其他类定义过程中的其他关键字参数会在以下元类操作中
进行传递<ul>
<li>解析MRO条目</li>
<li>确定适当元类</li>
<li>准备类命名空间<code>__prepare__</code></li>
<li>执行类主体</li>
<li>创建类对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="解释MRO条目"><a href="#解释MRO条目" class="headerlink" title="解释MRO条目"></a>解释MRO条目</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def type.__mro_entries__():</span><br><span class="line">	pass</span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：若类定义中基类不是<code>type</code>的实例，则使用此方法对
基类进行搜索</p>
<ul>
<li>找到结果时，以原始基类元组作为参数进行调用</li>
</ul>
</li>
<li><p>返回值：类的元组替代基类被使用</p>
<ul>
<li>元组可以为空，此时原始基类将被忽略</li>
</ul>
</li>
</ul>
<h4 id="元类确定"><a href="#元类确定" class="headerlink" title="元类确定"></a>元类确定</h4><ul>
<li>若没有显式给出基类、或元类，使用<code>type()</code></li>
<li>若显式给出的元类不是<code>type()</code>的实例，直接用其作为元类</li>
<li>若显式给出<code>type()</code>实例作为元类、或定义有基类，则选取
“最派生”元类<ul>
<li>最派生元类从显式指定的元类、基类中元类中选取</li>
<li>最派生元类应为所有候选元类的子类型</li>
<li>若没有满足条件的候选元类则<code>raise TypeError</code></li>
</ul>
</li>
</ul>
<h4 id="准备类命名空间"><a href="#准备类命名空间" class="headerlink" title="准备类命名空间"></a>准备类命名空间</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">type</span>.<span class="title">__prepare__</span>(<span class="params">name, bases, **kwds</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：确定合适的元类之后，准备类命名空间</p>
<ul>
<li>若元类没有<code>__prepare__</code>属性，类命名空间将被初始化为
空<code>ordered mapping</code></li>
</ul>
</li>
<li><p>参数：来自于类定义中的关键字参数</p>
</li>
</ul>
<h4 id="执行类定义主体"><a href="#执行类定义主体" class="headerlink" title="执行类定义主体"></a>执行类定义主体</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span>(body, <span class="built_in">globals</span>(), namespace)</span><br><span class="line">	<span class="comment"># 执行类主体类似于</span></span><br></pre></td></tr></table></figure>
<ul>
<li>普通调用和<code>exec()</code>区别<ul>
<li>类定义在函数内部时<ul>
<li>词法作用域允许类主体、方法引用来自当前、外部
作用域名称</li>
<li>但内部方法仍然无法看到在类作用域层次上名称</li>
<li>类变量必须通过实例的第一个形参、类方法方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="创建类对象"><a href="#创建类对象" class="headerlink" title="创建类对象"></a>创建类对象</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">metaclass(name, base, namespace, **kwds):</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：执行类主体填充类命名空间后，将通过调用
<code>metaclass(name, base, namespace, **kwds)</code>创建类对象</p>
</li>
<li><p>参数：来自类定义中的关键字参数</p>
</li>
</ul>
<h5 id="说明-8"><a href="#说明-8" class="headerlink" title="说明"></a>说明</h5><ul>
<li><p>若类主体中有方法中引用<code>__class__</code>、<code>super</code>，则<code>__class__</code>
将被编译器创建为隐式闭包引用</p>
<ul>
<li>这使得无参数调用<code>super</code>可以能基于词法作用域正确
定位类</li>
<li>而被用于进行当前调用的类、实例则是基于传递给方法
的第一个参数来标识</li>
</ul>
</li>
</ul>
<h2 id="自定义实例、子类检查"><a href="#自定义实例、子类检查" class="headerlink" title="自定义实例、子类检查"></a>自定义实例、子类检查</h2><ul>
<li><p>以下方法应该的定义在元类中，不能在类中定义为类方法</p>
<ul>
<li>类似于实例从类中查找方法</li>
</ul>
</li>
<li><p>元类<code>abc.ABCMeta</code>实现了以下方法以便允许将抽象基类<code>ABC</code>
作为“虚拟基类”添加到任何类、类型（包括内置类型）中</p>
</li>
</ul>
<h3 id="instancecheck"><a href="#instancecheck" class="headerlink" title="__instancecheck__"></a><code>__instancecheck__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">class</span>.<span class="title">__instancecheck__</span>(<span class="params">self, instance</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：若<code>instance</code>被视为<code>class</code>直接、间接实例则返回真值</p>
<ul>
<li>重载<code>instance</code>内置函数行为</li>
</ul>
</li>
<li><p>返回：布尔值</p>
<ul>
<li>内置钩子函数：<code>isintance(instance, class)</code></li>
</ul>
</li>
</ul>
<h3 id="subclasscheck"><a href="#subclasscheck" class="headerlink" title="__subclasscheck__"></a><code>__subclasscheck__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>.__subclasscheck__(self, subclass):</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：若<code>subclass</code>被视为<code>class</code>的直接、间解子类则返回
真值</p>
<ul>
<li>重载<code>issubclass</code>内置函数行为</li>
</ul>
</li>
<li><p>返回：布尔值</p>
<ul>
<li>内置钩子函数：<code>issubclass(subclass, class)</code></li>
</ul>
</li>
</ul>
<h2 id="模拟范型类型"><a href="#模拟范型类型" class="headerlink" title="模拟范型类型"></a>模拟范型类型</h2><h3 id="class-getitem"><a href="#class-getitem" class="headerlink" title="__class_getitem__"></a><code>__class_getitem__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">classmethod</span> <span class="built_in">object</span>.__class_getitem__(cls, key):</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：按照<code>key</code>指定类型返回表示泛型类的专门化对象</p>
<ul>
<li>实现<em>PEP 484</em>规定的泛型类语法</li>
<li>查找基于对象自身</li>
<li>主要被保留用于静态类型提示，不鼓励其他尝试使用</li>
<li>方法默认、隐式为类方法，不需要<code>classmethod</code>封装</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><code>cls</code>：当前类</li>
<li><code>key</code>：类型</li>
</ul>
</li>
</ul>
<h2 id="模拟可调用对象"><a href="#模拟可调用对象" class="headerlink" title="模拟可调用对象"></a>模拟可调用对象</h2><h3 id="call"><a href="#call" class="headerlink" title="__call__"></a><code>__call__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__call__</span>(<span class="params">self[,args...]</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用途：实例作为函数被调用时被调用<ul>
<li>若定义此方法<code>x(arg1, arg2, ...)</code>等价于
<code>x.__call__(arg1, args2, ...)</code></li>
</ul>
</li>
</ul>
<h2 id="模拟容器类型"><a href="#模拟容器类型" class="headerlink" title="模拟容器类型"></a>模拟容器类型</h2><ul>
<li><code>collections.abc.MutableMapping</code>为抽象基类<ul>
<li>其实现基本方法集<code>__getitem__</code>、<code>__setitem__</code>、
<code>__delitem__</code>、<code>keys()</code></li>
<li>可以方法继承、扩展、实现自定义映射类</li>
</ul>
</li>
</ul>
<h3 id="len"><a href="#len" class="headerlink" title="__len__"></a><code>__len__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：计算、返回实例长度</p>
<ul>
<li>若对象未定义<code>__bool__</code>，以<code>__len__</code>是否返回非0作为
布尔运算结果</li>
</ul>
</li>
<li><p>返回值：非负整形</p>
<ul>
<li>钩子函数：<code>len()</code></li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>CPython：要求长度最大为<code>sys.maxsize</code>，否则某些特征可能
  会<code>raise OverflowError</code></li>
</ul>
</blockquote>
<h3 id="length-hint"><a href="#length-hint" class="headerlink" title="__length_hint__"></a><code>__length_hint__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__length_hist__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：返回对象长度<strong>估计值</strong></p>
<ul>
<li>存粹为优化性能，不要求正确无误</li>
</ul>
</li>
<li><p>返回值：非负整形</p>
<ul>
<li>钩子函数：<code>operator.length_hint()</code></li>
</ul>
</li>
</ul>
<h3 id="getitem"><a href="#getitem" class="headerlink" title="__getitem__"></a><code>__getitem__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__getitem__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：实现根据索引取值</p>
</li>
<li><p>参数</p>
<ul>
<li><p>序列<code>key</code>：整数、切片对象</p>
<ul>
<li><code>key</code>类型不正确将<code>raise TypeError</code></li>
<li><code>key</code>在实例有效范围外将<code>raise IndexError</code></li>
</ul>
</li>
<li><p>映射<code>key</code>：可hash对象</p>
<ul>
<li><code>key</code>不存在将<code>raise KeyError</code></li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：<code>self[key]</code></p>
</li>
</ul>
<h3 id="setitem"><a href="#setitem" class="headerlink" title="__setitem__"></a><code>__setitem__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__setitem__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：实现根据索引赋值</p>
</li>
<li><p>参数：同<code>__geitem__</code></p>
</li>
</ul>
<h3 id="delitem"><a href="#delitem" class="headerlink" title="__delitem__"></a><code>__delitem__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__delitem</span>(<span class="params">self, key</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：实现删除索引对应项</p>
</li>
<li><p>参数：同<code>__getitem__</code></p>
</li>
</ul>
<h3 id="missing"><a href="#missing" class="headerlink" title="__missing__"></a><code>__missing__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__missing__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用途：<code>__getitem__</code>无法找到映射中键时调用</li>
</ul>
<h3 id="reversed"><a href="#reversed" class="headerlink" title="__reversed__"></a><code>__reversed__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：为容器类创建逆向迭代器</p>
</li>
<li><p>返回值：逆向迭代对象</p>
<ul>
<li>内置钩子函数：<code>reversed()</code></li>
</ul>
</li>
</ul>
<h4 id="说明-9"><a href="#说明-9" class="headerlink" title="说明"></a>说明</h4><ul>
<li><p>若未提供<code>__reversed__</code>方法，<code>reversed</code>函数将回退到使用
<strong>序列协议</strong>：<code>__len__</code>、<code>__getitem__</code></p>
</li>
<li><p>支持序列协议的对象应该仅在能够提供比<code>reversed</code>更高效实现
时才提供<code>__reversed__</code>方法</p>
</li>
</ul>
<h3 id="contains"><a href="#contains" class="headerlink" title="__contains__"></a><code>__contains__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__contains__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：实现成员检测</p>
<ul>
<li>若<code>item</code>是<code>self</code>成员则返回<code>True</code>、否则返回<code>False</code></li>
<li>对映射应检查键</li>
</ul>
</li>
<li><p>返回值：布尔值</p>
<ul>
<li>钩子运算：<code>in</code></li>
</ul>
</li>
</ul>
<h4 id="说明-10"><a href="#说明-10" class="headerlink" title="说明"></a>说明</h4><ul>
<li><p>若未提供<code>__contains__</code>方法，成员检测将依次尝试</p>
<ul>
<li>通过<code>__iter__</code>进行迭代</li>
<li>使用<code>__getitem__</code>旧式序列迭代协议</li>
</ul>
</li>
<li><p>容器对象可以提供更有效率的实现</p>
</li>
</ul>
<h2 id="模拟数字"><a href="#模拟数字" class="headerlink" title="模拟数字"></a>模拟数字</h2><h3 id="数字运算"><a href="#数字运算" class="headerlink" title="数字运算"></a>数字运算</h3><p>定义以下方法即可模拟数字类型</p>
<ul>
<li>特定类型数值类型不支持的运算应保持未定义状态</li>
<li>若不支持与提供的参数进行运算，应返回<code>NotImplemented</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `+`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__sub__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `-`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__mul__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `*`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__matmul__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `@`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__truediv__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `/`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__floordiv__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `//`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__mod__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `%`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__divmod__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `divmod()`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__pow__</span>(<span class="params">self, other[, modulo=<span class="number">1</span>]</span>):</span></span><br><span class="line">	<span class="comment"># `pow()`/`**`</span></span><br><span class="line">	<span class="comment"># 若要支持三元版本内置`pow()`函数，应该接受可选的第三个</span></span><br><span class="line">		<span class="comment"># 参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__lshift__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `&lt;&lt;`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__rshift__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `&gt;&gt;`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__and__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `&amp;`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__or__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `|`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__xor__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `~`</span></span><br></pre></td></tr></table></figure>
<h3 id="反射二进制算术运算"><a href="#反射二进制算术运算" class="headerlink" title="反射二进制算术运算"></a>反射二进制算术运算</h3><p>以下成员函数仅在<strong>左操作数不支持相应运算</strong>、
<strong>且两操作数类型不同时</strong>被调用</p>
<ul>
<li><p>实例作为作为相应运算的右操作数</p>
</li>
<li><p>若右操作数类型为左操作数类型子类，且字类提供如下反射方法</p>
<ul>
<li>右操作数反射方法优先于左操作数非反射方法被调用</li>
<li>允许子类覆盖祖先类运算符</li>
</ul>
</li>
<li><p>三元版<code>pow()</code>不会尝试调用<code>__rpow__</code>（转换规则太复杂）</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__radd__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `+`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__rsub__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `-`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__rmul__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `*`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__rmatmul__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `@`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__rtruediv__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `/`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__rfloordiv__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `//`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__rmod__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `%`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__rdivmod__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `divmod()`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__rpow__</span>(<span class="params">self, other[, modulo=<span class="number">1</span>]</span>):</span></span><br><span class="line">	<span class="comment"># `pow()`/`**`</span></span><br><span class="line">	<span class="comment"># 若要支持三元版本内置`pow()`函数，应该接受可选的第三个</span></span><br><span class="line">		<span class="comment"># 参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__rlshift__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `&lt;&lt;`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__rrshift__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `&gt;&gt;`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__rand__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `&amp;`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__ror__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `|`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__rxor__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `~`</span></span><br></pre></td></tr></table></figure>
<h3 id="扩展算术赋值"><a href="#扩展算术赋值" class="headerlink" title="扩展算术赋值"></a>扩展算术赋值</h3><p>实现以下方法实现扩展算数赋值</p>
<ul>
<li><p>以下方法应该尝试对自身进行操作</p>
<ul>
<li>修改<code>self</code>、返回结果（不一定为<code>self</code>）</li>
</ul>
</li>
<li><p>若方法未定义，相应扩展算数赋值将回退到普通方法中</p>
</li>
<li><p>某些情况下，扩展赋值可导致未预期错误</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__iadd__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `+=`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__isub__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `-=`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__imul__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `*=`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__imatmul__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `@=`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__itruediv__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `/=`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__ifloordiv__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `//=`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__imod__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `%=`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__ipow__</span>(<span class="params">self, other[, modulo=<span class="number">1</span>]</span>):</span></span><br><span class="line">	<span class="comment"># `**=`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__ilshift__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `&lt;&lt;=`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__irshift__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `&gt;&gt;=`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__iand__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `&amp;=`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__ior__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `|=`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__ixor__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">	<span class="comment"># `~=`</span></span><br></pre></td></tr></table></figure>
<h3 id="一元算术运算"><a href="#一元算术运算" class="headerlink" title="一元算术运算"></a>一元算术运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__neg__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="comment"># `-`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__pos__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="comment"># `+`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__abs__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="comment"># `abs()`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__invert__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="comment"># `~`</span></span><br></pre></td></tr></table></figure>
<h3 id="类型转换运算"><a href="#类型转换运算" class="headerlink" title="类型转换运算"></a>类型转换运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__complex__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="comment"># `complex()`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__int__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="comment"># `int()`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__float__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="comment"># `float()`</span></span><br></pre></td></tr></table></figure>
<h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__index__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>存在此方法表明对象属于整数类型</p>
<ul>
<li>必须返回整数</li>
<li>为保证以一致性，同时也应该定义<code>__int__()</code>，两者返回
相同值</li>
</ul>
</li>
<li><p>调用此方法以实现<code>operator.index()</code>、或需要无损的转换为
整数对象</p>
<ul>
<li>作为索引、切片参数</li>
<li>作为<code>bin()</code>、<code>hex()</code>、<code>oct()</code>函数参数</li>
</ul>
</li>
</ul>
<h3 id="精度运算"><a href="#精度运算" class="headerlink" title="精度运算"></a>精度运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__round__</span>(<span class="params">self[, ndigits]</span>):</span></span><br><span class="line">	<span class="comment"># `round()`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__trunc__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="comment"># `math.trunc()`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__floor__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="comment"># `math.floor()`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__ceil__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="comment"># `math.ceil()`</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>返回值：除<code>__round__</code>中给出<code>ndigits</code>参数外，都应该为
原对象截断为<code>Integral</code>（通常为<code>int</code>）</p>
</li>
<li><p>若未定义<code>__int__</code>，则<code>int</code>回退到<code>__trunc__</code></p>
</li>
</ul>
<h2 id="元属性查找"><a href="#元属性查找" class="headerlink" title="元属性查找"></a>元属性查找</h2><ul>
<li><p>元属性查找通常会绕过<code>__getattribute__</code>方法，甚至包括元类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">*args</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;Metaclass getattribute invoked&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">type</span>.__getattribute__(*args)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params"><span class="built_in">object</span>, metaclass=Meta</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">*args</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;Class getattribute invoked&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">object</span>.__geattribute__(*args)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	c = C()</span><br><span class="line">	c.__len__()</span><br><span class="line">		<span class="comment"># 通过实例显式调用</span></span><br><span class="line">		<span class="comment"># 输出`Class getattribute invoked\n10&quot;</span></span><br><span class="line">	<span class="built_in">type</span>(c).__len__(c)</span><br><span class="line">		<span class="comment"># 通过类型显式调用</span></span><br><span class="line">		<span class="comment"># 输出`Metaclass getattribute invoked\n10&quot;</span></span><br><span class="line">	<span class="built_in">len</span>(c)</span><br><span class="line">		<span class="comment"># 隐式查找</span></span><br><span class="line">		<span class="comment"># 输出`10`</span></span><br></pre></td></tr></table></figure>
<ul>
<li>为解释器内部速度优化提供了显著空间</li>
<li>但是牺牲了处理特殊元属性时的灵活性<ul>
<li>特殊元属性必须设置在类对象本身上以便始终一致地
由解释器发起调用</li>
</ul>
</li>
</ul>
</li>
<li><p>隐式调用元属性仅保证<strong>元属性定义在对象类型中</strong>能正确发挥
作用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	c = C()</span><br><span class="line">	c.__len__() = <span class="keyword">lambda</span>: <span class="number">5</span></span><br><span class="line">	<span class="built_in">len</span>(c)</span><br><span class="line">		<span class="comment"># `rasie TypeError`</span></span><br></pre></td></tr></table></figure>
<ul>
<li>元属性定义在实例字典中会引发异常</li>
<li>若元属性的隐式查找过程使用了传统查找过程，会在对类型
对象本身发起调用时失败</li>
<li><p>可以通过在查找元属性时绕过实例避免</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">1</span>).__hash__(<span class="number">1</span>) == <span class="built_in">hash</span>(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="built_in">int</span>).__hash__(<span class="built_in">int</span>) == <span class="built_in">hash</span>(<span class="built_in">int</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="上下文管理器协议"><a href="#上下文管理器协议" class="headerlink" title="上下文管理器协议"></a>上下文管理器协议</h2><p>上下文管理器：定义了在执行<code>with</code>语句时要建立的运行时上下文
的对象</p>
<ul>
<li><p>上下文管理器为执行代码块，处理进入、退出运行时所需上下文</p>
<ul>
<li>通常使用<code>with</code>语句调用</li>
<li>也可以直接调用协议中方法方法</li>
</ul>
</li>
<li><p>典型用法</p>
<ul>
<li>保存、恢复各种全局状态</li>
<li>锁、解锁资源：避免死锁</li>
<li>关闭打开的文件：自动控制资源释放</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>可利用<code>contextlib</code>模块方便实现上下文管理器协议</li>
</ul>
</blockquote>
<h3 id="enter"><a href="#enter" class="headerlink" title="__enter__"></a><code>__enter__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">contextmanager</span>.<span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：创建、进入与当前对象相关的运行时上下文</p>
<ul>
<li>在执行<code>with</code>语句块前设置运行时上下文</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li><code>with</code>子句绑定方法返回值到<code>as</code>子句中指定的目标，如果
方法返回值</li>
</ul>
</li>
</ul>
<h3 id="exit"><a href="#exit" class="headerlink" title="__exit__"></a><code>__exit__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">contextmanger</span>.<span class="title">__exit__</span>(<span class="params">self, exc_type, exc_value, traceback</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：销毁、退出关联到此对象的运行时上下文</p>
<ul>
<li><code>with</code>语句块结束后，<code>__exit__</code>方法触发进行清理工作</li>
<li>不论<code>with</code>代码块中发生什么，即使是出现异常，
<code>__exit__</code>控制流也会执行完</li>
</ul>
</li>
<li><p>参数：描述了导致上下文退出的异常，正常退出则各参数为
<code>None</code></p>
<ul>
<li><code>exc_type</code></li>
<li><code>exc_value</code></li>
<li><code>traceback</code></li>
</ul>
</li>
<li><p>返回值：布尔值</p>
<ul>
<li>若上下文因异常退出<ul>
<li>希望方法屏蔽此异常（避免传播），应该返回真值，
异常被清空</li>
<li>否则异常在退出此方法时将按照正常流程处理</li>
</ul>
</li>
<li>方法中不应该重新引发被传入的异常，这是调用者的责任</li>
</ul>
</li>
</ul>
<h3 id="例-2"><a href="#例-2" class="headerlink" title="例"></a>例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket, AF_INET, SOCK_STREAM</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyConnection</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, address, family=AF_INET, <span class="built_in">type</span>=SOCK_STREAM</span>):</span></span><br><span class="line">		self.address = address</span><br><span class="line">		self.family = family</span><br><span class="line">		self.<span class="built_in">type</span> = <span class="built_in">type</span></span><br><span class="line">		self.connections = []</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">		sock = socket(self.family, self.<span class="built_in">type</span>)</span><br><span class="line">		sock.connect(self.address)</span><br><span class="line">		self.connections.append(sock)</span><br><span class="line">		<span class="keyword">return</span> self.sock</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exc_ty, exc_val, tb</span>):</span></span><br><span class="line">		self.connections.pop().close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">	conn = LazyConnection(<span class="string">&quot;www.python.org&quot;</span>, <span class="number">80</span>))</span><br><span class="line">	<span class="keyword">with</span> conn <span class="keyword">as</span> s1:</span><br><span class="line">		<span class="comment"># `conn.__enter___()` executes: connection opened</span></span><br><span class="line">		s.send(<span class="string">b&quot;GET /index.html HTTP/1.0\r\n&quot;</span>)</span><br><span class="line">		s.send(<span class="string">b&quot;Host: www.python.org\r\n&quot;</span>)</span><br><span class="line">		s.send(<span class="string">b&quot;\r\n&quot;</span>)</span><br><span class="line">		resp = <span class="string">b&quot;&quot;</span>.join(<span class="built_in">iter</span>(partial(s.recv, <span class="number">8192</span>), <span class="string">b&quot;&quot;</span>))</span><br><span class="line">		<span class="comment"># `conn.__exit__()` executes: connection closed</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">with</span> conn <span class="keyword">as</span> s2:</span><br><span class="line">			<span class="comment"># 此版本`LasyConnection`可以看作是连接工厂</span></span><br><span class="line">			<span class="comment"># 使用列表构造栈管理连接，允许嵌套使用</span></span><br><span class="line">			<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h2 id="迭代器协议"><a href="#迭代器协议" class="headerlink" title="迭代器协议"></a>迭代器协议</h2><ul>
<li>可迭代对象：实现<code>__iter__</code>方法的对象</li>
<li>迭代器对象：同时实现<code>__next__</code>方法的可迭代对象</li>
</ul>
<blockquote>
<ul>
<li>使用<code>collections.abc</code>模块判断对象类型</li>
</ul>
</blockquote>
<h3 id="iter"><a href="#iter" class="headerlink" title="__iter__"></a><code>__iter__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：创建迭代器对象，<strong>不负责产生、返回迭代器元素</strong></p>
<ul>
<li>容器对象要提供迭代须实现此方法<ul>
<li>容器支持不同迭代类型，可以提供额外方法专门请求
不同迭代类型迭代器</li>
</ul>
</li>
<li>迭代对象本身需要实现此方法，返回对象自身<ul>
<li>允许容器、迭代器均可配合<code>for...in...</code>语句使用</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：迭代器对象</p>
<ul>
<li>映射类型应该逐个迭代容器中键</li>
<li>内置钩子函数：<code>iter()</code></li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>此方法对应Python/C API中python对象类型结构体中
  <code>tp_iter</code>槽位</li>
</ul>
</blockquote>
<h3 id="next"><a href="#next" class="headerlink" title="__next__"></a><code>__next__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__next__</span>():</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：从迭代器中返回下一项</p>
<ul>
<li>若没有项可以返回，则<code>raise StopIteration</code></li>
<li>一旦引发<code>raise StopIteration</code>，对后续调用必须一直
引发同样的异常，否则此行为特性无法正常使用</li>
</ul>
</li>
<li><p>返回值：迭代器对象中下个元素</p>
<ul>
<li>映射类型返回容器中键</li>
<li>内置钩子函数：<code>next()</code></li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>此方法对应Python/C API中python对象类型结构体中
  <code>tp_iternext</code>槽位</li>
</ul>
</blockquote>
<h2 id="协程-异步"><a href="#协程-异步" class="headerlink" title="协程/异步"></a>协程/异步</h2><h3 id="await"><a href="#await" class="headerlink" title="__await__"></a><code>__await__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__await__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：用于实现<strong>可等待对象</strong></p>
</li>
<li><p>返回值：迭代器</p>
<ul>
<li>钩子运算：<code>await</code></li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><code>asyncio.Future</code>实现此方法以与<code>await</code>表达式兼容</li>
</ul>
</blockquote>
<h4 id="Awaitable-Objects"><a href="#Awaitable-Objects" class="headerlink" title="Awaitable Objects"></a><em>Awaitable Objects</em></h4><p>可等待对象：异步调用句柄，<strong>等待结果应为迭代器</strong></p>
<ul>
<li><p>主要是实现<code>__await__</code>方法对象</p>
<ul>
<li>从<code>async def</code>函数返回的协程对象</li>
</ul>
</li>
<li><p><code>type.coroutine()</code>、<code>asyncio.coroutine()</code>装饰的生成器
返回的生成器迭代器对象也属于可等待对象，但其未实现
<code>__await__</code></p>
</li>
</ul>
<blockquote>
<ul>
<li>协程对象参见<em>cs_python/py3ref/dm_gfuncs</em></li>
<li>py3.7前多次<code>await</code>可等待对象返回<code>None</code>，之后报错</li>
</ul>
</blockquote>
<h3 id="异步迭代器协议"><a href="#异步迭代器协议" class="headerlink" title="异步迭代器协议"></a>异步迭代器协议</h3><ul>
<li>异步迭代器常用于<code>async for</code>语句中</li>
</ul>
<blockquote>
<ul>
<li>其他参见迭代器协议</li>
</ul>
</blockquote>
<h4 id="aiter"><a href="#aiter" class="headerlink" title="__aiter__"></a><code>__aiter__</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__aiter__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用途：返回异步迭代器对象，<strong>不负责产生、返回迭代器元素</strong><ul>
<li>返回其他任何对象都将<code>raise TypeError</code></li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>其他参见<code>__iter__</code>方法</li>
</ul>
</blockquote>
<h4 id="anext"><a href="#anext" class="headerlink" title="__anext__"></a><code>__anext__</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__anext__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>返回：从异步迭代器返回下个结果值</p>
<ul>
<li>迭代结束时应该<code>raise StopAsyncIteration</code></li>
</ul>
</li>
<li><p>用途</p>
<ul>
<li>在其中调用异步代码</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>其他参见<code>__next__</code>方法</li>
</ul>
</blockquote>
<h4 id="例-3"><a href="#例-3" class="headerlink" title="例"></a>例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reader</span>:</span></span><br><span class="line">	<span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">readline</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__aiter__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> self</span><br><span class="line">	<span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">__anext__</span>(<span class="params">self</span>):</span></span><br><span class="line">		val = <span class="keyword">await</span> self.readline()</span><br><span class="line">		<span class="keyword">if</span> val == <span class="string">&quot;b&quot;</span>:</span><br><span class="line">			<span class="keyword">raise</span> StopAsyncIteration</span><br><span class="line">		<span class="keyword">return</span> val</span><br></pre></td></tr></table></figure>
<h3 id="异步上下文管理器协议"><a href="#异步上下文管理器协议" class="headerlink" title="异步上下文管理器协议"></a>异步上下文管理器协议</h3><ul>
<li>异步上下文管理器常用于<code>async with</code><strong>异步</strong>语句中</li>
</ul>
<blockquote>
<ul>
<li>其他参见上下文管理器协议</li>
</ul>
</blockquote>
<h4 id="aenter"><a href="#aenter" class="headerlink" title="__aenter__"></a><code>__aenter__</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__aenter__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：异步创建、进入关联当前对象的上下文执行环境</p>
<ul>
<li>由<code>async def</code>定义为协程函数，即在创建上下文执行环境
时可以被挂起</li>
</ul>
</li>
<li><p>返回：可等待对象</p>
</li>
</ul>
<blockquote>
<ul>
<li>其他参见<code>__enter__</code></li>
</ul>
</blockquote>
<h4 id="aexit"><a href="#aexit" class="headerlink" title="__aexit__"></a><code>__aexit__</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">__aexit__</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>用途：异步销毁、退出关联当前对象的上下文执行环境</p>
<ul>
<li>由<code>async def</code>定义为协程函数，即在销毁上下文执行环境
时可以被挂起</li>
</ul>
</li>
<li><p>返回：可等待对象</p>
</li>
</ul>
<blockquote>
<ul>
<li>其他参见<code>__exit__</code>函数</li>
</ul>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-05-25T11:53:54.000Z" title="5/25/2019, 7:53:54 PM">2019-05-25</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-05-25T11:53:54.000Z" title="5/25/2019, 7:53:54 PM">2019-05-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Py3Ref/">Py3Ref</a></span><span class="level-item">23 minutes read (About 3485 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Py3Ref/cls_basics.html">类</a></h1><div class="content"><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><h3 id="Custom-Classes"><a href="#Custom-Classes" class="headerlink" title="Custom Classes"></a><em>Custom Classes</em></h3><p>用户定义类：通过类定义创建</p>
<ul>
<li><p>每个类通过字典对象<code>__dict__</code>实现独立的命名空间</p>
<ul>
<li>类属性引用被转化为在此字典中查找</li>
<li>其中未发现属性名时，继续在基类中查找<ul>
<li>基类查找使用C3方法解析顺序，即MRO列表</li>
</ul>
</li>
<li>也存在一些<strong>钩子对象</strong>允许其他定位属性的方式</li>
</ul>
</li>
<li><p>当类属性引用<em>yield</em>类方法对象时，其将转化为<code>__self__</code>
属性为当前类对象的<strong>实例方法对象</strong></p>
</li>
<li><p>当类属性引用<em>yield</em>静态方法对象时，其将转换为静态方法
对象所封装的对象</p>
</li>
<li><p>类属性复制会更新类字典，不会更新基类字典</p>
</li>
<li><p>类对象可被调用产生类实例</p>
</li>
</ul>
<h4 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h4><ul>
<li><code>__bases__</code>：包含基类的元组，依在基类列表中出现的顺序</li>
</ul>
<h3 id="Class-Instances"><a href="#Class-Instances" class="headerlink" title="Class Instances"></a><em>Class Instances</em></h3><p>类实例：通过<strong>调用类对象</strong>创建</p>
<ul>
<li><p>每个类实例都有一个通过字典对象<code>__dict__</code>实现的独立命名
空间</p>
<ul>
<li>属性引用首先在此字典中查找</li>
<li><p>其中未发现属性名时，继续在对应类属性中查找</p>
<ul>
<li>用户定义函数对象：其会被转化为<strong>实例方法对象</strong><ul>
<li><code>__self__</code>属性即为该实例</li>
</ul>
</li>
<li>静态方法、类方法对象：同样会被转化</li>
</ul>
<blockquote>
<ul>
<li>描述器属性有特殊处理，实际存放在类<code>__dict__</code>中
对象不同</li>
</ul>
</blockquote>
</li>
<li>若未找到类属性，对象对应类具有<code>__getattr__()</code>方法，
将调用该方法</li>
</ul>
</li>
<li><p>属性赋值、删除会更新实例字典，不会更新对应类字典</p>
<ul>
<li>若类具有<code>__setattr__</code>、<code>__delattr__</code>方法，将调用方法
而不是直接更更新对应实例字典</li>
</ul>
</li>
</ul>
<h4 id="特殊属性-1"><a href="#特殊属性-1" class="headerlink" title="特殊属性"></a>特殊属性</h4><ul>
<li><code>__class__</code>：实例对应类</li>
</ul>
<h3 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a><em>Classes</em></h3><p>类：类对象通常作为“工厂”创建自身实例</p>
<ul>
<li><code>__doc__</code>：类的文档字符串<ul>
<li>类定义第一条语句、且须为字符串字面值</li>
<li>没有则为<code>None</code></li>
<li>不会被子类继承</li>
</ul>
</li>
</ul>
<h3 id="Class-Instances-1"><a href="#Class-Instances-1" class="headerlink" title="Class Instances"></a><em>Class Instances</em></h3><p>类实例：在所属类中定义<code>__call__()</code>方法即成为可调用对象</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="属性访问"><a href="#属性访问" class="headerlink" title="属性访问."></a>属性访问<code>.</code></h3><ul>
<li><p><code>A.attr</code>被解释为<code>type(A)中__getattribute__(A, attr)</code></p>
<ul>
<li><code>.</code>的行为由python解释器定义</li>
<li><code>type(A)中__getattribute__</code>的<strong>中</strong>用于强调不会再从
<code>type(type(A))</code>继续获取调用<code>__getattibute__</code></li>
</ul>
</li>
<li><p>则<strong>定义在类命名空间中函数是为实例定义</strong></p>
<ul>
<li>要为类定义方法应该自定义元类</li>
</ul>
</li>
<li><p>测试代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self, attr</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;--Meta--&quot;</span>, attr)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">super</span>().attr</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>(<span class="params">metaclass=Meta</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self, attr</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;--Class--&quot;</span>, attr)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">super</span>().attr</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<ul>
<li><code>__getattribute__</code>函数说明参见
  <em>cs_python/py3ref/special_methods</em></li>
</ul>
</blockquote>
<h3 id="属性访问控制"><a href="#属性访问控制" class="headerlink" title="属性访问控制"></a>属性访问控制</h3><blockquote>
<ul>
<li>python没有没有属性访问控制，不依赖语言特性封装数据，而是
  遵循一定属性、方法命名规约达到效果</li>
</ul>
</blockquote>
<ul>
<li><p><code>__</code>开头属性：属性名称会被修改</p>
<ul>
<li>防止被派生类继承，此类属性无法通过继承覆盖</li>
<li>即若清楚代码会涉及子类，且应该在子类中隐藏起来，考虑
使用双下划线开头</li>
</ul>
<blockquote>
<ul>
<li>通常是在属性名称前添加类名标记<code>_cls</code></li>
<li>但同时以<code>__</code>结尾属性名称不会被修改</li>
</ul>
</blockquote>
</li>
<li><p>单<code>_</code>开头属性：应被视为私有属性，不应被外部访问</p>
<ul>
<li>python无法真正防止访问内部名称，但是这样会导致脆弱的
代码</li>
<li><p>此约定同样适用于模块名、模块级别函数</p>
<ul>
<li>默认情况下，通配符<code>*</code>不会导入模块私有属性，除非
在配置有<code>__all__</code>属性</li>
</ul>
<blockquote>
<ul>
<li>导入参见<em>cs_python/py3ref/simple_stmt#todo</em></li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>单<code>_</code>结尾：避免定义的变量和保留关键字冲突</p>
</li>
</ul>
<h3 id="特殊属性-2"><a href="#特殊属性-2" class="headerlink" title="特殊属性"></a>特殊属性</h3><ul>
<li><code>__dict__</code>：命名空间包含的属性</li>
<li><code>__doc__</code>：文档字符串<ul>
<li>第一条语句、且须为字符串字面值</li>
<li>没有则为<code>None</code></li>
<li>不会被子类继承</li>
</ul>
</li>
<li><code>__name__</code>：名称</li>
<li><code>__qualname__</code>：<em>qualified name</em>，完整限定名称<ul>
<li>以点号分隔的名称</li>
<li>显示模块全局作用域到模块中某个定义类、函数、方法的
路径</li>
</ul>
</li>
<li><code>__module__</code>：所属模块名称<ul>
<li>没有则为<code>None</code></li>
</ul>
</li>
</ul>
<h2 id="描述器属性"><a href="#描述器属性" class="headerlink" title="描述器属性"></a>描述器属性</h2><blockquote>
<ul>
<li>描述器协议参见<em>cs_python/py3ref/special_methods</em></li>
<li>实例/类/静态方法：参见<em>cs_python/py3ref/dm_gfuncs</em></li>
</ul>
</blockquote>
<h3 id="property"><a href="#property" class="headerlink" title="@property"></a><code>@property</code></h3><p><code>@property</code>装饰器：为类的属性增加处理逻辑，如：类型检查、
合法性验证</p>
<ul>
<li><p><em>property</em>属性和普通属性实现迥异，但使用类似</p>
<ul>
<li><em>property</em>属性就是绑定有这些处理逻辑函数的类实例</li>
<li>访问、赋值、解除绑定时会自动触发<code>getter</code>、<code>setter</code>、
<code>deleter</code>处理逻辑</li>
</ul>
</li>
<li><p><em>property</em>属性（或者说有效描述器）为类属性</p>
<ul>
<li>一般需要通过在实例、或描述器命名空间
<code>instance.__dict__</code>中存储数据，以实现对实例操作逻辑
独立</li>
<li>也可以实时计算属性值，此时无需为实例分别存储数据</li>
<li>初始化时，不应该直接设置底层数据属性，会绕过<code>setter</code>
的参数检查</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>过度使用<code>@property</code>时会降低代码可读性、效率，使用
  <em>get/set</em>方法可能有更好的兼容性</li>
</ul>
</blockquote>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><blockquote>
<ul>
<li>代码是C实现，这里是python模拟，和<code>help</code>结果不同</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Property</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="string">&quot;Emulate PyProperty_Type() in Objects/descrobject.c&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, fget=<span class="literal">None</span>, fset=<span class="literal">None</span>, fdel=<span class="literal">None</span>, doc=<span class="literal">None</span></span>):</span></span><br><span class="line">		self.fget = fget</span><br><span class="line">		self.fset = fset</span><br><span class="line">		self.fdel = fdel</span><br><span class="line">		<span class="keyword">if</span> doc <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> fget <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">			doc = fget.__doc__</span><br><span class="line">		self.__doc__ = doc</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, obj, objtype=<span class="literal">None</span></span>):</span></span><br><span class="line">		<span class="keyword">if</span> obj <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">			<span class="keyword">return</span> self</span><br><span class="line">		<span class="keyword">if</span> self.fget <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">			<span class="keyword">raise</span> AttributeError(<span class="string">&quot;unreadable attribute&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> self.fget(obj)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, obj, value</span>):</span></span><br><span class="line">		<span class="keyword">if</span> self.fset <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">			<span class="keyword">raise</span> AttributeError(<span class="string">&quot;can&#x27;t set attribute&quot;</span>)</span><br><span class="line">		self.fset(obj, value)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self, obj</span>):</span></span><br><span class="line">		<span class="keyword">if</span> self.fdel <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">			<span class="keyword">raise</span> AttributeError(<span class="string">&quot;can&#x27;t delete attribute&quot;</span>)</span><br><span class="line">		self.fdel(obj)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">getter</span>(<span class="params">self, fget</span>):</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">type</span>(self)(fget, self.fset, self.fdel, self.__doc__)</span><br><span class="line">		<span class="comment"># 返回描述器，可省略</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">setter</span>(<span class="params">self, fset</span>):</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">type</span>(self)(self.fget, fset, self.fdel, self.__doc__)</span><br><span class="line">		<span class="comment"># 返回更新`fset`的描述器，同名所以覆盖前者</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">deleter</span>(<span class="params">self, fdel</span>):</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">type</span>(self)(self.fget, self.fset, fdel, self.__doc__)</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>@property</code>是描述器类，接受方法返回同名资料描述器</li>
</ul>
</blockquote>
<h4 id="创建property属性"><a href="#创建property属性" class="headerlink" title="创建property属性"></a>创建<em>property</em>属性</h4><ul>
<li><p><code>@property[.getter]</code>装饰<em>getter-like</em>方法得到同名资料
描述器</p>
</li>
<li><p>返回描述器包含<code>.setter()</code>、<code>.deleter()</code>方法/装饰器进一步
完善描述器</p>
<ul>
<li><code>@method.setter</code>：为描述器完善赋值处理逻辑</li>
<li><code>@method.deleter</code>：为描述器完善<code>del</code>处理逻辑</li>
</ul>
</li>
<li><p>可以直接使用已有类中函数创建<code>property</code>类实例，得到
<em>property</em>属性（描述器）</p>
</li>
<li><p>派生类中<em>property</em>属性覆盖</p>
<ul>
<li><p>派生类中直接使用<code>@property</code>创建同名属性会覆盖基类
中<em>property</em>属性</p>
<ul>
<li>只有显式声明的处理逻辑被设置</li>
<li>基类中逻辑位于基类相应同名<em>property</em>属性，不会
被“隐式继承”</li>
</ul>
</li>
<li><p><code>@&lt;basecls&gt;.&lt;method&gt;.getter/setter/deleter</code>单独覆盖
<em>property</em>属性方法</p>
<ul>
<li>但是<code>basecls</code>是<strong>硬编码方式</strong>，必须知道定义
property属性的具体类（或其子类）</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>描述器协议、实现参见<em>cs_python/py3ref/special_methods</em></li>
</ul>
</blockquote>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">		self.birth = value</span><br><span class="line">			<span class="comment"># 使用`self.birth`而不是`self._birth`，保证即使</span></span><br><span class="line">				<span class="comment"># 实在初始化时仍然进行参数检查</span></span><br><span class="line"></span><br><span class="line"><span class="meta">	@property</span></span><br><span class="line">		<span class="comment"># 将一个getter-like方法变为属性</span></span><br><span class="line">		<span class="comment"># `@property`同时会创建装饰器`@method.setter`</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">birth</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> self._birth</span><br><span class="line"></span><br><span class="line"><span class="meta">	@birth.setter</span></span><br><span class="line">		<span class="comment"># `@property`对应，将setter-like方法变为属性</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">birth</span>(<span class="params">self, value</span>):</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> instance(value, <span class="built_in">int</span>):</span><br><span class="line">			<span class="keyword">raise</span> ValueError(<span class="string">&quot;birth must be an integer&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> value &lt; <span class="number">1900</span> <span class="keyword">or</span> value &gt; <span class="number">2020</span>:</span><br><span class="line">			<span class="keyword">raise</span> ValueError(<span class="string">&quot;birth must between 1900 ~ 2020&quot;</span>)</span><br><span class="line">		self._birth = value</span><br><span class="line"></span><br><span class="line"><span class="meta">	@birth.deleter</span></span><br><span class="line">		<span class="comment"># 同`@property`对应，在`del`时调用</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">birth</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">del</span>(self._age)</span><br><span class="line">		<span class="keyword">del</span>(self._birth)</span><br><span class="line"></span><br><span class="line"><span class="meta">	@property</span></span><br><span class="line">		<span class="comment"># 只设置`@property`而没有设置对应`@birth.setter`</span></span><br><span class="line">		<span class="comment"># 这样`birth`就成了只读属性</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">2018</span> - self._birth</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_first_name</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> self._first_name</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">set_first_name</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> instance(value, <span class="built_in">str</span>):</span><br><span class="line">			<span class="keyword">raise</span> TypeError(<span class="string">&quot;expected a string&quot;</span>)</span><br><span class="line">		self._first_name = value</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">del_first_name</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">raise</span> AttributeError(<span class="string">&quot;can&#x27;t delete attribute&quot;</span>)</span><br><span class="line"></span><br><span class="line">	name = <span class="built_in">property</span>(get_first_name,</span><br><span class="line">		set_first_name,</span><br><span class="line">		del_first_name)</span><br><span class="line">		<span class="comment"># 在已有getter-like、setter-like方法上创建property</span></span><br><span class="line">		<span class="comment"># 注意：这里就是应该定义类属性，本身使用`@property`</span></span><br><span class="line">			<span class="comment"># 装饰器也是相当于创建类属性</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">		self.name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">	@property</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">	@name.setter</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self, value</span>):</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> instance(value, <span class="built_in">str</span>):</span><br><span class="line">			<span class="keyword">raise</span> TypeError(<span class="string">&quot;expected a string&quot;</span>)</span><br><span class="line">		self._name = value</span><br><span class="line"></span><br><span class="line"><span class="meta">	@name.deleter</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">raise</span> AttributeError(<span class="string">&quot;can&#x27;t delete attribute&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubPersonAll</span>(<span class="params">Person</span>):</span></span><br><span class="line">	<span class="comment"># 这个类继承、扩展了`name`属性的所有功能</span></span><br><span class="line"><span class="meta">	@property</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;getting name&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">super</span>().name</span><br><span class="line"></span><br><span class="line"><span class="meta">	@name.setter</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self, value</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;Setting name to&quot;</span>, value)</span><br><span class="line">		<span class="built_in">super</span>(SubPerson, SubPerson).name.__set__(self, value)</span><br><span class="line">			<span class="comment"># 使用`super(SubPerson, SubPerson)`调用父类实现</span></span><br><span class="line">			<span class="comment"># 将控制权传递给`.name.__set__`方法，委托给父类</span></span><br><span class="line">				<span class="comment"># 中定义的setter方法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">	@name.deleter</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;deleting name&quot;</span>)</span><br><span class="line">		<span class="built_in">super</span>(SubPerson, SubPerson).name.__delete__(self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubPersonPart</span>(<span class="params">Person</span>):</span></span><br><span class="line">	<span class="comment"># 仅修改`name`属性的某个方法</span></span><br><span class="line">	<span class="comment"># 需要知道定义`name`属性的基类，否则重新定义property属性</span></span><br><span class="line">		<span class="comment"># 的所有方法，并使用`super`将控制权转移给父类</span></span><br><span class="line"><span class="meta">	@Person.name.getter</span></span><br><span class="line">		<span class="comment"># 使用硬编码的`Person`类名，这样会把之前已经定义的</span></span><br><span class="line">			<span class="comment"># property属性方法复制过来，而对应的`getter`、</span></span><br><span class="line">			<span class="comment"># `setter`、`deleter`方法被替换</span></span><br><span class="line">		<span class="comment"># 这里如果直接使用`@property`装饰，那么`setter`、</span></span><br><span class="line">			<span class="comment"># `deleter`方法将会消失</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;getting name&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">super</span>().name</span><br></pre></td></tr></table></figure>
<h2 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h2><ul>
<li>类继承会获得基类的所有方法<ul>
<li>类里面的方法其实真的不是给类使用的，而是给实例使用</li>
<li>类自身使用的方法是元类中的方法</li>
</ul>
</li>
</ul>
<h3 id="Method-Resolution-Order"><a href="#Method-Resolution-Order" class="headerlink" title="Method Resolution Order"></a><em>Method Resolution Order</em></h3><p><em>MRO</em>/方法解析顺序列表：包含当前类所有超类的线性顺序表</p>
<ul>
<li><p>MRO列表顺序通过C3线性化算法实现，对每个类按以下规则合并
所有父类的MRO列表</p>
<ul>
<li>子类先于父类检查</li>
<li>多个父类根据其在列表中的顺序被检查</li>
<li>若对下一个类存在多个合法的选择，选择第一个父类</li>
</ul>
</li>
<li><p>为了实现继承，python会在MRO列表上从左到右开始查找超类，
直到第一个匹配这个属性的类为止</p>
</li>
</ul>
<blockquote>
<ul>
<li>可以通过<strong>类</strong><code>__mro__</code>、<code>mro()</code>访问</li>
</ul>
</blockquote>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a><code>super</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">super</span>:</span></span><br><span class="line">	<span class="built_in">super</span>()</span><br><span class="line">		<span class="comment"># 等同于：`super(__class__, &lt;first_argument&gt;)`</span></span><br><span class="line">		<span class="comment"># `&lt;first_argument&gt;`常常就是`self`</span></span><br><span class="line">	<span class="built_in">super</span>(<span class="built_in">type</span>)</span><br><span class="line">		<span class="comment"># 返回：未绑定super对象，需要`__get__`绑定</span></span><br><span class="line">	<span class="built_in">super</span>(<span class="built_in">type</span>, obj)</span><br><span class="line">		<span class="comment"># 返回：已绑定super对象，要求`isinstance(obj,type)`</span></span><br><span class="line">	<span class="built_in">super</span>(<span class="built_in">type</span>, type2)</span><br><span class="line">		<span class="comment"># 返回：已绑定super对象，要求`issubclass(type2, type)`</span></span><br><span class="line">		<span class="comment"># 此时调用方法返回是函数，不是绑定方法，不会默认传入</span></span><br><span class="line">			<span class="comment"># `type2`作为首个参数</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, obj, <span class="built_in">type</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">super</span>(<span class="params">cls, inst/subcls</span>):</span></span><br><span class="line">    mro = inst.__class__.mro()</span><br><span class="line">	mro = subcls.mro()</span><br><span class="line">    <span class="keyword">return</span> mro[mro.index(cls) + <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数</p>
<ul>
<li>第一个参数：在MRO列表中定位类搜索起点（不包括）</li>
<li>第二个参数：<strong>提供MRO列表</strong><ul>
<li>类：直接传递MRO列表</li>
<li>实例：传递所属类的MRO列表</li>
</ul>
</li>
</ul>
</li>
<li><p>返回：封装有两个参数的<code>super</code>实例</p>
<ul>
<li>类似于返回MRO列表中某个类的实例，取决于访问的属性</li>
</ul>
</li>
<li><p>用途：依次遍历MRO列表（指定位置开始）中类，查找指定属性</p>
<ul>
<li>可以使用指定超类创建<code>super</code>实例，跳过对部分类搜索</li>
<li>只有MRO列表中每个类中的方法都<code>super()</code>调用，才能保证
列表中所有类的该方法都被链式调用</li>
</ul>
</li>
</ul>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul>
<li><p>需要注意<code>super(cls, inst).__getattribute__(&quot;meth&quot;)</code>中
共有两段属性访问，两次访问调用不同<code>__getattribute__</code></p>
<ul>
<li><p><code>super(cls, inst).__getattribute__</code>首先调用
<code>super.__getattribute__</code>在<code>type(inst).mro()</code>中寻找
<code>some_cls.__getattribute__</code></p>
</li>
<li><p>然后调用<code>some_cls.__getattrbibute__(&quot;meth&quot;)</code>访问
<code>meth</code>属性</p>
</li>
</ul>
</li>
<li><p>应使用<code>super</code>访问基类属性，而不是直接使用基类名称，避免
多继承中出现问题</p>
<ul>
<li>继承链<code>super</code>保证方法只按找MRO列表顺序调用一次</li>
<li>多继承中硬编码基类名称调用方法可能导致方法被调用多次</li>
</ul>
</li>
<li><p><code>super</code>访问的属性路线不够明确，所以需要遵循以下原则</p>
<ul>
<li>继承体系中，所有相同名字的方法拥有可兼容的参数名，
比如：相同参数个数、名称</li>
<li>最好确保最顶层类提供这个方法的实现，这样保证MRO上的
查找链肯定可以找到该方法</li>
</ul>
</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>接口、抽象类</p>
<ul>
<li><p>抽象类无法直接实例化</p>
<ul>
<li>目的就是让别的类继承它并实现特定的抽象方法</li>
<li>也可以通过注册方式让某类实现抽象基类</li>
</ul>
</li>
<li><p>用途</p>
<ul>
<li>通过执行类型检查，确保实现为特定类型、实现特定接口</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>类型检查很方便，但是不应该过度使用，因为动态语言目的就是
  灵活性，强制类型检查让代码更复杂</li>
<li>使用<code>abc</code>模块方便定义抽象类</li>
</ul>
</blockquote>
<h3 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h3><p><em>Mixins</em>：把一些有用的方法包装成Mixin类，用于扩展其他类的
功能，而这些类往往又没有继承关系</p>
<ul>
<li>Mixin不能直接实例化使用</li>
<li>Mixin没有自己的状态信息，即没有定义<code>__init__</code>方法，
没有实例属性，因此Mixin中往往会定义<code>__slots__ = ()</code></li>
</ul>
<blockquote>
<ul>
<li>Mixins讨论参见<em>cs_program/program_design/inheritation</em></li>
</ul>
</blockquote>
<h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggedMappingMixin</span>:</span></span><br><span class="line">	__slots__ = ()</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;getting:&quot;</span>, <span class="built_in">str</span>(key))</span><br><span class="line">		<span class="keyword">return</span> super9).__getimte__(key)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;setting &#123;&#125; = &#123;!r&#125;&quot;</span>.<span class="built_in">format</span>(key, value))</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">super</span>().__setitem__(key, value)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;deleting&quot;</span>, <span class="built_in">str</span>(key))</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">super</span>().__delitem__(key)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetOnceMappingMixin</span>:</span></span><br><span class="line">	__slots__ = ()</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">		<span class="keyword">if</span> key <span class="keyword">in</span> self:</span><br><span class="line">			<span class="keyword">raise</span> KeyError(<span class="built_in">str</span>(key), <span class="string">&quot;alreay set&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">super</span>().__setitem__(key, value)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringKeysMappingMixin</span>:</span></span><br><span class="line">	__slots__ = ()</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(key, <span class="built_in">str</span>):</span><br><span class="line">			<span class="keyword">raise</span> TypeError(<span class="string">&quot;keys must be strings&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">super</span>().__setitem__(key, value)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 单独的Mixin类使用没有意义，也无法实例化</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggedDict</span>(<span class="params">LoggedMappingMixin, <span class="built_in">dict</span></span>):</span></span><br><span class="line">	<span class="comment"># 把混入类和其他已存在的类结合起来使用</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetOnceDefaultDict</span>(<span class="params">SetOnceMappingMixin, defaultdict</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">	d = LoggedDict()</span><br><span class="line">	d[<span class="string">&quot;x&quot;</span>] = <span class="number">23</span></span><br><span class="line">	<span class="built_in">print</span>(d[<span class="string">&quot;x&quot;</span>])</span><br><span class="line">	<span class="keyword">del</span> d[<span class="string">&quot;x&quot;</span>]</span><br><span class="line"></span><br><span class="line">	d = setOnceDefaultDict(<span class="built_in">list</span>)</span><br><span class="line">	d[<span class="string">&quot;x&quot;</span>].append(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-05-22T00:28:30.000Z" title="5/22/2019, 8:28:30 AM">2019-05-22</time></span><span class="level-item">Updated&nbsp;<time dateTime="2019-05-22T00:28:30.000Z" title="5/22/2019, 8:28:30 AM">2019-05-22</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a><span> / </span><a class="link-muted" href="/categories/Python/Py3Ref/">Py3Ref</a></span><span class="level-item">22 minutes read (About 3291 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Python/Py3Ref/cls_templates.html">Python类用法实例</a></h1><div class="content"><h2 id="延迟计算"><a href="#延迟计算" class="headerlink" title="延迟计算"></a>延迟计算</h2><p>使用描述器类构造延迟计算属性</p>
<ul>
<li>主要目的是为了提升性能</li>
<li>避免立即计算</li>
<li>缓存计算结果供下次使用</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lazyproperty</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, func</span>):</span></span><br><span class="line">		self.func = func</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, cls</span>):</span></span><br><span class="line">		<span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">			<span class="keyword">return</span> self</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			value = self.func(instance)</span><br><span class="line">			<span class="built_in">setattr</span>(instance, self.func.__name__, value)</span><br><span class="line">			<span class="comment"># 计算完成之后，缓存计算结果于类实例中</span></span><br><span class="line">			<span class="keyword">return</span> value</span><br><span class="line">	<span class="comment"># 描述器仅仅定义一个`__get__`方法，比通常具有更弱的绑定</span></span><br><span class="line">	<span class="comment"># 这里，只有被访问属性不在**实例**底层字典`__dict__`中时</span></span><br><span class="line">		<span class="comment"># `__get__`方法才会被触发</span></span><br><span class="line">	<span class="comment"># 描述器属性是类属性，但优先级好像是高于实例属性？？？</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazyproperty_unchangable</span>(<span class="params">func</span>):</span></span><br><span class="line">	<span class="comment"># 这个版本的延迟计算，使用property属性限制对结果的修改</span></span><br><span class="line">	name = <span class="string">&quot;_lazy_&quot;</span> + func.__name __</span><br><span class="line"></span><br><span class="line"><span class="meta">	@property</span></span><br><span class="line">		<span class="comment"># 这里`@property`是在类外定义的</span></span><br><span class="line">		<span class="comment"># 并且，这里实际上返回的是`property`类实例，也不需要</span></span><br><span class="line">			<span class="comment"># `wraps(func)`保持原函数元信息</span></span><br><span class="line">		<span class="comment"># 但此时所有的操作都定向到`getter`函数上，效率较低</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">lazy</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">hasattr</span>(self, name):</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">getattr</span>(self, name)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			value = func(self)</span><br><span class="line">			<span class="built_in">setattr</span>(self, name, value)</span><br><span class="line">			<span class="keyword">return</span> value</span><br><span class="line">	<span class="keyword">return</span> lazy</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, radiu</span>):</span></span><br><span class="line">		self.radius = radius</span><br><span class="line"></span><br><span class="line"><span class="meta">	@lazyproperty</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">area</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;computing area&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> math.pi * self.radius ** <span class="number">2</span></span><br><span class="line">	<span class="comment"># 等价于`area = lazyproperty(area)`</span></span><br><span class="line">	<span class="comment"># 所以是真的把描述器类实例作为类属性</span></span><br><span class="line"></span><br><span class="line"><span class="meta">	@lazyproperty</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">perimeter</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;computing perimeter&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span> * math.pi * self.radius</span><br></pre></td></tr></table></figure>
<h2 id="数据模型类型约束"><a href="#数据模型类型约束" class="headerlink" title="数据模型类型约束"></a>数据模型类型约束</h2><p>使用描述器在对实例某些属性赋值时进行检查</p>
<h3 id="类继承方案"><a href="#类继承方案" class="headerlink" title="类继承方案"></a>类继承方案</h3><h4 id="基础构建模块"><a href="#基础构建模块" class="headerlink" title="基础构建模块"></a>基础构建模块</h4><p>创建数据模型、类型系统的基础构建模块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Descriptor</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name=<span class="literal">None</span>, **opts</span>):</span></span><br><span class="line">		self.name = name</span><br><span class="line">		<span class="keyword">for</span> key, value <span class="keyword">in</span> opts.items()</span><br><span class="line">			<span class="built_in">setattr</span>(self, key, value)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span></span><br><span class="line">		<span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">			<span class="keyword">return</span> self</span><br><span class="line">		instance.__dict__[self.name] = value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Typed</span>(<span class="params">Descriptor</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span></span><br><span class="line">		<span class="keyword">if</span> value &lt; <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">raise</span> ValueError(<span class="string">&quot;expected &gt;= 0&quot;</span>)</span><br><span class="line">		<span class="built_in">super</span>().__set__(instance, value)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Unsigned</span>(<span class="params">Descriptor</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span></span><br><span class="line">		<span class="keyword">if</span> value &lt; <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">raise</span> ValueError(<span class="string">&quot;expect &gt;= 0&quot;</span>)</span><br><span class="line">		<span class="built_in">super</span>().__set__(instance, value)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxSized</span>(<span class="params">Descriptor</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name=<span class="literal">None</span>, **opts</span>):</span></span><br><span class="line">		<span class="keyword">if</span> <span class="string">&quot;size&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> opts:</span><br><span class="line">			<span class="keyword">raise</span> TypeError(<span class="string">&quot;missing size options&quot;</span>)</span><br><span class="line">		<span class="built_in">super</span>.__init__(name, **opts)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(value) &gt;= self.size:</span><br><span class="line">			<span class="keyword">raise</span> ValueError(<span class="string">&quot;size must be &lt;&quot;</span> + <span class="built_in">str</span>(self.size))</span><br><span class="line">		<span class="built_in">super</span>().__set__(instance, value)</span><br></pre></td></tr></table></figure>
<h4 id="具体数据类型"><a href="#具体数据类型" class="headerlink" title="具体数据类型"></a>具体数据类型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span>(<span class="params">Typed</span>):</span></span><br><span class="line">	expected_type = <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UsignedInteger</span>(<span class="params">Integer, Unsigned</span>):</span></span><br><span class="line">	<span class="comment"># 描述器类是基于混入实现的</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Float</span>(<span class="params">Typed</span>):</span></span><br><span class="line">	expected_type = Float</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsignedFloat</span>(<span class="params">Float, Unsigned</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span>(<span class="params">Typed</span>):</span></span><br><span class="line">	expected_type = <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SizedString</span>(<span class="params">String, MaxSized</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span>:</span></span><br><span class="line">	name = SizedString(<span class="string">&quot;name&quot;</span>, size=<span class="number">8</span>)</span><br><span class="line">	shares = UnsignedInteger(<span class="string">&quot;shares&quot;</span>)</span><br><span class="line">	price = UnsignedFloat(<span class="string">&quot;price&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, shares, price</span>):</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.shares = shares</span><br><span class="line">		self.price = price</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_attributes</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">decrator</span>(<span class="params">cls</span>):</span></span><br><span class="line">		<span class="keyword">for</span> key, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">isinstance</span>(value, Descriptor):</span><br><span class="line">				value.name = key</span><br><span class="line">				<span class="built_in">setattr</span>(cls, key, value)</span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				<span class="built_in">setattr</span>(cls, key, value(key))</span><br><span class="line">		<span class="keyword">return</span> cls</span><br><span class="line">	<span class="keyword">return</span> decrator</span><br><span class="line"></span><br><span class="line"><span class="meta">@check_attributes(<span class="params">name=SizedString(<span class="params">size=<span class="number">8</span></span>),</span></span></span><br><span class="line"><span class="params"><span class="meta">	shares=UnsignedInteger,</span></span></span><br><span class="line"><span class="params"><span class="meta">	price=UnsignedFloat</span>)</span></span><br><span class="line">	<span class="comment"># 使用类装饰器简化版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock2</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, shares, price</span>):</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.shares = shares</span><br><span class="line">		self.price = price</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">checkmeta</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, clsname, bases, methods</span>):</span></span><br><span class="line">		<span class="keyword">for</span> key, value <span class="keyword">in</span> method.items():</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">isinstance</span>(value, Descriptor):</span><br><span class="line">				value.name = key</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls, clsname, bases, methods)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock3</span>(<span class="params">metaclass=checkdmeta</span>):</span></span><br><span class="line">	name = SizedString(size=<span class="number">8</span>)</span><br><span class="line">	shares = UnsignedInteger()</span><br><span class="line">	price = UnsignedFloat()</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, shares, price</span>):</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.shares = shares</span><br><span class="line">		self.price = price</span><br></pre></td></tr></table></figure>
<h3 id="装饰器类替代mixin"><a href="#装饰器类替代mixin" class="headerlink" title="装饰器类替代mixin"></a>装饰器类替代mixin</h3><p>使用类装饰器、元类都可以简化代码，但类装饰器更加灵活</p>
<ul>
<li>类装饰器不依赖其他任何新技术</li>
<li>类装饰器可以容易的添加、删除</li>
<li>类装饰器能做为mixin的替代技术实现同样的效果，而且速度
更快，设置一个简单的类型属性值，装饰器要快一倍</li>
</ul>
<h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LoggedMapping</span>(<span class="params">cls</span>):</span></span><br><span class="line">	cls_getitem = cls.__getitem__</span><br><span class="line">	cls_setitem = cls.__setitem__</span><br><span class="line">	cls_delitem = cls.__setitem__</span><br><span class="line">		<span class="comment"># 获取原`cls`的方法，避免死循环调用</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;getting&quot;</span>, <span class="built_in">str</span>(key))</span><br><span class="line">		<span class="keyword">return</span> cls_getitem(self, key)</span><br><span class="line">			<span class="comment"># 这里使用之前获取的方法指针调用，而不直接使用</span></span><br><span class="line">				<span class="comment"># `cls.__getitem__`避免死循环</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">		pritn(<span class="string">&quot;setting &#123;&#125; = &#123;!r&#125;&quot;</span>, <span class="built_in">str</span>(key))</span><br><span class="line">		<span class="keyword">return</span> cls_set(self, key, value)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;deleting&quot;</span>, <span class="built_in">str</span>(key))</span><br><span class="line">		<span class="keyword">return</span> cls_delitem(self, key)</span><br><span class="line"></span><br><span class="line">	cls.__getitem__ = __getitem__</span><br><span class="line">	cls.__setitem__ = __setitem__</span><br><span class="line">	cls.__delitem__ = __delitem__</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line"><span class="meta">@LoggedMapping</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggedDict</span>(<span class="params"><span class="built_in">dict</span></span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Type</span>(<span class="params">expected_type, cls=<span class="literal">None</span></span>):</span></span><br><span class="line">	<span class="keyword">if</span> cls <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">lambda</span> cls: Typerd(expected_type, cls)</span><br><span class="line">	super_set = cls.__set__</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span></span><br><span class="line">		<span class="keyword">if</span> no instance(value, expected_type):</span><br><span class="line">			<span class="keyword">raise</span> TypeError(<span class="string">&quot;expect &quot;</span> + <span class="built_in">str</span>(expected_type))</span><br><span class="line">		super_set(self, instance, value)</span><br><span class="line"></span><br><span class="line">	cls.__set__ = __set__</span><br><span class="line">	<span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Unsigned</span>(<span class="params">cls</span>):</span></span><br><span class="line">	super_set = cls.__set__</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span></span><br><span class="line">		<span class="keyword">if</span> value &lt; <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">raise</span> TypeError(<span class="string">&quot;missing size option&quot;</span>)</span><br><span class="line">		super_set(self, name, **opts)</span><br><span class="line"></span><br><span class="line">	cls.__init__ = __set__</span><br><span class="line">	<span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MaxSized</span>(<span class="params">cls</span>):</span></span><br><span class="line">	super_init = cls.__init__</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name=<span class="literal">None</span>, **opts</span>):</span></span><br><span class="line">		<span class="keyword">if</span> <span class="string">&quot;size&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> opts:</span><br><span class="line">			<span class="keyword">raise</span> TypeError(<span class="string">&quot;missing size option&quot;</span>)</span><br><span class="line">		super_init(self, name, **opts)</span><br><span class="line"></span><br><span class="line">	cls.__init__ = __init__</span><br><span class="line"></span><br><span class="line">	super_set = cls.__set__</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(value) &gt;= self.size:</span><br><span class="line">			<span class="keyword">raise</span> ValueError(<span class="string">&quot;size must be &lt;&quot;</span> + <span class="built_in">str</span>(self.size))</span><br><span class="line">		super_set(self, instance, value)</span><br><span class="line"></span><br><span class="line">	cls.__set__ = __set__</span><br><span class="line">	<span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line"><span class="meta">@Typed(<span class="params"><span class="built_in">int</span></span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span>(<span class="params">Descriptor</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Unsigned</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsignedInteger</span>(<span class="params">Integer</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Typed(<span class="params"><span class="built_in">float</span></span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Float</span>(<span class="params">Descriptor</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Unsigned</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsignedFloat</span>(<span class="params">Float</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Typed(<span class="params"><span class="built_in">str</span></span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span>(<span class="params">Descriptor</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@MaxSized</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SizedString</span>(<span class="params">String</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h2 id="自定义容器"><a href="#自定义容器" class="headerlink" title="自定义容器"></a>自定义容器</h2><p><code>collections</code>定义了很多抽象基类，可以用于定义自定义基类</p>
<h3 id="collections-Sequence"><a href="#collections-Sequence" class="headerlink" title="collections.Sequence"></a><code>collections.Sequence</code></h3><p><code>Sequence</code>需要实现的抽象方法有：</p>
<ul>
<li><code>__getitem__</code></li>
<li><code>__len__</code></li>
<li><code>add</code></li>
</ul>
<p>继承自其的类，支持的常用操作：索引、迭代、包含判断、切片</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> <span class="type">Sequence</span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedItems</span>(<span class="params"><span class="type">Sequence</span></span>):</span></span><br><span class="line">	<span class="comment"># 必须要实现所有抽象方法，否则报错</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, initial=<span class="literal">None</span></span>):</span></span><br><span class="line">		self._items = <span class="built_in">sorted</span>(initial) <span class="keyword">if</span> initial <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> [ ]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">		<span class="keyword">return</span> self._items[index]</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">len</span>(self._items)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, item</span>):</span></span><br><span class="line">		bisect.insort(self._items, item)</span><br><span class="line">			<span class="comment"># `bisect`模块是用于在排序列表中高效插入元素</span></span><br><span class="line">			<span class="comment"># 保证在元素插入之后仍然保持顺序</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># `SortedItems`继承了`colllections.Sequence`，现在和</span></span><br><span class="line">	<span class="comment"># 普通序列无差，支持常用操作：索引、迭代、包含判断、切片</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">	items = SortedItems([<span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">list</span>(items))</span><br><span class="line">	<span class="built_in">print</span>(items[<span class="number">0</span>], items[-<span class="number">1</span>])</span><br><span class="line">	items.add(<span class="number">2</span>)</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">list</span>(items))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> instance(items, collections.Iterable):</span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">	<span class="keyword">if</span> instance(items, collections.<span class="type">Sequence</span>):</span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">	<span class="keyword">if</span> instance(items, collections.Container):</span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">	<span class="keyword">if</span> instance(items, collections.Sized):</span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">	<span class="keyword">if</span> instance(items, collections.Mapping):</span><br><span class="line">		<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="collections-MutableSequence"><a href="#collections-MutableSequence" class="headerlink" title="collections.MutableSequence"></a><code>collections.MutableSequence</code></h3><p><code>MutableSequence</code>基类包括需要实现的抽象方法</p>
<ul>
<li><code>__getitem__</code></li>
<li><code>__setitem__</code></li>
<li><code>__delitem__</code></li>
<li><code>__len__</code></li>
<li><code>insert</code></li>
</ul>
<p>提供的可用方法包括；</p>
<ul>
<li><code>append</code></li>
<li><code>count</code>：统计某值出现的次数</li>
<li><code>remove</code>：移除某值的元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> MutableSequence</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">collections.MutableSequence</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, initial=<span class="literal">None</span></span>):</span></span><br><span class="line">		self._items = <span class="built_in">list</span>(initial) <span class="keyword">if</span> initial <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> [ ]</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;getting:&quot;</span>, index)</span><br><span class="line">		<span class="keyword">return</span> self._items[index]</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;setting:&quot;</span>, index)</span><br><span class="line">		self._items[index] = value</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;deleting:&quot;</span>, index)</span><br><span class="line">		<span class="keyword">del</span> self._items[index]</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, index, value</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;inserting:&quot;</span>, index, value)</span><br><span class="line">		self._items.insert(index, value)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;len&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">len</span>(self._items)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 基本支持几乎所有的核心列表方法：`append`、`remove`、</span></span><br><span class="line">		<span class="comment"># `count`</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span>():</span></span><br><span class="line">	a = Items([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">len</span>(a))</span><br><span class="line">	a.append(<span class="number">4</span>)</span><br><span class="line">		<span class="comment"># 在末尾添加元素</span></span><br><span class="line">		<span class="comment"># 调用了`__len__`、`insert`方法</span></span><br><span class="line">	a.count(<span class="number">2</span>)</span><br><span class="line">		<span class="comment"># 统计值为`2`出现的次数</span></span><br><span class="line">		<span class="comment"># 调用`__getitem__`方法</span></span><br><span class="line">	a.remove(<span class="number">3</span>)</span><br><span class="line">		<span class="comment"># 删除值为`3`的元素</span></span><br><span class="line">		<span class="comment"># 调用`__getitem__`、`__delitem__`方法</span></span><br></pre></td></tr></table></figure>
<h2 id="属性的代理访问"><a href="#属性的代理访问" class="headerlink" title="属性的代理访问"></a>属性的代理访问</h2><p>代理是一种编程模式，将某个操作转移给另一个对象来实现</p>
<ul>
<li><p>需要代理多个方法时，可以使用<code>__getattr__</code></p>
<ul>
<li><p><code>__getattr__</code>方法只在属性、方法不存在时才被调用，
所以代理类实例本身有该属性不会触发该方法，也不会代理
至被代理类</p>
</li>
<li><p>如果需要管理所有对方法、属性的访问，可以定义
<code>__getattribute__</code>，其在对类的所有属性、访问时均会
被触发，且优先级高于<code>__getattr__</code></p>
</li>
<li><p><code>__setattr__</code>、<code>__delattr__</code>需要约定是对代理类还是
被代理类操作，通常约定只代理<code>_</code>开头的属性，即代理类
只暴露被代理类公共属性</p>
</li>
<li><p>注意：对象的元信息直接访问能通过<code>__getattr__</code>代理，
但是对应的hook可能无法正常工作，如果需要，要单独为
代理类实现<strong>元信息代理方法</strong></p>
</li>
</ul>
</li>
<li><p>通过自定义属性访问方法，可以用不同方式自定义代理类行为，
如：日志功能、只读访问</p>
</li>
<li>代理有时候可以作为继承的替代方案：代理类相当于继承了被
代理类</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span>:</span></span><br><span class="line">	<span class="comment"># 这个类用于包装、代理其他类，修改其行为</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, obj</span>):</span></span><br><span class="line">		self._obj = obj</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;getattr:&quot;</span>, name)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">getattr</span>(self._obj, name)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span>(<span class="params">self, name, value</span>):</span></span><br><span class="line">		<span class="keyword">if</span> name.startwith(<span class="string">&quot;_&quot;</span>):</span><br><span class="line">			<span class="comment"># 约定只代理不以`_`开头的属性</span></span><br><span class="line">			<span class="comment"># 代理类只暴露被代理类的公共属性</span></span><br><span class="line">			<span class="built_in">super</span>().__setattr__(name, value)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;setattr:&quot;</span>, name, value)</span><br><span class="line">			<span class="built_in">setattr</span>(self._obj, name, value)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">		<span class="keyword">if</span> name.startwith(<span class="string">&quot;_&quot;</span>):</span><br><span class="line">			<span class="built_in">super</span>().__delattr__(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;delattr:&quot;</span>, name)</span><br><span class="line">			<span class="built_in">delattr</span>(self._obj, name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">		self.x = x</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">self, x</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;Spam.bar&quot;</span>, self.x, y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">	s = Spam(<span class="number">2</span>)</span><br><span class="line">	p = Proxy(s)</span><br><span class="line">	p.bar(<span class="number">3</span>)</span><br><span class="line">	p.x = <span class="number">37</span></span><br><span class="line">		<span class="comment"># 通过`p`代理`s`</span></span><br><span class="line"></span><br><span class="line">	p = Porxy([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line">	<span class="comment"># len(p)</span></span><br><span class="line">		<span class="comment"># `len`函数直接使用会报错</span></span><br><span class="line">	p.__len__()</span><br><span class="line">		<span class="comment"># `p.__len__`可以正常代理，返回代理的列表长度</span></span><br><span class="line">		<span class="comment"># 这说明python中的钩子函数有特殊的结构？</span></span><br></pre></td></tr></table></figure>
<h2 id="状态机（状态模式）"><a href="#状态机（状态模式）" class="headerlink" title="状态机（状态模式）"></a>状态机（状态模式）</h2><p>为不同的状态定义对象，而不是使用过多的条件判断</p>
<ul>
<li>提高执行效率</li>
<li>提高代码可维护性、可读性</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connection</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		self.new_state(ClosedConnectionState)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">new_state</span>(<span class="params">self, newstate</span>):</span></span><br><span class="line">		self._state = newstate</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> self._state.read(self)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">self, data</span>):</span></span><br><span class="line">		<span class="keyword">return</span> self._state.write(self, data)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">open</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> self._state.close(self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectionState</span>:</span></span><br><span class="line"><span class="meta">	@staticmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">conn</span>):</span></span><br><span class="line">		<span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line"><span class="meta">	@staticmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">conn, data</span>):</span></span><br><span class="line">		<span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line"><span class="meta">	@staticmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">open</span>(<span class="params">conn</span>):</span></span><br><span class="line">		<span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line"><span class="meta">	@staticmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">conn</span>):</span></span><br><span class="line">		<span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClosedConnectionState</span>(<span class="params">ConnectionState</span>):</span></span><br><span class="line"><span class="meta">	@staticmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">conn</span>):</span></span><br><span class="line">		<span class="keyword">raise</span> RuntimeError(<span class="string">&quot;not open&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">	@staticmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">conn</span>):</span></span><br><span class="line">		<span class="keyword">raise</span> RuntimeError(<span class="string">&quot;not open&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">	@staticmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">open</span>(<span class="params">conn</span>):</span></span><br><span class="line">		conn.new_state(OpenConnectionState)</span><br><span class="line"></span><br><span class="line"><span class="meta">	@staticmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">conn</span>):</span></span><br><span class="line">		<span class="keyword">raise</span> RuntimeError(<span class="string">&quot;already closed&quot;</span>)</span><br><span class="line"></span><br><span class="line">calss OpenConnectionState(ConnectionState):</span><br><span class="line"><span class="meta">	@staicmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">conn</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;reading&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">	@staticmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">conn, data</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;writing&quot;</span>, data)</span><br><span class="line"></span><br><span class="line"><span class="meta">	@staticmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">open</span>(<span class="params">conn</span>):</span></span><br><span class="line">		<span class="keyword">raise</span> RuntimeError(<span class="string">&quot;already open&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">	@staticmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">conn</span>):</span></span><br><span class="line">		conn.new_state(ClosedConnectionState)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">	c = Connection()</span><br><span class="line">	c.<span class="built_in">open</span>()</span><br><span class="line">	c.read()</span><br><span class="line">	c.write(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">	c.close()</span><br></pre></td></tr></table></figure>
<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnaryOperator</span>(<span class="params">Node</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, operand</span>):</span></span><br><span class="line">		self.operand =operand</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryOperator</span>(<span class="params">Node</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, left, right</span>):</span></span><br><span class="line">		self.left = left</span><br><span class="line">		self.right = right</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Add</span>(<span class="params">BinaryOperator</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span>(<span class="params">BinaryOperator</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mul</span>(<span class="params">BinaryOperator</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Div</span>(<span class="params">BinaryOperator</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nagate</span>(<span class="params">UnaryOperator</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span>(<span class="params">Node</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">		self.value = value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeVsistor</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">visit</span>(<span class="params">self, node</span>):</span></span><br><span class="line">		methname = <span class="string">&quot;visit_&quot;</span> + <span class="built_in">type</span>(node).__name__</span><br><span class="line">		meth = <span class="built_in">getattr</span>(self, methname, <span class="literal">None</span>)</span><br><span class="line">			<span class="comment"># 使用`getattr`获取相应方法，避免大量`switch`</span></span><br><span class="line">			<span class="comment"># 子类需要实现`visit_Node`一系列方法</span></span><br><span class="line">		<span class="keyword">if</span> meth <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">			meth = self.generic_visit</span><br><span class="line">		<span class="keyword">return</span> meth(node)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">generic_visit</span>(<span class="params">self, node</span>):</span></span><br><span class="line">		<span class="keyword">raise</span> RuntimeError(<span class="string">&quot;No &#123;&#125; method&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;visit_&quot;</span> + <span class="built_in">type</span>(node).__name_))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Evaluator</span>(<span class="params">NodeVisitor</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">visit_Number</span>(<span class="params">self, node</span>):</span></span><br><span class="line">		<span class="keyword">return</span> node.value</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">visit_Add</span>(<span class="params">self, node</span>):</span></span><br><span class="line">		<span class="keyword">return</span> self.visit(node.left) + self.visit(node.right)</span><br><span class="line">		<span class="comment"># 递归调用`visit`计算结果</span></span><br><span class="line">		<span class="comment"># 因此可能超过python递归嵌套层级限制而失败</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">visit_Sub</span>(<span class="params">self, node</span>):</span></span><br><span class="line">		<span class="keyword">return</span> self.visit(node.left) - self.visit(node.right)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">visit_Mul</span>(<span class="params">self, node</span>):</span></span><br><span class="line">		<span class="keyword">return</span> self.visit(node.left) * self.visit(node.right)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">visit_Div</span>(<span class="params">self, node</span>):</span></span><br><span class="line">		<span class="keyword">return</span> self.visit(node.left) / self.visit(node.right)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">visit_Negate</span>(<span class="params">self, node</span>):</span></span><br><span class="line">		<span class="keyword">return</span> -node.operand</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">	t1 = Sub(Number(<span class="number">3</span>), Number(<span class="number">4</span>))</span><br><span class="line">	t2 = Mul(Number(<span class="number">2</span>), t1)</span><br><span class="line">	t3 = Div(t2, Number(<span class="number">5</span>))</span><br><span class="line">	t4 = Add(Number(<span class="number">1</span>), t3)</span><br><span class="line"></span><br><span class="line">	e = Evaluator()</span><br><span class="line">	e.visit(t4)</span><br></pre></td></tr></table></figure>
<h3 id="yield消除递归"><a href="#yield消除递归" class="headerlink" title="yield消除递归"></a><code>yield</code>消除递归</h3><p>消除递归一般是使用栈、队列，在python还可以使用<code>yield</code>得到
更加简洁的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> types</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeVisitor</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">visit</span>(<span class="params">self, node</span>):</span></span><br><span class="line">		stack = [node]</span><br><span class="line">		last_result = <span class="literal">None</span></span><br><span class="line">		<span class="keyword">while</span> stack:</span><br><span class="line">			<span class="keyword">try</span>:</span><br><span class="line">				last = stack[-<span class="number">1</span>]</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">isinstance</span>(last, types.GeneratorType):</span><br><span class="line">					<span class="comment"># 对`yield`实现</span></span><br><span class="line">					stack.append(last.send(last_result))</span><br><span class="line">					last_result = <span class="literal">None</span></span><br><span class="line">				<span class="keyword">elif</span> <span class="built_in">isinstance</span>(last, Node):</span><br><span class="line">					<span class="comment"># 对递归实现</span></span><br><span class="line">					stack.append(self._visit(stack.pop()))</span><br><span class="line">				<span class="keyword">else</span>:</span><br><span class="line">					last_result = stack.pop()</span><br><span class="line">			<span class="keyword">except</span> StopIteration:</span><br><span class="line">				stack.pop()</span><br><span class="line">		<span class="keyword">return</span> last_result</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">_visit</span>(<span class="params">self, node</span>):</span></span><br><span class="line">		methname = <span class="string">&quot;visit&quot;</span> + <span class="built_in">type</span>(node).__name__</span><br><span class="line">		meth = <span class="built_in">getattr</span>(self, methname, <span class="literal">None</span>)</span><br><span class="line">		<span class="keyword">if</span> meth <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">			meth = self.generic_visit</span><br><span class="line">		<span class="keyword">return</span> meth(node)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">generic_visit</span>(<span class="params">self, node</span>):</span></span><br><span class="line">		<span class="keyword">raise</span> RuntimeError(<span class="string">&quot;No &#123;&#125; method&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;visit_&quot;</span>, <span class="built_in">type</span>(node).__name__))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Evaluator</span>(<span class="params">NodeVisitor</span>):</span></span><br><span class="line">	<span class="comment"># `yield`版本不会多次递归，可以接受更多层级</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">visit_Number</span>(<span class="params">self, node</span>):</span></span><br><span class="line">		<span class="keyword">return</span> node.value</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">visit_Add</span>(<span class="params">self, node</span>):</span></span><br><span class="line">		<span class="keyword">yield</span> (<span class="keyword">yield</span> node.left) + (<span class="keyword">yield</span> node.right)</span><br><span class="line">		<span class="comment"># 遇到`yield`，生成器返回一个数据并暂时挂起</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">visit_Sub</span>(<span class="params">self, node</span>):</span></span><br><span class="line">		<span class="keyword">yield</span> (<span class="keyword">yield</span> node.left) + (<span class="keyword">yield</span> node.right)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">visit_Mul</span>(<span class="params">self, node</span>):</span></span><br><span class="line">		<span class="keyword">yield</span> (<span class="keyword">yield</span> node.left) * (<span class="keyword">yield</span> node.right)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">visit_Div</span>(<span class="params">self, node</span>):</span></span><br><span class="line">		<span class="keyword">yield</span> (<span class="keyword">yield</span> node.left) * (<span class="keyword">yield</span> node.right)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">visit_Nagate</span>(<span class="params">self, node</span>):</span></span><br><span class="line">		<span class="keyword">yield</span> - (<span class="keyword">yield</span> node.operand)</span><br></pre></td></tr></table></figure>
<h2 id="字符串调用方法"><a href="#字符串调用方法" class="headerlink" title="字符串调用方法"></a>字符串调用方法</h2><ul>
<li>可以使用<code>getattr(instance, name)</code>通过字符串调用方法</li>
<li>也可以用<code>operator.methodcaller</code><ul>
<li><code>operator.methodcaller</code>创建可调用对象，同时提供所有
必要参数</li>
<li>调用时只需要将实例对象传递给其即可</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> methodcaller</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">		self.x = x</span><br><span class="line">		self.y = y</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Point(&#123;!r&#125;, &#123;!r&#125;)&quot;</span>.<span class="built_in">format</span>(self.x, self.y)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">distance</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">		<span class="keyword">return</span> math.hypot(self.x -x, self.y - y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">	points = [</span><br><span class="line">		Point(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">		Point(<span class="number">3</span>, <span class="number">0</span>),</span><br><span class="line">		Point(<span class="number">10</span>, -<span class="number">3</span>),</span><br><span class="line">		Point(-<span class="number">5</span>, -<span class="number">7</span>)</span><br><span class="line">	]</span><br><span class="line"></span><br><span class="line">	points.sort(key=methodcaller(<span class="string">&quot;distance&#x27;, 0, 0))</span></span><br><span class="line"><span class="string">		# `methodcaller`创建可调用对象，并提供所有必要参数</span></span><br></pre></td></tr></table></figure>
<h2 id="缓存实例"><a href="#缓存实例" class="headerlink" title="缓存实例"></a>缓存实例</h2><h3 id="工厂函数"><a href="#工厂函数" class="headerlink" title="工厂函数"></a>工厂函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">		self.name = name</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line">_spam_cache = weakref.WeakValueDictionary()</span><br><span class="line">	<span class="comment"># `WeakValueDictionary`实例只保存在其他地方还被使用的</span></span><br><span class="line">		<span class="comment"># 实例，否则从字典移除</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_spam</span>(<span class="params">name</span>):</span></span><br><span class="line">	<span class="comment"># 使用工厂函数修改实例创建行为</span></span><br><span class="line">	<span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> _spam_cache:</span><br><span class="line">		s = Spam(name)</span><br><span class="line">		_spam_cache[name] = s</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		s = _spam_cache[name]</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">	a = get_spam(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">	b = get_spam(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">	<span class="built_in">print</span>(a <span class="keyword">is</span> b)</span><br></pre></td></tr></table></figure>
<h3 id="缓存管理器"><a href="#缓存管理器" class="headerlink" title="缓存管理器"></a>缓存管理器</h3><p>将缓存代码放到单独的缓存管理器中，</p>
<ul>
<li>代码更清晰、灵活，可以增加更多的缓存管理机制</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedSpamManager</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		self._cache = weakref.WeakValueDictionary()</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_spam</span>(<span class="params">self, name</span>):</span></span><br><span class="line">		<span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> self._cache:</span><br><span class="line">			s = Spam(name)</span><br><span class="line">			self._cache[name] = s</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			s = self._cache[name]</span><br><span class="line">		<span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">clear</span>(<span class="params">self</span>):</span></span><br><span class="line">		self._cache.clear()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span>:</span></span><br><span class="line">	manager = CacheSpamManager()</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">		<span class="comment"># `__init__`方法抛出异常，防止用户直接初始化</span></span><br><span class="line">		<span class="comment"># 也可以将类名加上`_`，提醒用户不要实例化</span></span><br><span class="line">		<span class="keyword">raise</span> RuntimeError(<span class="string">&quot;can&#x27;t instantiate directly&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">	@classmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">_new</span>(<span class="params">cls, name</span>):</span></span><br><span class="line">		self = cls.__new__(cls)</span><br><span class="line">		self.name = name</span><br><span class="line">		<span class="keyword">return</span> self</span><br></pre></td></tr></table></figure>
<h3 id="new"><a href="#new" class="headerlink" title="__new__"></a><code>__new__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line">clas Spam:</span><br><span class="line">	_spam_cache = weakref.WeakValueDictionary()</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, name</span>):</span></span><br><span class="line">		<span class="keyword">if</span> name <span class="keyword">in</span> cls._spam_cache:</span><br><span class="line">			<span class="keyword">return</span> cls._spam_cache[name]</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			self = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">			cls._spam_cache[name] = self</span><br><span class="line">			<span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;initializing Spam&quot;</span>)</span><br><span class="line">		self.name = name</span><br><span class="line">	<span class="comment"># 这种方式实际会多次调用`__init__`方法，即使已经结果已经</span></span><br><span class="line">		<span class="comment"># 缓存，不是个好方法</span></span><br></pre></td></tr></table></figure>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/categories/Python/page/4/">Previous</a></div><div class="pagination-next"><a href="/categories/Python/page/6/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/categories/Python/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/categories/Python/page/4/">4</a></li><li><a class="pagination-link is-current" href="/categories/Python/page/5/">5</a></li><li><a class="pagination-link" href="/categories/Python/page/6/">6</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/categories/Python/page/9/">9</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">36</span></span></a><ul><li><a class="level is-mobile" href="/categories/Algorithm/Data-Structure/"><span class="level-start"><span class="level-item">Data Structure</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Heuristic/"><span class="level-start"><span class="level-item">Heuristic</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Issue/"><span class="level-start"><span class="level-item">Issue</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Problem/"><span class="level-start"><span class="level-item">Problem</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Specification/"><span class="level-start"><span class="level-item">Specification</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/C-C/"><span class="level-start"><span class="level-item">C/C++</span></span><span class="level-end"><span class="level-item tag">34</span></span></a><ul><li><a class="level is-mobile" href="/categories/C-C/Cppref/"><span class="level-start"><span class="level-item">Cppref</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/Cstd/"><span class="level-start"><span class="level-item">Cstd</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/MPI/"><span class="level-start"><span class="level-item">MPI</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/C-C/STL/"><span class="level-start"><span class="level-item">STL</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/CS/"><span class="level-start"><span class="level-item">CS</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/CS/Character/"><span class="level-start"><span class="level-item">Character</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Parallel/"><span class="level-start"><span class="level-item">Parallel</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Program-Design/"><span class="level-start"><span class="level-item">Program Design</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/CS/Storage/"><span class="level-start"><span class="level-item">Storage</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Daily-Life/"><span class="level-start"><span class="level-item">Daily Life</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/Daily-Life/Maxism/"><span class="level-start"><span class="level-item">Maxism</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Database/"><span class="level-start"><span class="level-item">Database</span></span><span class="level-end"><span class="level-item tag">27</span></span></a><ul><li><a class="level is-mobile" href="/categories/Database/Hadoop/"><span class="level-start"><span class="level-item">Hadoop</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Database/SQL-DB/"><span class="level-start"><span class="level-item">SQL DB</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Database/Spark/"><span class="level-start"><span class="level-item">Spark</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/Scala/"><span class="level-start"><span class="level-item">Scala</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">42</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Bash-Programming/"><span class="level-start"><span class="level-item">Bash Programming</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Configuration/"><span class="level-start"><span class="level-item">Configuration</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/File-System/"><span class="level-start"><span class="level-item">File System</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/IPC/"><span class="level-start"><span class="level-item">IPC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Network/"><span class="level-start"><span class="level-item">Network</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Process-Schedual/"><span class="level-start"><span class="level-item">Process Schedual</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Shell/"><span class="level-start"><span class="level-item">Shell</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Linux/Tool/"><span class="level-start"><span class="level-item">Tool</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/Tool/Vi/"><span class="level-start"><span class="level-item">Vi</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Model/"><span class="level-start"><span class="level-item">ML Model</span></span><span class="level-end"><span class="level-item tag">21</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Model/Linear-Model/"><span class="level-start"><span class="level-item">Linear Model</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Model-Component/"><span class="level-start"><span class="level-item">Model Component</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Nolinear-Model/"><span class="level-start"><span class="level-item">Nolinear Model</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Model/Unsupervised-Model/"><span class="level-start"><span class="level-item">Unsupervised Model</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/"><span class="level-start"><span class="level-item">ML Specification</span></span><span class="level-end"><span class="level-item tag">17</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/Click-Through-Rate/"><span class="level-start"><span class="level-item">Click Through Rate</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/Click-Through-Rate/Recommandation-System/"><span class="level-start"><span class="level-item">Recommandation System</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/Computer-Vision/"><span class="level-start"><span class="level-item">Computer Vision</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Specification/FinTech/"><span class="level-start"><span class="level-item">FinTech</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Specification/FinTech/Risk-Control/"><span class="level-start"><span class="level-item">Risk Control</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Specification/Graph-Analysis/"><span class="level-start"><span class="level-item">Graph Analysis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Specification/NLP/"><span class="level-start"><span class="level-item">NLP</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Technique/"><span class="level-start"><span class="level-item">ML Technique</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Technique/Feature-Engineering/"><span class="level-start"><span class="level-item">Feature Engineering</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Technique/Neural-Network/"><span class="level-start"><span class="level-item">Neural Network</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ML-Theory/"><span class="level-start"><span class="level-item">ML Theory</span></span><span class="level-end"><span class="level-item tag">11</span></span></a><ul><li><a class="level is-mobile" href="/categories/ML-Theory/Loss/"><span class="level-start"><span class="level-item">Loss</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Theory/Model-Enhencement/"><span class="level-start"><span class="level-item">Model Enhencement</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/ML-Theory/Optimization/"><span class="level-start"><span class="level-item">Optimization</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Algebra/"><span class="level-start"><span class="level-item">Math Algebra</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Algebra/Linear-Algebra/"><span class="level-start"><span class="level-item">Linear Algebra</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Algebra/Universal-Algebra/"><span class="level-start"><span class="level-item">Universal Algebra</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Analysis/"><span class="level-start"><span class="level-item">Math Analysis</span></span><span class="level-end"><span class="level-item tag">23</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Analysis/Fourier-Analysis/"><span class="level-start"><span class="level-item">Fourier Analysis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Functional-Analysis/"><span class="level-start"><span class="level-item">Functional Analysis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Optimization/"><span class="level-start"><span class="level-item">Optimization</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Analysis/Real-Analysis/"><span class="level-start"><span class="level-item">Real Analysis</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math-Mixin/"><span class="level-start"><span class="level-item">Math Mixin</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math-Mixin/Statistics/"><span class="level-start"><span class="level-item">Statistics</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Math-Mixin/Time-Series/"><span class="level-start"><span class="level-item">Time Series</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Probability/"><span class="level-start"><span class="level-item">Probability</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">89</span></span></a><ul><li><a class="level is-mobile" href="/categories/Python/Cookbook/"><span class="level-start"><span class="level-item">Cookbook</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Jupyter/"><span class="level-start"><span class="level-item">Jupyter</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Keras/"><span class="level-start"><span class="level-item">Keras</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Matplotlib/"><span class="level-start"><span class="level-item">Matplotlib</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Numpy/"><span class="level-start"><span class="level-item">Numpy</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Pandas/"><span class="level-start"><span class="level-item">Pandas</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Py3Ref/"><span class="level-start"><span class="level-item">Py3Ref</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Py3std/"><span class="level-start"><span class="level-item">Py3std</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Pywin32/"><span class="level-start"><span class="level-item">Pywin32</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Readme/"><span class="level-start"><span class="level-item">Readme</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/TensorFlow/"><span class="level-start"><span class="level-item">TensorFlow</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/Twists/"><span class="level-start"><span class="level-item">Twists</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/RLang/"><span class="level-start"><span class="level-item">RLang</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Rust/"><span class="level-start"><span class="level-item">Rust</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Set/"><span class="level-start"><span class="level-item">Set</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/"><span class="level-start"><span class="level-item">Tool</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/Tool/Editor/"><span class="level-start"><span class="level-item">Editor</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Markup-Language/"><span class="level-start"><span class="level-item">Markup Language</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Web-Browser/"><span class="level-start"><span class="level-item">Web Browser</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Tool/Windows/"><span class="level-start"><span class="level-item">Windows</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/Web/CSS/"><span class="level-start"><span class="level-item">CSS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/NPM/"><span class="level-start"><span class="level-item">NPM</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/Proxy/"><span class="level-start"><span class="level-item">Proxy</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/Thrift/"><span class="level-start"><span class="level-item">Thrift</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://octodex.github.com/images/hula_loop_octodex03.gif" alt="UBeaRLy"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">UBeaRLy</p><p class="is-size-6 is-block">Protector of Proxy</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">392</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">93</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">522</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/xyy15926" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/xyy15926"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-04T15:07:54.896Z">2021-08-04</time></p><p class="title"><a href="/uncategorized/README.html"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-03T07:46:51.000Z">2021-08-03</time></p><p class="title"><a href="/Web/NPM/hexo_config.html">Hexo 建站</a></p><p class="categories"><a href="/categories/Web/">Web</a> / <a href="/categories/Web/NPM/">NPM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-03T02:32:45.000Z">2021-08-03</time></p><p class="title"><a href="/Web/NPM/config.html">NPM 总述</a></p><p class="categories"><a href="/categories/Web/">Web</a> / <a href="/categories/Web/NPM/">NPM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-02T08:11:11.000Z">2021-08-02</time></p><p class="title"><a href="/Python/Py3std/internet_data.html">互联网数据</a></p><p class="categories"><a href="/categories/Python/">Python</a> / <a href="/categories/Python/Py3std/">Py3std</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-29T13:55:00.000Z">2021-07-29</time></p><p class="title"><a href="/Linux/Shell/sh_apps.html">Shell 应用程序</a></p><p class="categories"><a href="/categories/Linux/">Linux</a> / <a href="/categories/Linux/Shell/">Shell</a></p></div></article></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">Advertisement</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="pub-5385776267343559" data-ad-slot="6995841235" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="https://api.follow.it/subscription-form/WWxwMVBsOUtoNTdMSlJ4Z1lWVnRISERsd2t6ek9MeVpEUWs0YldlZGxUdXlKdDNmMEZVV1hWaFZFYWFSNmFKL25penZodWx3UzRiaVkxcnREWCtOYUJhZWhNbWpzaUdyc1hPangycUh5RTVjRXFnZnFGdVdSTzZvVzJBcTJHKzl8aXpDK1ROWWl4N080YkFEK3QvbEVWNEJuQjFqdWdxODZQcGNoM1NqbERXST0=/8" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="UBeaRLy" height="28"></a><p class="is-size-7"><span>&copy; 2021 UBeaRLy</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/xyy15926/proxy"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>